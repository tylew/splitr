// File: /Users/devyn/splitr/nrf5340_ble_switching/CMakeLists.txt
target_sources(app PRIVATE
    src/main.c
    src/nrf5340_audio_common.c
)


// File: /Users/devyn/splitr/nrf5340_ble_switching/Kconfig
CONFIG_BUTTON_1=0x0B  # Adjust pin number as needed
CONFIG_LOG_DEFAULT_LEVEL=3

# Audio configuration
config AUDIO_SAMPLE_RATE_HZ
    int "Audio sample rate in Hz"
    default 48000
    help
      Sample rate for audio processing

config AUDIO_BIT_DEPTH_BITS
    int "Audio bit depth in bits"
    default 16
    help
      Bit depth for audio samples

config AUDIO_FRAME_DURATION_US
    int "Audio frame duration in microseconds"
    default 10000
    help
      Duration of each audio frame

# Button configuration
config BUTTON_1
    int "GPIO pin number for mode switch button"
    default 11
    help
      GPIO pin number for the mode switch button

# Audio buffer sizes
config BUF_BLE_RX_PACKET_NUM
    int "Number of BLE RX packets to buffer"
    default 5
    help
      Number of BLE packets to buffer for audio reception

# Enable required features
config BT_AUDIO
    bool
    default y

config BT_BAP_BROADCAST_SOURCE
    bool
    default y if TRANSPORT_BIS

config BT_BAP_BROADCAST_SINK
    bool
    default y if TRANSPORT_BIS

config BT_BAP_SCAN_DELEGATOR
    bool
    default y if TRANSPORT_BIS

config AUDIO_SOURCE_I2S
    bool "Use I2S as audio source"
    default y
    help
      Enable I2S as the audio source/sink



// File: /Users/devyn/splitr/nrf5340_ble_switching/main.c
#include <zephyr/kernel.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/audio/audio.h>
#include <zephyr/bluetooth/audio/capabilities.h>
#include <zephyr/zbus/zbus.h>

#include "audio_system.h"
#include "bt_mgmt.h"
#include "bt_content_ctrl.h"
#include "nrf5340_audio_common.h"
#include "audio_datapath.h"
#include "le_audio_rx.h"
#include "button_handler.h"
#include "macros_common.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(main, CONFIG_LOG_DEFAULT_LEVEL);

/* Audio configuration */
#define AUDIO_FRAME_DURATION_US 10000  // 10ms frame duration
#define AUDIO_SAMPLE_RATE_HZ    48000  // 48kHz sample rate
#define AUDIO_BITRATE          128000  // 128 kbps

static enum {
    MODE_BROADCAST,
    MODE_SINK
} current_mode = MODE_BROADCAST;

/* Data FIFO for audio */
static struct data_fifo audio_fifo_rx;

ZBUS_SUBSCRIBER_DEFINE(button_sub, CONFIG_BUTTON_MSG_SUB_QUEUE_SIZE);

static void handle_mode_switch(void)
{
    int ret;
    
    LOG_INF("Mode switch button pressed");
    
    // Stop current audio and BLE operations
    audio_system_stop();
    audio_datapath_stop();
    bt_mgmt_disconnect();

    // Switch mode
    if (current_mode == MODE_BROADCAST) {
        LOG_INF("Switching to SINK mode");
        current_mode = MODE_SINK;
        
        // Initialize audio RX path
        ret = le_audio_rx_init();
        if (ret) {
            LOG_ERR("Failed to init audio RX: %d", ret);
            return;
        }

        // Start scanning for broadcast
        ret = bt_mgmt_scan_start(SCAN_TYPE_BROADCAST);
        if (ret) {
            LOG_ERR("Failed to start scanning: %d", ret);
            return;
        }

    } else {
        LOG_INF("Switching to BROADCAST mode");
        current_mode = MODE_BROADCAST;
        
        // Configure audio system for broadcasting
        ret = audio_system_config_set(AUDIO_SAMPLE_RATE_HZ, 
                                    AUDIO_BITRATE,
                                    AUDIO_SAMPLE_RATE_HZ);
        if (ret) {
            LOG_ERR("Failed to configure audio: %d", ret);
            return;
        }

        // Start audio system
        audio_system_start();
        
        // Start broadcasting
        ret = bt_mgmt_adv_start(ADV_TYPE_BROADCAST);
        if (ret) {
            LOG_ERR("Failed to start broadcasting: %d", ret);
            return;
        }
    }
}

/* Button message handler thread */
static void button_msg_handler(void)
{
    int ret;
    struct button_msg msg;

    while (1) {
        ret = zbus_sub_wait(&button_sub, &msg, K_FOREVER);
        ERR_CHK(ret);

        switch (msg.button_pin) {
        case BUTTON_PLAY_PAUSE:
            if (msg.button_action == BUTTON_PRESS) {
                handle_mode_switch();
            }
            break;

        default:
            break;
        }
    }
}

K_THREAD_DEFINE(button_msg_thread_id, CONFIG_BUTTON_MSG_SUB_STACK_SIZE, button_msg_handler, NULL,
                NULL, NULL, K_PRIO_PREEMPT(CONFIG_BUTTON_MSG_SUB_THREAD_PRIO), 0, 0);

/* Callback for when broadcast audio is received */
static void broadcast_started_cb(void)
{
    int ret;

    if (current_mode != MODE_SINK) {
        return;
    }

    LOG_INF("Broadcast received, starting audio datapath");

    // Start audio datapath for receiving
    ret = audio_datapath_start(&audio_fifo_rx);
    if (ret) {
        LOG_ERR("Failed to start audio datapath: %d", ret);
        return;
    }
}

int main(void)
{
    int ret;

    LOG_INF("nRF5340 BLE Mode Switching Application");

    /* Initialize audio datapath */
    ret = audio_datapath_init();
    if (ret) {
        LOG_ERR("Failed to initialize audio datapath: %d", ret);
        return ret;
    }

    /* Initialize audio system */
    ret = audio_system_init();
    if (ret) {
        LOG_ERR("Failed to initialize audio system: %d", ret);
        return ret;
    }

    /* Initialize BLE management */
    ret = bt_mgmt_init();
    if (ret) {
        LOG_ERR("Failed to initialize BT management: %d", ret);
        return ret;
    }

    /* Initialize content control */
    ret = bt_content_ctrl_init();
    if (ret) {
        LOG_ERR("Failed to initialize content control: %d", ret);
        return ret;
    }

    /* Initialize button handling */
    ret = button_handler_init();
    if (ret) {
        LOG_ERR("Failed to initialize button handler: %d", ret);
        return ret;
    }

    /* Configure initial audio settings */
    ret = audio_system_config_set(AUDIO_SAMPLE_RATE_HZ, 
                                 AUDIO_BITRATE,
                                 AUDIO_SAMPLE_RATE_HZ);
    if (ret) {
        LOG_ERR("Failed to configure audio: %d", ret);
        return ret;
    }

    /* Start audio system */
    audio_system_start();

    /* Start in broadcast mode by default */
    ret = bt_mgmt_adv_start(ADV_TYPE_BROADCAST);
    if (ret) {
        LOG_ERR("Failed to start broadcasting: %d", ret);
        return ret;
    }

    LOG_INF("Application started in BROADCAST mode");
    LOG_INF("Press PLAY/PAUSE button to switch modes");

    return 0;
}

// File: /Users/devyn/splitr/nrf5340_ble_switching/mock.c
/*
* nRF5340 BLE Audio System - Zephyr Implementation
* Features:
* - BLE GATT Handshake with iPhone
* - BLE Audio Broadcast (Auracast TX)
* - BLE Audio Sink (Auracast RX)
* - Dynamic Switching via API interface or GATT
* - Play/Pause & Volume Control for Sinks
*/

#include <zephyr.h>
#include <sys/printk.h>
#include <bluetooth/bluetooth.h>
#include <bluetooth/hci.h>
#include <bluetooth/conn.h>
#include <bluetooth/gatt.h>
#include <bluetooth/iso.h>
#include <bluetooth/audio.h>

/* Define BLE Service UUIDs */
#define AUDIO_CONTROL_SERVICE_UUID BT_UUID_DECLARE_16(0x180A)
#define MODE_CHARACTERISTIC_UUID   BT_UUID_DECLARE_16(0x2A00)
#define VOLUME_CHARACTERISTIC_UUID BT_UUID_DECLARE_16(0x2A01)
#define PLAY_PAUSE_CHARACTERISTIC_UUID BT_UUID_DECLARE_16(0x2A02)

static struct bt_conn *default_conn;
static uint8_t audio_mode = 0; // 0 = TX, 1 = RX
static uint8_t volume_level = 50; // Default volume (0-100%)
static uint8_t play_state = 1; // 1 = Playing, 0 = Paused

/* BLE GATT Characteristics */
static ssize_t write_mode(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf, uint16_t len, uint16_t offset, uint8_t flags) {
    if (len == 1) {
        audio_mode = *((uint8_t *)buf);
        printk("Switching mode to: %s\n", (audio_mode == 0) ? "Broadcast (TX)" : "Sink (RX)");
    }
    return len;
}

static ssize_t write_volume(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf, uint16_t len, uint16_t offset, uint8_t flags) {
    if (len == 1) {
        volume_level = *((uint8_t *)buf);
        printk("Setting volume to: %d%%\n", volume_level);
        /* TODO: Apply volume change to audio output */
    }
    return len;
}

static ssize_t write_play_pause(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf, uint16_t len, uint16_t offset, uint8_t flags) {
    if (len == 1) {
        play_state = *((uint8_t *)buf);
        printk("Playback state: %s\n", (play_state == 1) ? "Playing" : "Paused");
        /* TODO: Implement play/pause control */
    }
    return len;
}

/* GATT Service Definition */
BT_GATT_SERVICE_DEFINE(audio_svc,
    BT_GATT_PRIMARY_SERVICE(AUDIO_CONTROL_SERVICE_UUID),
    BT_GATT_CHARACTERISTIC(MODE_CHARACTERISTIC_UUID, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE, NULL, write_mode, &audio_mode),
    BT_GATT_CHARACTERISTIC(VOLUME_CHARACTERISTIC_UUID, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE, NULL, write_volume, &volume_level),
    BT_GATT_CHARACTERISTIC(PLAY_PAUSE_CHARACTERISTIC_UUID, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE, NULL, write_play_pause, &play_state),
);

/* BLE Advertisement (For Handshake) */
static const struct bt_data ad[] = {
    BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)),
    BT_DATA_BYTES(BT_DATA_UUID16_ALL, 0x0A, 0x18),
};

/* Initialize BLE */
static void bt_ready(int err) {
    if (err) {
        printk("Bluetooth init failed (err %d)\n", err);
        return;
    }
    printk("Bluetooth initialized\n");
    bt_le_adv_start(BT_LE_ADV_CONN, ad, ARRAY_SIZE(ad), NULL, 0);
}

void start_broadcast_tx(void) {
    printk("Starting Auracast Broadcast TX\n");
    /* TODO: Implement LC3 encoding and start broadcasting over BLE ISO */
}

void start_broadcast_rx(void) {
    printk("Starting Auracast Sink RX\n");
    /* TODO: Scan for Auracast streams and start decoding */
    /* Apply play/pause state and volume adjustments here */
}

void main(void) {
    int err;
    err = bt_enable(bt_ready);
    if (err) {
        printk("Bluetooth init failed (err %d)\n", err);
        return;
    }
    while (1) {
        if (audio_mode == 0) {
            start_broadcast_tx();
        } else {
            start_broadcast_rx();
        }
        k_sleep(K_SECONDS(5)); // Poll every 5s
    }
}

// File: /Users/devyn/splitr/nrf5340_ble_switching/src/nrf5340_audio_common.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "bt_mgmt.h"
#include "fw_info_app.h"
#include "nrf5340_audio_common.h"
#include <zephyr/drivers/gpio.h>
#include <zephyr/logging/log.h>

LOG_MODULE_REGISTER(audio_common, CONFIG_LOG_DEFAULT_LEVEL);

static struct gpio_callback button_cb_data;
static button_handler_cb button_callback;

static void button_pressed(const struct device *dev, struct gpio_callback *cb, uint32_t pins)
{
	if (button_callback) {
		button_callback(pins, pins);
	}
}

int button_handler_init(button_handler_cb callback)
{
	const struct device *gpio_dev;
	int ret;

	if (!callback) {
		return -EINVAL;
	}

	button_callback = callback;

	gpio_dev = device_get_binding(DT_GPIO_LABEL(DT_NODELABEL(gpio0), gpios));
	if (!gpio_dev) {
		LOG_ERR("GPIO device not found");
		return -ENODEV;
	}

	ret = gpio_pin_configure(gpio_dev, CONFIG_BUTTON_1, GPIO_INPUT | GPIO_PULL_UP);
	if (ret) {
		LOG_ERR("Failed to configure button pin");
		return ret;
	}

	gpio_init_callback(&button_cb_data, button_pressed, BIT(CONFIG_BUTTON_1));
	ret = gpio_add_callback(gpio_dev, &button_cb_data);
	if (ret) {
		LOG_ERR("Failed to add button callback");
		return ret;
	}

	ret = gpio_pin_interrupt_configure(gpio_dev, CONFIG_BUTTON_1, GPIO_INT_EDGE_BOTH);
	if (ret) {
		LOG_ERR("Failed to configure button interrupt");
		return ret;
	}

	return 0;
}

int nrf5340_audio_common_init(void)
{
	int ret;

	ret = fw_info_app_print();
	if (ret) {
		LOG_ERR("Failed to print application FW info");
		return ret;
	}

	ret = bt_mgmt_init();
	if (ret) {
		LOG_ERR("Failed to initialize bt_mgmt");
		return ret;
	}

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/nrf5340_audio_common.h
#ifndef _NRF5340_AUDIO_COMMON_H_
#define _NRF5340_AUDIO_COMMON_H_

#include <zephyr/kernel.h>
#include <zephyr/drivers/gpio.h>

/* Button assignments structure */
struct button_assignments {
    uint32_t mode_switch;
};

/* Button handler callback type */
typedef void (*button_handler_cb)(uint32_t button_pin, uint32_t has_changed);

/* Initialize button handling */
int button_handler_init(button_handler_cb callback);

#endif /* _NRF5340_AUDIO_COMMON_H_ */ 

// File: /Users/devyn/splitr/nrf5340_ble_switching/src/drivers/cs47l63_reg_conf.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _CS47L63_REG_CONF_H_
#define _CS47L63_REG_CONF_H_

#include "cs47l63_spec.h"

/* Magic value to signal a sleep instead of register address.
 * This can be used e.g. after resets where time is needed before
 * a device is ready.
 * Note that this is a busy wait, and should only be used sparingly where fast
 * execution is not critical.
 *
 * 0001 is used as the reg addr. In case of a fault, this reg is read only.
 */
#define SPI_BUSY_WAIT 0x0001
#define SPI_BUSY_WAIT_US_1000 1000
#define SPI_BUSY_WAIT_US_3000 3000

#define MAX_VOLUME_REG_VAL 0x80
#define MAX_VOLUME_DB 64
#define OUT_VOLUME_DEFAULT 0x62
#define VOLUME_UPDATE_BIT (1 << 9)

#define CS47L63_SOFT_RESET_VAL 0x5A000000

/* clang-format off */
/* Set up clocks */
const uint32_t clock_configuration[][2] = {
	{ CS47L63_SAMPLE_RATE3, 0x0012 },
	{ CS47L63_SAMPLE_RATE2, 0x0002 },
	{ CS47L63_SAMPLE_RATE1, 0x0003 },
	{ CS47L63_SYSTEM_CLOCK1, 0x034C },
	{ CS47L63_ASYNC_CLOCK1, 0x034C },
	{ CS47L63_FLL1_CONTROL2, 0x88200008 },
	{ CS47L63_FLL1_CONTROL3, 0x10000 },
	{ CS47L63_FLL1_GPIO_CLOCK, 0x0005 },
	{ CS47L63_FLL1_CONTROL1, 0x0001 },
};
/* clang-format on */

/* Set up GPIOs */
const uint32_t GPIO_configuration[][2] = {
	{ CS47L63_GPIO6_CTRL1, 0x61000001 },
	{ CS47L63_GPIO7_CTRL1, 0x61000001 },
	{ CS47L63_GPIO8_CTRL1, 0x61000001 },

	/* Enable CODEC LED */
	{ CS47L63_GPIO10_CTRL1, 0x41008001 },
};

const uint32_t pdm_mic_enable_configure[][2] = {
	/* Set MICBIASes */
	{ CS47L63_LDO2_CTRL1, 0x0005 },
	{ CS47L63_MICBIAS_CTRL1, 0x00EC },
	{ CS47L63_MICBIAS_CTRL5, 0x0272 },

	/* Enable IN1L */
	{ CS47L63_INPUT_CONTROL, 0x000F },

	/* Enable PDM mic as digital input */
	{ CS47L63_INPUT1_CONTROL1, 0x50021 },

	/* Un-mute and set gain to 0dB */
	{ CS47L63_IN1L_CONTROL2, 0x800080 },
	{ CS47L63_IN1R_CONTROL2, 0x800080 },

	/* Volume Update */
	{ CS47L63_INPUT_CONTROL3, 0x20000000 },

	/* Send PDM MIC to I2S Tx */
	{ CS47L63_ASP1TX1_INPUT1, 0x800010 },
	{ CS47L63_ASP1TX2_INPUT1, 0x800011 },
};

/* Set up input */
const uint32_t line_in_enable[][2] = {
	/* Select LINE-IN as analog input */
	{ CS47L63_INPUT2_CONTROL1, 0x50020 },

	/* Set IN2L and IN2R to single-ended */
	{ CS47L63_IN2L_CONTROL1, 0x10000000 },
	{ CS47L63_IN2R_CONTROL1, 0x10000000 },

	/* Un-mute and set gain to 0dB */
	{ CS47L63_IN2L_CONTROL2, 0x800080 },
	{ CS47L63_IN2R_CONTROL2, 0x800080 },

	/* Enable IN2L and IN2R */
	{ CS47L63_INPUT_CONTROL, 0x000F },

	/* Volume Update */
	{ CS47L63_INPUT_CONTROL3, 0x20000000 },

	/* Route IN2L and IN2R to I2S */
	{ CS47L63_ASP1TX1_INPUT1, 0x800012 },
	{ CS47L63_ASP1TX2_INPUT1, 0x800013 },
};

/* Set up output */
const uint32_t output_enable[][2] = {
	{ CS47L63_OUTPUT_ENABLE_1, 0x0002 },
	{ CS47L63_OUT1L_INPUT1, 0x800020 },
	{ CS47L63_OUT1L_INPUT2, 0x800021 },
};

const uint32_t output_disable[][2] = {
	{ CS47L63_OUTPUT_ENABLE_1, 0x00 },
};

/* Set up ASP1 (I2S) */
const uint32_t asp1_enable[][2] = {
	/* Enable ASP1 GPIOs */
	{ CS47L63_GPIO1_CTRL1, 0x61000000 },
	{ CS47L63_GPIO2_CTRL1, 0xE1000000 },
	{ CS47L63_GPIO3_CTRL1, 0xE1000000 },
	{ CS47L63_GPIO4_CTRL1, 0xE1000000 },
	{ CS47L63_GPIO5_CTRL1, 0x61000001 },

/* Set correct sample rate */
#if CONFIG_AUDIO_SAMPLE_RATE_16000_HZ
	{ CS47L63_SAMPLE_RATE1, 0x000000012 },
#elif CONFIG_AUDIO_SAMPLE_RATE_24000_HZ
	{ CS47L63_SAMPLE_RATE1, 0x000000002 },
#elif CONFIG_AUDIO_SAMPLE_RATE_48000_HZ
	{ CS47L63_SAMPLE_RATE1, 0x000000003 },
#endif
	/* Disable unused sample rates */
	{ CS47L63_SAMPLE_RATE2, 0 },
	{ CS47L63_SAMPLE_RATE3, 0 },
	{ CS47L63_SAMPLE_RATE4, 0 },

	/* Set ASP1 in slave mode and 16 bit per channel */
	{ CS47L63_ASP1_CONTROL2, 0x10100200 },
	{ CS47L63_ASP1_CONTROL3, 0x0000 },
	{ CS47L63_ASP1_DATA_CONTROL1, 0x0020 },
	{ CS47L63_ASP1_DATA_CONTROL5, 0x0020 },
	{ CS47L63_ASP1_ENABLES1, 0x30003 },
};

const uint32_t FLL_toggle[][2] = {
	{ CS47L63_FLL1_CONTROL1, 0x0000 },
	{ SPI_BUSY_WAIT, SPI_BUSY_WAIT_US_1000 },
	{ CS47L63_FLL1_CONTROL1, 0x0001 },
};

const uint32_t soft_reset[][2] = {
	{ CS47L63_SFT_RESET, CS47L63_SOFT_RESET_VAL },
	{ SPI_BUSY_WAIT, SPI_BUSY_WAIT_US_3000 },
};

#endif /* _CS47L63_REG_CONF_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/drivers/cs47l63_comm.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _CS47L63_COMM_H_
#define _CS47L63_COMM_H_

#include <stdint.h>
#include "cs47l63.h"

/**@brief Initialize the CS47L63
 *
 * @param driver   Pointer to CS47L63 driver
 *
 * @return 0 on success.
 */
int cs47l63_comm_init(cs47l63_t *driver);

#endif /* _CS47L63_COMM_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/drivers/CMakeLists.txt
#
# Copyright (c) 2022 Nordic Semiconductor
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

target_sources(app PRIVATE
	       ${CMAKE_CURRENT_SOURCE_DIR}/cs47l63_comm.c
)


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/drivers/Kconfig
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

menu "Drivers"

#----------------------------------------------------------------------------#
menu "Thread priorities"

config CS47L63_THREAD_PRIO
	int "Priority for CS47L63 thread"
	default 5
	help
	  This is a preemptible thread

endmenu # Thread priorities

#----------------------------------------------------------------------------#
menu "Stack sizes"

config CS47L63_STACK_SIZE
	int "Stack size for CS47L63"
	default 700

endmenu # Stack sizes

#----------------------------------------------------------------------------#
menu "Log levels"

module = CS47L63
module-str = cs47l63
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log levels
endmenu # Drivers


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/drivers/cs47l63_comm.c
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#define DT_DRV_COMPAT cirrus_cs47l63

#include "cs47l63_comm.h"

#include <zephyr/kernel.h>
#include <zephyr/drivers/spi.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <zephyr/kernel.h>
#include <zephyr/drivers/gpio.h>

#include "bsp_driver_if.h"
#include "cs47l63.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(CS47L63, CONFIG_CS47L63_LOG_LEVEL);

#define CS47L63_DEVID_VAL 0x47A63
#define PAD_LEN 4 /* Four bytes padding after address */
/* Delay the processing thread to allow interrupts to settle after boot */
#define CS47L63_PROCESS_THREAD_DELAY_MS 10

static const struct gpio_dt_spec hw_codec_gpio = GPIO_DT_SPEC_INST_GET(0, gpio9_gpios);
static const struct gpio_dt_spec hw_codec_irq = GPIO_DT_SPEC_INST_GET(0, irq_gpios);
static const struct gpio_dt_spec hw_codec_reset = GPIO_DT_SPEC_INST_GET(0, reset_gpios);

const static struct device *gpio_dev = DEVICE_DT_GET(DT_NODELABEL(gpio0));

static const struct spi_dt_spec spi = SPI_DT_SPEC_INST_GET(
	0, SPI_OP_MODE_MASTER | SPI_TRANSFER_MSB | SPI_WORD_SET(8) | SPI_LINES_SINGLE, 0);
static bsp_callback_t bsp_callback;
static void *bsp_callback_arg;

static struct gpio_callback gpio_cb;

static struct k_thread cs47l63_data;
static K_THREAD_STACK_DEFINE(cs47l63_stack, CONFIG_CS47L63_STACK_SIZE);

static K_SEM_DEFINE(sem_cs47l63, 0, 1);

static struct k_mutex cirrus_reg_oper_mutex;

static void notification_callback(uint32_t event_flags, void *arg)
{
	LOG_DBG("Notification from CS47L63, flags: %d", event_flags);
}

/* Locks the mutex and holds the CS pin
 * for consecutive transactions
 */
static int spi_mutex_lock(void)
{
	int ret;

	ret = k_mutex_lock(&cirrus_reg_oper_mutex, K_FOREVER);
	if (ret) {
		LOG_ERR("Failed to lock mutex: %d", ret);
		return ret;
	}

	/* If operation mode set to HOLD or the SPI_LOCK_ON is set when
	 * taking the mutex something is wrong
	 */
	if ((spi.config.operation & SPI_HOLD_ON_CS) || (spi.config.operation & SPI_LOCK_ON)) {
		LOG_ERR("SPI_HOLD_ON_CS and SPI_LOCK_ON must be freed before releasing mutex");
		return -EPERM;
	}

	return 0;
}

/* Unlocks mutex and CS pin */
static int spi_mutex_unlock(void)
{
	int ret;
	/* If operation mode still set to HOLD or
	 * the SPI_LOCK_ON is still set when releasing the mutex
	 * something is wrong
	 */
	if ((spi.config.operation & SPI_HOLD_ON_CS) || (spi.config.operation & SPI_LOCK_ON)) {
		LOG_ERR("SPI_HOLD_ON_CS and SPI_LOCK_ON must be freed before releasing mutex");
		return -EPERM;
	}

	ret = k_mutex_unlock(&cirrus_reg_oper_mutex);
	if (ret) {
		LOG_ERR("Failed to unlock mutex: %d", ret);
		return ret;
	}

	return 0;
}

/* Pin interrupt handler for CS47L63 */
static void cs47l63_comm_pin_int_handler(const struct device *gpio_port, struct gpio_callback *cb,
					 uint32_t pins)
{
	__ASSERT(bsp_callback != NULL, "No callback registered");

	if (pins == BIT(hw_codec_irq.pin)) {
		bsp_callback(BSP_STATUS_OK, bsp_callback_arg);
		k_sem_give(&sem_cs47l63);
	}
}

static uint32_t cs47l63_comm_reg_read(uint32_t bsp_dev_id, uint8_t *addr_buffer,
				      uint32_t addr_length, uint8_t *data_buffer,
				      uint32_t data_length, uint32_t pad_len)
{
	if (pad_len != PAD_LEN) {
		LOG_ERR("Trying to pad more than 4 bytes: %d", pad_len);
		return BSP_STATUS_FAIL;
	}

	int ret;

	uint8_t pad_buffer[PAD_LEN] = { 0 };

	struct spi_buf_set rx;
	struct spi_buf rx_buf[] = { { .buf = addr_buffer, .len = addr_length },
				    { .buf = pad_buffer, .len = pad_len },
				    { .buf = data_buffer, .len = data_length } };

	rx.buffers = rx_buf;
	rx.count = ARRAY_SIZE(rx_buf);

	ret = spi_mutex_lock();
	if (ret) {
		return BSP_STATUS_FAIL;
	}

	ret = spi_transceive_dt(&spi, &rx, &rx);
	if (ret) {
		LOG_ERR("Failed transceive operation: %d", ret);
		return BSP_STATUS_FAIL;
	}

	ret = spi_mutex_unlock();
	if (ret) {
		return BSP_STATUS_FAIL;
	}

	return BSP_STATUS_OK;
}

static uint32_t cs47l63_comm_reg_write(uint32_t bsp_dev_id, uint8_t *addr_buffer,
				       uint32_t addr_length, uint8_t *data_buffer,
				       uint32_t data_length, uint32_t pad_len)
{
	if (pad_len != PAD_LEN) {
		LOG_ERR("Trying to pad more than 4 bytes: %d", pad_len);
		return BSP_STATUS_FAIL;
	}

	int ret;

	uint8_t pad_buffer[PAD_LEN] = { 0 };

	struct spi_buf_set tx;
	struct spi_buf tx_buf[] = { { .buf = addr_buffer, .len = addr_length },
				    { .buf = pad_buffer, .len = pad_len },
				    { .buf = data_buffer, .len = data_length } };

	tx.buffers = tx_buf;
	tx.count = ARRAY_SIZE(tx_buf);

	ret = spi_mutex_lock();
	if (ret) {
		return BSP_STATUS_FAIL;
	}

	ret = spi_write_dt(&spi, &tx);
	if (ret) {
		LOG_ERR("SPI failed to write: %d", ret);
		return BSP_STATUS_FAIL;
	}

	ret = spi_mutex_unlock();
	if (ret) {
		return BSP_STATUS_FAIL;
	}

	return BSP_STATUS_OK;
}

static uint32_t cs47l63_comm_gpio_set(uint32_t gpio_id, uint8_t gpio_state)
{
	int ret;

	ret = gpio_pin_set_raw(gpio_dev, gpio_id, gpio_state);

	if (ret) {
		LOG_ERR("Failed to set gpio state, ret: %d", ret);
		return BSP_STATUS_FAIL;
	}

	return BSP_STATUS_OK;
}

/* Register callback for pin interrupt from CS47L63 */
static uint32_t cs47l63_comm_gpio_cb_register(uint32_t gpio_id, bsp_callback_t cb, void *cb_arg)
{
	int ret;

	bsp_callback = cb;
	bsp_callback_arg = cb_arg;

	gpio_init_callback(&gpio_cb, cs47l63_comm_pin_int_handler, BIT(gpio_id));

	ret = gpio_add_callback(gpio_dev, &gpio_cb);
	if (ret) {
		return BSP_STATUS_FAIL;
	}

	ret = gpio_pin_interrupt_configure(gpio_dev, gpio_id, GPIO_INT_EDGE_TO_INACTIVE);
	if (ret) {
		return BSP_STATUS_FAIL;
	}

	return BSP_STATUS_OK;
}

static uint32_t cs47l63_comm_timer_set(uint32_t duration_ms, bsp_callback_t cb, void *cb_arg)
{
	if (cb != NULL || cb_arg != NULL) {
		LOG_ERR("Timer with callback not supported");
		return BSP_STATUS_FAIL;
	}

	k_msleep(duration_ms);

	return BSP_STATUS_OK;
}

static uint32_t cs47l63_comm_set_supply(uint32_t supply_id, uint8_t supply_state)
{
	LOG_DBG("Tried to set supply, not supported");
	/* OK is returned in order to make reset function work */
	return BSP_STATUS_OK;
}

static uint32_t cs47l63_comm_i2c_reset(uint32_t bsp_dev_id, bool *was_i2c_busy)
{
	LOG_ERR("Tried to reset I2C, not supported");
	return BSP_STATUS_FAIL;
}

static uint32_t cs47l63_comm_i2c_read_repeated_start(uint32_t bsp_dev_id, uint8_t *write_buffer,
						     uint32_t write_length, uint8_t *read_buffer,
						     uint32_t read_length, bsp_callback_t cb,
						     void *cb_arg)
{
	LOG_ERR("Tried to read repeated start I2C, not supported");
	return BSP_STATUS_FAIL;
}

static uint32_t cs47l63_comm_i2c_write(uint32_t bsp_dev_id, uint8_t *write_buffer,
				       uint32_t write_length, bsp_callback_t cb, void *cb_arg)
{
	LOG_ERR("Tried writing to I2C, not supported");
	return BSP_STATUS_FAIL;
}

static uint32_t cs47l63_comm_i2c_db_write(uint32_t bsp_dev_id, uint8_t *write_buffer_0,
					  uint32_t write_length_0, uint8_t *write_buffer_1,
					  uint32_t write_length_1, bsp_callback_t cb, void *cb_arg)
{
	LOG_ERR("Tried to write double buffered I2C, not supported");
	return BSP_STATUS_FAIL;
}

static uint32_t cs47l63_comm_enable_irq(void)
{
	LOG_ERR("Tried to enable irq, not supported");
	return BSP_STATUS_FAIL;
}

static uint32_t cs47l63_comm_disable_irq(void)
{
	LOG_ERR("Tried to disable irq, not supported");
	return BSP_STATUS_FAIL;
}

static uint32_t cs47l63_comm_spi_throttle_speed(uint32_t speed_hz)
{
	LOG_ERR("Tried to throttle SPI speed, not supported");
	return BSP_STATUS_FAIL;
}

static uint32_t cs47l63_comm_spi_restore_speed(void)
{
	LOG_ERR("Tried to restore SPI speed, not supported");
	return BSP_STATUS_FAIL;
}

/* Thread to process events from CS47L63 */
static void cs47l63_comm_thread(void *cs47l63_driver, void *dummy2, void *dummy3)
{
	int ret;

	while (1) {
		k_sem_take(&sem_cs47l63, K_FOREVER);
		ret = cs47l63_process((cs47l63_t *)cs47l63_driver);
		if (ret) {
			LOG_ERR("CS47L63 failed to process event");
		}
	}
}

static cs47l63_bsp_config_t bsp_config = { .bsp_reset_gpio_id = hw_codec_reset.pin,
					   .bsp_int_gpio_id = hw_codec_irq.pin,
					   .cp_config.bus_type = CS47L63_BUS_TYPE_SPI,
					   .cp_config.spi_pad_len = 4,
					   .notification_cb = &notification_callback,
					   .notification_cb_arg = NULL };

int cs47l63_comm_init(cs47l63_t *cs47l63_driver)
{
	int ret;

	cs47l63_config_t cs47l63_config;

	memset(&cs47l63_config, 0, sizeof(cs47l63_config_t));

	k_mutex_init(&cirrus_reg_oper_mutex);

	if (!spi_is_ready_dt(&spi)) {
		LOG_ERR("CS47L63 is not ready!");
		return -ENXIO;
	}

	if (!gpio_is_ready_dt(&hw_codec_gpio)) {
		LOG_ERR("GPIO is not ready!");
		return -ENXIO;
	}

	ret = gpio_pin_configure_dt(&hw_codec_gpio, GPIO_INPUT);
	if (ret) {
		return ret;
	}

	if (!gpio_is_ready_dt(&hw_codec_irq)) {
		LOG_ERR("GPIO is not ready!");
		return -ENXIO;
	}

	ret = gpio_pin_configure_dt(&hw_codec_irq, GPIO_INPUT);
	if (ret) {
		return ret;
	}

	if (!gpio_is_ready_dt(&hw_codec_reset)) {
		LOG_ERR("GPIO is not ready!");
		return -ENXIO;
	}

	ret = gpio_pin_configure_dt(&hw_codec_reset, GPIO_OUTPUT);
	if (ret) {
		return ret;
	}

	/* Start thread to handle events from CS47L63 */
	(void)k_thread_create(&cs47l63_data, cs47l63_stack, CONFIG_CS47L63_STACK_SIZE,
			      (k_thread_entry_t)cs47l63_comm_thread, (void *)cs47l63_driver, NULL,
			      NULL, K_PRIO_PREEMPT(CONFIG_CS47L63_THREAD_PRIO), 0,
			      K_MSEC(CS47L63_PROCESS_THREAD_DELAY_MS));

	ret = k_thread_name_set(&cs47l63_data, "CS47L63");
	if (ret) {
		return ret;
	}

	/* Initialize CS47L63 drivers */
	ret = cs47l63_initialize(cs47l63_driver);
	if (ret != CS47L63_STATUS_OK) {
		LOG_ERR("Failed to initialize CS47L63");
		return -ENXIO;
	}

	cs47l63_config.bsp_config = bsp_config;

	cs47l63_config.syscfg_regs = cs47l63_syscfg_regs;
	cs47l63_config.syscfg_regs_total = CS47L63_SYSCFG_REGS_TOTAL;

	ret = cs47l63_configure(cs47l63_driver, &cs47l63_config);
	if (ret != CS47L63_STATUS_OK) {
		LOG_ERR("Failed to configure CS47L63");
		return -ENXIO;
	}

	/* Will pin reset the device and wait until boot done */
	ret = cs47l63_reset(cs47l63_driver);
	if (ret != CS47L63_STATUS_OK) {
		LOG_ERR("Failed to reset CS47L63");
		return -ENXIO;
	}

	if (cs47l63_driver->devid != CS47L63_DEVID_VAL) {
		LOG_ERR("Wrong device id: 0x%02x, should be 0x%02x", cs47l63_driver->devid,
			CS47L63_DEVID_VAL);
		return -EIO;
	}

	return 0;
}

static bsp_driver_if_t bsp_driver_if_s = { .set_gpio = &cs47l63_comm_gpio_set,
					   .register_gpio_cb = &cs47l63_comm_gpio_cb_register,
					   .set_timer = &cs47l63_comm_timer_set,
					   .spi_read = &cs47l63_comm_reg_read,
					   .spi_write = &cs47l63_comm_reg_write,

					   /* Functions not supported */
					   .set_supply = &cs47l63_comm_set_supply,
					   .i2c_read_repeated_start =
						   &cs47l63_comm_i2c_read_repeated_start,
					   .i2c_write = &cs47l63_comm_i2c_write,
					   .i2c_db_write = &cs47l63_comm_i2c_db_write,
					   .i2c_reset = &cs47l63_comm_i2c_reset,
					   .enable_irq = &cs47l63_comm_enable_irq,
					   .disable_irq = &cs47l63_comm_disable_irq,
					   .spi_throttle_speed = &cs47l63_comm_spi_throttle_speed,
					   .spi_restore_speed = &cs47l63_comm_spi_restore_speed };

bsp_driver_if_t *bsp_driver_if_g = &bsp_driver_if_s;


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/utils/uicr.c
/*
 * Copyright (c) 2021 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "uicr.h"
#include <stdint.h>
#include <errno.h>
#include <nrfx_nvmc.h>

/* Memory address to store segger number of the board */
#define MEM_ADDR_UICR_SNR UICR_APP_BASE_ADDR
/* Memory address to store the channel intended used for this board */
#define MEM_ADDR_UICR_CH (MEM_ADDR_UICR_SNR + sizeof(uint32_t))

uint8_t uicr_channel_get(void)
{
	return *(uint8_t *)MEM_ADDR_UICR_CH;
}

int uicr_channel_set(uint8_t channel)
{
	if (channel == *(uint8_t *)MEM_ADDR_UICR_CH) {
		return 0;
	} else if (*(uint32_t *)MEM_ADDR_UICR_CH != 0xFFFFFFFF) {
		return -EROFS;
	}

	nrfx_nvmc_byte_write(MEM_ADDR_UICR_CH, channel);

	if (channel == *(uint8_t *)MEM_ADDR_UICR_CH) {
		return 0;
	} else {
		return -EIO;
	}
}

uint64_t uicr_snr_get(void)
{
	return *(uint64_t *)MEM_ADDR_UICR_SNR;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/utils/CMakeLists.txt
#
# Copyright (c) 2022 Nordic Semiconductor
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

target_sources(app PRIVATE
	       ${CMAKE_CURRENT_SOURCE_DIR}/board_version.c
	       ${CMAKE_CURRENT_SOURCE_DIR}/channel_assignment.c
	       ${CMAKE_CURRENT_SOURCE_DIR}/error_handler.c
	       ${CMAKE_CURRENT_SOURCE_DIR}/uicr.c
	       ${CMAKE_CURRENT_SOURCE_DIR}/nrf5340_audio_dk.c
)


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/utils/Kconfig.defaults
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

# Channel assignment writes to UICR
config NRFX_NVMC
	default y


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/utils/channel_assignment.c
/*
 * Copyright (c) 2022 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "channel_assignment.h"

#include <errno.h>

#include "uicr.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(channel_assignment, CONFIG_CHAN_ASSIGNMENT_LOG_LEVEL);

static uint8_t channel_value;

void channel_assignment_get(enum audio_channel *channel)
{
	*channel = (enum audio_channel)channel_value;
}

#if CONFIG_AUDIO_HEADSET_CHANNEL_RUNTIME
void channel_assignment_set(enum audio_channel channel)
{
	int ret;

	channel_value = channel;

	/* Try to write the channel value to UICR */
	ret = uicr_channel_set(channel);
	if (ret) {
		LOG_DBG("Unable to write channel value to UICR");
	}
}
#endif /* CONFIG_AUDIO_HEADSET_CHANNEL_RUNTIME */

void channel_assignment_init(void)
{
#if CONFIG_AUDIO_HEADSET_CHANNEL_RUNTIME
	channel_value = uicr_channel_get();

	if (channel_value >= AUDIO_CH_NUM) {
		/* Invalid value in UICR if UICR is not written */
		channel_value = AUDIO_CHANNEL_DEFAULT;
	}
#else
	channel_value = CONFIG_AUDIO_HEADSET_CHANNEL;
#endif /* CONFIG_AUDIO_HEADSET_CHANNEL_RUNTIME */
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/utils/nrf5340_audio_dk.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "led.h"
#include "button_handler.h"
#include "button_assignments.h"
#include "nrfx_clock.h"
#include "sd_card.h"
#include "board_version.h"
#include "channel_assignment.h"
#include "audio_system.h"

#include "sd_card_playback.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(nrf5340_audio_dk, CONFIG_MODULE_NRF5340_AUDIO_DK_LOG_LEVEL);

static struct board_version board_rev;

static int hfclock_config_and_start(void)
{
	int ret;

	/* Use this to turn on 128 MHz clock for cpu_app */
	ret = nrfx_clock_divider_set(NRF_CLOCK_DOMAIN_HFCLK, NRF_CLOCK_HFCLK_DIV_1);

	ret -= NRFX_ERROR_BASE_NUM;
	if (ret) {
		return ret;
	}

	nrfx_clock_hfclk_start();
	while (!nrfx_clock_hfclk_is_running()) {
	}

	return 0;
}

static int leds_set(void)
{
	int ret;

	/* Blink LED 3 to indicate that APP core is running */
	ret = led_blink(LED_APP_3_GREEN);
	if (ret) {
		return ret;
	}

#if (CONFIG_AUDIO_DEV == HEADSET)
	enum audio_channel channel;

	channel_assignment_get(&channel);

	if (channel == AUDIO_CH_L) {
		ret = led_on(LED_APP_RGB, LED_COLOR_BLUE);
	} else {
		ret = led_on(LED_APP_RGB, LED_COLOR_MAGENTA);
	}

	if (ret) {
		return ret;
	}
#elif (CONFIG_AUDIO_DEV == GATEWAY)
	ret = led_on(LED_APP_RGB, LED_COLOR_GREEN);
	if (ret) {
		return ret;
	}
#endif /* (CONFIG_AUDIO_DEV == HEADSET) */

	return 0;
}

static int channel_assign_check(void)
{
#if (CONFIG_AUDIO_DEV == HEADSET) && CONFIG_AUDIO_HEADSET_CHANNEL_RUNTIME
	int ret;
	bool pressed;

	ret = button_pressed(BUTTON_VOLUME_DOWN, &pressed);
	if (ret) {
		return ret;
	}

	if (pressed) {
		channel_assignment_set(AUDIO_CH_L);
		return 0;
	}

	ret = button_pressed(BUTTON_VOLUME_UP, &pressed);
	if (ret) {
		return ret;
	}

	if (pressed) {
		channel_assignment_set(AUDIO_CH_R);
		return 0;
	}
#endif

	return 0;
}

int nrf5340_audio_dk_init(void)
{
	int ret;

	ret = hfclock_config_and_start();
	if (ret) {
		return ret;
	}

	ret = led_init();
	if (ret) {
		LOG_ERR("Failed to initialize LED module");
		return ret;
	}

	ret = button_handler_init();
	if (ret) {
		LOG_ERR("Failed to initialize button handler");
		return ret;
	}

	channel_assignment_init();

	ret = channel_assign_check();
	if (ret) {
		LOG_ERR("Failed get channel assignment");
		return ret;
	}

	ret = board_version_valid_check();
	if (ret) {
		return ret;
	}

	ret = board_version_get(&board_rev);
	if (ret) {
		return ret;
	}

	if (board_rev.mask & BOARD_VERSION_VALID_MSK_SD_CARD) {
		ret = sd_card_init();
		if (ret != -ENODEV && ret != 0) {
			LOG_ERR("Failed to initialize SD card");
			return ret;
		}
	}

	ret = leds_set();
	if (ret) {
		LOG_ERR("Failed to set LEDs");
		return ret;
	}

	if (IS_ENABLED(CONFIG_SD_CARD_PLAYBACK)) {
		ret = sd_card_playback_init();
		if (ret) {
			LOG_ERR("Failed to initialize SD card playback");
			return ret;
		}
	}

	ret = audio_system_init();
	if (ret) {
		LOG_ERR("Failed to initialize the audio system");
		return ret;
	}

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/utils/error_handler.c
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include <zephyr/kernel.h>
#include <zephyr/sys/reboot.h>
#include <zephyr/fatal.h>
#include <zephyr/logging/log_ctrl.h>
#include <zephyr/drivers/gpio.h>

/* Print everything from the error handler */
#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(error_handler, CONFIG_ERROR_HANDLER_LOG_LEVEL);

#if (defined(CONFIG_BOARD_NRF5340_AUDIO_DK_NRF5340_CPUAPP) && (CONFIG_DEBUG))
/* nRF5340 Audio DK center RGB LED */
static const struct gpio_dt_spec center_led_r = GPIO_DT_SPEC_GET(DT_NODELABEL(rgb1_red), gpios);
static const struct gpio_dt_spec center_led_g = GPIO_DT_SPEC_GET(DT_NODELABEL(rgb1_green), gpios);
static const struct gpio_dt_spec center_led_b = GPIO_DT_SPEC_GET(DT_NODELABEL(rgb1_blue), gpios);
#endif /* (defined(CONFIG_BOARD_NRF5340_AUDIO_DK_NRF5340_CPUAPP) && (CONFIG_DEBUG)) */

void error_handler(unsigned int reason, const z_arch_esf_t *esf)
{
#if (CONFIG_DEBUG)
	LOG_ERR("Caught system error -- reason %d. Entering infinite loop", reason);
	LOG_PANIC();
#if defined(CONFIG_BOARD_NRF5340_AUDIO_DK_NRF5340_CPUAPP)
	(void)gpio_pin_configure_dt(&center_led_r, GPIO_OUTPUT_ACTIVE);
	(void)gpio_pin_configure_dt(&center_led_g, GPIO_OUTPUT_INACTIVE);
	(void)gpio_pin_configure_dt(&center_led_b, GPIO_OUTPUT_INACTIVE);
#endif /* defined(CONFIG_BOARD_NRF5340_AUDIO_DK_NRF5340_CPUAPP) */
	irq_lock();
	while (1) {
		__asm__ volatile("nop");
	}
#else
	LOG_ERR("Caught system error -- reason %d. Cold rebooting.", reason);
#if (CONFIG_LOG)
	LOG_PANIC();
#endif /* (CONFIG_LOG) */
	sys_reboot(SYS_REBOOT_COLD);
#endif /* (CONFIG_DEBUG) */
	CODE_UNREACHABLE;
}

void bt_ctlr_assert_handle(char *c, int code)
{
	LOG_ERR("BT controller assert: %s, code: 0x%x", c, code);
	error_handler(code, NULL);
}

void k_sys_fatal_error_handler(unsigned int reason, const z_arch_esf_t *esf)
{
	error_handler(reason, esf);
}

void assert_post_action(const char *file, unsigned int line)
{
	LOG_ERR("Assert post action: file: %s, line %d", file, line);
	error_handler(0, NULL);
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/utils/Kconfig
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

rsource "Kconfig.defaults"

menu "Utils"

menu "FIFO"

config FIFO_FRAME_SPLIT_NUM
	int "Number of blocks to make up one frame of audio data"
	default 10
	help
	  Easy DMA in I2S requires two buffers to be filled before I2S
	  transmission will begin. In order to reduce latency, an audio
	  frame can be split into multiple blocks with this parameter. USB
	  sends data in 1 ms blocks, so we need the split to match that.
	  Since we set frame size to 10 ms for USB, 10 is selected as
	  FRAME_SPLIT_NUM

config FIFO_TX_FRAME_COUNT
	int "Max number of audio frames in TX slab"
	default 3
	help
	  FIFO_TX is the buffer that holds decoded audio data before it
	  is sent to either I2S or USB

config FIFO_RX_FRAME_COUNT
	int "Max number of audio frames in RX slab"
	default 1
	help
	  FIFO_RX is the buffer that holds uncompressed audio data coming
	  from either I2S or USB

endmenu # FIFO

#----------------------------------------------------------------------------#
menu "Log levels"

module = BOARD_VERSION
module-str = board-version
source "subsys/logging/Kconfig.template.log_config"

module = CHAN_ASSIGNMENT
module-str = chan-assignment
source "subsys/logging/Kconfig.template.log_config"

module = ERROR_HANDLER
module-str = error-handler
source "subsys/logging/Kconfig.template.log_config"

module = FW_INFO
module-str = fw-info
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log levels
endmenu # Utils


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/utils/fw_info_app.c.in
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "fw_info_app.h"

#include <zephyr/kernel.h>
#include <stdio.h>
#include <zephyr/logging/log_ctrl.h>
#include "channel_assignment.h"
#include "ncs_version.h"

#include "macros_common.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(fw_info, CONFIG_FW_INFO_LOG_LEVEL);

static const char COMPILE_DATE[] = "@NRF5340_AUDIO_CORE_APP_COMP_DATE@";
/* NOTE: The string below is used by the Nordic CI system */
static const char NRF5340_CORE[] = "nRF5340 Audio nRF5340 Audio DK cpuapp";

int fw_info_app_print(void)
{
	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF(COLOR_GREEN "\r\n\t %s \
			    \r\n\t NCS base version: %s \
			    \r\n\t Cmake run : %s" COLOR_RESET,
		NRF5340_CORE, NCS_VERSION_STRING, COMPILE_DATE);

#if (CONFIG_DEBUG)
	int ret;

	LOG_INF("------- DEBUG BUILD -------");

#if (CONFIG_AUDIO_DEV == HEADSET)
	enum audio_channel channel;

	channel_assignment_get(&channel);
	if (channel == AUDIO_CH_L) {
		ret = log_set_tag(CH_L_TAG);
		if (ret) {
			return ret;
		}
		/* NOTE: The string below is used by the Nordic CI system */
		LOG_INF(COLOR_CYAN "HEADSET left device" COLOR_RESET);
	} else if (channel == AUDIO_CH_R) {
		ret = log_set_tag(CH_R_TAG);
		if (ret) {
			return ret;
		}
		/* NOTE: The string below is used by the Nordic CI system */
		LOG_INF(COLOR_CYAN "HEADSET right device" COLOR_RESET);
	} else {
		__ASSERT(false, "Unknown channel");
	}

#elif CONFIG_AUDIO_DEV == GATEWAY
	ret = log_set_tag(GW_TAG);
	if (ret) {
		return ret;
	}
	LOG_INF(COLOR_CYAN "Compiled for GATEWAY device" COLOR_RESET);
#endif /* (CONFIG_AUDIO_DEV == HEADSET) */
#endif /* (CONFIG_DEBUG) */

	return 0;
}

// File: /Users/devyn/splitr/nrf5340_ble_switching/src/utils/board_version.c
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "board_version.h"

#include <zephyr/kernel.h>
#include <zephyr/drivers/adc.h>
#include <zephyr/drivers/gpio.h>
#include <stdlib.h>

#include "board.h"
#include "macros_common.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(board_version, CONFIG_BOARD_VERSION_LOG_LEVEL);

#define BOARD_ID DT_NODELABEL(board_id)

static const struct adc_dt_spec adc = ADC_DT_SPEC_GET(BOARD_ID);
static const struct gpio_dt_spec power_gpios = GPIO_DT_SPEC_GET(BOARD_ID, power_gpios);

/* We allow the ADC register value to deviate by N points in either direction */
#define BOARD_VERSION_TOLERANCE	  70
#define VOLTAGE_STABILIZE_TIME_US 5

static int16_t sample_buffer;

static struct adc_sequence sequence = {
	.buffer = &sample_buffer,
	.buffer_size = sizeof(sample_buffer),
};

/* @brief Enable board version voltage divider and trigger ADC read */
static int divider_value_get(void)
{
	int ret;

	ret = gpio_pin_set_dt(&power_gpios, 1);
	if (ret) {
		return ret;
	}

	/* Wait for voltage to stabilize */
	k_busy_wait(VOLTAGE_STABILIZE_TIME_US);

	ret = adc_read(adc.dev, &sequence);
	if (ret) {
		return ret;
	}

	ret = gpio_pin_set_dt(&power_gpios, 0);
	if (ret) {
		return ret;
	}

	return 0;
}

/**@brief Traverse all defined versions and get the one with the
 * most similar value. Check tolerances.
 */
static int version_search(int reg_value, uint32_t tolerance, struct board_version *board_rev)
{
	uint32_t diff;
	uint32_t smallest_diff = UINT_MAX;
	uint8_t smallest_diff_idx = UCHAR_MAX;

	for (uint8_t i = 0; i < (uint8_t)ARRAY_SIZE(BOARD_VERSION_ARR); i++) {
		diff = abs(BOARD_VERSION_ARR[i].adc_reg_val - reg_value);

		if (diff < smallest_diff) {
			smallest_diff = diff;
			smallest_diff_idx = i;
		}
	}

	if (smallest_diff >= tolerance) {
		LOG_ERR("Board ver search failed. ADC reg read: %d", reg_value);
		return -ESPIPE; /* No valid board_rev found */
	}

	*board_rev = BOARD_VERSION_ARR[smallest_diff_idx];
	LOG_DBG("Board ver search OK!. ADC reg val: %d", reg_value);
	return 0;
}

/* @brief Internal init routine */
static int board_version_init(void)
{
	int ret;
	static bool initialized;

	if (initialized) {
		return 0;
	}

	if (!gpio_is_ready_dt(&power_gpios)) {
		return -ENXIO;
	}

	ret = gpio_pin_configure_dt(&power_gpios, GPIO_OUTPUT_INACTIVE);
	if (ret) {
		return ret;
	}

	if (!device_is_ready(adc.dev)) {
		LOG_ERR("ADC not ready");
		return -ENODEV;
	}

	ret = adc_channel_setup_dt(&adc);
	if (ret) {
		return ret;
	}

	(void)adc_sequence_init_dt(&adc, &sequence);

	initialized = true;
	return 0;
}

int board_version_get(struct board_version *board_rev)
{
	int ret;

	ret = board_version_init();
	if (ret) {
		return ret;
	}

	ret = divider_value_get();
	if (ret) {
		return ret;
	}

	ret = version_search(sample_buffer, BOARD_VERSION_TOLERANCE, board_rev);
	if (ret) {
		return ret;
	}

	return 0;
}

int board_version_valid_check(void)
{
	int ret;
	struct board_version board_rev;

	ret = board_version_get(&board_rev);
	if (ret) {
		LOG_ERR("Unable to get any board version");
		return ret;
	}

	if (BOARD_VERSION_VALID_MSK & (board_rev.mask)) {
		LOG_INF(COLOR_GREEN "Compatible board/HW version found: %s" COLOR_RESET,
			board_rev.name);
	} else {
		LOG_ERR("Invalid board found, rev: %s Valid mask: 0x%x valid mask: 0x%lx",
			board_rev.name, board_rev.mask, BOARD_VERSION_VALID_MSK);
		return -EPERM;
	}

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/utils/uicr.h
/*
 * Copyright (c) 2021 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _UICR_H_
#define _UICR_H_

#include <stdint.h>

// TODO: Discuss better alternative for UICR storage. This memory range is not documented
#define UICR_APP_BASE_ADDR (NRF_UICR_S_BASE + 0xF0)

/**
 * @brief Get raw channel value from UICR
 */
uint8_t uicr_channel_get(void);

/**
 * @brief Write raw channel value to UICR
 *
 * @param channel Channel value
 *
 * @return 0 if successful
 * @return -EROFS if different channel is already written
 * @return -EIO if channel failed to be written
 */
int uicr_channel_set(uint8_t channel);

/**
 * @brief Get Segger serial number value from UICR
 */
uint64_t uicr_snr_get(void);

#endif /* _UICR_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/utils/fw_info_app.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _FW_INFO_APP_H_
#define _FW_INFO_APP_H_

/**
 * @brief Prints firmware info, such as Git details, compiled timestamp etc.
 *
 * @return      0 on success.
 *              Otherwise, error from underlying drivers
 */
int fw_info_app_print(void);

#endif /* _FW_INFO_APP_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/utils/nrf5340_audio_dk.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

/**
 * @brief	Initialize the hardware related modules on the nRF5340 Audio DK/PCA10121
 *
 * @return	0 if successful, error otherwise.
 */
int nrf5340_audio_dk_init(void);


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/utils/channel_assignment.h
/*
 * Copyright (c) 2022 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _CHANNEL_ASSIGNMENT_H_
#define _CHANNEL_ASSIGNMENT_H_

/** @file
 *  @brief Audio channel assignment
 *
 * Audio channel can be assigned at runtime or compile-time, depending on configuration.
 *
 */

#include <audio_defines.h>

#ifndef AUDIO_CHANNEL_DEFAULT
#define AUDIO_CHANNEL_DEFAULT AUDIO_CH_L
#endif /* AUDIO_CHANNEL_DEFAULT */

static const char CH_L_TAG[] = "HL";
static const char CH_R_TAG[] = "HR";
static const char GW_TAG[] = "GW";

/**
 * @brief Get assigned audio channel.
 *
 * @param[out] channel Channel value
 */
void channel_assignment_get(enum audio_channel *channel);

#if CONFIG_AUDIO_HEADSET_CHANNEL_RUNTIME
/**
 * @brief Assign audio channel.
 *
 * @param[out] channel Channel value
 */
void channel_assignment_set(enum audio_channel channel);
#endif /* AUDIO_HEADSET_CHANNEL_RUNTIME */

/**
 * @brief Initialize the channel assignment
 */
void channel_assignment_init(void);

#endif /* _CHANNEL_ASSIGNMENT_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/utils/board_version.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BOARD_VERSION_H_
#define _BOARD_VERSION_H_

#include "board.h"

/**@brief Get the board/HW version
 *
 * @note  This function will init the ADC, perform a reading, and
 *	  return the HW version.
 *
 * @param board_rev	Pointer to container for board version
 *
 * @return 0 on success.
 * Error code on fault or -ESPIPE if no valid version found
 */
int board_version_get(struct board_version *board_rev);

/**@brief Check that the FW is compatible with the HW version
 *
 * @note  This function will init the ADC, perform a reading, and
 * check for valid version match.
 *
 * @note The board file must define a BOARD_VERSION_ARR array of
 * possible valid ADC register values (voltages) for the divider.
 * A BOARD_VERSION_VALID_MSK with valid version bits must also be defined.
 *
 * @return 0 on success. Error code on fault or -EPERM if incompatible board version.
 */
int board_version_valid_check(void);

#endif /* _BOARD_VERSION_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/utils/macros/macros_common.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _MACROS_H_
#define _MACROS_H_

#include <errno.h>

/* Error check. If != 0, print err code and call _SysFatalErrorHandler in main.
 * For debug mode all LEDs are turned on in case of an error.
 */

#define PRINT_AND_OOPS(code)                                                                       \
	do {                                                                                       \
		LOG_ERR("ERR_CHK Err_code: [%d] @ line: %d\t", code, __LINE__);                    \
		k_oops();                                                                          \
	} while (0)

#define ERR_CHK(err_code)                                                                          \
	do {                                                                                       \
		if (err_code) {                                                                    \
			PRINT_AND_OOPS(err_code);                                                  \
		}                                                                                  \
	} while (0)

#define ERR_CHK_MSG(err_code, msg)                                                                 \
	do {                                                                                       \
		if (err_code) {                                                                    \
			LOG_ERR("%s", msg);                                                        \
			PRINT_AND_OOPS(err_code);                                                  \
		}                                                                                  \
	} while (0)

#if (defined(CONFIG_INIT_STACKS) && defined(CONFIG_THREAD_ANALYZER))

#define STACK_USAGE_PRINT(thread_name, p_thread)                                                   \
	do {                                                                                       \
		static uint64_t thread_ts;                                                         \
		size_t unused_space_in_thread_bytes;                                               \
		if (k_uptime_get() - thread_ts > CONFIG_PRINT_STACK_USAGE_MS) {                    \
			k_thread_stack_space_get(p_thread, &unused_space_in_thread_bytes);         \
			thread_ts = k_uptime_get();                                                \
			LOG_DBG("Unused space in %s thread: %d bytes", thread_name,                \
				unused_space_in_thread_bytes);                                     \
		}                                                                                  \
	} while (0)
#else
#define STACK_USAGE_PRINT(thread_name, p_stack)
#endif /* (defined(CONFIG_INIT_STACKS) && defined(CONFIG_THREAD_ANALYZER)) */

#ifndef MIN
#define MIN(a, b) (((a) < (b)) ? (a) : (b))
#endif /* MIN */

#define COLOR_BLACK "\x1B[0;30m"
#define COLOR_RED "\x1B[0;31m"
#define COLOR_GREEN "\x1B[0;32m"
#define COLOR_YELLOW "\x1B[0;33m"
#define COLOR_BLUE "\x1B[0;34m"
#define COLOR_MAGENTA "\x1B[0;35m"
#define COLOR_CYAN "\x1B[0;36m"
#define COLOR_WHITE "\x1B[0;37m"

#define COLOR_RESET "\x1b[0m"

#define BIT_SET(REG, BIT) ((REG) |= (BIT))
#define BIT_CLEAR(REG, BIT) ((REG) &= ~(BIT))

#endif /* _MACROS_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/audio/CMakeLists.txt
#
# Copyright (c) 2022 Nordic Semiconductor
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

target_sources(app PRIVATE
	       ${CMAKE_CURRENT_SOURCE_DIR}/audio_system.c
	       ${CMAKE_CURRENT_SOURCE_DIR}/audio_datapath.c
	       ${CMAKE_CURRENT_SOURCE_DIR}/sw_codec_select.c
	       ${CMAKE_CURRENT_SOURCE_DIR}/le_audio_rx.c
)


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/audio/Kconfig.defaults
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

# Audio sync timer
config NRFX_TIMER1
	default y

# Audio sync timer
config NRFX_DPPI
	default y


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/audio/le_audio_rx.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include <zephyr/kernel.h>
#include <nrfx_clock.h>

#include "streamctrl.h"
#include "audio_datapath.h"
#include "macros_common.h"
#include "audio_system.h"
#include "audio_sync_timer.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(le_audio_rx, CONFIG_LE_AUDIO_RX_LOG_LEVEL);

struct ble_iso_data {
	uint8_t data[CONFIG_BT_ISO_RX_MTU];
	size_t data_size;
	bool bad_frame;
	uint32_t sdu_ref;
	uint32_t recv_frame_ts;
} __packed;

struct rx_stats {
	uint32_t recv_cnt;
	uint32_t bad_frame_cnt;
	uint32_t data_size_mismatch_cnt;
};

static bool initialized;
static struct k_thread audio_datapath_thread_data;
static k_tid_t audio_datapath_thread_id;
K_THREAD_STACK_DEFINE(audio_datapath_thread_stack, CONFIG_AUDIO_DATAPATH_STACK_SIZE);

DATA_FIFO_DEFINE(ble_fifo_rx, CONFIG_BUF_BLE_RX_PACKET_NUM, WB_UP(sizeof(struct ble_iso_data)));

/* Callback for handling ISO RX */
void le_audio_rx_data_handler(uint8_t const *const p_data, size_t data_size, bool bad_frame,
			      uint32_t sdu_ref, enum audio_channel channel_index,
			      size_t desired_data_size)
{
	int ret;
	uint32_t blocks_alloced_num, blocks_locked_num;
	struct ble_iso_data *iso_received = NULL;
	static struct rx_stats rx_stats[AUDIO_CH_NUM];
	static uint32_t num_overruns;

	if (!initialized) {
		ERR_CHK_MSG(-EPERM, "Data received but le_audio_rx is not initialized");
	}

	/* Capture timestamp of when audio frame is received */
	uint32_t recv_frame_ts = audio_sync_timer_capture();

	rx_stats[channel_index].recv_cnt++;

	if (data_size != desired_data_size) {
		/* A valid frame should always be equal to desired_data_size, set bad_frame
		 * if that is not the case
		 */
		bad_frame = true;
		rx_stats[channel_index].data_size_mismatch_cnt++;
	}

	if (bad_frame) {
		rx_stats[channel_index].bad_frame_cnt++;
	}

	if ((rx_stats[channel_index].recv_cnt % 100) == 0 && rx_stats[channel_index].recv_cnt) {
		/* NOTE: The string below is used by the Nordic CI system */
		LOG_DBG("ISO RX SDUs: Ch: %d Total: %d Bad: %d Size mismatch %d", channel_index,
			rx_stats[channel_index].recv_cnt, rx_stats[channel_index].bad_frame_cnt,
			rx_stats[channel_index].data_size_mismatch_cnt);
	}

	if (stream_state_get() != STATE_STREAMING) {
		/* Throw away data */
		LOG_WRN("Not in streaming state, throwing data: %d", stream_state_get());
		return;
	}

	if (channel_index != AUDIO_CH_L && (CONFIG_AUDIO_DEV == GATEWAY)) {
		/* Only left channel RX data in use on gateway */
		return;
	}

	ret = data_fifo_num_used_get(&ble_fifo_rx, &blocks_alloced_num, &blocks_locked_num);
	ERR_CHK(ret);

	if (blocks_alloced_num >= CONFIG_BUF_BLE_RX_PACKET_NUM) {
		/* FIFO buffer is full, swap out oldest frame for a new one */

		void *stale_data;
		size_t stale_size;
		num_overruns++;

		if ((num_overruns % 100) == 1) {
			LOG_WRN("BLE ISO RX overrun: Num: %d", num_overruns);
		}

		ret = data_fifo_pointer_last_filled_get(&ble_fifo_rx, &stale_data, &stale_size,
							K_NO_WAIT);
		ERR_CHK(ret);

		data_fifo_block_free(&ble_fifo_rx, stale_data);
	}

	ret = data_fifo_pointer_first_vacant_get(&ble_fifo_rx, (void *)&iso_received, K_NO_WAIT);
	ERR_CHK_MSG(ret, "Unable to get FIFO pointer");

	if (data_size > ARRAY_SIZE(iso_received->data)) {
		ERR_CHK_MSG(-ENOMEM, "Data size too large for buffer");
		return;
	}

	memcpy(iso_received->data, p_data, data_size);

	iso_received->bad_frame = bad_frame;
	iso_received->data_size = data_size;
	iso_received->sdu_ref = sdu_ref;
	iso_received->recv_frame_ts = recv_frame_ts;

	ret = data_fifo_block_lock(&ble_fifo_rx, (void *)&iso_received,
				   sizeof(struct ble_iso_data));
	ERR_CHK_MSG(ret, "Failed to lock block");
}

/**
 * @brief	Receive data from BLE through a k_fifo and send to USB or audio datapath.
 */
static void audio_datapath_thread(void *dummy1, void *dummy2, void *dummy3)
{
	int ret;
	struct ble_iso_data *iso_received = NULL;
	size_t iso_received_size;

	while (1) {
		ret = data_fifo_pointer_last_filled_get(&ble_fifo_rx, (void *)&iso_received,
							&iso_received_size, K_FOREVER);
		ERR_CHK(ret);

		if (IS_ENABLED(CONFIG_AUDIO_SOURCE_USB) && (CONFIG_AUDIO_DEV == GATEWAY)) {
			ret = audio_system_decode(iso_received->data, iso_received->data_size,
						  iso_received->bad_frame);
			ERR_CHK(ret);
		} else {
			audio_datapath_stream_out(iso_received->data, iso_received->data_size,
						  iso_received->sdu_ref, iso_received->bad_frame,
						  iso_received->recv_frame_ts);
		}
		data_fifo_block_free(&ble_fifo_rx, (void *)iso_received);

		STACK_USAGE_PRINT("audio_datapath_thread", &audio_datapath_thread_data);
	}
}

static int audio_datapath_thread_create(void)
{
	int ret;

	audio_datapath_thread_id = k_thread_create(
		&audio_datapath_thread_data, audio_datapath_thread_stack,
		CONFIG_AUDIO_DATAPATH_STACK_SIZE, (k_thread_entry_t)audio_datapath_thread, NULL,
		NULL, NULL, K_PRIO_PREEMPT(CONFIG_AUDIO_DATAPATH_THREAD_PRIO), 0, K_NO_WAIT);
	ret = k_thread_name_set(audio_datapath_thread_id, "AUDIO_DATAPATH");
	if (ret) {
		LOG_ERR("Failed to create audio_datapath thread");
		return ret;
	}

	return 0;
}

int le_audio_rx_init(void)
{
	int ret;

	if (initialized) {
		return -EALREADY;
	}

	ret = data_fifo_init(&ble_fifo_rx);
	if (ret) {
		LOG_ERR("Failed to set up ble_rx FIFO");
		return ret;
	}

	ret = audio_datapath_thread_create();
	if (ret) {
		return ret;
	}

	initialized = true;

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/audio/audio_system.c
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "audio_system.h"

#include <zephyr/kernel.h>
#include <zephyr/shell/shell.h>

#include "macros_common.h"
#include "sw_codec_select.h"
#include "audio_datapath.h"
#include "audio_i2s.h"
#include "data_fifo.h"
#include "hw_codec.h"
#include "tone.h"
#include "contin_array.h"
#include "pcm_stream_channel_modifier.h"
#include "audio_usb.h"
#include "streamctrl.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(audio_system, CONFIG_AUDIO_SYSTEM_LOG_LEVEL);

#define FIFO_TX_BLOCK_COUNT (CONFIG_FIFO_FRAME_SPLIT_NUM * CONFIG_FIFO_TX_FRAME_COUNT)
#define FIFO_RX_BLOCK_COUNT (CONFIG_FIFO_FRAME_SPLIT_NUM * CONFIG_FIFO_RX_FRAME_COUNT)

#define DEBUG_INTERVAL_NUM     1000
#define TEST_TONE_BASE_FREQ_HZ 1000

K_THREAD_STACK_DEFINE(encoder_thread_stack, CONFIG_ENCODER_STACK_SIZE);

DATA_FIFO_DEFINE(fifo_tx, FIFO_TX_BLOCK_COUNT, WB_UP(BLOCK_SIZE_BYTES));
DATA_FIFO_DEFINE(fifo_rx, FIFO_RX_BLOCK_COUNT, WB_UP(BLOCK_SIZE_BYTES));

static K_SEM_DEFINE(sem_encoder_start, 0, 1);

static struct k_thread encoder_thread_data;
static k_tid_t encoder_thread_id;

static struct k_poll_signal encoder_sig;

static struct k_poll_event encoder_evt =
	K_POLL_EVENT_INITIALIZER(K_POLL_TYPE_SIGNAL, K_POLL_MODE_NOTIFY_ONLY, &encoder_sig);

static struct sw_codec_config sw_codec_cfg;
/* Buffer which can hold max 1 period test tone at 1000 Hz */
static int16_t test_tone_buf[CONFIG_AUDIO_SAMPLE_RATE_HZ / 1000];
static size_t test_tone_size;

static bool sample_rate_valid(uint32_t sample_rate_hz)
{
	if (sample_rate_hz == 16000 || sample_rate_hz == 24000 || sample_rate_hz == 48000) {
		return true;
	}

	return false;
}

static void audio_gateway_configure(void)
{
	if (IS_ENABLED(CONFIG_SW_CODEC_LC3)) {
		sw_codec_cfg.sw_codec = SW_CODEC_LC3;
	} else {
		ERR_CHK_MSG(-EINVAL, "No codec selected");
	}

#if (CONFIG_STREAM_BIDIRECTIONAL)
	sw_codec_cfg.decoder.enabled = true;
	sw_codec_cfg.decoder.num_ch = 1;
	sw_codec_cfg.decoder.channel_mode = SW_CODEC_MONO;
#endif /* (CONFIG_STREAM_BIDIRECTIONAL) */

	if (IS_ENABLED(CONFIG_MONO_TO_ALL_RECEIVERS)) {
		sw_codec_cfg.encoder.num_ch = 1;
	} else {
		sw_codec_cfg.encoder.num_ch = 2;
	}

	sw_codec_cfg.encoder.channel_mode =
		(sw_codec_cfg.encoder.num_ch == 1) ? SW_CODEC_MONO : SW_CODEC_STEREO;
	sw_codec_cfg.encoder.enabled = true;
}

static void audio_headset_configure(void)
{
	if (IS_ENABLED(CONFIG_SW_CODEC_LC3)) {
		sw_codec_cfg.sw_codec = SW_CODEC_LC3;
	} else {
		ERR_CHK_MSG(-EINVAL, "No codec selected");
	}

#if (CONFIG_STREAM_BIDIRECTIONAL)
	sw_codec_cfg.encoder.enabled = true;
	sw_codec_cfg.encoder.num_ch = 1;
	sw_codec_cfg.encoder.channel_mode = SW_CODEC_MONO;
#endif /* (CONFIG_STREAM_BIDIRECTIONAL) */

	sw_codec_cfg.decoder.num_ch = 1;
	sw_codec_cfg.decoder.channel_mode = SW_CODEC_MONO;

	if (IS_ENABLED(CONFIG_SD_CARD_PLAYBACK)) {
		/* Need an extra decoder channel to decode data from SD card */
		sw_codec_cfg.decoder.num_ch++;
	}

	sw_codec_cfg.decoder.enabled = true;
}

static void encoder_thread(void *arg1, void *arg2, void *arg3)
{
	int ret;
	uint32_t blocks_alloced_num;
	uint32_t blocks_locked_num;

	int debug_trans_count = 0;
	size_t encoded_data_size = 0;

	void *tmp_pcm_raw_data[CONFIG_FIFO_FRAME_SPLIT_NUM];
	char pcm_raw_data[FRAME_SIZE_BYTES];

	static uint8_t *encoded_data;
	static size_t pcm_block_size;
	static uint32_t test_tone_finite_pos;

	while (1) {
		/* Don't start encoding until the stream needing it has started */
		ret = k_poll(&encoder_evt, 1, K_FOREVER);

		/* Get PCM data from I2S */
		/* Since one audio frame is divided into a number of
		 * blocks, we need to fetch the pointers to all of these
		 * blocks before copying it to a continuous area of memory
		 * before sending it to the encoder
		 */
		for (int i = 0; i < CONFIG_FIFO_FRAME_SPLIT_NUM; i++) {
			ret = data_fifo_pointer_last_filled_get(&fifo_rx, &tmp_pcm_raw_data[i],
								&pcm_block_size, K_FOREVER);
			ERR_CHK(ret);
			memcpy(pcm_raw_data + (i * BLOCK_SIZE_BYTES), tmp_pcm_raw_data[i],
			       pcm_block_size);

			data_fifo_block_free(&fifo_rx, tmp_pcm_raw_data[i]);
		}

		if (sw_codec_cfg.encoder.enabled) {
			if (test_tone_size) {
				/* Test tone takes over audio stream */
				uint32_t num_bytes;
				char tmp[FRAME_SIZE_BYTES / 2];

				ret = contin_array_create(tmp, FRAME_SIZE_BYTES / 2, test_tone_buf,
							  test_tone_size, &test_tone_finite_pos);
				ERR_CHK(ret);

				ret = pscm_copy_pad(tmp, FRAME_SIZE_BYTES / 2,
						    CONFIG_AUDIO_BIT_DEPTH_BITS, pcm_raw_data,
						    &num_bytes);
				ERR_CHK(ret);
			}

			ret = sw_codec_encode(pcm_raw_data, FRAME_SIZE_BYTES, &encoded_data,
					      &encoded_data_size);

			ERR_CHK_MSG(ret, "Encode failed");
		}

		/* Print block usage */
		if (debug_trans_count == DEBUG_INTERVAL_NUM) {
			ret = data_fifo_num_used_get(&fifo_rx, &blocks_alloced_num,
						     &blocks_locked_num);
			ERR_CHK(ret);
			LOG_DBG(COLOR_CYAN "RX alloced: %d, locked: %d" COLOR_RESET,
				blocks_alloced_num, blocks_locked_num);
			debug_trans_count = 0;
		} else {
			debug_trans_count++;
		}

		if (sw_codec_cfg.encoder.enabled) {
			streamctrl_send(encoded_data, encoded_data_size,
					sw_codec_cfg.encoder.num_ch);
		}
		STACK_USAGE_PRINT("encoder_thread", &encoder_thread_data);
	}
}

void audio_system_encoder_start(void)
{
	LOG_DBG("Encoder started");
	k_poll_signal_raise(&encoder_sig, 0);
}

void audio_system_encoder_stop(void)
{
	k_poll_signal_reset(&encoder_sig);
}

int audio_system_encode_test_tone_set(uint32_t freq)
{
	int ret;

	if (freq == 0) {
		test_tone_size = 0;
		return 0;
	}

	if (IS_ENABLED(CONFIG_AUDIO_TEST_TONE)) {
		ret = tone_gen(test_tone_buf, &test_tone_size, freq, CONFIG_AUDIO_SAMPLE_RATE_HZ,
			       1);
		ERR_CHK(ret);
	} else {
		LOG_ERR("Test tone is not enabled");
		return -ENXIO;
	}

	if (test_tone_size > sizeof(test_tone_buf)) {
		return -ENOMEM;
	}

	return 0;
}

int audio_system_encode_test_tone_step(void)
{
	int ret;
	static uint32_t test_tone_hz;

	if (CONFIG_AUDIO_BIT_DEPTH_BITS != 16) {
		LOG_WRN("Tone gen only supports 16 bits");
		return -ECANCELED;
	}

	if (test_tone_hz == 0) {
		test_tone_hz = TEST_TONE_BASE_FREQ_HZ;
	} else if (test_tone_hz >= TEST_TONE_BASE_FREQ_HZ * 4) {
		test_tone_hz = 0;
	} else {
		test_tone_hz = test_tone_hz * 2;
	}

	if (test_tone_hz != 0) {
		LOG_INF("Test tone set at %d Hz", test_tone_hz);
	} else {
		LOG_INF("Test tone off");
	}

	ret = audio_system_encode_test_tone_set(test_tone_hz);
	if (ret) {
		LOG_ERR("Failed to generate test tone");
		return ret;
	}

	return 0;
}

int audio_system_config_set(uint32_t encoder_sample_rate_hz, uint32_t encoder_bitrate,
			    uint32_t decoder_sample_rate_hz)
{
	if (sample_rate_valid(encoder_sample_rate_hz)) {
		sw_codec_cfg.encoder.sample_rate_hz = encoder_sample_rate_hz;
	} else if (encoder_sample_rate_hz) {
		LOG_ERR("%d is not a valid sample rate", encoder_sample_rate_hz);
		return -EINVAL;
	}

	if (sample_rate_valid(decoder_sample_rate_hz)) {
		sw_codec_cfg.decoder.sample_rate_hz = decoder_sample_rate_hz;
	} else if (decoder_sample_rate_hz) {
		LOG_ERR("%d is not a valid sample rate", decoder_sample_rate_hz);
		return -EINVAL;
	}

	if (encoder_bitrate) {
		sw_codec_cfg.encoder.bitrate = encoder_bitrate;
	}

	return 0;
}

/* This function is only used on gateway using USB as audio source and bidirectional stream */
int audio_system_decode(void const *const encoded_data, size_t encoded_data_size, bool bad_frame)
{
	int ret;
	uint32_t blocks_alloced_num;
	uint32_t blocks_locked_num;
	static int debug_trans_count;
	static void *tmp_pcm_raw_data[CONFIG_FIFO_FRAME_SPLIT_NUM];
	static void *pcm_raw_data;
	size_t pcm_block_size;

	if (!sw_codec_cfg.initialized) {
		/* Throw away data */
		/* This can happen when using play/pause since there might be
		 * some packages left in the buffers
		 */
		LOG_DBG("Trying to decode while codec is not initialized");
		return -EPERM;
	}

	ret = data_fifo_num_used_get(&fifo_tx, &blocks_alloced_num, &blocks_locked_num);
	if (ret) {
		return ret;
	}

	uint8_t free_blocks_num = FIFO_TX_BLOCK_COUNT - blocks_locked_num;

	/* If not enough space for a full frame, remove oldest samples to make room */
	if (free_blocks_num < CONFIG_FIFO_FRAME_SPLIT_NUM) {
		void *old_data;
		size_t size;

		for (int i = 0; i < (CONFIG_FIFO_FRAME_SPLIT_NUM - free_blocks_num); i++) {
			ret = data_fifo_pointer_last_filled_get(&fifo_tx, &old_data, &size,
								K_NO_WAIT);
			if (ret == -ENOMSG) {
				/* If there are no more blocks in FIFO, break */
				break;
			}

			data_fifo_block_free(&fifo_tx, old_data);
		}
	}

	for (int i = 0; i < CONFIG_FIFO_FRAME_SPLIT_NUM; i++) {
		ret = data_fifo_pointer_first_vacant_get(&fifo_tx, &tmp_pcm_raw_data[i], K_FOREVER);
		if (ret) {
			return ret;
		}
	}

	ret = sw_codec_decode(encoded_data, encoded_data_size, bad_frame, &pcm_raw_data,
			      &pcm_block_size);
	if (ret) {
		LOG_ERR("Failed to decode");
		return ret;
	}

	/* Split decoded frame into CONFIG_FIFO_FRAME_SPLIT_NUM blocks */
	for (int i = 0; i < CONFIG_FIFO_FRAME_SPLIT_NUM; i++) {
		memcpy(tmp_pcm_raw_data[i], (char *)pcm_raw_data + (i * (BLOCK_SIZE_BYTES)),
		       BLOCK_SIZE_BYTES);

		ret = data_fifo_block_lock(&fifo_tx, &tmp_pcm_raw_data[i], BLOCK_SIZE_BYTES);
		if (ret) {
			LOG_ERR("Failed to lock block");
			return ret;
		}
	}
	if (debug_trans_count == DEBUG_INTERVAL_NUM) {
		ret = data_fifo_num_used_get(&fifo_tx, &blocks_alloced_num, &blocks_locked_num);
		if (ret) {
			return ret;
		}
		LOG_DBG(COLOR_MAGENTA "TX alloced: %d, locked: %d" COLOR_RESET, blocks_alloced_num,
			blocks_locked_num);
		debug_trans_count = 0;
	} else {
		debug_trans_count++;
	}

	return 0;
}

/**@brief Initializes the FIFOs, the codec, and starts the I2S
 */
void audio_system_start(void)
{
	int ret;

	if (CONFIG_AUDIO_DEV == HEADSET) {
		audio_headset_configure();
	} else if (CONFIG_AUDIO_DEV == GATEWAY) {
		audio_gateway_configure();
	} else {
		LOG_ERR("Invalid CONFIG_AUDIO_DEV: %d", CONFIG_AUDIO_DEV);
		ERR_CHK(-EINVAL);
	}

	if (!fifo_tx.initialized) {
		ret = data_fifo_init(&fifo_tx);
		ERR_CHK_MSG(ret, "Failed to set up tx FIFO");
	}

	if (!fifo_rx.initialized) {
		ret = data_fifo_init(&fifo_rx);
		ERR_CHK_MSG(ret, "Failed to set up rx FIFO");
	}

	ret = sw_codec_init(sw_codec_cfg);
	ERR_CHK_MSG(ret, "Failed to set up codec");

	sw_codec_cfg.initialized = true;

	if (sw_codec_cfg.encoder.enabled && encoder_thread_id == NULL) {
		encoder_thread_id = k_thread_create(
			&encoder_thread_data, encoder_thread_stack, CONFIG_ENCODER_STACK_SIZE,
			(k_thread_entry_t)encoder_thread, NULL, NULL, NULL,
			K_PRIO_PREEMPT(CONFIG_ENCODER_THREAD_PRIO), 0, K_NO_WAIT);
		ret = k_thread_name_set(encoder_thread_id, "ENCODER");
		ERR_CHK(ret);
	}

#if ((CONFIG_AUDIO_SOURCE_USB) && (CONFIG_AUDIO_DEV == GATEWAY))
	ret = audio_usb_start(&fifo_tx, &fifo_rx);
	ERR_CHK(ret);
#else
	ret = hw_codec_default_conf_enable();
	ERR_CHK(ret);

	ret = audio_datapath_start(&fifo_rx);
	ERR_CHK(ret);
#endif /* ((CONFIG_AUDIO_SOURCE_USB) && (CONFIG_AUDIO_DEV == GATEWAY))) */
}

void audio_system_stop(void)
{
	int ret;

	if (!sw_codec_cfg.initialized) {
		LOG_WRN("Codec already unitialized");
		return;
	}

	LOG_DBG("Stopping codec");

#if ((CONFIG_AUDIO_DEV == GATEWAY) && CONFIG_AUDIO_SOURCE_USB)
	audio_usb_stop();
#else
	ret = hw_codec_soft_reset();
	ERR_CHK(ret);

	ret = audio_datapath_stop();
	ERR_CHK(ret);
#endif /* ((CONFIG_AUDIO_DEV == GATEWAY) && CONFIG_AUDIO_SOURCE_USB) */

	ret = sw_codec_uninit(sw_codec_cfg);
	ERR_CHK_MSG(ret, "Failed to uninit codec");
	sw_codec_cfg.initialized = false;

	data_fifo_empty(&fifo_rx);
	data_fifo_empty(&fifo_tx);
}

int audio_system_fifo_rx_block_drop(void)
{
	int ret;
	void *temp;
	size_t temp_size;

	ret = data_fifo_pointer_last_filled_get(&fifo_rx, &temp, &temp_size, K_NO_WAIT);
	if (ret) {
		LOG_WRN("Failed to get last filled block");
		return -ECANCELED;
	}

	data_fifo_block_free(&fifo_rx, temp);

	LOG_DBG("Block dropped");
	return 0;
}

int audio_system_decoder_num_ch_get(void)
{
	return sw_codec_cfg.decoder.num_ch;
}

int audio_system_init(void)
{
	int ret;

#if ((CONFIG_AUDIO_DEV == GATEWAY) && (CONFIG_AUDIO_SOURCE_USB))
	ret = audio_usb_init();
	if (ret) {
		LOG_ERR("Failed to initialize USB: %d", ret);
		return ret;
	}
#else
	ret = audio_datapath_init();
	if (ret) {
		LOG_ERR("Failed to initialize audio datapath: %d", ret);
		return ret;
	}

	ret = hw_codec_init();
	if (ret) {
		LOG_ERR("Failed to initialize HW codec: %d", ret);
		return ret;
	}
#endif
	k_poll_signal_init(&encoder_sig);

	return 0;
}

static int cmd_audio_system_start(const struct shell *shell, size_t argc, const char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	audio_system_start();

	shell_print(shell, "Audio system started");

	return 0;
}

static int cmd_audio_system_stop(const struct shell *shell, size_t argc, const char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	audio_system_stop();

	shell_print(shell, "Audio system stopped");

	return 0;
}

SHELL_STATIC_SUBCMD_SET_CREATE(audio_system_cmd,
			       SHELL_COND_CMD(CONFIG_SHELL, start, NULL, "Start the audio system",
					      cmd_audio_system_start),
			       SHELL_COND_CMD(CONFIG_SHELL, stop, NULL, "Stop the audio system",
					      cmd_audio_system_stop),
			       SHELL_SUBCMD_SET_END);

SHELL_CMD_REGISTER(audio_system, &audio_system_cmd, "Audio system commands", NULL);


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/audio/sw_codec_select.c
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "sw_codec_select.h"

#include <zephyr/kernel.h>
#include <errno.h>

#include "channel_assignment.h"
#include "pcm_stream_channel_modifier.h"
#include "sample_rate_converter.h"
#if (CONFIG_SW_CODEC_LC3)
#include "sw_codec_lc3.h"
#endif /* (CONFIG_SW_CODEC_LC3) */

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(sw_codec_select, CONFIG_SW_CODEC_SELECT_LOG_LEVEL);

static struct sw_codec_config m_config;

static struct sample_rate_converter_ctx encoder_converters[AUDIO_CH_NUM];
static struct sample_rate_converter_ctx decoder_converters[AUDIO_CH_NUM];

/**
 * @brief	Converts the sample rate of the uncompressed audio stream if needed.
 *
 * @details	Two buffers must be made available for the function: the input_data buffer that
 *		contains the samples for the audio stream, and the conversion buffer that will be
 *		used to store the converted audio stream. data_ptr will point to conversion_buffer
 *		if a conversion took place; otherwise, it will point to input_data.
 *
 * @param[in]	ctx			Sample rate converter context.
 * @param[in]	input_sample_rate	Input sample rate.
 * @param[in]	output_sample_rate	Output sample rate.
 * @param[in]	input_data		Data coming in. Buffer is assumed to be of size
 *					PCM_NUM_BYTES_MONO.
 * @param[in]	input_data_size		Size of input data.
 * @param[in]	conversion_buffer	Buffer to perform sample rate conversion. Must be of size
 *					PCM_NUM_BYTES_MONO.
 * @param[out]	data_ptr		Pointer to the data to be used from this point on.
 *					Will point to either @p input_data or @p conversion_buffer.
 * @param[out]	output_size		Number of bytes out.
 *
 * @retval	-ENOTSUP	Sample rates are not equal, and the sample rate conversion has not
 *been enabled in the application.
 * @retval	0		Success.
 */
static int sw_codec_sample_rate_convert(struct sample_rate_converter_ctx *ctx,
					uint32_t input_sample_rate, uint32_t output_sample_rate,
					char *input_data, size_t input_data_size,
					char *conversion_buffer, char **data_ptr,
					size_t *output_size)
{
	int ret;

	if (input_sample_rate == output_sample_rate) {
		*data_ptr = input_data;
		*output_size = input_data_size;
	} else if (IS_ENABLED(CONFIG_SAMPLE_RATE_CONVERTER)) {
		ret = sample_rate_converter_process(ctx, SAMPLE_RATE_FILTER_SIMPLE, input_data,
						    input_data_size, input_sample_rate,
						    conversion_buffer, PCM_NUM_BYTES_MONO,
						    output_size, output_sample_rate);
		if (ret) {
			LOG_ERR("Failed to convert sample rate: %d", ret);
			return ret;
		}

		*data_ptr = conversion_buffer;
	} else {
		LOG_ERR("Sample rates are not equal, and sample rate conversion has not been "
			"enabled in the application.");
		return -ENOTSUP;
	}

	return 0;
}

bool sw_codec_is_initialized(void)
{
	return m_config.initialized;
}

int sw_codec_encode(void *pcm_data, size_t pcm_size, uint8_t **encoded_data, size_t *encoded_size)
{
	int ret;

	/* Temp storage for split stereo PCM signal */
	char pcm_data_mono_system_sample_rate[AUDIO_CH_NUM][PCM_NUM_BYTES_MONO] = {0};
	/* Make sure we have enough space for two frames (stereo) */
	static uint8_t m_encoded_data[ENC_MAX_FRAME_SIZE * AUDIO_CH_NUM];

	char pcm_data_mono_converted_buf[AUDIO_CH_NUM][PCM_NUM_BYTES_MONO] = {0};

	size_t pcm_block_size_mono_system_sample_rate;
	size_t pcm_block_size_mono;

	if (!m_config.encoder.enabled) {
		LOG_ERR("Encoder has not been initialized");
		return -ENXIO;
	}

	switch (m_config.sw_codec) {
	case SW_CODEC_LC3: {
#if (CONFIG_SW_CODEC_LC3)
		uint16_t encoded_bytes_written;
		char *pcm_data_mono_ptrs[m_config.encoder.channel_mode];

		/* Since LC3 is a single channel codec, we must split the
		 * stereo PCM stream
		 */
		ret = pscm_two_channel_split(pcm_data, pcm_size, CONFIG_AUDIO_BIT_DEPTH_BITS,
					     pcm_data_mono_system_sample_rate[AUDIO_CH_L],
					     pcm_data_mono_system_sample_rate[AUDIO_CH_R],
					     &pcm_block_size_mono_system_sample_rate);
		if (ret) {
			return ret;
		}

		for (int i = 0; i < m_config.encoder.channel_mode; ++i) {
			ret = sw_codec_sample_rate_convert(
				&encoder_converters[i], CONFIG_AUDIO_SAMPLE_RATE_HZ,
				m_config.encoder.sample_rate_hz,
				pcm_data_mono_system_sample_rate[i],
				pcm_block_size_mono_system_sample_rate,
				pcm_data_mono_converted_buf[i], &pcm_data_mono_ptrs[i],
				&pcm_block_size_mono);
			if (ret) {
				LOG_ERR("Sample rate conversion failed for channel %d: %d", i, ret);
				return ret;
			}
		}

		switch (m_config.encoder.channel_mode) {
		case SW_CODEC_MONO: {
			ret = sw_codec_lc3_enc_run(pcm_data_mono_ptrs[AUDIO_CH_L],
						   pcm_block_size_mono, LC3_USE_BITRATE_FROM_INIT,
						   0, sizeof(m_encoded_data), m_encoded_data,
						   &encoded_bytes_written);
			if (ret) {
				return ret;
			}
			break;
		}
		case SW_CODEC_STEREO: {
			ret = sw_codec_lc3_enc_run(pcm_data_mono_ptrs[AUDIO_CH_L],
						   pcm_block_size_mono, LC3_USE_BITRATE_FROM_INIT,
						   AUDIO_CH_L, sizeof(m_encoded_data),
						   m_encoded_data, &encoded_bytes_written);
			if (ret) {
				return ret;
			}

			ret = sw_codec_lc3_enc_run(
				pcm_data_mono_ptrs[AUDIO_CH_R], pcm_block_size_mono,
				LC3_USE_BITRATE_FROM_INIT, AUDIO_CH_R,
				sizeof(m_encoded_data) - encoded_bytes_written,
				m_encoded_data + encoded_bytes_written, &encoded_bytes_written);
			if (ret) {
				return ret;
			}
			encoded_bytes_written += encoded_bytes_written;
			break;
		}
		default:
			LOG_ERR("Unsupported channel mode for encoder: %d",
				m_config.encoder.channel_mode);
			return -ENODEV;
		}

		*encoded_data = m_encoded_data;
		*encoded_size = encoded_bytes_written;

#endif /* (CONFIG_SW_CODEC_LC3) */
		break;
	}
	default:
		LOG_ERR("Unsupported codec: %d", m_config.sw_codec);
		return -ENODEV;
	}

	return 0;
}

int sw_codec_decode(uint8_t const *const encoded_data, size_t encoded_size, bool bad_frame,
		    void **decoded_data, size_t *decoded_size)
{
	if (!m_config.decoder.enabled) {
		LOG_ERR("Decoder has not been initialized");
		return -ENXIO;
	}

	int ret;

	static char pcm_data_stereo[PCM_NUM_BYTES_STEREO];

	char decoded_data_mono[AUDIO_CH_NUM][PCM_NUM_BYTES_MONO] = {0};
	char decoded_data_mono_system_sample_rate[AUDIO_CH_NUM][PCM_NUM_BYTES_MONO] = {0};

	size_t pcm_size_stereo = 0;
	size_t pcm_size_mono = 0;
	size_t decoded_data_size = 0;

	switch (m_config.sw_codec) {
	case SW_CODEC_LC3: {
#if (CONFIG_SW_CODEC_LC3)
		char *pcm_in_data_ptrs[m_config.decoder.channel_mode];

		switch (m_config.decoder.channel_mode) {
		case SW_CODEC_MONO: {
			if (bad_frame && IS_ENABLED(CONFIG_SW_CODEC_OVERRIDE_PLC)) {
				memset(decoded_data_mono[AUDIO_CH_L], 0, PCM_NUM_BYTES_MONO);
				decoded_data_size = PCM_NUM_BYTES_MONO;
			} else {
				ret = sw_codec_lc3_dec_run(
					encoded_data, encoded_size, LC3_PCM_NUM_BYTES_MONO, 0,
					decoded_data_mono[AUDIO_CH_L],
					(uint16_t *)&decoded_data_size, bad_frame);
				if (ret) {
					return ret;
				}

				ret = sw_codec_sample_rate_convert(
					&decoder_converters[AUDIO_CH_L],
					m_config.decoder.sample_rate_hz,
					CONFIG_AUDIO_SAMPLE_RATE_HZ, decoded_data_mono[AUDIO_CH_L],
					decoded_data_size,
					decoded_data_mono_system_sample_rate[AUDIO_CH_L],
					&pcm_in_data_ptrs[AUDIO_CH_L], &pcm_size_mono);
				if (ret) {
					LOG_ERR("Sample rate conversion failed for mono: %d", ret);
					return ret;
				}
			}

			/* For now, i2s is only stereo, so in order to send
			 * just one channel, we need to insert 0 for the
			 * other channel
			 */
			ret = pscm_zero_pad(pcm_in_data_ptrs[AUDIO_CH_L], pcm_size_mono,
					    m_config.decoder.audio_ch, CONFIG_AUDIO_BIT_DEPTH_BITS,
					    pcm_data_stereo, &pcm_size_stereo);
			if (ret) {
				return ret;
			}
			break;
		}
		case SW_CODEC_STEREO: {
			if (bad_frame && IS_ENABLED(CONFIG_SW_CODEC_OVERRIDE_PLC)) {
				memset(decoded_data_mono[AUDIO_CH_L], 0, PCM_NUM_BYTES_MONO);
				memset(decoded_data_mono[AUDIO_CH_R], 0, PCM_NUM_BYTES_MONO);
				decoded_data_size = PCM_NUM_BYTES_MONO;
			} else {
				/* Decode left channel */
				ret = sw_codec_lc3_dec_run(
					encoded_data, encoded_size / 2, LC3_PCM_NUM_BYTES_MONO,
					AUDIO_CH_L, decoded_data_mono[AUDIO_CH_L],
					(uint16_t *)&decoded_data_size, bad_frame);
				if (ret) {
					return ret;
				}

				/* Decode right channel */
				ret = sw_codec_lc3_dec_run(
					(encoded_data + (encoded_size / 2)), encoded_size / 2,
					LC3_PCM_NUM_BYTES_MONO, AUDIO_CH_R,
					decoded_data_mono[AUDIO_CH_R],
					(uint16_t *)&decoded_data_size, bad_frame);
				if (ret) {
					return ret;
				}

				for (int i = 0; i < m_config.decoder.channel_mode; ++i) {
					ret = sw_codec_sample_rate_convert(
						&decoder_converters[i],
						m_config.decoder.sample_rate_hz,
						CONFIG_AUDIO_SAMPLE_RATE_HZ, decoded_data_mono[i],
						decoded_data_size,
						decoded_data_mono_system_sample_rate[i],
						&pcm_in_data_ptrs[i], &pcm_size_mono);
					if (ret) {
						LOG_ERR("Sample rate conversion failed for channel "
							"%d : %d",
							i, ret);
						return ret;
					}
				}
			}

			ret = pscm_combine(pcm_in_data_ptrs[AUDIO_CH_L],
					   pcm_in_data_ptrs[AUDIO_CH_R], pcm_size_mono,
					   CONFIG_AUDIO_BIT_DEPTH_BITS, pcm_data_stereo,
					   &pcm_size_stereo);
			if (ret) {
				return ret;
			}
			break;
		}
		default:
			LOG_ERR("Unsupported channel mode for decoder: %d",
				m_config.decoder.channel_mode);
			return -ENODEV;
		}

		*decoded_size = pcm_size_stereo;
		*decoded_data = pcm_data_stereo;
#endif /* (CONFIG_SW_CODEC_LC3) */
		break;
	}
	default:
		LOG_ERR("Unsupported codec: %d", m_config.sw_codec);
		return -ENODEV;
	}
	return 0;
}

int sw_codec_uninit(struct sw_codec_config sw_codec_cfg)
{
	int ret;

	if (m_config.sw_codec != sw_codec_cfg.sw_codec) {
		LOG_ERR("Trying to uninit a codec that is not first initialized");
		return -ENODEV;
	}
	switch (m_config.sw_codec) {
	case SW_CODEC_LC3:
#if (CONFIG_SW_CODEC_LC3)
		if (sw_codec_cfg.encoder.enabled) {
			if (!m_config.encoder.enabled) {
				LOG_ERR("Trying to uninit encoder, it has not been "
					"initialized");
				return -EALREADY;
			}
			ret = sw_codec_lc3_enc_uninit_all();
			if (ret) {
				return ret;
			}
			m_config.encoder.enabled = false;
		}

		if (sw_codec_cfg.decoder.enabled) {
			if (!m_config.decoder.enabled) {
				LOG_WRN("Trying to uninit decoder, it has not been "
					"initialized");
				return -EALREADY;
			}

			ret = sw_codec_lc3_dec_uninit_all();
			if (ret) {
				return ret;
			}
			m_config.decoder.enabled = false;
		}
#endif /* (CONFIG_SW_CODEC_LC3) */
		break;
	default:
		LOG_ERR("Unsupported codec: %d", m_config.sw_codec);
		return false;
	}

	m_config.initialized = false;

	return 0;
}

int sw_codec_init(struct sw_codec_config sw_codec_cfg)
{
	int ret;

	switch (sw_codec_cfg.sw_codec) {
	case SW_CODEC_LC3: {
#if (CONFIG_SW_CODEC_LC3)
		if (m_config.sw_codec != SW_CODEC_LC3) {
			/* Check if LC3 is already initialized */
			ret = sw_codec_lc3_init(NULL, NULL, CONFIG_AUDIO_FRAME_DURATION_US);
			if (ret) {
				return ret;
			}
		}

		if (sw_codec_cfg.encoder.enabled) {
			if (m_config.encoder.enabled) {
				LOG_WRN("The LC3 encoder is already initialized");
				return -EALREADY;
			}
			uint16_t pcm_bytes_req_enc;

			LOG_DBG("Encode: %dHz %dbits %dus %dbps %d channel(s)",
				sw_codec_cfg.encoder.sample_rate_hz, CONFIG_AUDIO_BIT_DEPTH_BITS,
				CONFIG_AUDIO_FRAME_DURATION_US, sw_codec_cfg.encoder.bitrate,
				sw_codec_cfg.encoder.num_ch);

			ret = sw_codec_lc3_enc_init(
				sw_codec_cfg.encoder.sample_rate_hz, CONFIG_AUDIO_BIT_DEPTH_BITS,
				CONFIG_AUDIO_FRAME_DURATION_US, sw_codec_cfg.encoder.bitrate,
				sw_codec_cfg.encoder.num_ch, &pcm_bytes_req_enc);

			if (ret) {
				return ret;
			}
		}

		if (sw_codec_cfg.decoder.enabled) {
			if (m_config.decoder.enabled) {
				LOG_WRN("The LC3 decoder is already initialized");
				return -EALREADY;
			}

			LOG_DBG("Decode: %dHz %dbits %dus %d channel(s)",
				sw_codec_cfg.decoder.sample_rate_hz, CONFIG_AUDIO_BIT_DEPTH_BITS,
				CONFIG_AUDIO_FRAME_DURATION_US, sw_codec_cfg.decoder.num_ch);

			ret = sw_codec_lc3_dec_init(
				sw_codec_cfg.decoder.sample_rate_hz, CONFIG_AUDIO_BIT_DEPTH_BITS,
				CONFIG_AUDIO_FRAME_DURATION_US, sw_codec_cfg.decoder.num_ch);

			if (ret) {
				return ret;
			}
		}
		break;
#else
		LOG_ERR("LC3 is not compiled in, please open menuconfig and select "
			"LC3");
		return -ENODEV;
#endif /* (CONFIG_SW_CODEC_LC3) */
	}

	default:
		LOG_ERR("Unsupported codec: %d", sw_codec_cfg.sw_codec);
		return false;
	}

	if (sw_codec_cfg.encoder.enabled && IS_ENABLED(SAMPLE_RATE_CONVERTER)) {
		for (int i = 0; i < sw_codec_cfg.encoder.channel_mode; i++) {
			ret = sample_rate_converter_open(&encoder_converters[i]);
			if (ret) {
				LOG_ERR("Failed to initialize the sample rate converter for "
					"encoding channel %d: %d",
					i, ret);
				return ret;
			}
		}
	}

	if (sw_codec_cfg.decoder.enabled && IS_ENABLED(SAMPLE_RATE_CONVERTER)) {
		for (int i = 0; i < sw_codec_cfg.decoder.channel_mode; i++) {
			ret = sample_rate_converter_open(&decoder_converters[i]);
			if (ret) {
				LOG_ERR("Failed to initialize the sample rate converter for "
					"decoding channel %d: %d",
					i, ret);
				return ret;
			}
		}
	}

	m_config = sw_codec_cfg;
	m_config.initialized = true;

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/audio/Kconfig
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

rsource "Kconfig.defaults"

menu "Audio"

choice AUDIO_FRAME_DURATION
	prompt "Select frame duration - 7.5 ms frame duration is not tested"
	default AUDIO_FRAME_DURATION_10_MS
	help
	  LC3 supports frame duration of 7.5 and 10 ms.
	  If USB is selected as audio source, we should
	  have a frame duration of 10 ms since USB sends 1ms at a time.

config AUDIO_FRAME_DURATION_7_5_MS
	bool "7.5 ms"

config AUDIO_FRAME_DURATION_10_MS
	bool "10 ms"
endchoice

config AUDIO_FRAME_DURATION_US
	int
	default 7500 if AUDIO_FRAME_DURATION_7_5_MS
	default 10000 if AUDIO_FRAME_DURATION_10_MS
	help
	  Audio frame duration in s.

config AUDIO_MIN_PRES_DLY_US
	int "The minimum presentation delay"
	default 4000
	help
	  The minimum presentation delay in micro seconds determined by
	  the audio system processing and the minimum buffering.

config AUDIO_MAX_PRES_DLY_US
	int "The maximum presentation delay"
	default 60000
	help
	  The maximum presentation delay in micro seconds.

choice AUDIO_SYSTEM_SAMPLE_RATE
	prompt "System audio sample rate"
	default AUDIO_SAMPLE_RATE_48000_HZ
	help
	  This configuration reflects the system sample rate, but the audio data may be resampled to
	  another sample rate before encoding, and after decoding.

config AUDIO_SAMPLE_RATE_16000_HZ
	bool "16 kHz"
	help
	  Sample rate of 16kHz is currently only valid for I2S/line-in.

config AUDIO_SAMPLE_RATE_24000_HZ
	bool "24 kHz"
	help
	  Sample rate of 24kHz is currently only valid for I2S/line-in.

config AUDIO_SAMPLE_RATE_48000_HZ
	bool "48 kHz"
	help
	  Sample rate of 48kHz is valid for both I2S/line-in and USB.
endchoice

config AUDIO_SAMPLE_RATE_HZ
	int
	default 16000 if AUDIO_SAMPLE_RATE_16000_HZ
	default 24000 if AUDIO_SAMPLE_RATE_24000_HZ
	default 48000 if AUDIO_SAMPLE_RATE_48000_HZ
	help
	  I2S supports 16, 24, and 48 kHz sample rates for both input and output.
	  USB supports only 48 kHz for input.

choice AUDIO_BIT_DEPTH
	prompt "Audio bit depth"
	default AUDIO_BIT_DEPTH_16
	help
	  Select the bit depth for audio.

config AUDIO_BIT_DEPTH_16
	bool "16 bit audio"

config AUDIO_BIT_DEPTH_32
	bool "32 bit audio"
endchoice

config AUDIO_BIT_DEPTH_BITS
	int
	default 16 if AUDIO_BIT_DEPTH_16
	default 32 if AUDIO_BIT_DEPTH_32
	help
	  Bit depth of one sample in storage.

config AUDIO_BIT_DEPTH_OCTETS
	int
	default 2 if AUDIO_BIT_DEPTH_16
	default 4 if AUDIO_BIT_DEPTH_32
	help
	  Bit depth of one sample in storage given in octets.

config AUDIO_MIN_PRES_DLY_US
	int "The minimum presentation delay"
	default 4000
	help
	  The minimum allowable presentation delay in microseconds.
	  This needs to allow time for decoding and internal routing.
	  For 48kHz sampling rate and 96kbps bitrate this is about 4000 us.

config AUDIO_MAX_PRES_DLY_US
	int "The maximum presentation delay"
	default 60000
	help
	  The maximum allowable presentation delay in microseconds.
	  Increasing this will also increase the FIFO buffers to allow buffering.

choice AUDIO_SOURCE_GATEWAY
	prompt "Audio source for gateway"
	default AUDIO_SOURCE_I2S if WALKIE_TALKIE_DEMO
	default AUDIO_SOURCE_USB
	help
	  Select audio source for the gateway.

config AUDIO_SOURCE_USB
	bool "Use USB as audio source"
	help
	  Set USB as audio source. Note that this forces the
	  stream to be unidirectional because of CPU load.

config AUDIO_SOURCE_I2S
	bool "Use I2S as audio source"
endchoice

choice AUDIO_HEADSET_CHANNEL
	prompt "Headset audio channel assignment"
	default AUDIO_HEADSET_CHANNEL_RUNTIME
	help
	  Set whether audio channel assignment for the headset
	  should happen at runtime or compile-time.

config AUDIO_HEADSET_CHANNEL_RUNTIME
	bool "Select at runtime"
	help
	  Make channel selection at runtime. Selected value is stored in persistent memory.
	  Left channel: Hold volume-down button on headset while resetting headset.
	  Right channel: Hold volume-up button on headset while resetting headset.

config AUDIO_HEADSET_CHANNEL_COMPILE_TIME
	bool "Set at compile-time"
	help
	  Set channel selection at compile-time.
endchoice

config AUDIO_TEST_TONE
	bool "Test tone instead of doing user defined action"
	select TONE
	default y
	help
	  Use button 4 to set a test tone
	  instead of doing a user defined action.
	  The test tone is generated on the device itself.

config AUDIO_MUTE
	bool "Mute instead of doing user defined action"
	default y
	help
	  Use button 5 to mute audio instead of
	  doing a user defined action.

if AUDIO_HEADSET_CHANNEL_COMPILE_TIME

config AUDIO_HEADSET_CHANNEL
	int "Audio channel used by headset"
	range 0 1
	default 0
	help
	  Audio channel compile-time selection.
	  Left = 0.
	  Right = 1.

endif # AUDIO_HEADSET_CHANNEL_COMPILE_TIME

#----------------------------------------------------------------------------#
menu "SW Codec"

choice SW_CODEC_DEFAULT
	prompt "Starting SW codec"
	default SW_CODEC_LC3
	help
	  Select the default codec to use on start up.

config SW_CODEC_LC3
	bool "LC3"
	select SW_CODEC_LC3_T2_SOFTWARE
	help
	  LC3 is the mandatory codec for LE Audio.

# Leave room for other codecs
endchoice

config SW_CODEC_PLC_DISABLED
	bool "Skip PLC on a bad frame and fill the output buffer(s) with zeros instead"
	default n
	select LC3_PLC_DISABLED

#----------------------------------------------------------------------------#
menu "LC3"
visible if SW_CODEC_LC3

config LC3_BITRATE_MAX
	int "Max bitrate for LC3"
	default 96000

config LC3_BITRATE_MIN
	int "Min bitrate for LC3"
	default 32000

config LC3_BITRATE
	int
	range LC3_BITRATE_MIN LC3_BITRATE_MAX
	default 96000

osource "../nrfxlib/lc3/Kconfig"

endmenu # LC3
endmenu # SW Codec

#----------------------------------------------------------------------------#
menu "Stream"

config BUF_BLE_RX_PACKET_NUM
	int
	default 5
	range 2 5
	help
	  Value can be adjusted to affect the overall latency.
	  This adjusts the number packets in the BLE FIFO RX buffer,
	  which is where the main latency resides. A low value will decrease
	  latency and reduce stability, and vice-versa.
	  Two is recommended minimum to reduce the likelyhood of audio
	  gaps due to BLE retransmits.

config STREAM_BIDIRECTIONAL
	depends on TRANSPORT_CIS
	bool "Bidirectional stream"
	default n
	help
	  Bidirectional stream enables encoder and decoder on both sides,
	  and one device can both send and receive audio.

config WALKIE_TALKIE_DEMO
	select STREAM_BIDIRECTIONAL
	bool "Walkie talkie demo"
	default n
	help
	  The walkie talkie demo will set up a bidirectional stream using PDM
	  microphones on each side.

config MONO_TO_ALL_RECEIVERS
	bool "Send mono (first/left channel) to all receivers"
	default y if BT_BAP_UNICAST_CLIENT_ASE_SNK_COUNT = 1
	default y if BT_BAP_BROADCAST_SRC_STREAM_COUNT = 1
	default n
	help
	  With this flag set, the gateway will encode and send the same (first/left)
	  channel on all ISO channels.

endmenu # Stream

#----------------------------------------------------------------------------#
menu "Log levels"

module = AUDIO_SYSTEM
module-str = audio-system
source "subsys/logging/Kconfig.template.log_config"

module = SW_CODEC_SELECT
module-str = sw-codec-select
source "subsys/logging/Kconfig.template.log_config"

module = STREAMCTRL
module-str = streamctrl
source "subsys/logging/Kconfig.template.log_config"

module = AUDIO_DATAPATH
module-str = audio-datapath
source "subsys/logging/Kconfig.template.log_config"

module = AUDIO_SYNC_TIMER
module-str = audio-sync-timer
source "subsys/logging/Kconfig.template.log_config"

module = LE_AUDIO_RX
module-str = le-audio-rx
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log levels

#----------------------------------------------------------------------------#
menu "Thread priorities"

config ENCODER_THREAD_PRIO
	int "Priority for encoder thread"
	default 3
	help
	  This is a preemptible thread.

config AUDIO_DATAPATH_THREAD_PRIO
	int "Priority for audio datapath thread"
	default 4
	help
	  This is a preemptible thread.

config BUTTON_MSG_SUB_THREAD_PRIO
	int "Thread priority for button subscriber"
	default 5
	help
	  This is a preemptible thread.
	  This thread will subscribe to button events from zbus.

config LE_AUDIO_MSG_SUB_THREAD_PRIO
	int "Thread priority for LE Audio subscriber"
	default 5
	help
	  This is a preemptible thread.
	  This thread will subscribe to LE Audio events from zbus.

config CONTENT_CONTROL_MSG_SUB_THREAD_PRIO
	int "Thread priority for content control subscriber"
	default 5
	help
	  This is a preemptible thread.
	  This thread will subscribe to content control events from zbus.

endmenu # Thread priorities

#----------------------------------------------------------------------------#
menu "Stack sizes"

config ENCODER_STACK_SIZE
	int "Stack size for encoder thread"
	default 11000 if AUDIO_BIT_DEPTH_16
	default 21400 if AUDIO_BIT_DEPTH_32

config AUDIO_DATAPATH_STACK_SIZE
	int "Stack size for audio datapath thread"
	default 7600 if AUDIO_BIT_DEPTH_16
	default 14700 if AUDIO_BIT_DEPTH_32

config BUTTON_MSG_SUB_STACK_SIZE
	int "Stack size for button subscriber"
	default 2048

config LE_AUDIO_MSG_SUB_STACK_SIZE
	int "Stack size for LE Audio subscriber"
	default 2048

config CONTENT_CONTROL_MSG_SUB_STACK_SIZE
	int "Stack size for content control subscriber"
	default 1024

endmenu # Stack sizes

#----------------------------------------------------------------------------#
menu "Zbus"

config BUTTON_MSG_SUB_QUEUE_SIZE
	int "Queue size for button subscriber"
	default 4

config CONTENT_CONTROL_MSG_SUB_QUEUE_SIZE
	int "Queue size for content control subscriber"
	default 4

endmenu # Zbus
endmenu # Audio


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/audio/audio_datapath.c
/*
 *  Copyright (c) 2021, PACKETCRAFT, INC.
 *
 *  SPDX-License-Identifier: LicenseRef-PCFT
 */

#include "audio_datapath.h"

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <zephyr/zbus/zbus.h>
#include <zephyr/kernel.h>
#include <zephyr/shell/shell.h>
#include <nrfx_clock.h>

#include "nrf5340_audio_common.h"
#include "macros_common.h"
#include "led.h"
#include "audio_i2s.h"
#include "sw_codec_select.h"
#include "audio_system.h"
#include "tone.h"
#include "contin_array.h"
#include "pcm_mix.h"
#include "streamctrl.h"
#include "audio_sync_timer.h"
#include "sd_card_playback.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(audio_datapath, CONFIG_AUDIO_DATAPATH_LOG_LEVEL);

/*
 * Terminology
 *   - sample: signed integer of audio waveform amplitude
 *   - sample FIFO: circular array of raw audio samples
 *   - block: set of raw audio samples exchanged with I2S
 *   - frame: encoded audio packet exchanged with connectivity
 */

#define SDU_REF_DELTA_MAX_ERR_US (int)(CONFIG_AUDIO_FRAME_DURATION_US * 0.001)

#define BLK_PERIOD_US 1000

/* Total sample FIFO period in microseconds */
#define FIFO_SMPL_PERIOD_US (CONFIG_AUDIO_MAX_PRES_DLY_US * 2)
#define FIFO_NUM_BLKS	    NUM_BLKS(FIFO_SMPL_PERIOD_US)
#define MAX_FIFO_SIZE	    (FIFO_NUM_BLKS * BLK_SIZE_SAMPLES(CONFIG_AUDIO_SAMPLE_RATE_HZ) * 2)

/* Number of audio blocks given a duration */
#define NUM_BLKS(d) ((d) / BLK_PERIOD_US)
/* Single audio block size in number of samples (stereo) */
/* clang-format off */
#define BLK_SIZE_SAMPLES(r) (((r)*BLK_PERIOD_US) / 1000000)
/* clang-format on */
/* Increment sample FIFO index by one block */
#define NEXT_IDX(i) (((i) < (FIFO_NUM_BLKS - 1)) ? ((i) + 1) : 0)
/* Decrement sample FIFO index by one block */
#define PREV_IDX(i) (((i) > 0) ? ((i)-1) : (FIFO_NUM_BLKS - 1))

#define NUM_BLKS_IN_FRAME      NUM_BLKS(CONFIG_AUDIO_FRAME_DURATION_US)
#define BLK_MONO_NUM_SAMPS     BLK_SIZE_SAMPLES(CONFIG_AUDIO_SAMPLE_RATE_HZ)
#define BLK_STEREO_NUM_SAMPS   (BLK_MONO_NUM_SAMPS * 2)
/* Number of octets in a single audio block */
#define BLK_MONO_SIZE_OCTETS   (BLK_MONO_NUM_SAMPS * CONFIG_AUDIO_BIT_DEPTH_OCTETS)
#define BLK_STEREO_SIZE_OCTETS (BLK_MONO_SIZE_OCTETS * 2)
/* How many function calls before moving on with drift compensation */
#define DRIFT_COMP_WAITING_CNT (DRIFT_MEAS_PERIOD_US / BLK_PERIOD_US)
/* How much data to be collected before moving on with presentation compensation */
#define PRES_COMP_NUM_DATA_PTS (DRIFT_MEAS_PERIOD_US / CONFIG_AUDIO_FRAME_DURATION_US)

/* Audio clock - nRF5340 Analog Phase-Locked Loop (APLL) */
#define APLL_FREQ_CENTER 39854
#define APLL_FREQ_MIN	 36834
#define APLL_FREQ_MAX	 42874
/* Use nanoseconds to reduce rounding errors */
/* clang-format off */
#define APLL_FREQ_ADJ(t) (-((t)*1000) / 331)
/* clang-format on */

#define DRIFT_MEAS_PERIOD_US	   100000
#define DRIFT_ERR_THRESH_LOCK	   16
#define DRIFT_ERR_THRESH_UNLOCK	   32
/* To get smaller corrections */
#define DRIFT_REGULATOR_DIV_FACTOR 2

/* To allow BLE transmission and (host -> HCI -> controller) */
#if defined(CONFIG_BT_LL_ACS_NRF53)
#define JUST_IN_TIME_TARGET_DLY_US (CONFIG_AUDIO_FRAME_DURATION_US - 3000)
#else /* !CONFIG_BT_LL_ACS_NRF53 */
#define JUST_IN_TIME_TARGET_DLY_US 3000
#endif /* !CONFIG_BT_LL_ACS_NRF53 */
#define JUST_IN_TIME_BOUND_US 2500

/* How often to print under-run warning */
#define UNDERRUN_LOG_INTERVAL_BLKS 5000

enum drift_comp_state {
	DRIFT_STATE_INIT,   /* Waiting for data to be received */
	DRIFT_STATE_CALIB,  /* Calibrate and zero out local delay */
	DRIFT_STATE_OFFSET, /* Adjust I2S offset relative to SDU Reference */
	DRIFT_STATE_LOCKED  /* Drift compensation locked - Minor corrections */
};

static const char *const drift_comp_state_names[] = {
	"INIT",
	"CALIB",
	"OFFSET",
	"LOCKED",
};

enum pres_comp_state {
	PRES_STATE_INIT,  /* Initialize presentation compensation */
	PRES_STATE_MEAS,  /* Measure presentation delay */
	PRES_STATE_WAIT,  /* Wait for some time */
	PRES_STATE_LOCKED /* Presentation compensation locked */
};

static const char *const pres_comp_state_names[] = {
	"INIT",
	"MEAS",
	"WAIT",
	"LOCKED",
};

static struct {
	bool datapath_initialized;
	bool stream_started;
	void *decoded_data;

	struct {
		struct data_fifo *fifo;
	} in;

	struct {
#if CONFIG_AUDIO_BIT_DEPTH_16
		int16_t __aligned(sizeof(uint32_t)) fifo[MAX_FIFO_SIZE];
#elif CONFIG_AUDIO_BIT_DEPTH_32
		int32_t __aligned(sizeof(uint32_t)) fifo[MAX_FIFO_SIZE];
#endif
		uint16_t prod_blk_idx; /* Output producer audio block index */
		uint16_t cons_blk_idx; /* Output consumer audio block index */
		uint32_t prod_blk_ts[FIFO_NUM_BLKS];
		/* Statistics */
		uint32_t total_blk_underruns;
	} out;

	uint32_t prev_drift_sdu_ref_us;
	uint32_t prev_pres_sdu_ref_us;
	uint32_t current_pres_dly_us;

	struct {
		enum drift_comp_state state: 8;
		uint16_t ctr; /* Count func calls. Used for waiting */
		uint32_t meas_start_time_us;
		uint32_t center_freq;
		bool enabled;
	} drift_comp;

	struct {
		enum pres_comp_state state: 8;
		uint16_t ctr; /* Count func calls. Used for collecting data points and waiting */
		int32_t sum_err_dly_us;
		uint32_t pres_delay_us;
		bool enabled;
	} pres_comp;
} ctrl_blk;

static bool tone_active;
/* Buffer which can hold max 1 period test tone at 100 Hz */
static uint16_t test_tone_buf[CONFIG_AUDIO_SAMPLE_RATE_HZ / 100];
static size_t test_tone_size;

/**
 * @brief	Calculate error between sdu_ref and frame_start_ts_us.
 *
 * @note	Used to adjust audio clock to account for drift.
 *
 * @param	sdu_ref_us	Timestamp for SDU.
 * @param	frame_start_ts_us	Timestamp for I2S.
 *
 * @return	Error in microseconds (err_us).
 */
static int32_t err_us_calculate(uint32_t sdu_ref_us, uint32_t frame_start_ts_us)
{
	bool err_neg = false;

	if (IS_ENABLED(CONFIG_BT_LL_ACS_NRF53) && IS_ENABLED(CONFIG_TRANSPORT_BIS)) {
		/* To make the drift compensation work as expected
		 * when using the LE Audio Controller Subsystem Link Layer
		 * and BIS we must add CONFIG_AUDIO_FRAME_DURATION_US to
		 * sdu_ref_us.
		 * This is a temporary workaround.
		 */
		sdu_ref_us += CONFIG_AUDIO_FRAME_DURATION_US;
	}

	int64_t total_err = ((int64_t)sdu_ref_us - (int64_t)frame_start_ts_us);

	/* Store sign for later use, since remainder operation is undefined for negatives */
	if (total_err < 0) {
		err_neg = true;
		total_err *= -1;
	}

	/* Check diff below 1000 us, diff above 1000 us is fixed later on */
	int32_t err_us = total_err % BLK_PERIOD_US;

	if (err_us > (BLK_PERIOD_US / 2)) {
		err_us = err_us - BLK_PERIOD_US;
	}

	/* Restore the sign */
	if (err_neg) {
		err_us *= -1;
	}

	return err_us;
}

static void hfclkaudio_set(uint16_t freq_value)
{
	uint16_t freq_val = freq_value;

	freq_val = MIN(freq_val, APLL_FREQ_MAX);
	freq_val = MAX(freq_val, APLL_FREQ_MIN);

	nrfx_clock_hfclkaudio_config_set(freq_val);
}

static void drift_comp_state_set(enum drift_comp_state new_state)
{
	if (new_state == ctrl_blk.drift_comp.state) {
		LOG_WRN("Trying to change to the same drift compensation state");
		return;
	}

	ctrl_blk.drift_comp.state = new_state;
	LOG_INF("Drft comp state: %s", drift_comp_state_names[new_state]);
}

/**
 * @brief	Adjust frequency of HFCLKAUDIO to get audio in sync.
 *
 * @note	The audio sync is based on sdu_ref_us.
 *
 * @param	frame_start_ts_us	I2S frame start timestamp.
 */
static void audio_datapath_drift_compensation(uint32_t frame_start_ts_us)
{
	if (CONFIG_AUDIO_DEV == HEADSET) {
		/** For headsets we do not use the timestamp gotten from hci_tx_sync_get to adjust
		 * for drift
		 */
		ctrl_blk.prev_drift_sdu_ref_us = ctrl_blk.prev_pres_sdu_ref_us;
	}
	switch (ctrl_blk.drift_comp.state) {
	case DRIFT_STATE_INIT: {
		/* Check if audio data has been received */
		if (ctrl_blk.prev_drift_sdu_ref_us) {
			ctrl_blk.drift_comp.meas_start_time_us = ctrl_blk.prev_drift_sdu_ref_us;

			drift_comp_state_set(DRIFT_STATE_CALIB);
		}

		break;
	}
	case DRIFT_STATE_CALIB: {
		if (++ctrl_blk.drift_comp.ctr < DRIFT_COMP_WAITING_CNT) {
			/* Waiting */
			return;
		}

		ctrl_blk.drift_comp.ctr = 0;

		int32_t err_us = DRIFT_MEAS_PERIOD_US - (ctrl_blk.prev_drift_sdu_ref_us -
							 ctrl_blk.drift_comp.meas_start_time_us);

		int32_t freq_adj = APLL_FREQ_ADJ(err_us);

		ctrl_blk.drift_comp.center_freq = APLL_FREQ_CENTER + freq_adj;

		if ((ctrl_blk.drift_comp.center_freq > (APLL_FREQ_MAX)) ||
		    (ctrl_blk.drift_comp.center_freq < (APLL_FREQ_MIN))) {
			LOG_DBG("Invalid center frequency, re-calculating");
			drift_comp_state_set(DRIFT_STATE_INIT);
			return;
		}

		hfclkaudio_set(ctrl_blk.drift_comp.center_freq);

		drift_comp_state_set(DRIFT_STATE_OFFSET);

		break;
	}
	case DRIFT_STATE_OFFSET: {
		if (++ctrl_blk.drift_comp.ctr < DRIFT_COMP_WAITING_CNT) {
			/* Waiting */
			return;
		}

		ctrl_blk.drift_comp.ctr = 0;

		int32_t err_us =
			err_us_calculate(ctrl_blk.prev_drift_sdu_ref_us, frame_start_ts_us);

		err_us /= DRIFT_REGULATOR_DIV_FACTOR;
		int32_t freq_adj = APLL_FREQ_ADJ(err_us);

		hfclkaudio_set(ctrl_blk.drift_comp.center_freq + freq_adj);

		if ((err_us < DRIFT_ERR_THRESH_LOCK) && (err_us > -DRIFT_ERR_THRESH_LOCK)) {
			drift_comp_state_set(DRIFT_STATE_LOCKED);
		}

		break;
	}
	case DRIFT_STATE_LOCKED: {
		if (++ctrl_blk.drift_comp.ctr < DRIFT_COMP_WAITING_CNT) {
			/* Waiting */
			return;
		}

		ctrl_blk.drift_comp.ctr = 0;

		int32_t err_us =
			err_us_calculate(ctrl_blk.prev_drift_sdu_ref_us, frame_start_ts_us);

		err_us /= DRIFT_REGULATOR_DIV_FACTOR;
		int32_t freq_adj = APLL_FREQ_ADJ(err_us);

		hfclkaudio_set(ctrl_blk.drift_comp.center_freq + freq_adj);

		if ((err_us > DRIFT_ERR_THRESH_UNLOCK) || (err_us < -DRIFT_ERR_THRESH_UNLOCK)) {
			drift_comp_state_set(DRIFT_STATE_INIT);
		}

		break;
	}
	default: {
		break;
	}
	}
}

static void pres_comp_state_set(enum pres_comp_state new_state)
{
	int ret;

	if (new_state == ctrl_blk.pres_comp.state) {
		return;
	}

	ctrl_blk.pres_comp.state = new_state;
	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Pres comp state: %s", pres_comp_state_names[new_state]);
	if (new_state == PRES_STATE_LOCKED) {
		ret = led_on(LED_APP_2_GREEN);
	} else {
		ret = led_off(LED_APP_2_GREEN);
	}
	ERR_CHK(ret);
}

/**
 * @brief	Move audio blocks back and forth in FIFO to get audio in sync.
 *
 * @note	The audio sync is based on sdu_ref_us.
 *
 * @param	recv_frame_ts_us	Timestamp of when frame was received.
 * @param	sdu_ref_us		ISO timestamp reference from Bluetooth LE controller.
 * @param	sdu_ref_not_consecutive	True if sdu_ref_us and the previous sdu_ref_us
 *					originate from non-consecutive frames.
 */
static void audio_datapath_presentation_compensation(uint32_t recv_frame_ts_us, uint32_t sdu_ref_us,
						     bool sdu_ref_not_consecutive)
{
	if (ctrl_blk.drift_comp.state != DRIFT_STATE_LOCKED) {
		/* Unconditionally reset state machine if drift compensation looses lock */
		pres_comp_state_set(PRES_STATE_INIT);
		return;
	}

	/* Move presentation compensation into PRES_STATE_WAIT if sdu_ref_us and
	 * the previous sdu_ref_us originate from non-consecutive frames.
	 */
	if (sdu_ref_not_consecutive) {
		ctrl_blk.pres_comp.ctr = 0;
		pres_comp_state_set(PRES_STATE_WAIT);
	}

	int32_t wanted_pres_dly_us =
		ctrl_blk.pres_comp.pres_delay_us - (recv_frame_ts_us - sdu_ref_us);
	int32_t pres_adj_us = 0;

	switch (ctrl_blk.pres_comp.state) {
	case PRES_STATE_INIT: {
		ctrl_blk.pres_comp.ctr = 0;
		ctrl_blk.pres_comp.sum_err_dly_us = 0;
		pres_comp_state_set(PRES_STATE_MEAS);

		break;
	}
	case PRES_STATE_MEAS: {
		if (ctrl_blk.pres_comp.ctr++ < PRES_COMP_NUM_DATA_PTS) {
			ctrl_blk.pres_comp.sum_err_dly_us +=
				wanted_pres_dly_us - ctrl_blk.current_pres_dly_us;

			/* Same state - Collect more data */
			break;
		}

		ctrl_blk.pres_comp.ctr = 0;

		pres_adj_us = ctrl_blk.pres_comp.sum_err_dly_us / PRES_COMP_NUM_DATA_PTS;
		if ((pres_adj_us >= (BLK_PERIOD_US / 2)) || (pres_adj_us <= -(BLK_PERIOD_US / 2))) {
			pres_comp_state_set(PRES_STATE_WAIT);
		} else {
			/* Drift compensation will always be in DRIFT_STATE_LOCKED here */
			pres_comp_state_set(PRES_STATE_LOCKED);
		}

		break;
	}
	case PRES_STATE_WAIT: {
		if (ctrl_blk.pres_comp.ctr++ >
		    (FIFO_SMPL_PERIOD_US / CONFIG_AUDIO_FRAME_DURATION_US)) {
			pres_comp_state_set(PRES_STATE_INIT);
		}

		break;
	}
	case PRES_STATE_LOCKED: {
		/*
		 * Presentation delay compensation moves into PRES_STATE_WAIT if sdu_ref_us
		 * and the previous sdu_ref_us originate from non-consecutive frames, or into
		 * PRES_STATE_INIT if drift compensation unlocks.
		 */

		break;
	}
	default: {
		break;
	}
	}

	if (pres_adj_us == 0) {
		return;
	}

	if (pres_adj_us >= 0) {
		pres_adj_us += (BLK_PERIOD_US / 2);
	} else {
		pres_adj_us += -(BLK_PERIOD_US / 2);
	}

	/* Number of adjustment blocks is 0 as long as |pres_adj_us| < BLK_PERIOD_US */
	int32_t pres_adj_blks = pres_adj_us / BLK_PERIOD_US;

	if (pres_adj_blks > (FIFO_NUM_BLKS / 2)) {
		/* Limit adjustment */
		pres_adj_blks = FIFO_NUM_BLKS / 2;

		LOG_WRN("Requested presentation delay out of range: pres_adj_us=%d", pres_adj_us);
	} else if (pres_adj_blks < -(FIFO_NUM_BLKS / 2)) {
		/* Limit adjustment */
		pres_adj_blks = -(FIFO_NUM_BLKS / 2);

		LOG_WRN("Requested presentation delay out of range: pres_adj_us=%d", pres_adj_us);
	}

	if (pres_adj_blks > 0) {
		LOG_DBG("Presentation delay inserted: pres_adj_blks=%d", pres_adj_blks);

		/* Increase presentation delay */
		for (int i = 0; i < pres_adj_blks; i++) {
			/* Mute audio block */
			memset(&ctrl_blk.out.fifo[ctrl_blk.out.prod_blk_idx * BLK_STEREO_NUM_SAMPS],
			       0, BLK_STEREO_SIZE_OCTETS);

			/* Record producer block start reference */
			ctrl_blk.out.prod_blk_ts[ctrl_blk.out.prod_blk_idx] =
				recv_frame_ts_us - ((pres_adj_blks - i) * BLK_PERIOD_US);

			ctrl_blk.out.prod_blk_idx = NEXT_IDX(ctrl_blk.out.prod_blk_idx);
		}
	} else if (pres_adj_blks < 0) {
		LOG_DBG("Presentation delay removed: pres_adj_blks=%d", pres_adj_blks);

		/* Reduce presentation delay */
		for (int i = 0; i > pres_adj_blks; i--) {
			ctrl_blk.out.prod_blk_idx = PREV_IDX(ctrl_blk.out.prod_blk_idx);
		}
	}
}

static void tone_stop_worker(struct k_work *work)
{
	tone_active = false;
	memset(test_tone_buf, 0, sizeof(test_tone_buf));
	LOG_DBG("Tone stopped");
}

K_WORK_DEFINE(tone_stop_work, tone_stop_worker);

static void tone_stop_timer_handler(struct k_timer *dummy)
{
	k_work_submit(&tone_stop_work);
};

K_TIMER_DEFINE(tone_stop_timer, tone_stop_timer_handler, NULL);

int audio_datapath_tone_play(uint16_t freq, uint16_t dur_ms, float amplitude)
{
	int ret;

	if (tone_active) {
		return -EBUSY;
	}

	if (IS_ENABLED(CONFIG_AUDIO_TEST_TONE)) {
		ret = tone_gen(test_tone_buf, &test_tone_size, freq, CONFIG_AUDIO_SAMPLE_RATE_HZ,
			       amplitude);
		if (ret) {
			return ret;
		}
	} else {
		LOG_ERR("Test tone is not enabled");
		return -ENXIO;
	}

	/* If duration is 0, play forever */
	if (dur_ms != 0) {
		k_timer_start(&tone_stop_timer, K_MSEC(dur_ms), K_NO_WAIT);
	}

	tone_active = true;
	LOG_DBG("Tone started");
	return 0;
}

void audio_datapath_tone_stop(void)
{
	k_timer_stop(&tone_stop_timer);
	k_work_submit(&tone_stop_work);
}

static void tone_mix(uint8_t *tx_buf)
{
	int ret;
	int8_t tone_buf_continuous[BLK_MONO_SIZE_OCTETS];
	static uint32_t finite_pos;

	ret = contin_array_create(tone_buf_continuous, BLK_MONO_SIZE_OCTETS, test_tone_buf,
				  test_tone_size, &finite_pos);
	ERR_CHK(ret);

	ret = pcm_mix(tx_buf, BLK_STEREO_SIZE_OCTETS, tone_buf_continuous, BLK_MONO_SIZE_OCTETS,
		      B_MONO_INTO_A_STEREO_L);
	ERR_CHK(ret);
}

/* Alternate-buffers used when there is no active audio stream.
 * Used interchangeably by I2S.
 */
static struct {
	uint8_t __aligned(WB_UP(1)) buf_0[BLK_STEREO_SIZE_OCTETS];
	uint8_t __aligned(WB_UP(1)) buf_1[BLK_STEREO_SIZE_OCTETS];
	bool buf_0_in_use;
	bool buf_1_in_use;
} alt;

/**
 * @brief	Get first available alternative-buffer.
 *
 * @param	p_buffer	Double pointer to populate with buffer.
 *
 * @retval	0 if success.
 * @retval	-ENOMEM No available buffers.
 */
static int alt_buffer_get(void **p_buffer)
{
	if (!alt.buf_0_in_use) {
		alt.buf_0_in_use = true;
		*p_buffer = alt.buf_0;
	} else if (!alt.buf_1_in_use) {
		alt.buf_1_in_use = true;
		*p_buffer = alt.buf_1;
	} else {
		return -ENOMEM;
	}

	return 0;
}

/**
 * @brief	Checks if pointer matches that of a buffer
 *		and frees it in one operation.
 *
 * @param	p_buffer	Buffer to free.
 */
static void alt_buffer_free(void const *const p_buffer)
{
	if (p_buffer == alt.buf_0) {
		alt.buf_0_in_use = false;
	} else if (p_buffer == alt.buf_1) {
		alt.buf_1_in_use = false;
	}
}

/**
 * @brief	Frees both alternative buffers.
 */
static void alt_buffer_free_both(void)
{
	alt.buf_0_in_use = false;
	alt.buf_1_in_use = false;
}

/*
 * This handler function is called every time I2S needs new buffers for
 * TX and RX data.
 *
 * The new TX data buffer is the next consumer block in out.fifo.
 *
 * The new RX data buffer is the first empty slot of in.fifo.
 * New I2S RX data is located in rx_buf_released, and is locked into
 * the in.fifo message queue.
 */
static void audio_datapath_i2s_blk_complete(uint32_t frame_start_ts_us, uint32_t *rx_buf_released,
					    uint32_t const *tx_buf_released)
{
	int ret;
	static bool underrun_condition;

	alt_buffer_free(tx_buf_released);

	/*** Presentation delay measurement ***/
	ctrl_blk.current_pres_dly_us =
		frame_start_ts_us - ctrl_blk.out.prod_blk_ts[ctrl_blk.out.cons_blk_idx];

	/********** I2S TX **********/
	static uint8_t *tx_buf;

	if (IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL) || (CONFIG_AUDIO_DEV == HEADSET)) {
		if (tx_buf_released != NULL) {
			/* Double buffered index */
			uint32_t next_out_blk_idx = NEXT_IDX(ctrl_blk.out.cons_blk_idx);

			if (next_out_blk_idx != ctrl_blk.out.prod_blk_idx) {
				/* Only increment if not in under-run condition */
				ctrl_blk.out.cons_blk_idx = next_out_blk_idx;
				if (underrun_condition) {
					underrun_condition = false;
					LOG_WRN("Data received, total under-runs: %d",
						ctrl_blk.out.total_blk_underruns);
				}

				tx_buf = (uint8_t *)&ctrl_blk.out
						 .fifo[next_out_blk_idx * BLK_STEREO_NUM_SAMPS];

			} else {
				if (stream_state_get() == STATE_STREAMING) {
					underrun_condition = true;
					ctrl_blk.out.total_blk_underruns++;

					if ((ctrl_blk.out.total_blk_underruns %
					     UNDERRUN_LOG_INTERVAL_BLKS) == 0) {
						LOG_WRN("In I2S TX under-run condition, total: %d",
							ctrl_blk.out.total_blk_underruns);
					}
				}

				/*
				 * No data available in out.fifo
				 * use alternative buffers
				 */
				ret = alt_buffer_get((void **)&tx_buf);
				ERR_CHK(ret);

				memset(tx_buf, 0, BLK_STEREO_SIZE_OCTETS);
			}

			if (tone_active) {
				tone_mix(tx_buf);
			}
		}
	}

	/********** I2S RX **********/
	static uint32_t *rx_buf;
	static int prev_ret;

	if (IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL) || (CONFIG_AUDIO_DEV == GATEWAY)) {
		/* Lock last filled buffer into message queue */
		if (rx_buf_released != NULL) {
			ret = data_fifo_block_lock(ctrl_blk.in.fifo, (void **)&rx_buf_released,
						   BLOCK_SIZE_BYTES);

			ERR_CHK_MSG(ret, "Unable to lock block RX");
		}

		/* Get new empty buffer to send to I2S HW */
		ret = data_fifo_pointer_first_vacant_get(ctrl_blk.in.fifo, (void **)&rx_buf,
							 K_NO_WAIT);
		if (ret == 0 && prev_ret == -ENOMEM) {
			LOG_WRN("I2S RX continuing stream");
			prev_ret = ret;
		}

		/* If RX FIFO is filled up */
		if (ret == -ENOMEM) {
			void *data;
			size_t size;

			if (ret != prev_ret) {
				LOG_WRN("I2S RX overrun. Single msg");
				prev_ret = ret;
			}

			ret = data_fifo_pointer_last_filled_get(ctrl_blk.in.fifo, &data, &size,
								K_NO_WAIT);
			ERR_CHK(ret);

			data_fifo_block_free(ctrl_blk.in.fifo, data);

			ret = data_fifo_pointer_first_vacant_get(ctrl_blk.in.fifo, (void **)&rx_buf,
								 K_NO_WAIT);
		}

		ERR_CHK_MSG(ret, "RX failed to get block");
	}

	/*** Data exchange ***/
	audio_i2s_set_next_buf(tx_buf, rx_buf);

	/*** Drift compensation ***/
	if (ctrl_blk.drift_comp.enabled) {
		audio_datapath_drift_compensation(frame_start_ts_us);
	}
}

static void audio_datapath_i2s_start(void)
{
	int ret;

	/* Double buffer I2S */
	uint8_t *tx_buf_one = NULL;
	uint8_t *tx_buf_two = NULL;
	uint32_t *rx_buf_one = NULL;
	uint32_t *rx_buf_two = NULL;

	/* TX */
	if (IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL) || (CONFIG_AUDIO_DEV == HEADSET)) {
		ctrl_blk.out.cons_blk_idx = PREV_IDX(ctrl_blk.out.cons_blk_idx);
		tx_buf_one = (uint8_t *)&ctrl_blk.out
				     .fifo[ctrl_blk.out.cons_blk_idx * BLK_STEREO_NUM_SAMPS];

		ctrl_blk.out.cons_blk_idx = PREV_IDX(ctrl_blk.out.cons_blk_idx);
		tx_buf_two = (uint8_t *)&ctrl_blk.out
				     .fifo[ctrl_blk.out.cons_blk_idx * BLK_STEREO_NUM_SAMPS];
	}

	/* RX */
	if (IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL) || (CONFIG_AUDIO_DEV == GATEWAY)) {
		uint32_t alloced_cnt;
		uint32_t locked_cnt;

		ret = data_fifo_num_used_get(ctrl_blk.in.fifo, &alloced_cnt, &locked_cnt);
		if (alloced_cnt || locked_cnt || ret) {
			ERR_CHK_MSG(-ENOMEM, "FIFO is not empty!");
		}

		ret = data_fifo_pointer_first_vacant_get(ctrl_blk.in.fifo, (void **)&rx_buf_one,
							 K_NO_WAIT);
		ERR_CHK_MSG(ret, "RX failed to get block");
		ret = data_fifo_pointer_first_vacant_get(ctrl_blk.in.fifo, (void **)&rx_buf_two,
							 K_NO_WAIT);
		ERR_CHK_MSG(ret, "RX failed to get block");
	}

	/* Start I2S */
	audio_i2s_start(tx_buf_one, rx_buf_one);
	audio_i2s_set_next_buf(tx_buf_two, rx_buf_two);
}

static void audio_datapath_i2s_stop(void)
{
	audio_i2s_stop();
	alt_buffer_free_both();
}

/**
 * @brief	Adjust timing to make sure audio data is sent just in time for Bluetooth LE event.
 *
 * @note	The time from last anchor point is checked and then blocks of 1 ms can be dropped
 *		to allow the sending of encoded data to be sent just before the connection interval
 *		opens up. This is done to reduce overall latency.
 *
 * @param[in]	tx_sync_ts_us	The timestamp from get_tx_sync.
 * @param[in]	curr_ts_us	The current time. This must be in the controller frame of reference.
 */
static void audio_datapath_just_in_time_check_and_adjust(uint32_t tx_sync_ts_us,
							 uint32_t curr_ts_us)
{
	int ret;
	static int32_t print_count;
	int64_t diff;

	if (IS_ENABLED(CONFIG_BT_LL_ACS_NRF53)) {
		/* CONFIG_BT_LL_ACS_NRF53 custom implementation. */
		diff = (int64_t)curr_ts_us - tx_sync_ts_us;
	} else {
		diff = (int64_t)tx_sync_ts_us - curr_ts_us;
	}

	/*
	 * The diff should always be positive. If diff is a large negative number, it is likely
	 * that wrapping has occurred. A small negative value however, may point to the application
	 * sending data too late, and we need to drop data to get back in sync with the controller.
	 */
	if (diff < -((int64_t)UINT32_MAX / 2)) {
		LOG_DBG("Timestamp wrap. diff: %lld", diff);
		diff += UINT32_MAX;

	} else if (diff < 0) {
		LOG_DBG("tx_sync_ts_us: %u is earlier than curr_ts_us %u", tx_sync_ts_us,
			curr_ts_us);
	}

	if (print_count % 100 == 0) {
		if (IS_ENABLED(CONFIG_BT_LL_ACS_NRF53)) {
			LOG_DBG("JIT diff: %lld us. Target: %u +/- %u",
				CONFIG_AUDIO_FRAME_DURATION_US - diff,
				CONFIG_AUDIO_FRAME_DURATION_US - JUST_IN_TIME_TARGET_DLY_US,
				JUST_IN_TIME_BOUND_US);
		} else {
			LOG_DBG("JIT diff: %lld us. Target: %u +/- %u", diff,
				JUST_IN_TIME_TARGET_DLY_US, JUST_IN_TIME_BOUND_US);
		}
	}
	print_count++;

	if ((diff < (JUST_IN_TIME_TARGET_DLY_US - JUST_IN_TIME_BOUND_US)) ||
	    (diff > (JUST_IN_TIME_TARGET_DLY_US + JUST_IN_TIME_BOUND_US))) {
		ret = audio_system_fifo_rx_block_drop();
		if (ret) {
			LOG_WRN("Not able to drop FIFO RX block");
			return;
		}
		LOG_DBG("Dropped block to align with connection interval");
		print_count = 0;
	}
}

/**
 * @brief	Update sdu_ref_us so that drift compensation can work correctly.
 *
 * @note	This function is only valid for gateway using I2S as audio source
 *		and unidirectional audio stream (gateway to one or more headsets).
 *
 * @param	sdu_ref_us    ISO timestamp reference from Bluetooth LE controller.
 * @param	adjust        Indicate if the sdu_ref should be used to adjust timing.
 */
static void audio_datapath_sdu_ref_update(const struct zbus_channel *chan)
{
	if (IS_ENABLED(CONFIG_AUDIO_SOURCE_I2S)) {
		uint32_t tx_sync_ts_us;
		uint32_t curr_ts_us;
		bool adjust;
		const struct sdu_ref_msg *msg;

		msg = zbus_chan_const_msg(chan);
		tx_sync_ts_us = msg->tx_sync_ts_us;
		curr_ts_us = msg->curr_ts_us;
		adjust = msg->adjust;

		if (ctrl_blk.stream_started) {
			ctrl_blk.prev_drift_sdu_ref_us = tx_sync_ts_us;

			if (adjust && tx_sync_ts_us != 0) {
				audio_datapath_just_in_time_check_and_adjust(tx_sync_ts_us,
									     curr_ts_us);
			}
		} else {
			LOG_WRN("Stream not started - Can not update tx_sync_ts_us");
		}
	}
}

ZBUS_LISTENER_DEFINE(sdu_ref_msg_listen, audio_datapath_sdu_ref_update);

int audio_datapath_pres_delay_us_set(uint32_t delay_us)
{
	if (!IN_RANGE(delay_us, CONFIG_AUDIO_MIN_PRES_DLY_US, CONFIG_AUDIO_MAX_PRES_DLY_US)) {
		LOG_WRN("Presentation delay not supported: %d", delay_us);
		return -EINVAL;
	}

	ctrl_blk.pres_comp.pres_delay_us = delay_us;

	LOG_DBG("Presentation delay set to %d us", delay_us);

	return 0;
}

void audio_datapath_pres_delay_us_get(uint32_t *delay_us)
{
	*delay_us = ctrl_blk.pres_comp.pres_delay_us;
}

void audio_datapath_stream_out(const uint8_t *buf, size_t size, uint32_t sdu_ref_us, bool bad_frame,
			       uint32_t recv_frame_ts_us)
{
	if (!ctrl_blk.stream_started) {
		LOG_WRN("Stream not started");
		return;
	}

	/*** Check incoming data ***/

	if (!buf) {
		LOG_ERR("Buffer pointer is NULL");
	}

	if (sdu_ref_us == ctrl_blk.prev_pres_sdu_ref_us && sdu_ref_us != 0) {
		LOG_WRN("Duplicate sdu_ref_us (%d) - Dropping audio frame", sdu_ref_us);
		return;
	}

	bool sdu_ref_not_consecutive = false;

	if (ctrl_blk.prev_pres_sdu_ref_us) {
		uint32_t sdu_ref_delta_us = sdu_ref_us - ctrl_blk.prev_pres_sdu_ref_us;

		/* Check if the delta is from two consecutive frames */
		if (sdu_ref_delta_us <
		    (CONFIG_AUDIO_FRAME_DURATION_US + (CONFIG_AUDIO_FRAME_DURATION_US / 2))) {
			/* Check for invalid delta */
			if ((sdu_ref_delta_us >
			     (CONFIG_AUDIO_FRAME_DURATION_US + SDU_REF_DELTA_MAX_ERR_US)) ||
			    (sdu_ref_delta_us <
			     (CONFIG_AUDIO_FRAME_DURATION_US - SDU_REF_DELTA_MAX_ERR_US))) {
				LOG_DBG("Invalid sdu_ref_us delta (%d) - Estimating sdu_ref_us",
					sdu_ref_delta_us);

				/* Estimate sdu_ref_us */
				sdu_ref_us = ctrl_blk.prev_pres_sdu_ref_us +
					     CONFIG_AUDIO_FRAME_DURATION_US;
			}
		} else {
			LOG_INF("sdu_ref_us not from consecutive frames (diff: %d us)",
				sdu_ref_delta_us);
			sdu_ref_not_consecutive = true;
		}
	}

	ctrl_blk.prev_pres_sdu_ref_us = sdu_ref_us;

	/*** Presentation compensation ***/
	if (ctrl_blk.pres_comp.enabled) {
		audio_datapath_presentation_compensation(recv_frame_ts_us, sdu_ref_us,
							 sdu_ref_not_consecutive);
	}

	/*** Decode ***/

	int ret;
	size_t pcm_size;

	ret = sw_codec_decode(buf, size, bad_frame, &ctrl_blk.decoded_data, &pcm_size);
	if (ret) {
		LOG_WRN("SW codec decode error: %d", ret);
	}

	if (IS_ENABLED(CONFIG_SD_CARD_PLAYBACK)) {
		if (sd_card_playback_is_active()) {
			sd_card_playback_mix_with_stream(ctrl_blk.decoded_data, pcm_size);
		}
	}

	if (pcm_size != (BLK_STEREO_SIZE_OCTETS * NUM_BLKS_IN_FRAME)) {
		LOG_WRN("Decoded audio has wrong size: %d. Expected: %d", pcm_size,
			(BLK_STEREO_SIZE_OCTETS * NUM_BLKS_IN_FRAME));
		/* Discard frame */
		return;
	}

	/*** Add audio data to FIFO buffer ***/

	int32_t num_blks_in_fifo = ctrl_blk.out.prod_blk_idx - ctrl_blk.out.cons_blk_idx;

	if ((num_blks_in_fifo + NUM_BLKS_IN_FRAME) > FIFO_NUM_BLKS) {
		LOG_WRN("Output audio stream overrun - Discarding audio frame");

		/* Discard frame to allow consumer to catch up */
		return;
	}

	uint32_t out_blk_idx = ctrl_blk.out.prod_blk_idx;

	for (uint32_t i = 0; i < NUM_BLKS_IN_FRAME; i++) {
		if (IS_ENABLED(CONFIG_AUDIO_BIT_DEPTH_16)) {
			memcpy(&ctrl_blk.out.fifo[out_blk_idx * BLK_STEREO_NUM_SAMPS],
			       &((int16_t *)ctrl_blk.decoded_data)[i * BLK_STEREO_NUM_SAMPS],
			       BLK_STEREO_SIZE_OCTETS);
		} else if (IS_ENABLED(CONFIG_AUDIO_BIT_DEPTH_32)) {
			memcpy(&ctrl_blk.out.fifo[out_blk_idx * BLK_STEREO_NUM_SAMPS],
			       &((int32_t *)ctrl_blk.decoded_data)[i * BLK_STEREO_NUM_SAMPS],
			       BLK_STEREO_SIZE_OCTETS);
		}

		/* Record producer block start reference */
		ctrl_blk.out.prod_blk_ts[out_blk_idx] = recv_frame_ts_us + (i * BLK_PERIOD_US);

		out_blk_idx = NEXT_IDX(out_blk_idx);
	}

	ctrl_blk.out.prod_blk_idx = out_blk_idx;
}

int audio_datapath_start(struct data_fifo *fifo_rx)
{
	__ASSERT_NO_MSG(fifo_rx != NULL);

	if (!ctrl_blk.datapath_initialized) {
		LOG_WRN("Audio datapath not initialized");
		return -ECANCELED;
	}

	if (!ctrl_blk.stream_started) {
		ctrl_blk.in.fifo = fifo_rx;

		/* Clear counters and mute initial audio */
		memset(&ctrl_blk.out, 0, sizeof(ctrl_blk.out));

		audio_datapath_i2s_start();
		ctrl_blk.stream_started = true;

		return 0;
	} else {
		return -EALREADY;
	}
}

int audio_datapath_stop(void)
{
	if (ctrl_blk.stream_started) {
		ctrl_blk.stream_started = false;
		audio_datapath_i2s_stop();
		ctrl_blk.prev_pres_sdu_ref_us = 0;
		ctrl_blk.prev_drift_sdu_ref_us = 0;

		pres_comp_state_set(PRES_STATE_INIT);

		return 0;
	} else {
		return -EALREADY;
	}
}

int audio_datapath_init(void)
{
	memset(&ctrl_blk, 0, sizeof(ctrl_blk));
	audio_i2s_blk_comp_cb_register(audio_datapath_i2s_blk_complete);
	audio_i2s_init();
	ctrl_blk.datapath_initialized = true;
	ctrl_blk.drift_comp.enabled = true;
	if (IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL) && (CONFIG_AUDIO_DEV == GATEWAY) &&
	    IS_ENABLED(CONFIG_BT_LL_ACS_NRF53)) {
		/* Disable presentation compensation feature for microphone return on gateway when
		 * using Audio Controller Subsystem. Also, since there's only one stream output from
		 * gateway for now, so no need to have presentation compensation.
		 */
		ctrl_blk.pres_comp.enabled = false;
	} else {
		ctrl_blk.pres_comp.enabled = true;
	}

	ctrl_blk.pres_comp.pres_delay_us = CONFIG_BT_AUDIO_PRESENTATION_DELAY_US;

	return 0;
}

static int cmd_i2s_tone_play(const struct shell *shell, size_t argc, const char **argv)
{
	int ret;
	uint16_t freq;
	uint16_t dur_ms;
	float amplitude;

	if (argc != 4) {
		shell_error(
			shell,
			"3 arguments (freq [Hz], dur [ms], and amplitude [0-1.0] must be provided");
		return -EINVAL;
	}

	if (!isdigit((int)argv[1][0])) {
		shell_error(shell, "Argument 1 is not numeric");
		return -EINVAL;
	}

	if (!isdigit((int)argv[2][0])) {
		shell_error(shell, "Argument 2 is not numeric");
		return -EINVAL;
	}

	freq = strtoul(argv[1], NULL, 10);
	dur_ms = strtoul(argv[2], NULL, 10);
	amplitude = strtof(argv[3], NULL);

	if (amplitude <= 0 || amplitude > 1) {
		shell_error(shell, "Make sure amplitude is 0 < [float] >= 1");
		return -EINVAL;
	}

	shell_print(shell, "Setting tone %d Hz for %d ms", freq, dur_ms);
	ret = audio_datapath_tone_play(freq, dur_ms, amplitude);

	if (ret == -EBUSY) {
		/* Abort continuous running tone with new tone */
		audio_datapath_tone_stop();
		ret = audio_datapath_tone_play(freq, dur_ms, amplitude);
	}

	if (ret) {
		shell_print(shell, "Tone failed with code %d", ret);
	}

	shell_print(shell, "Tone play: %d Hz for %d ms with amplitude %.02f", freq, dur_ms,
		    amplitude);

	return ret;
}

static int cmd_i2s_tone_stop(const struct shell *shell, size_t argc, const char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	audio_datapath_tone_stop();

	shell_print(shell, "Tone stop");

	return 0;
}

static int cmd_hfclkaudio_drift_comp_enable(const struct shell *shell, size_t argc,
					    const char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	ctrl_blk.drift_comp.enabled = true;

	shell_print(shell, "Audio PLL drift compensation enabled");

	return 0;
}

static int cmd_hfclkaudio_drift_comp_disable(const struct shell *shell, size_t argc,
					     const char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	if (ctrl_blk.pres_comp.enabled) {
		shell_print(shell, "Pres comp must be disabled to disable drift comp");
	} else {
		ctrl_blk.drift_comp.enabled = false;
		ctrl_blk.drift_comp.ctr = 0;
		drift_comp_state_set(DRIFT_STATE_INIT);

		shell_print(shell, "Audio PLL drift compensation disabled");
	}

	return 0;
}

static int cmd_audio_pres_comp_enable(const struct shell *shell, size_t argc, const char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	if (ctrl_blk.drift_comp.enabled) {
		ctrl_blk.pres_comp.enabled = true;

		shell_print(shell, "Presentation compensation enabled");
	} else {
		shell_print(shell, "Drift comp must be enabled to enable pres comp");
	}

	return 0;
}

static int cmd_audio_pres_comp_disable(const struct shell *shell, size_t argc, const char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	ctrl_blk.pres_comp.enabled = false;
	pres_comp_state_set(PRES_STATE_INIT);

	shell_print(shell, "Presentation compensation disabled");

	return 0;
}

SHELL_STATIC_SUBCMD_SET_CREATE(test_cmd,
			       SHELL_COND_CMD(CONFIG_SHELL, nrf_tone_start, NULL,
					      "Start local tone from nRF5340", cmd_i2s_tone_play),
			       SHELL_COND_CMD(CONFIG_SHELL, nrf_tone_stop, NULL,
					      "Stop local tone from nRF5340", cmd_i2s_tone_stop),
			       SHELL_COND_CMD(CONFIG_SHELL, pll_drift_comp_enable, NULL,
					      "Enable audio PLL auto drift compensation (default)",
					      cmd_hfclkaudio_drift_comp_enable),
			       SHELL_COND_CMD(CONFIG_SHELL, pll_drift_comp_disable, NULL,
					      "Disable audio PLL auto drift compensation",
					      cmd_hfclkaudio_drift_comp_disable),
			       SHELL_COND_CMD(CONFIG_SHELL, pll_pres_comp_enable, NULL,
					      "Enable audio presentation compensation (default)",
					      cmd_audio_pres_comp_enable),
			       SHELL_COND_CMD(CONFIG_SHELL, pll_pres_comp_disable, NULL,
					      "Disable audio presentation compensation",
					      cmd_audio_pres_comp_disable),
			       SHELL_SUBCMD_SET_END);

SHELL_CMD_REGISTER(test, &test_cmd, "Test mode commands", NULL);


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/audio/le_audio_rx.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _LE_AUDIO_RX_H_
#define _LE_AUDIO_RX_H_

/**
 * @brief Data handler when ISO data has been received.
 *
 * @param[in] p_data		Pointer to the received data.
 * @param[in] data_size		Size of the received data.
 * @param[in] bad_frame		Bad frame flag. (I.e. set for missed ISO data).
 * @param[in] sdu_ref		SDU reference timestamp.
 * @param[in] channel_index	Which channel is received.
 * @param[in] desired_data_size	The expected data size.
 *
 * @return 0 if successful, error otherwise.
 */
void le_audio_rx_data_handler(uint8_t const *const p_data, size_t data_size, bool bad_frame,
			      uint32_t sdu_ref, enum audio_channel channel_index,
			      size_t desired_data_size);

/**
 * @brief Initialize the receive audio path.
 *
 * @return 0 if successful, error otherwise.
 */
int le_audio_rx_init(void);

#endif /* _LE_AUDIO_RX_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/audio/sw_codec_select.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _SW_CODEC_SELECT_H_
#define _SW_CODEC_SELECT_H_

#include <zephyr/kernel.h>
#include "channel_assignment.h"

#if (CONFIG_SW_CODEC_LC3)
#define LC3_MAX_FRAME_SIZE_MS	10
#define LC3_ENC_MONO_FRAME_SIZE (CONFIG_LC3_BITRATE_MAX * LC3_MAX_FRAME_SIZE_MS / (8 * 1000))

#define LC3_PCM_NUM_BYTES_MONO                                                                     \
	(CONFIG_AUDIO_SAMPLE_RATE_HZ * CONFIG_AUDIO_BIT_DEPTH_OCTETS * LC3_MAX_FRAME_SIZE_MS / 1000)
#define LC3_ENC_TIME_US 3000
#define LC3_DEC_TIME_US 1500
#else
#define LC3_ENC_MONO_FRAME_SIZE 0
#define LC3_PCM_NUM_BYTES_MONO	0
#define LC3_ENC_TIME_US		0
#define LC3_DEC_TIME_US		0
#endif /* CONFIG_SW_CODEC_LC3 */

/* Max will be used when multiple codecs are supported */
#define ENC_MAX_FRAME_SIZE   MAX(LC3_ENC_MONO_FRAME_SIZE, 0)
#define ENC_TIME_US	     MAX(LC3_ENC_TIME_US, 0)
#define DEC_TIME_US	     MAX(LC3_DEC_TIME_US, 0)
#define PCM_NUM_BYTES_MONO   MAX(LC3_PCM_NUM_BYTES_MONO, 0)
#define PCM_NUM_BYTES_STEREO (PCM_NUM_BYTES_MONO * 2)

enum sw_codec_select {
	SW_CODEC_NONE,
	SW_CODEC_LC3, /* Low Complexity Communication Codec */
};

enum sw_codec_channel_mode {
	SW_CODEC_MONO = 1,
	SW_CODEC_STEREO,
};

struct sw_codec_encoder {
	bool enabled;
	int bitrate;
	enum sw_codec_channel_mode channel_mode;
	uint8_t num_ch;
	enum audio_channel audio_ch;
	uint32_t sample_rate_hz;
};

struct sw_codec_decoder {
	bool enabled;
	bool started;
	enum sw_codec_channel_mode channel_mode; /* Mono or stereo. */
	uint8_t num_ch;				 /* Number of decoder channels. */
	enum audio_channel audio_ch;		 /* Used to choose which channel to use. */
	uint32_t sample_rate_hz;
};

/**
 * @brief  Sw_codec configuration structure.
 */
struct sw_codec_config {
	enum sw_codec_select sw_codec;	 /* sw_codec to be used, e.g. LC3, etc. */
	struct sw_codec_decoder decoder; /* Struct containing settings for decoder. */
	struct sw_codec_encoder encoder; /* Struct containing settings for encoder. */
	bool initialized;		 /* Status of codec. */
};

/**
 * @brief	Check if the software codec is initialized.
 *
 * @retval	true	SW codec is initialized.
 * @retval	false	SW codec is not initialized.
 */
bool sw_codec_is_initialized(void);

/**
 * @brief	Encode PCM data and output encoded data.
 *
 * @note	Takes in stereo PCM stream, will encode either one or two
 *		channels, based on channel_mode set during init.
 *
 * @param[in]	pcm_data	Pointer to PCM data.
 * @param[in]	pcm_size	Size of PCM data.
 * @param[out]	encoded_data	Pointer to buffer to store encoded data.
 * @param[out]	encoded_size	Size of encoded data.
 *
 * @return	0 if success, error codes depends on sw_codec selected.
 */
int sw_codec_encode(void *pcm_data, size_t pcm_size, uint8_t **encoded_data, size_t *encoded_size);

/**
 * @brief	Decode encoded data and output PCM data.
 *
 * @param[in]	encoded_data	Pointer to encoded data.
 * @param[in]	encoded_size	Size of encoded data.
 * @param[in]	bad_frame	Flag to indicate a missing/bad frame (only LC3).
 * @param[out]	pcm_data	Pointer to buffer to store decoded PCM data.
 * @param[out]	pcm_size	Size of decoded data.
 *
 * @return	0 if success, error codes depends on sw_codec selected.
 */
int sw_codec_decode(uint8_t const *const encoded_data, size_t encoded_size, bool bad_frame,
		    void **pcm_data, size_t *pcm_size);

/**
 * @brief	Uninitialize the software codec and free the allocated space.
 *
 * @note	Must be called before calling init for another sw_codec.
 *
 * @param[in]	sw_codec_cfg	Struct to tear down sw_codec.
 *
 * @return	0 if success, error codes depends on sw_codec selected.
 */
int sw_codec_uninit(struct sw_codec_config sw_codec_cfg);

/**
 * @brief	Initialize the software codec and statically or dynamically
 *		allocate memory to be used, depending on the selected codec
 *		and its configuration.
 *
 * @param[in]	sw_codec_cfg	Struct to set up sw_codec.
 *
 * @return	0 if success, error codes depends on sw_codec selected.
 */
int sw_codec_init(struct sw_codec_config sw_codec_cfg);

#endif /* _SW_CODEC_SELECT_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/audio/audio_system.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _AUDIO_SYSTEM_H_
#define _AUDIO_SYSTEM_H_

#include <stddef.h>
#include <stdbool.h>
#include <stdint.h>

#define VALUE_NOT_SET 0

/**
 * @brief	Start the execution of the encoder thread.
 */
void audio_system_encoder_start(void);

/**
 * @brief	Stop the encoder thread from executing.
 *
 * @note	Using this allows the encode thread to always be enabled,
 *		but disables the execution when not needed, saving power.
 */
void audio_system_encoder_stop(void);

/**
 * @brief	Toggle a test tone on and off.
 *
 * @note	A stream must already be running to use this feature.
 *
 * @param[in]	freq	Desired frequency of tone. Off if set to 0.
 *
 * @retval	-ENOMEM	The frequency is too low (buffer overflow).
 * @retval	0	Success.
 */
int audio_system_encode_test_tone_set(uint32_t freq);

/**
 * @brief	Step through different test tones.
 *
 * @note	A stream must already be running to use this feature.
 *		Will step through test tones: 1 kHz, 2 kHz, 4 kHz and off.
 *
 * @return	0 on success, error otherwise.
 */
int audio_system_encode_test_tone_step(void);

/**
 * @brief	Set the sample rates for the encoder and the decoder, and the bit rate for encoder.
 *
 * @note	If any of the values are 0, the corresponding configuration will not be set.
 *
 * @param[in]	encoder_sample_rate_hz	Sample rate to be used by the encoder; can be 0.
 * @param[in]	encoder_bitrate		Bit rate to be used by the encoder (bps); can be 0.
 * @param[in]	decoder_sample_rate_hz	Sample rate to be used by the decoder; can be 0.
 *
 * @retval	-EINVAL	Invalid sample rate given.
 * @retval	0	On success.
 */
int audio_system_config_set(uint32_t encoder_sample_rate_hz, uint32_t encoder_bitrate,
			    uint32_t decoder_sample_rate_hz);

/**
 * @brief	Decode data and then add it to TX FIFO buffer.
 *
 * @param[in]	encoded_data		Pointer to encoded data.
 * @param[in]	encoded_data_size	Size of encoded data.
 * @param[in]	bad_frame		Indication on missed or incomplete frame.
 *
 * @return	0 on success, error otherwise.
 */
int audio_system_decode(void const *const encoded_data, size_t encoded_data_size, bool bad_frame);

/**
 * @brief	Initialize and start both HW and SW audio codec.
 */
void audio_system_start(void);

/**
 * @brief	Stop all activities related to audio.
 */
void audio_system_stop(void);

/**
 * @brief	Drop oldest block from the fifo_rx buffer.
 *
 * @note	This can be used to reduce latency by adjusting the timing of the completed frame
 *		that was sampled in relation to the connection interval in Bluetooth LE.
 *
 * @return	0 on success, -ECANCELED otherwise.
 */
int audio_system_fifo_rx_block_drop(void);

/**
 * @brief	Get number of decoder channels.
 *
 * @return	Number of decoder channels.
 */
int audio_system_decoder_num_ch_get(void);

/**
 * @brief	Initialize the audio_system.
 *
 * @return	0 on success, error otherwise.
 */
int audio_system_init(void);

#endif /* _AUDIO_SYSTEM_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/audio/audio_datapath.h
/*
 *  Copyright (c) 2021, PACKETCRAFT, INC.
 *
 *  SPDX-License-Identifier: LicenseRef-PCFT
 */

#ifndef _AUDIO_DATAPATH_H_
#define _AUDIO_DATAPATH_H_

#include <zephyr/kernel.h>
#include <stdint.h>
#include <stdbool.h>

#include "data_fifo.h"
#include "sw_codec_select.h"

/**
 * @brief Mixes a tone into the I2S TX stream
 *
 * @param freq Tone frequency [Hz]
 * @param dur_ms Tone duration [ms]. 0 = forever
 * @param amplitude Tone amplitude [0, 1]
 *
 * @return 0 if successful, error otherwise
 */
int audio_datapath_tone_play(uint16_t freq, uint16_t dur_ms, float amplitude);

/**
 * @brief Stops tone playback
 */
void audio_datapath_tone_stop(void);

/**
 * @brief Set the presentation delay
 *
 * @param delay_us The presentation delay in s
 *
 * @return 0 if successful, error otherwise
 */
int audio_datapath_pres_delay_us_set(uint32_t delay_us);

/**
 * @brief Get the current presentation delay
 *
 * @param delay_us  The presentation delay in s
 */
void audio_datapath_pres_delay_us_get(uint32_t *delay_us);

/**
 * @brief Input an audio data frame which is processed and outputted over I2S
 *
 * @note A frame of raw encoded audio data is inputted, and this data then is decoded
 *       and processed before being outputted over I2S. The audio is synchronized
 *       using sdu_ref_us
 *
 * @param buf Pointer to audio data frame
 * @param size Size of audio data frame in bytes
 * @param sdu_ref_us ISO timestamp reference from BLE controller
 * @param bad_frame Indicating if the audio frame is bad or not
 * @param recv_frame_ts_us Timestamp of when audio frame was received
 */
void audio_datapath_stream_out(const uint8_t *buf, size_t size, uint32_t sdu_ref_us, bool bad_frame,
			       uint32_t recv_frame_ts_us);

/**
 * @brief Start the audio datapath module
 *
 * @note The continuously running I2S is started
 *
 * @param fifo_rx Pointer to FIFO structure where I2S RX data is put
 *
 * @return 0 if successful, error otherwise
 */
int audio_datapath_start(struct data_fifo *fifo_rx);

/**
 * @brief Stop the audio datapath module
 *
 * @return 0 if successful, error otherwise
 */
int audio_datapath_stop(void);

/**
 * @brief Initialize the audio datapath module
 *
 * @return 0 if successful, error otherwise
 */
int audio_datapath_init(void);

#endif /* _AUDIO_DATAPATH_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/audio/streamctrl.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _STREAMCTRL_H_
#define _STREAMCTRL_H_

#include <stddef.h>
#include <zephyr/kernel.h>

/* State machine states for peer or stream. */
enum stream_state {
	STATE_STREAMING,
	STATE_PAUSED,
};

/**
 * @brief Get the current streaming state.
 *
 * @return      strm_state enum value.
 */
uint8_t stream_state_get(void);

/**
 * @brief Send audio data over the stream.
 *
 * @param data		Data to send.
 * @param size		Size of data.
 * @param num_ch	Number of audio channels.
 */
void streamctrl_send(void const *const data, size_t size, uint8_t num_ch);

#endif /* _STREAMCTRL_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/CMakeLists.txt
#
# Copyright (c) 2022 Nordic Semiconductor
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

add_subdirectory(bt_management)
add_subdirectory(bt_renderer)
add_subdirectory(bt_content_control)
add_subdirectory(bt_stream)

zephyr_library_include_directories(
    bt_management
    bt_renderer
    bt_content_control
    bt_stream
)


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/Kconfig.defaults
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

config BT_AUDIO
	default y

config BT_DEVICE_NAME
	default BT_AUDIO_BROADCAST_NAME if TRANSPORT_BIS
	default "NRF5340_AUDIO"

config BT_ECC
	default y if BT

config BT_EXT_ADV
	default y

# Mandatory to support at least 1 for ASCS
config BT_ATT_PREPARE_COUNT
	default 1


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/Kconfig
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

rsource "Kconfig.defaults"

menu "Bluetooth"

rsource "bt_management/Kconfig"

#----------------------------------------------------------------------------#
menu "Bluetooth audio"

if TRANSPORT_BIS
rsource "bt_stream/broadcast/Kconfig"
endif # TRANSPORT_BIS

if TRANSPORT_CIS
rsource "bt_stream/unicast/Kconfig"
endif # TRANSPORT_CIS

config BT_AUDIO_PACKING_INTERLEAVED
	bool "Interleaved packing"
	default n
	help
	  ISO channels can either be interleaved or sequentially packed; sequential is the default one.

config BT_AUDIO_PREF_SAMPLE_RATE_VALUE
	hex
	default 0x03 if BT_AUDIO_PREF_SAMPLE_RATE_16KHZ
	default 0x05 if BT_AUDIO_PREF_SAMPLE_RATE_24KHZ
	default 0x08 if BT_AUDIO_PREF_SAMPLE_RATE_48KHZ

choice BT_AUDIO_PREF_SAMPLE_RATE
	prompt "Preferred audio sample rate"
	default BT_AUDIO_PREF_SAMPLE_RATE_24KHZ if STREAM_BIDIRECTIONAL
	default BT_AUDIO_PREF_SAMPLE_RATE_48KHZ
	help
	  Select the preferred sample rate if there are more than one to choose from.

config  BT_AUDIO_PREF_SAMPLE_RATE_48KHZ
	bool "48 kHz"
	help
	  Select 48000 Hz as the preferred sample rate.

config  BT_AUDIO_PREF_SAMPLE_RATE_24KHZ
	bool "24 kHz"
	help
	  Select 24000 Hz as the preferred sample rate.

config  BT_AUDIO_PREF_SAMPLE_RATE_16KHZ
	bool "16 kHz"
	help
	  Select 16000 Hz as the preferred sample rate.
endchoice

#----------------------------------------------------------------------------#
menu "QoS"

config BT_AUDIO_PRESENTATION_DELAY_US
	int "Presentation delay"
	range AUDIO_MIN_PRES_DLY_US AUDIO_MAX_PRES_DLY_US
	default 10000
	help
	  The audio source/client defined presentation delay if within
	  AUDIO_MIN_PRES_DLY_US and AUDIO_MAX_PRES_DLY_US range. This will
	  override the audio receivers presentation delay as long as it
	  is in range of the max and min supported by the audio receivers.
	  If it is outside this range, then it will revert to the closest
	  supported value.

config BT_AUDIO_MAX_TRANSPORT_LATENCY_MS
	int "Max transport latency"
	range 5 4000
	default 20
	help
	  Max transport latency for the ISO link.

config BT_AUDIO_RETRANSMITS
	int "Number of re-transmits"
	range 0 30
	default 2
	help
	  Number of re-transmits for the ISO link. 2 re-transmits means a total
	  of 3 packets sent per stream.

endmenu # QoS
endmenu # Bluetooth audio

rsource "bt_renderer/Kconfig"
rsource "bt_content_control/Kconfig"

#----------------------------------------------------------------------------#
menu "Log levels"

module = BLE
module-str = ble
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log levels

#----------------------------------------------------------------------------#
menu "Testing"

config TESTING_BLE_ADDRESS_RANDOM
	bool "Random address and bonding clear on every restart [EXPERIMENTAL]"
	default n
	select EXPERIMENTAL
	help
	  If enabled the system will generate a new address on every
	  restart (i.e. reset, re-flash). Any bonding information will
	  be cleared. This is only for testing purposes.

endmenu # Testing
endmenu # Bluetooth


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_content_control/CMakeLists.txt
#
# Copyright (c) 2023 Nordic Semiconductor
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

zephyr_library_include_directories(
    media
)

target_sources(app PRIVATE
		${CMAKE_CURRENT_SOURCE_DIR}/bt_content_ctrl.c)

if (CONFIG_BT_MCC OR CONFIG_BT_MCS)
target_sources(app PRIVATE
		${CMAKE_CURRENT_SOURCE_DIR}/media/bt_content_ctrl_media.c)
endif()


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_content_control/Kconfig
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

menu "Content control"

rsource "media/Kconfig"

#----------------------------------------------------------------------------#
menu "Log level"

module = BT_CONTENT_CTRL
module-str = bt_content_ctrl
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log level
endmenu # Content control


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_content_control/bt_content_ctrl.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BT_CONTENT_CTRL_H_
#define _BT_CONTENT_CTRL_H_

#include <zephyr/bluetooth/conn.h>

/**
 * @brief	Send the start request for content transmission.
 *
 * @param[in]	conn	Pointer to the connection to control; can be NULL.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_start(struct bt_conn *conn);

/**
 * @brief	Send the stop request for content transmission.
 *
 * @param[in]	conn	Pointer to the connection to control; can be NULL.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_stop(struct bt_conn *conn);

/**
 * @brief	Handle disconnected connection for the content control services.
 *
 * @param[in]	conn	Pointer to the disconnected connection.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_conn_disconnected(struct bt_conn *conn);

/**
 * @brief	Discover the content control services for the given connection pointer.
 *
 * @param[in]	conn	Pointer to the connection on which to discover the services.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_discover(struct bt_conn *conn);

/**
 * @brief	Put the UUIDs from this module into the buffer.
 *
 * @note	This partial data is used to build a complete extended advertising packet.
 *
 * @param[out]	uuid_buf	Buffer being populated with UUIDs.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_uuid_populate(struct net_buf_simple *uuid_buf);

/**
 * @brief	Initialize the content control module.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_init(void);

#endif /* _BT_CONTENT_CTRL_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_content_control/bt_content_ctrl.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "bt_content_ctrl.h"

#include <zephyr/zbus/zbus.h>
#include <zephyr/bluetooth/uuid.h>

#include "bt_content_ctrl_media_internal.h"
#include "nrf5340_audio_common.h"
#include "macros_common.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(bt_content_ctrl, CONFIG_BT_CONTENT_CTRL_LOG_LEVEL);

ZBUS_CHAN_DEFINE(cont_media_chan, struct content_control_msg, NULL, NULL, ZBUS_OBSERVERS_EMPTY,
		 ZBUS_MSG_INIT(0));

static void media_control_cb(bool play)
{
	int ret;
	struct content_control_msg msg;

	if (play) {
		msg.event = MEDIA_START;
	} else {
		msg.event = MEDIA_STOP;
	}

	ret = zbus_chan_pub(&cont_media_chan, &msg, K_NO_WAIT);
	ERR_CHK_MSG(ret, "zbus publication failed");
}

int bt_content_ctrl_start(struct bt_conn *conn)
{
	int ret;
	struct content_control_msg msg;

	if (IS_ENABLED(CONFIG_BT_MCC) || IS_ENABLED(CONFIG_BT_MCS)) {
		ret = bt_content_ctrl_media_play(conn);
		if (ret) {
			LOG_WRN("Failed to change the streaming state");
			return ret;
		}

		return 0;
	}

	msg.event = MEDIA_START;

	ret = zbus_chan_pub(&cont_media_chan, &msg, K_NO_WAIT);
	ERR_CHK_MSG(ret, "zbus publication failed");

	return 0;
}

int bt_content_ctrl_stop(struct bt_conn *conn)
{
	int ret;
	struct content_control_msg msg;

	if (IS_ENABLED(CONFIG_BT_MCC) || IS_ENABLED(CONFIG_BT_MCS)) {
		ret = bt_content_ctrl_media_pause(conn);
		if (ret) {
			LOG_WRN("Failed to change the streaming state");
			return ret;
		}

		return 0;
	}

	msg.event = MEDIA_STOP;

	ret = zbus_chan_pub(&cont_media_chan, &msg, K_NO_WAIT);
	ERR_CHK_MSG(ret, "zbus publication failed");

	return 0;
}

int bt_content_ctrl_conn_disconnected(struct bt_conn *conn)
{
	int ret;

	if (IS_ENABLED(CONFIG_BT_MCC)) {
		ret = bt_content_ctrl_media_conn_disconnected(conn);
		if (ret) {
			LOG_ERR("bt_content_ctrl_media_conn_disconnected failed with %d", ret);
		}
	}

	return 0;
}

int bt_content_ctrl_discover(struct bt_conn *conn)
{
	int ret;

	if (IS_ENABLED(CONFIG_BT_MCC)) {
		ret = bt_content_ctrl_media_discover(conn);
		if (ret) {
			LOG_ERR("Failed to discover the media control client");
			return ret;
		}
	}

	return 0;
}

int bt_content_ctrl_uuid_populate(struct net_buf_simple *uuid_buf)
{
	if (IS_ENABLED(CONFIG_BT_MCC)) {
		if (net_buf_simple_tailroom(uuid_buf) >= BT_UUID_SIZE_16) {
			net_buf_simple_add_le16(uuid_buf, BT_UUID_MCS_VAL);
		} else {
			return -ENOMEM;
		}
	}

	return 0;
}

int bt_content_ctrl_init(void)
{
	int ret;

	if (IS_ENABLED(CONFIG_BT_MCS)) {
		ret = bt_content_ctrl_media_server_init(media_control_cb);
		if (ret) {
			LOG_ERR("MCS server init failed");
			return ret;
		}
	}

	if (IS_ENABLED(CONFIG_BT_MCC)) {
		ret = bt_content_ctrl_media_client_init();
		if (ret) {
			LOG_ERR("MCS client init failed");
			return ret;
		}
	}

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_content_control/media/bt_content_ctrl_media.c
/*
 * Copyright (c) 2021 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "bt_content_ctrl_media_internal.h"

#include <zephyr/kernel.h>
#include <zephyr/types.h>
#include <zephyr/bluetooth/att.h>
#include <zephyr/bluetooth/conn.h>
#include <zephyr/bluetooth/audio/media_proxy.h>
#include <zephyr/bluetooth/audio/mcs.h>
#include <zephyr/bluetooth/audio/mcc.h>

#include "macros_common.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(bt_content_ctrl_media, CONFIG_BT_CONTENT_CTRL_MEDIA_LOG_LEVEL);

static uint8_t media_player_state = BT_MCS_MEDIA_STATE_PLAYING;

static struct media_player *local_player;
static bt_content_ctrl_media_play_pause_cb play_pause_cb;

enum mcs_disc_status {
	IDLE,
	IN_PROGRESS,
	FINISHED,
};

struct media_ctlr {
	enum mcs_disc_status mcp_mcs_disc_status;
	struct bt_conn *conn;
};

static struct media_ctlr mcc_peer[CONFIG_BT_MAX_CONN];

/**
 * @brief	Get the index of the first available mcc_peer
 *
 * @return	Index if success, -ENOMEM if no available indexes
 */
static int mcc_peer_index_free_get(void)
{
	for (int i = 0; i < ARRAY_SIZE(mcc_peer); i++) {
		if (mcc_peer[i].conn == NULL) {
			return i;
		}
	}

	LOG_WRN("No more indexes for MCC peer");

	return -ENOMEM;
}

/**
 * @brief	Get index of a given conn pointer
 *
 * @param	conn	Pointer to check against
 *
 * @return	index if found, -ESRCH if not found, -EINVAL if invalid conn pointer
 */
static int mcc_peer_index_get(struct bt_conn *conn)
{
	if (conn == NULL) {
		LOG_WRN("Invalid conn pointer");
		return -EINVAL;
	}

	for (uint8_t i = 0; i < ARRAY_SIZE(mcc_peer); i++) {
		if (mcc_peer[i].conn == conn) {
			return i;
		}
	}

	LOG_DBG("No matching conn pointer for this mcc_peer");
	return -ESRCH;
}

/**
 * @brief	Callback handler for MCS discover finished.
 *
 * @note	This callback handler will be triggered when MCS
 *		discovery is finished. Used by the client.
 */
static void mcc_discover_mcs_cb(struct bt_conn *conn, int err)
{
	int ret;
	int idx = mcc_peer_index_get(conn);

	if (idx < 0) {
		LOG_WRN("Unable to look up conn pointer: %d", idx);
		return;
	}

	if (err) {
		if (err == BT_ATT_ERR_UNLIKELY) {
			/* BT_ATT_ERR_UNLIKELY may occur in normal operating conditions if there is
			 * a disconnect while discovering, hence it will be treated as a warning.
			 */
			LOG_WRN("Discovery of MCS failed (%d)", err);
		} else {
			LOG_ERR("Discovery of MCS failed (%d)", err);
		}

		mcc_peer[idx].mcp_mcs_disc_status = IDLE;
		return;
	}

	if (mcc_peer[idx].mcp_mcs_disc_status != IN_PROGRESS) {
		/* Due to the design of MCC, there will be several
		 * invocations of this callback. We are only interested
		 * in what we have explicitly requested.
		 */
		LOG_DBG("Filtered out callback");
		return;
	}

	mcc_peer[idx].mcp_mcs_disc_status = FINISHED;
	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Discovery of MCS finished");

	ret = bt_content_ctrl_media_state_update(conn);
	if (ret < 0 && ret != -EBUSY) {
		LOG_WRN("Failed to update media state: %d", ret);
	}
}

/**
 * @brief	Callback handler for sent MCS commands.
 *
 * @note	This callback will be triggered when MCS commands have been sent.
 *		Used by the client.
 */
static void mcc_send_command_cb(struct bt_conn *conn, int err, const struct mpl_cmd *cmd)
{
	LOG_DBG("mcc_send_command_cb");

	if (err) {
		LOG_ERR("MCC: cmd send failed (%d) - opcode: %u, param: %d", err, cmd->opcode,
			cmd->param);
	}
}

/**
 * @brief  Callback handler for received notifications.
 *
 * @note	This callback will be triggered when a notification has been received.
 *		Used by the client.
 */
static void mcc_cmd_notification_cb(struct bt_conn *conn, int err, const struct mpl_cmd_ntf *ntf)
{
	LOG_DBG("mcc_cmd_ntf_cb");

	if (err) {
		LOG_ERR("MCC: cmd ntf error (%d) - opcode: %u, result: %u", err,
			ntf->requested_opcode, ntf->result_code);
	}
}

/**
 * @brief  Callback handler for reading media state.
 *
 * @note	This callback will be triggered when the client has asked to read
 *		the current state of the media player.
 */
static void mcc_read_media_state_cb(struct bt_conn *conn, int err, uint8_t state)
{
	LOG_DBG("mcc_read_media_cb, state: %d", state);

	if (err) {
		LOG_ERR("MCC: Media State read failed (%d)", err);
		return;
	}

	media_player_state = state;
}

/**
 * @brief  Callback handler for received MCS commands.
 *
 * @note	This callback will be triggered when the server has received a
 *		command from the client or the commander.
 */
static void mcs_command_recv_cb(struct media_player *plr, int err,
				const struct mpl_cmd_ntf *cmd_ntf)
{
	if (err) {
		LOG_ERR("Command failed (%d)", err);
		return;
	}

	LOG_DBG("Received opcode: %d", cmd_ntf->requested_opcode);

	if (cmd_ntf->requested_opcode == BT_MCS_OPC_PLAY) {
		play_pause_cb(true);
	} else if (cmd_ntf->requested_opcode == BT_MCS_OPC_PAUSE) {
		play_pause_cb(false);
	} else {
		LOG_WRN("Unsupported opcode: %d", cmd_ntf->requested_opcode);
	}
}

/**
 * @brief  Callback handler for getting the current state of the media player.
 *
 * @note	This callback will be triggered when the server has asked for the
 *		current state of its local media player.
 */
static void mcs_media_state_cb(struct media_player *plr, int err, uint8_t state)
{
	if (err) {
		LOG_ERR("Media state failed (%d)", err);
		return;
	}

	media_player_state = state;
}

/**
 * @brief  Callback handler for getting a pointer to the local media player.
 *
 * @note	This callback will be triggered during initialization when the
 *		local media player is ready.
 */
static void mcs_local_player_instance_cb(struct media_player *player, int err)
{
	int ret;
	struct mpl_cmd cmd;

	if (err) {
		LOG_ERR("Local player instance failed (%d)", err);
		return;
	}

	LOG_DBG("Received local player");

	local_player = player;

	cmd.opcode = BT_MCS_OPC_PLAY;

	/* Since the media player is default paused when initialized, we
	 * send a play command when the first stream is enabled
	 */
	ret = media_proxy_ctrl_send_command(local_player, &cmd);
	if (ret) {
		LOG_WRN("Failed to set media proxy state to play: %d", ret);
	}
}

/**
 * @brief	Send command to either local media player or peer
 *
 * @param	conn	Pointer to the conn to send the command to
 * @param	cmd	Command to send
 *
 * @return	0 for success, error otherwise.
 */
static int mpl_cmd_send(struct bt_conn *conn, struct mpl_cmd *cmd)
{
	int ret;
	int any_failures = 0;

	if (IS_ENABLED(CONFIG_BT_MCS)) {
		ret = media_proxy_ctrl_send_command(local_player, cmd);
		if (ret) {
			LOG_WRN("Failed to send command: %d", ret);
			return ret;
		}
	}

	if (IS_ENABLED(CONFIG_BT_MCC)) {
		if (conn != NULL) {
			int idx = mcc_peer_index_get(conn);

			if (idx < 0) {
				LOG_ERR("Unable to find mcc_peer");
				return idx;
			}

			if (mcc_peer[idx].mcp_mcs_disc_status == FINISHED) {
				ret = bt_mcc_send_cmd(mcc_peer[idx].conn, cmd);
				if (ret) {
					LOG_WRN("Failed to send command: %d", ret);
					return ret;
				}
			} else {
				LOG_WRN("MCS discovery has not finished: %d",
					mcc_peer[idx].mcp_mcs_disc_status);
				return -EBUSY;
			}

			return 0;
		}

		/* Send cmd to all peers connected and has finished discovery */
		for (uint8_t i = 0; i < ARRAY_SIZE(mcc_peer); i++) {
			if (mcc_peer[i].conn != NULL) {
				if (mcc_peer[i].mcp_mcs_disc_status == FINISHED) {
					ret = bt_mcc_send_cmd(mcc_peer[i].conn, cmd);
					if (ret) {
						LOG_WRN("Failed to send command: %d", ret);
						any_failures = ret;
					}
				} else {
					LOG_WRN("MCS discovery has not finished: %d",
						mcc_peer[i].mcp_mcs_disc_status);
					any_failures = -EBUSY;
				}
			}
		}
	}

	if (any_failures) {
		return any_failures;
	}

	return 0;
}

int bt_content_ctrl_media_discover(struct bt_conn *conn)
{
	int ret;

	if (!IS_ENABLED(CONFIG_BT_MCC)) {
		LOG_ERR("MCC not enabled");
		return -ECANCELED;
	}

	if (conn == NULL) {
		LOG_ERR("Invalid conn pointer");
		return -EINVAL;
	}

	int idx = mcc_peer_index_get(conn);

	if (idx == -ESRCH) {
		idx = mcc_peer_index_free_get();
		if (idx < 0) {
			LOG_WRN("Error getting free index: %d", idx);
			return idx;
		}

		mcc_peer[idx].conn = conn;
	}

	if (mcc_peer[idx].mcp_mcs_disc_status == FINISHED ||
	    mcc_peer[idx].mcp_mcs_disc_status == IN_PROGRESS) {
		return -EALREADY;
	}

	mcc_peer[idx].mcp_mcs_disc_status = IN_PROGRESS;

	ret = bt_mcc_discover_mcs(conn, true);
	if (ret) {
		mcc_peer[idx].mcp_mcs_disc_status = IDLE;
		return ret;
	}

	return 0;
}

int bt_content_ctrl_media_state_update(struct bt_conn *conn)
{
	if (!IS_ENABLED(CONFIG_BT_MCC)) {
		LOG_ERR("MCC not enabled");
		return -ECANCELED;
	}

	int idx = mcc_peer_index_get(conn);

	if (idx < 0) {
		LOG_WRN("Unable to look up conn pointer: %d", idx);
		return idx;
	}

	if (mcc_peer[idx].mcp_mcs_disc_status != FINISHED) {
		LOG_WRN("MCS discovery has not finished");
		return -EBUSY;
	}

	return bt_mcc_read_media_state(conn);
}

int bt_content_ctrl_media_play(struct bt_conn *conn)
{
	int ret;
	struct mpl_cmd cmd;

	if (media_player_state != BT_MCS_MEDIA_STATE_PLAYING &&
	    media_player_state != BT_MCS_MEDIA_STATE_PAUSED) {
		LOG_ERR("Invalid state: %d", media_player_state);
		return -ECANCELED;
	}

	if (media_player_state == BT_MCS_MEDIA_STATE_PLAYING) {
		LOG_WRN("Already in a playing state");
		return -EAGAIN;
	}

	cmd.opcode = BT_MCS_OPC_PLAY;
	cmd.use_param = false;

	ret = mpl_cmd_send(conn, &cmd);
	if (ret) {
		return ret;
	}

	return 0;
}

int bt_content_ctrl_media_pause(struct bt_conn *conn)
{
	int ret;
	struct mpl_cmd cmd;

	if (media_player_state != BT_MCS_MEDIA_STATE_PLAYING &&
	    media_player_state != BT_MCS_MEDIA_STATE_PAUSED) {
		LOG_ERR("Invalid state: %d", media_player_state);
		return -ECANCELED;
	}

	if (media_player_state == BT_MCS_MEDIA_STATE_PAUSED) {
		LOG_WRN("Already in a paused state");
		return -EAGAIN;
	}

	cmd.opcode = BT_MCS_OPC_PAUSE;
	cmd.use_param = false;

	ret = mpl_cmd_send(conn, &cmd);
	if (ret) {
		return ret;
	}

	return 0;
}

int bt_content_ctrl_media_conn_disconnected(struct bt_conn *conn)
{
	int idx = mcc_peer_index_get(conn);

	if (idx < 0) {
		LOG_WRN("Unable to look up conn pointer: %d", idx);
		return idx;
	}

	LOG_DBG("MCS discover state reset due to disconnection");
	mcc_peer[idx].mcp_mcs_disc_status = IDLE;
	mcc_peer[idx].conn = NULL;
	return 0;
}

int bt_content_ctrl_media_client_init(void)
{
	if (!IS_ENABLED(CONFIG_BT_MCC)) {
		LOG_ERR("MCC not enabled");
		return -ECANCELED;
	}

	static struct bt_mcc_cb mcc_cb;

	mcc_cb.discover_mcs = mcc_discover_mcs_cb;
	mcc_cb.send_cmd = mcc_send_command_cb;
	mcc_cb.cmd_ntf = mcc_cmd_notification_cb;
	mcc_cb.read_media_state = mcc_read_media_state_cb;
	return bt_mcc_init(&mcc_cb);
}

int bt_content_ctrl_media_server_init(bt_content_ctrl_media_play_pause_cb play_pause)
{
	int ret;

	if (!IS_ENABLED(CONFIG_BT_MCS)) {
		LOG_ERR("MCS not enabled");
		return -ECANCELED;
	}

	static struct media_proxy_ctrl_cbs mcs_cb;

	play_pause_cb = play_pause;

	ret = media_proxy_pl_init();
	if (ret) {
		LOG_ERR("Failed to init media proxy: %d", ret);
		return ret;
	}

	mcs_cb.command_recv = mcs_command_recv_cb;
	mcs_cb.media_state_recv = mcs_media_state_cb;
	mcs_cb.local_player_instance = mcs_local_player_instance_cb;

	ret = media_proxy_ctrl_register(&mcs_cb);
	if (ret) {
		LOG_ERR("Could not init mpl: %d", ret);
		return ret;
	}

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_content_control/media/bt_content_ctrl_media_internal.h
/*
 * Copyright (c) 2021 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BT_CONTENT_CTRL_MEDIA_INTERNAL_H_
#define _BT_CONTENT_CTRL_MEDIA_INTERNAL_H_

#include <zephyr/bluetooth/conn.h>

/**
 * @brief	Callback for changing the stream state.
 *
 * @param[in]	play	Differentiate between the play command and the pause command.
 */
typedef void (*bt_content_ctrl_media_play_pause_cb)(bool play);

/**
 * @brief	Discover Media Control Service and the included services.
 *
 * @note	Only valid for client.
 *
 * @param[in]	conn	Pointer to the active connection.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_media_discover(struct bt_conn *conn);

/**
 * @brief	Get the current state of the media player.
 *
 * @note	Only valid for client.
 *
 * @param[in]	conn	Pointer to the active connection.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_media_state_update(struct bt_conn *conn);

/**
 * @brief	Send a play command to the media player,
 *		depending on the current state.
 *
 * @param[in]	conn	Pointer to the connection to control; can be NULL.
 *
 * @note	If @p conn is NULL, play will be sent to all mcc_peers discovered.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_media_play(struct bt_conn *conn);

/**
 * @brief	Send a pause command to the media player,
 *		depending on the current state.
 *
 * @param[in]	conn	Pointer to the connection to control; can be NULL.
 *
 * @note	If @p conn is NULL, pause will be sent to all mcc_peers discovered.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_media_pause(struct bt_conn *conn);

/**
 * @brief	Reset the media control peer's discovered state
 *
 * @note	Only valid for client.
 *
 * @param[in]	conn	Pointer to the active connection.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_media_conn_disconnected(struct bt_conn *conn);

/**
 * @brief	Initialize the Media Control Client.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_media_client_init(void);

/**
 * @brief	Initialize the Media Control Server.
 *
 * @param[in]	play_pause_cb	Callback for received play/pause commands.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_media_server_init(bt_content_ctrl_media_play_pause_cb play_pause_cb);

#endif /* _BT_CONTENT_CTRL_MEDIA_INTERNAL_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_content_control/media/Kconfig
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

menu "Media"

#----------------------------------------------------------------------------#
menu "Log level"

module = BT_CONTENT_CTRL_MEDIA
module-str = bt_content_ctrl_media
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log level
endmenu # Media


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_stream/CMakeLists.txt
#
# Copyright (c) 2023 Nordic Semiconductor
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

zephyr_library_include_directories(
    broadcast
    unicast
    bt_le_audio_tx
)

add_subdirectory(bt_le_audio_tx)

target_sources(app PRIVATE
		${CMAKE_CURRENT_SOURCE_DIR}/le_audio.c)

if (CONFIG_BT_BAP_BROADCAST_SINK)
	target_sources(app PRIVATE
			${CMAKE_CURRENT_SOURCE_DIR}/broadcast/broadcast_sink.c)
endif()

if (CONFIG_BT_BAP_BROADCAST_SOURCE)
	target_sources(app PRIVATE
			${CMAKE_CURRENT_SOURCE_DIR}/broadcast/broadcast_source.c)
endif()

if (CONFIG_BT_BAP_UNICAST_CLIENT)
	target_sources(app PRIVATE
			${CMAKE_CURRENT_SOURCE_DIR}/unicast/unicast_client.c)
endif()

if (CONFIG_BT_BAP_UNICAST_SERVER)
	target_sources(app PRIVATE
			${CMAKE_CURRENT_SOURCE_DIR}/unicast/unicast_server.c)
endif()


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_stream/le_audio.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _LE_AUDIO_H_
#define _LE_AUDIO_H_

#include <zephyr/bluetooth/audio/bap.h>
#include <audio_defines.h>

#define LE_AUDIO_ZBUS_EVENT_WAIT_TIME	  K_MSEC(5)
#define LE_AUDIO_SDU_SIZE_OCTETS(bitrate) (bitrate / (1000000 / CONFIG_AUDIO_FRAME_DURATION_US) / 8)

#if CONFIG_SAMPLE_RATE_CONVERTER
#define BT_AUDIO_CODEC_CAPABILIY_FREQ                                                              \
	BT_AUDIO_CODEC_LC3_FREQ_48KHZ | BT_AUDIO_CODEC_LC3_FREQ_24KHZ |                            \
		BT_AUDIO_CODEC_LC3_FREQ_16KHZ

#elif CONFIG_AUDIO_SAMPLE_RATE_16000_HZ
#define BT_AUDIO_CODEC_CAPABILIY_FREQ BT_AUDIO_CODEC_LC3_FREQ_16KHZ

#elif CONFIG_AUDIO_SAMPLE_RATE_24000_HZ
#define BT_AUDIO_CODEC_CAPABILIY_FREQ BT_AUDIO_CODEC_LC3_FREQ_24KHZ

#elif CONFIG_AUDIO_SAMPLE_RATE_48000_HZ
#define BT_AUDIO_CODEC_CAPABILIY_FREQ BT_AUDIO_CODEC_LC3_FREQ_48KHZ

#else
#error No sample rate supported
#endif /* CONFIG_SAMPLE_RATE_CONVERTER */

#define BT_BAP_LC3_PRESET_CONFIGURABLE(_loc, _stream_context, _bitrate)                            \
	BT_BAP_LC3_PRESET(                                                                         \
		BT_AUDIO_CODEC_LC3_CONFIG(CONFIG_BT_AUDIO_PREF_SAMPLE_RATE_VALUE,                  \
					  BT_AUDIO_CODEC_CONFIG_LC3_DURATION_10, _loc,             \
					  LE_AUDIO_SDU_SIZE_OCTETS(_bitrate), 1, _stream_context), \
		BT_AUDIO_CODEC_LC3_QOS_10_UNFRAMED(LE_AUDIO_SDU_SIZE_OCTETS(_bitrate),             \
						   CONFIG_BT_AUDIO_RETRANSMITS,                    \
						   CONFIG_BT_AUDIO_MAX_TRANSPORT_LATENCY_MS,       \
						   CONFIG_BT_AUDIO_PRESENTATION_DELAY_US))

/**
 * @brief Callback for receiving Bluetooth LE Audio data.
 *
 * @param	data		Pointer to received data.
 * @param	size		Size of received data.
 * @param	bad_frame	Indicating if the frame is a bad frame or not.
 * @param	sdu_ref		ISO timestamp.
 * @param	channel_index	Audio channel index.
 */
typedef void (*le_audio_receive_cb)(const uint8_t *const data, size_t size, bool bad_frame,
				    uint32_t sdu_ref, enum audio_channel channel_index,
				    size_t desired_size);

/**
 * @brief	Encoded audio data and information.
 *
 * @note	Container for SW codec (typically LC3) compressed audio data.
 */
struct le_audio_encoded_audio {
	uint8_t const *const data;
	size_t size;
	uint8_t num_ch;
};

/**
 * @brief	Check if an endpoint is in the given state.
 *		If the endpoint is NULL, it is not in the
 *		given state, and this function returns false.
 *
 * @param[in]	ep       The endpoint to check.
 * @param[in]	state    The state to check for.
 *
 * @retval	true	The endpoint is in the given state.
 * @retval	false	Otherwise.
 */
bool le_audio_ep_state_check(struct bt_bap_ep *ep, enum bt_bap_ep_state state);

/**
 * @brief	Decode the audio sampling frequency in the codec configuration.
 *
 * @param[in]	codec		The audio codec structure.
 * @param[out]	freq_hz		Pointer to the sampling frequency in Hz.
 *
 * @return	0 for success, error otherwise.
 */
int le_audio_freq_hz_get(const struct bt_audio_codec_cfg *codec, int *freq_hz);

/**
 * @brief	Decode the audio frame duration in us in the codec configuration.
 *
 * @param[in]	codec			The audio codec structure.
 * @param[out]	frame_dur_us	Pointer to the frame duration in us.
 *
 * @return	0 for success, error otherwise.
 */
int le_audio_duration_us_get(const struct bt_audio_codec_cfg *codec, int *frame_dur_us);

/**
 * @brief	Decode the number of octets per frame in the codec configuration.
 *
 * @param[in]	codec			The audio codec structure.
 * @param[out]	octets_per_sdu	Pointer to the number of octets per SDU.
 *
 * @return	0 for success, error otherwise.
 */
int le_audio_octets_per_frame_get(const struct bt_audio_codec_cfg *codec, uint32_t *octets_per_sdu);

/**
 * @brief	Decode the number of frame blocks per SDU in the codec configuration.
 *
 * @param[in]	codec				The audio codec structure.
 * @param[out]	frame_blks_per_sdu	Pointer to the number of frame blocks per SDU.
 *
 * @return	0 for success, error otherwise.
 */
int le_audio_frame_blocks_per_sdu_get(const struct bt_audio_codec_cfg *codec,
				      uint32_t *frame_blks_per_sdu);

/**
 * @brief	Get the bitrate for the codec configuration.
 *
 * @details	Decodes the audio frame duration and the number of octets per fram from the codec
 *		configuration, and calculates the bitrate.
 *
 * @param[in]	codec	The audio codec structure.
 * @param[out]	bitrate	Pointer to the bitrate in bps.
 */
int le_audio_bitrate_get(const struct bt_audio_codec_cfg *const codec, uint32_t *bitrate);

/**
 * @brief	Get the direction of the @p stream provided
 *
 * @param	stream	Stream to check direction for.
 *
 * @retval	BT_AUDIO_DIR_SINK	sink direction.
 * @retval	BT_AUDIO_DIR_SOURCE	source direction.
 * @retval	Negative value		Failed to get ep_info from host.
 *
 */
int le_audio_stream_dir_get(struct bt_bap_stream const *const stream);

#endif /* _LE_AUDIO_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_stream/le_audio.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "le_audio.h"

#include <zephyr/bluetooth/audio/bap.h>
#include <zephyr/bluetooth/audio/audio.h>

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(le_audio, CONFIG_BLE_LOG_LEVEL);

/*TODO: Create helper function in host to perform this action. */
bool le_audio_ep_state_check(struct bt_bap_ep *ep, enum bt_bap_ep_state state)
{
	int ret;
	struct bt_bap_ep_info ep_info;

	if (ep == NULL) {
		/* If an endpoint is NULL it is not in any of the states */
		return false;
	}

	ret = bt_bap_ep_get_info(ep, &ep_info);
	if (ret) {
		LOG_WRN("Unable to get info for ep");
		return false;
	}

	if (ep_info.state == state) {
		return true;
	}

	return false;
}

int le_audio_freq_hz_get(const struct bt_audio_codec_cfg *codec, int *freq_hz)
{
	int ret;

	ret = bt_audio_codec_cfg_get_freq(codec);
	if (ret < 0) {
		*freq_hz = 0;
		return ret;
	}

	ret = bt_audio_codec_cfg_freq_to_freq_hz(ret);
	if (ret < 0) {
		*freq_hz = 0;
		return ret;
	}

	*freq_hz = ret;

	return 0;
}

int le_audio_duration_us_get(const struct bt_audio_codec_cfg *codec, int *frame_dur_us)
{
	int ret;

	ret = bt_audio_codec_cfg_get_frame_dur(codec);
	if (ret < 0) {
		*frame_dur_us = 0;
		return ret;
	}

	ret = bt_audio_codec_cfg_frame_dur_to_frame_dur_us(ret);
	if (ret < 0) {
		*frame_dur_us = 0;
		return ret;
	}

	*frame_dur_us = ret;

	return 0;
}

int le_audio_octets_per_frame_get(const struct bt_audio_codec_cfg *codec, uint32_t *octets_per_sdu)
{
	int ret;

	ret = bt_audio_codec_cfg_get_octets_per_frame(codec);
	if (ret < 0) {
		*octets_per_sdu = 0;
		return ret;
	}

	*octets_per_sdu = ret;

	return 0;
}

int le_audio_frame_blocks_per_sdu_get(const struct bt_audio_codec_cfg *codec,
				      uint32_t *frame_blks_per_sdu)
{
	int ret;

	ret = bt_audio_codec_cfg_get_frame_blocks_per_sdu(codec, true);
	if (ret < 0) {
		*frame_blks_per_sdu = 0;
		return ret;
	}

	*frame_blks_per_sdu = ret;

	return 0;
}

int le_audio_bitrate_get(const struct bt_audio_codec_cfg *const codec, uint32_t *bitrate)
{
	int ret;
	int dur_us;

	ret = le_audio_duration_us_get(codec, &dur_us);
	if (ret) {
		*bitrate = 0;
		return ret;
	}

	int frames_per_sec = 1000000 / dur_us;
	int octets_per_sdu;

	ret = le_audio_octets_per_frame_get(codec, &octets_per_sdu);
	if (ret) {
		*bitrate = 0;
		return ret;
	}

	*bitrate = frames_per_sec * (octets_per_sdu * 8);

	return 0;
}

int le_audio_stream_dir_get(struct bt_bap_stream const *const stream)
{
	int ret;
	struct bt_bap_ep_info ep_info;

	ret = bt_bap_ep_get_info(stream->ep, &ep_info);

	if (ret) {
		LOG_WRN("Failed to get ep_info");
		return ret;
	}

	return ep_info.dir;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_stream/unicast/Kconfig.defaults
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

config BT_GATT_CLIENT
	default y

config BT_BONDABLE
	default y

config BT_PRIVACY
	default y

config BT_FILTER_ACCEPT_LIST
	default y

config BT_SMP
	default y

config BT_GAP_AUTO_UPDATE_CONN_PARAMS
	default n

config BT_AUTO_PHY_UPDATE
	default n

config BT_AUTO_DATA_LEN_UPDATE
	default n

config BT_L2CAP_TX_BUF_COUNT
	default 12

config BT_BUF_ACL_RX_SIZE
	default 502 if (AUDIO_DFU > 0)
	default 259

config SETTINGS
	default y

config BT_SETTINGS
	default y

config FLASH
	default y

config FLASH_MAP
	default y

config NVS
	default y

config NVS_LOG_LEVEL
	default 2


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_stream/unicast/unicast_client.c
/*
 * Copyright (c) 2022 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "unicast_client.h"

#include <zephyr/sys/byteorder.h>
#include <zephyr/zbus/zbus.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/sys/byteorder.h>
#include <zephyr/bluetooth/conn.h>
#include <zephyr/bluetooth/audio/audio.h>
#include <zephyr/bluetooth/audio/pacs.h>
#include <zephyr/bluetooth/audio/csip.h>
#include <zephyr/bluetooth/audio/cap.h>
#include <zephyr/bluetooth/audio/bap.h>
#include <zephyr/bluetooth/audio/bap_lc3_preset.h>
#include <../subsys/bluetooth/audio/bap_iso.h>

/* TODO: Remove when a get_info function is implemented in host */
#include <../subsys/bluetooth/audio/bap_endpoint.h>

#include "macros_common.h"
#include "nrf5340_audio_common.h"
#include "bt_le_audio_tx.h"
#include "le_audio.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(unicast_client, CONFIG_UNICAST_CLIENT_LOG_LEVEL);

ZBUS_CHAN_DEFINE(le_audio_chan, struct le_audio_msg, NULL, NULL, ZBUS_OBSERVERS_EMPTY,
		 ZBUS_MSG_INIT(0));

#define HCI_ISO_BUF_ALLOC_PER_CHAN 2
#define CIS_CONN_RETRY_TIMES	   5
#define CIS_CONN_RETRY_DELAY_MS	   500

struct le_audio_headset {
	char *ch_name;
	uint8_t num_sink_eps;
	uint8_t num_source_eps;
	struct bt_bap_stream sink_stream;
	bool waiting_for_sink_disc;
	struct bt_bap_ep *sink_ep;
	struct bt_audio_codec_cap sink_codec_cap[CONFIG_CODEC_CAP_COUNT_MAX];
	struct bt_bap_stream source_stream;
	bool waiting_for_source_disc;
	struct bt_bap_ep *source_ep;
	struct bt_audio_codec_cap source_codec_cap[CONFIG_CODEC_CAP_COUNT_MAX];
	struct bt_conn *headset_conn;
	struct k_work_delayable stream_start_sink_work;
	struct k_work_delayable stream_start_source_work;
	bool qos_reconfigure;
	uint32_t reconfigure_pd;
};

struct discover_dir {
	struct bt_conn *conn;
	bool source;
	bool sink;
};

struct worker_data {
	uint8_t channel_index;
	enum bt_audio_dir dir;
	uint8_t retries;
} __aligned(4);

struct temp_cap_storage {
	struct bt_conn *conn;
	uint8_t num_caps;
	/* Must be the same size as sink_codec_cap and source_codec_cap */
	struct bt_audio_codec_cap codec[CONFIG_CODEC_CAP_COUNT_MAX];
};

static struct le_audio_headset headsets[CONFIG_BT_MAX_CONN];
static struct discover_dir discover_list[CONFIG_BT_MAX_CONN];

K_MSGQ_DEFINE(kwork_msgq, sizeof(struct worker_data),
	      2 * (CONFIG_BT_BAP_UNICAST_CLIENT_ASE_SNK_COUNT +
		   CONFIG_BT_BAP_UNICAST_CLIENT_ASE_SRC_COUNT),
	      sizeof(uint32_t));

static struct temp_cap_storage temp_cap[CONFIG_BT_MAX_CONN];

/* Make sure that we have at least one headset device per CONFIG_BT_BAP_UNICAST_CLIENT_ASE_SNK */
BUILD_ASSERT(ARRAY_SIZE(headsets) >= CONFIG_BT_BAP_UNICAST_CLIENT_ASE_SNK_COUNT,
	     "We need to have at least one headset device per ASE SINK");

/* Make sure that we have at least one headset device per CONFIG_BT_BAP_UNICAST_CLIENT_ASE_SRC */
BUILD_ASSERT(ARRAY_SIZE(headsets) >= CONFIG_BT_BAP_UNICAST_CLIENT_ASE_SRC_COUNT,
	     "We need to have at least one headset device per ASE SOURCE");

static le_audio_receive_cb receive_cb;

static struct bt_bap_unicast_group *unicast_group;

/* Used for group creation only */
static struct bt_bap_lc3_preset lc3_preset_max = BT_BAP_LC3_PRESET_CONFIGURABLE(
	BT_AUDIO_LOCATION_FRONT_LEFT, BT_AUDIO_CONTEXT_TYPE_MEDIA, CONFIG_LC3_BITRATE_MAX);

static struct bt_bap_lc3_preset lc3_preset_sink = BT_BAP_LC3_UNICAST_PRESET_NRF5340_AUDIO_SINK;
static struct bt_bap_lc3_preset lc3_preset_sink_48_4_1 =
	BT_BAP_LC3_UNICAST_PRESET_48_4_1(BT_AUDIO_LOCATION_ANY, (BT_AUDIO_CONTEXT_TYPE_MEDIA));
static struct bt_bap_lc3_preset lc3_preset_sink_24_2_1 =
	BT_BAP_LC3_UNICAST_PRESET_24_2_1(BT_AUDIO_LOCATION_ANY, (BT_AUDIO_CONTEXT_TYPE_MEDIA));
static struct bt_bap_lc3_preset lc3_preset_sink_16_2_1 =
	BT_BAP_LC3_UNICAST_PRESET_16_2_1(BT_AUDIO_LOCATION_ANY, (BT_AUDIO_CONTEXT_TYPE_MEDIA));

static struct bt_bap_lc3_preset lc3_preset_source = BT_BAP_LC3_UNICAST_PRESET_NRF5340_AUDIO_SOURCE;
static struct bt_bap_lc3_preset lc3_preset_source_48_4_1 =
	BT_BAP_LC3_UNICAST_PRESET_48_4_1(BT_AUDIO_LOCATION_ANY, BT_AUDIO_CONTEXT_TYPE_MEDIA);
static struct bt_bap_lc3_preset lc3_preset_source_24_2_1 =
	BT_BAP_LC3_UNICAST_PRESET_24_2_1(BT_AUDIO_LOCATION_ANY, BT_AUDIO_CONTEXT_TYPE_MEDIA);
static struct bt_bap_lc3_preset lc3_preset_source_16_2_1 =
	BT_BAP_LC3_UNICAST_PRESET_16_2_1(BT_AUDIO_LOCATION_ANY, BT_AUDIO_CONTEXT_TYPE_MEDIA);

static bool playing_state = true;

static void le_audio_event_publish(enum le_audio_evt_type event, struct bt_conn *conn,
				   enum bt_audio_dir dir)
{
	int ret;
	struct le_audio_msg msg;

	msg.event = event;
	msg.conn = conn;
	msg.dir = dir;

	ret = zbus_chan_pub(&le_audio_chan, &msg, LE_AUDIO_ZBUS_EVENT_WAIT_TIME);
	ERR_CHK(ret);
}

/**
 * @brief	Add a conn pointer to the discover list.
 *
 * @param[in]	conn	Pointer to the connection to add.
 * @param[in]	dir	Directions to do discovery for.
 *
 * @retval	-ENOMEM	No more space for connections.
 * @retval	0	Successfully added connection.
 */
static int discover_list_add(struct bt_conn *conn, enum unicast_discover_dir dir)
{
	if (!(dir & BT_AUDIO_DIR_SOURCE) && !(dir & BT_AUDIO_DIR_SINK)) {
		LOG_ERR("No direction is set for the discover list entry");
		return -EINVAL;
	}

	/* Check if conn is already in the list */
	for (int i = 0; i < ARRAY_SIZE(discover_list); i++) {
		if (discover_list[i].conn == conn) {
			discover_list[i].source = false;
			discover_list[i].sink = false;

			if (dir & BT_AUDIO_DIR_SOURCE) {
				discover_list[i].source = true;
			}

			if (dir & BT_AUDIO_DIR_SINK) {
				discover_list[i].sink = true;
			}

			return 0;
		}
	}

	/* If not already in the list, add to list if there is room */
	for (int i = 0; i < ARRAY_SIZE(discover_list); i++) {
		if (discover_list[i].conn == NULL) {
			discover_list[i].conn = conn;

			if (dir & BT_AUDIO_DIR_SOURCE) {
				discover_list[i].source = true;
			}

			if (dir & BT_AUDIO_DIR_SINK) {
				discover_list[i].sink = true;
			}

			return 0;
		}
	}

	return -ENOMEM;
}

/**
 * @brief	Remove a conn pointer from the discover list.
 *
 * @param[in]	conn	Pointer to the connection to remove.
 *
 * @retval	-EINVAL	No such connection found.
 * @retval	0	Successfully removed connection.
 */
static int discover_list_remove(struct bt_conn const *const conn)
{
	for (int i = 0; i < ARRAY_SIZE(discover_list); i++) {
		if (discover_list[i].conn == conn) {
			discover_list[i].conn = NULL;
			discover_list[i].sink = false;
			discover_list[i].source = false;

			return 0;
		}
	}

	return -EINVAL;
}

/**
 * @brief	Get discover_list index for given @p conn.
 *
 * @param[in]	conn	Pointer to the connection.
 *
 * @return	-ESRCH if @p conn not found, index otherwise.
 */
static int discover_list_index_get(struct bt_conn const *const conn)
{
	for (int i = 0; i < ARRAY_SIZE(discover_list); i++) {
		if (conn == discover_list[i].conn) {
			return i;
		}
	}

	return -ESRCH;
}

/**
 * @brief  Get the common presentation delay for all headsets.
 *
 * @param[in]	index		The index of the headset to test against.
 * @param[out]	pres_dly_us	Pointer to where the presentation delay will be stored.
 *
 * @retval	0	Operation successful.
 * @retval	-EINVAL	Any error.
 */
static int headset_pres_delay_find(uint8_t index, uint32_t *pres_dly_us)
{
	uint32_t pres_dly_min = headsets[index].sink_ep->qos_pref.pd_min;
	uint32_t pres_dly_max = headsets[index].sink_ep->qos_pref.pd_max;
	uint32_t pref_dly_min = headsets[index].sink_ep->qos_pref.pref_pd_min;
	uint32_t pref_dly_max = headsets[index].sink_ep->qos_pref.pref_pd_max;

	LOG_DBG("Index: %d, Pref min: %d, pref max: %d, pres_min: %d, pres_max: %d", index,
		pref_dly_min, pref_dly_max, pres_dly_min, pres_dly_max);

	for (int i = 0; i < ARRAY_SIZE(headsets); i++) {
		if (headsets[i].sink_ep != NULL) {
			pres_dly_min = MAX(pres_dly_min, headsets[i].sink_ep->qos_pref.pd_min);
			pres_dly_max = MIN(pres_dly_max, headsets[i].sink_ep->qos_pref.pd_max);
			pref_dly_min = MAX(pref_dly_min, headsets[i].sink_ep->qos_pref.pref_pd_min);
			pref_dly_max = MIN(pref_dly_max, headsets[i].sink_ep->qos_pref.pref_pd_max);
		}
	}

	if (IS_ENABLED(CONFIG_BT_AUDIO_PRES_DELAY_SRCH_MIN)) {
		*pres_dly_us = pres_dly_min;

		return 0;
	}

	if (IS_ENABLED(CONFIG_BT_AUDIO_PRES_DELAY_SRCH_MAX)) {
		*pres_dly_us = pres_dly_max;

		return 0;
	}

	if (IS_ENABLED(CONFIG_BT_AUDIO_PRES_DELAY_SRCH_PREF_MIN)) {
		/* Preferred min is 0, so we set min supported */
		if (pref_dly_min == 0) {
			*pres_dly_us = pres_dly_min;
		} else {
			*pres_dly_us = pref_dly_min;
		}

		return 0;
	}

	if (IS_ENABLED(CONFIG_BT_AUDIO_PRES_DELAY_SRCH_PREF_MAX)) {
		/* Preferred max is 0, so we set max supported */
		if (pref_dly_max == 0) {
			*pres_dly_us = pres_dly_max;
		} else {
			*pres_dly_us = pref_dly_max;
		}

		return 0;
	}

	LOG_ERR("Trying to use unrecognized search mode");

	return -EINVAL;
}

/**
 * @brief	Get channel index based on connection.
 *
 * @param[in]	conn	The connection to search for.
 * @param[out]	index	The channel index.
 *
 * @retval	0	Operation successful.
 * @retval	-EINVAL	There is no match.
 */
static int channel_index_get(const struct bt_conn *conn, uint8_t *index)
{
	if (conn == NULL) {
		LOG_ERR("No connection provided");
		return -EINVAL;
	}

	for (int i = 0; i < ARRAY_SIZE(headsets); i++) {
		if (headsets[i].headset_conn == conn) {
			*index = i;
			return 0;
		}
	}

	LOG_WRN("Connection not found");

	return -EINVAL;
}

static void supported_sample_rates_print(uint16_t supported_sample_rates, enum bt_audio_dir dir)
{
	char supported_str[20] = "";

	if (supported_sample_rates & BT_AUDIO_CODEC_LC3_FREQ_48KHZ) {
		strcat(supported_str, "48, ");
	}

	if (supported_sample_rates & BT_AUDIO_CODEC_LC3_FREQ_24KHZ) {
		strcat(supported_str, "24, ");
	}

	if (supported_sample_rates & BT_AUDIO_CODEC_LC3_FREQ_16KHZ) {
		strcat(supported_str, "16, ");
	}

	if (dir == BT_AUDIO_DIR_SINK) {
		LOG_DBG("Headset supports: %s kHz in sink direction", supported_str);
	} else if (dir == BT_AUDIO_DIR_SOURCE) {
		LOG_DBG("Headset supports: %s kHz in source direction", supported_str);
	}
}

static bool sink_parse_cb(struct bt_data *data, void *user_data)
{
	if (data->type == BT_AUDIO_CODEC_LC3_FREQ) {
		uint16_t lc3_freq_bit = sys_get_le16(data->data);

		supported_sample_rates_print(lc3_freq_bit, BT_AUDIO_DIR_SINK);

		/* Try with the preferred sample rate first */
		switch (CONFIG_BT_AUDIO_PREF_SAMPLE_RATE_VALUE) {
		case BT_AUDIO_CODEC_CONFIG_LC3_FREQ_48KHZ:
			if (lc3_freq_bit & BT_AUDIO_CODEC_LC3_FREQ_48KHZ) {
				lc3_preset_sink = lc3_preset_sink_48_4_1;
				*(bool *)user_data = true;
				/* Found what we were looking for, stop parsing LTV */
				return false;
			}

			break;

		case BT_AUDIO_CODEC_CONFIG_LC3_FREQ_24KHZ:
			if (lc3_freq_bit & BT_AUDIO_CODEC_LC3_FREQ_24KHZ) {
				lc3_preset_sink = lc3_preset_sink_24_2_1;
				*(bool *)user_data = true;
				/* Found what we were looking for, stop parsing LTV */
				return false;
			}

			break;

		case BT_AUDIO_CODEC_CONFIG_LC3_FREQ_16KHZ:
			if (lc3_freq_bit & BT_AUDIO_CODEC_LC3_FREQ_16KHZ) {
				lc3_preset_sink = lc3_preset_sink_16_2_1;
				*(bool *)user_data = true;
				/* Found what we were looking for, stop parsing LTV */
				return false;
			}

			break;
		}

		/* If no match with the preferred, revert to trying highest first */
		if (lc3_freq_bit & BT_AUDIO_CODEC_LC3_FREQ_48KHZ) {
			lc3_preset_sink = lc3_preset_sink_48_4_1;
			*(bool *)user_data = true;
		} else if (lc3_freq_bit & BT_AUDIO_CODEC_LC3_FREQ_24KHZ) {
			lc3_preset_sink = lc3_preset_sink_24_2_1;
			*(bool *)user_data = true;
		} else if (lc3_freq_bit & BT_AUDIO_CODEC_LC3_FREQ_16KHZ) {
			lc3_preset_sink = lc3_preset_sink_16_2_1;
			*(bool *)user_data = true;
		}

		/* Found what we were looking for, stop parsing LTV */
		return false;
	}

	/* Did not find what we were looking for, continue parsing LTV */
	return true;
}

static bool source_parse_cb(struct bt_data *data, void *user_data)
{
	if (data->type == BT_AUDIO_CODEC_LC3_FREQ) {
		uint16_t lc3_freq_bit = sys_get_le16(data->data);

		supported_sample_rates_print(lc3_freq_bit, BT_AUDIO_DIR_SOURCE);

		/* Try with the preferred sample rate first */
		switch (CONFIG_BT_AUDIO_PREF_SAMPLE_RATE_VALUE) {
		case BT_AUDIO_CODEC_CONFIG_LC3_FREQ_48KHZ:
			if (lc3_freq_bit & BT_AUDIO_CODEC_LC3_FREQ_48KHZ) {
				lc3_preset_source = lc3_preset_source_48_4_1;
				*(bool *)user_data = true;
				/* Found what we were looking for, stop parsing LTV */
				return false;
			}

			break;

		case BT_AUDIO_CODEC_CONFIG_LC3_FREQ_24KHZ:
			if (lc3_freq_bit & BT_AUDIO_CODEC_LC3_FREQ_24KHZ) {
				lc3_preset_source = lc3_preset_source_24_2_1;
				*(bool *)user_data = true;
				/* Found what we were looking for, stop parsing LTV */
				return false;
			}

			break;

		case BT_AUDIO_CODEC_CONFIG_LC3_FREQ_16KHZ:
			if (lc3_freq_bit & BT_AUDIO_CODEC_LC3_FREQ_16KHZ) {
				lc3_preset_source = lc3_preset_source_16_2_1;
				*(bool *)user_data = true;
				/* Found what we were looking for, stop parsing LTV */
				return false;
			}

			break;
		}

		/* If no match with the preferred, revert to trying highest first */
		if (lc3_freq_bit & BT_AUDIO_CODEC_LC3_FREQ_48KHZ) {
			lc3_preset_source = lc3_preset_source_48_4_1;
			*(bool *)user_data = true;
		} else if (lc3_freq_bit & BT_AUDIO_CODEC_LC3_FREQ_24KHZ) {
			lc3_preset_source = lc3_preset_source_24_2_1;
			*(bool *)user_data = true;
		} else if (lc3_freq_bit & BT_AUDIO_CODEC_LC3_FREQ_16KHZ) {
			lc3_preset_source = lc3_preset_source_16_2_1;
			*(bool *)user_data = true;
		}

		/* Found what we were looking for, stop parsing LTV */
		return false;
	}

	/* Did not find what we were looking for, continue parsing LTV */
	return true;
}

/**
 * @brief	Check if the gateway can support the headset codec capabilities.
 *
 * @note	Currently only the sampling frequency is checked.
 *
 * @param[in]	cap_array	The array of pointers to codec capabilities.
 * @param[in]	num_caps	The size of cap_array.
 * @param[in]	dir		Direction of the capabilities to check.
 *
 * @return	True if valid codec capability found, false otherwise.
 */
static bool valid_codec_cap_check(struct bt_audio_codec_cap cap_array[], uint8_t num_caps,
				  enum bt_audio_dir dir)
{
	bool valid_result = false;

	/* Only the sampling frequency is checked */
	if (dir == BT_AUDIO_DIR_SINK) {
		for (int i = 0; i < num_caps; i++) {
			(void)bt_audio_data_parse(cap_array[i].data, cap_array[i].data_len,
						  sink_parse_cb, &valid_result);
		}
	} else if (dir == BT_AUDIO_DIR_SOURCE) {
		for (int i = 0; i < num_caps; i++) {
			(void)bt_audio_data_parse(cap_array[i].data, cap_array[i].data_len,
						  source_parse_cb, &valid_result);
		}
	}

	return valid_result;
}

/**
 * @brief Set the allocation to a preset codec configuration.
 *
 * @param codec The preset codec configuration.
 * @param loc   Location bitmask setting.
 *
 */
static void bt_audio_codec_allocation_set(struct bt_audio_codec_cfg *codec_cfg,
					  enum bt_audio_location loc)
{
	for (size_t i = 0U; i < codec_cfg->data_len;) {
		const uint8_t len = codec_cfg->data[i++];
		const uint8_t type = codec_cfg->data[i++];
		uint8_t *value = &codec_cfg->data[i];
		const uint8_t value_len = len - sizeof(type);

		if (type == BT_AUDIO_CODEC_CONFIG_LC3_CHAN_ALLOC) {
			const uint32_t loc_32 = loc;

			sys_put_le32(loc_32, value);

			return;
		}
		i += value_len;
	}
}

static int update_sink_stream_qos(struct le_audio_headset *headset, uint32_t pres_delay_us)
{
	int ret;

	if (headset->sink_stream.ep == NULL) {
		return -ESRCH;
	}

	if (headset->sink_stream.qos == NULL) {
		LOG_WRN("No QoS found for %p", &headset->sink_stream);
		return -ENXIO;
	}

	if (headset->sink_stream.qos->pd != pres_delay_us) {
		if (playing_state &&
		    le_audio_ep_state_check(headset->sink_stream.ep, BT_BAP_EP_STATE_STREAMING)) {
			LOG_DBG("Update streaming %s headset, connection %p, stream %p",
				headset->ch_name, &headset->headset_conn, &headset->sink_stream);

			headset->qos_reconfigure = true;
			headset->reconfigure_pd = pres_delay_us;

			ret = bt_bap_stream_disable(&headset->sink_stream);
			if (ret) {
				LOG_ERR("Unable to disable stream: %d", ret);
				return ret;
			}
		} else {
			LOG_DBG("Reset %s headset, connection %p, stream %p", headset->ch_name,
				&headset->headset_conn, &headset->sink_stream);

			headset->sink_stream.qos->pd = pres_delay_us;

			ret = bt_bap_stream_qos(headset->headset_conn, unicast_group);
			if (ret && ret != -EINVAL) {
				/* ret == -EINVAL means that the stream is not ready to
				 * be configured yet
				 */
				LOG_ERR("Unable to configure %s headset: %d", headset->ch_name,
					ret);
				return ret;
			}
		}
	}

	return 0;
}

static void unicast_client_location_cb(struct bt_conn *conn, enum bt_audio_dir dir,
				       enum bt_audio_location loc)
{
	int index = discover_list_index_get(conn);

	if (index < 0) {
		LOG_WRN("Failed to get discover_list index");
		return;
	}

	if ((loc & BT_AUDIO_LOCATION_FRONT_LEFT) || (loc & BT_AUDIO_LOCATION_SIDE_LEFT)) {
		if (headsets[AUDIO_CH_L].headset_conn == NULL) {
			headsets[AUDIO_CH_L].headset_conn = conn;
			headsets[AUDIO_CH_L].waiting_for_sink_disc = discover_list[index].sink;
			headsets[AUDIO_CH_L].waiting_for_source_disc = discover_list[index].source;
		}

	} else if ((loc & BT_AUDIO_LOCATION_FRONT_RIGHT) || (loc & BT_AUDIO_LOCATION_SIDE_RIGHT)) {
		if (headsets[AUDIO_CH_R].headset_conn == NULL) {
			headsets[AUDIO_CH_R].headset_conn = conn;
			headsets[AUDIO_CH_R].waiting_for_sink_disc = discover_list[index].sink;
			headsets[AUDIO_CH_R].waiting_for_source_disc = discover_list[index].source;
		}
	} else {
		LOG_WRN("Channel location not supported");
		le_audio_event_publish(LE_AUDIO_EVT_NO_VALID_CFG, conn, dir);
	}
}

static void available_contexts_cb(struct bt_conn *conn, enum bt_audio_context snk_ctx,
				  enum bt_audio_context src_ctx)
{
	char addr[BT_ADDR_LE_STR_LEN];

	(void)bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));

	LOG_DBG("conn: %s, snk ctx %d src ctx %d", addr, snk_ctx, src_ctx);
}

static int temp_cap_index_get(struct bt_conn *conn, uint8_t *index)
{
	if (conn == NULL) {
		LOG_ERR("No conn provided");
		return -EINVAL;
	}

	for (int i = 0; i < ARRAY_SIZE(temp_cap); i++) {
		if (temp_cap[i].conn == conn) {
			*index = i;
			return 0;
		}
	}

	/* Connection not found in temp_cap, searching for empty slot */
	for (int i = 0; i < ARRAY_SIZE(temp_cap); i++) {
		if (temp_cap[i].conn == NULL) {
			temp_cap[i].conn = conn;
			*index = i;
			return 0;
		}
	}

	LOG_WRN("No more space in temp_cap");

	return -ECANCELED;
}

static void pac_record_cb(struct bt_conn *conn, enum bt_audio_dir dir,
			  const struct bt_audio_codec_cap *codec)
{
	int ret;
	uint8_t temp_cap_index;

	ret = temp_cap_index_get(conn, &temp_cap_index);
	if (ret) {
		LOG_ERR("Could not get temporary CAP storage index");
		return;
	}

	if (codec->id != BT_HCI_CODING_FORMAT_LC3) {
		LOG_DBG("Only the LC3 codec is supported");
		return;
	}

	/* num_caps is an increasing index that starts at 0 */
	if (temp_cap[temp_cap_index].num_caps < ARRAY_SIZE(temp_cap[temp_cap_index].codec)) {
		struct bt_audio_codec_cap *codec_loc =
			&temp_cap[temp_cap_index].codec[temp_cap[temp_cap_index].num_caps];

		memcpy(codec_loc, codec, sizeof(struct bt_audio_codec_cap));

		temp_cap[temp_cap_index].num_caps++;
	} else {
		LOG_WRN("No more space. Increase CODEC_CAPAB_COUNT_MAX");
	}
}

static void endpoint_cb(struct bt_conn *conn, enum bt_audio_dir dir, struct bt_bap_ep *ep)
{
	int ret;
	uint8_t channel_index = 0;

	ret = channel_index_get(conn, &channel_index);
	if (ret) {
		LOG_ERR("Unknown connection, should not reach here");
		return;
	}

	if (dir == BT_AUDIO_DIR_SINK) {
		if (ep != NULL) {
			if (headsets[channel_index].num_sink_eps > 0) {
				LOG_WRN("More than one sink endpoint found, idx 0 is used "
					"by default");
				return;
			}

			headsets[channel_index].sink_ep = ep;
			headsets[channel_index].num_sink_eps++;
			return;
		}

		if (headsets[channel_index].sink_ep == NULL) {
			LOG_WRN("No sink endpoints found");
		}

		return;
	} else if (dir == BT_AUDIO_DIR_SOURCE) {
		if (ep != NULL) {
			if (headsets[channel_index].num_source_eps > 0) {
				LOG_WRN("More than one source endpoint found, idx 0 is "
					"used by default");
				return;
			}

			headsets[channel_index].source_ep = ep;
			headsets[channel_index].num_source_eps++;
			return;
		}

		if (headsets[channel_index].source_ep == NULL) {
			LOG_WRN("No source endpoints found");
		}

		return;
	} else {
		LOG_WRN("Endpoint direction not recognized: %d", dir);
	}
}

static void discover_cb(struct bt_conn *conn, int err, enum bt_audio_dir dir)
{
	int ret;
	uint8_t channel_index;
	uint8_t temp_cap_index;

	ret = channel_index_get(conn, &channel_index);
	if (ret) {
		LOG_ERR("Unknown connection, should not reach here");
		return;
	}

	if (err == BT_ATT_ERR_ATTRIBUTE_NOT_FOUND) {
		if (dir == BT_AUDIO_DIR_SINK) {
			LOG_WRN("No sinks found");
			headsets[channel_index].waiting_for_sink_disc = false;
		} else if (dir == BT_AUDIO_DIR_SOURCE) {
			LOG_WRN("No sources found");
			headsets[channel_index].waiting_for_source_disc = false;
			/**
			 * We usually wait until both sink and source has been discovered
			 * before configuring, but since no source was found and we have a
			 * sink, we need to configure that.
			 */
			if (headsets[channel_index].sink_ep != NULL) {
				ret = bt_bap_stream_config(conn,
							   &headsets[channel_index].sink_stream,
							   headsets[channel_index].sink_ep,
							   &lc3_preset_sink.codec_cfg);
				if (ret) {
					LOG_ERR("Could not configure sink stream, ret = %d", ret);
				}
			}
		}

		return;
	} else if (err) {
		LOG_ERR("Discovery failed: %d", err);
		return;
	}

	ret = temp_cap_index_get(conn, &temp_cap_index);
	if (ret) {
		LOG_ERR("Could not get temporary CAP storage index");
		return;
	}

	for (int i = 0; i < CONFIG_CODEC_CAP_COUNT_MAX; i++) {
		if (dir == BT_AUDIO_DIR_SINK) {
			memcpy(&headsets[channel_index].sink_codec_cap[i],
			       &temp_cap[temp_cap_index].codec[i],
			       sizeof(struct bt_audio_codec_cap));
		} else if (dir == BT_AUDIO_DIR_SOURCE) {
			memcpy(&headsets[channel_index].source_codec_cap[i],
			       &temp_cap[temp_cap_index].codec[i],
			       sizeof(struct bt_audio_codec_cap));
		}
	}

	if (dir == BT_AUDIO_DIR_SINK) {
		if (valid_codec_cap_check(headsets[channel_index].sink_codec_cap,
					  temp_cap[temp_cap_index].num_caps, BT_AUDIO_DIR_SINK)) {
			if (conn == headsets[AUDIO_CH_L].headset_conn) {
				bt_audio_codec_allocation_set(&lc3_preset_sink.codec_cfg,
							      BT_AUDIO_LOCATION_FRONT_LEFT);
			} else if (conn == headsets[AUDIO_CH_R].headset_conn) {
				bt_audio_codec_allocation_set(&lc3_preset_sink.codec_cfg,
							      BT_AUDIO_LOCATION_FRONT_RIGHT);
			} else {
				LOG_ERR("Unknown connection, cannot set allocation");
			}
		} else {
			/* NOTE: The string below is used by the Nordic CI system */
			LOG_WRN("No valid codec capability found for %s headset sink",
				headsets[channel_index].ch_name);
			headsets[channel_index].sink_ep = NULL;
		}
	} else if (dir == BT_AUDIO_DIR_SOURCE) {
		if (valid_codec_cap_check(headsets[channel_index].source_codec_cap,
					  temp_cap[temp_cap_index].num_caps, BT_AUDIO_DIR_SOURCE)) {
			if (conn == headsets[AUDIO_CH_L].headset_conn) {
				bt_audio_codec_allocation_set(&lc3_preset_source.codec_cfg,
							      BT_AUDIO_LOCATION_FRONT_LEFT);
			} else if (conn == headsets[AUDIO_CH_R].headset_conn) {
				bt_audio_codec_allocation_set(&lc3_preset_source.codec_cfg,
							      BT_AUDIO_LOCATION_FRONT_RIGHT);
			} else {
				LOG_ERR("Unknown connection, cannot set allocation");
			}
		} else {
			LOG_WRN("No valid codec capability found for %s headset source",
				headsets[channel_index].ch_name);
			headsets[channel_index].source_ep = NULL;
		}
	}

	/* Free up the slot in temp_cap */
	memset(temp_cap[temp_cap_index].codec, 0, sizeof(temp_cap[temp_cap_index].codec));
	temp_cap[temp_cap_index].conn = NULL;
	temp_cap[temp_cap_index].num_caps = 0;

	if (dir == BT_AUDIO_DIR_SINK) {
		headsets[channel_index].waiting_for_sink_disc = false;

		if (headsets[channel_index].waiting_for_source_disc) {
			ret = bt_bap_unicast_client_discover(conn, BT_AUDIO_DIR_SOURCE);
			if (ret) {
				LOG_WRN("Failed to discover source: %d", ret);
			}

			return;
		}
	} else if (dir == BT_AUDIO_DIR_SOURCE) {
		headsets[channel_index].waiting_for_source_disc = false;
	}

	if (headsets[channel_index].sink_ep) {
		ret = bt_bap_stream_config(conn, &headsets[channel_index].sink_stream,
					   headsets[channel_index].sink_ep,
					   &lc3_preset_sink.codec_cfg);
		if (ret) {
			LOG_ERR("Could not configure sink stream, ret = %d", ret);
		}
	}

	if (headsets[channel_index].source_ep) {
		ret = bt_bap_stream_config(conn, &headsets[channel_index].source_stream,
					   headsets[channel_index].source_ep,
					   &lc3_preset_source.codec_cfg);
		if (ret) {
			LOG_ERR("Could not configure source stream, ret = %d", ret);
		}
	}
}

static struct bt_bap_unicast_client_cb unicast_client_cbs = {
	.location = unicast_client_location_cb,
	.available_contexts = available_contexts_cb,
	.pac_record = pac_record_cb,
	.endpoint = endpoint_cb,
	.discover = discover_cb,
};

static void stream_sent_cb(struct bt_bap_stream *stream)
{
	int ret;
	uint8_t channel_index;

	if (le_audio_ep_state_check(stream->ep, BT_BAP_EP_STATE_STREAMING)) {

		ret = channel_index_get(stream->conn, &channel_index);
		if (ret) {
			LOG_ERR("Channel index not found");
		} else {
			ERR_CHK(bt_le_audio_tx_stream_sent(channel_index));
		}
	} else {
		LOG_WRN("Not in streaming state");
	}
}

static void stream_configured_cb(struct bt_bap_stream *stream,
				 const struct bt_audio_codec_qos_pref *pref)
{
	int ret;
	uint8_t channel_index;
	uint32_t new_pres_dly_us;

	ret = channel_index_get(stream->conn, &channel_index);
	if (ret) {
		LOG_ERR("Channel index not found");
		return;
	}

	if (stream->ep->dir == BT_AUDIO_DIR_SINK) {
		/* NOTE: The string below is used by the Nordic CI system */
		LOG_INF("%s sink stream configured", headsets[channel_index].ch_name);
	} else if (stream->ep->dir == BT_AUDIO_DIR_SOURCE) {
		LOG_INF("%s source stream configured", headsets[channel_index].ch_name);
	} else {
		LOG_WRN("Endpoint direction not recognized: %d", stream->ep->dir);
		return;
	}
	LOG_DBG("Configured Stream info: %s, %p, dir %d", headsets[channel_index].ch_name,
		(void *)stream, stream->ep->dir);

	ret = headset_pres_delay_find(channel_index, &new_pres_dly_us);
	if (ret) {
		LOG_ERR("Cannot get a valid presentation delay");
		return;
	}

	if (headsets[channel_index].waiting_for_source_disc) {
		return;
	}

	if (le_audio_ep_state_check(headsets[channel_index].sink_stream.ep,
				    BT_BAP_EP_STATE_CODEC_CONFIGURED)) {
		for (int i = 0; i < ARRAY_SIZE(headsets); i++) {
			if (i != channel_index && headsets[i].headset_conn != NULL) {
				ret = update_sink_stream_qos(&headsets[i], new_pres_dly_us);
				if (ret && ret != -ESRCH) {
					LOG_ERR("Presentation delay not set for %s "
						"headset: %d",
						headsets[channel_index].ch_name, ret);
				}
			}
		}

		LOG_DBG("Set %s headset, connection %p, stream %p", headsets[channel_index].ch_name,
			&headsets[channel_index].headset_conn,
			&headsets[channel_index].sink_stream);

		headsets[channel_index].sink_stream.qos->pd = new_pres_dly_us;
	}

	le_audio_event_publish(LE_AUDIO_EVT_CONFIG_RECEIVED, stream->conn, stream->ep->dir);

	/* Make sure both sink and source ep (if both are discovered) are configured before
	 * QoS
	 */
	if ((headsets[channel_index].sink_ep != NULL &&
	     !le_audio_ep_state_check(headsets[channel_index].sink_stream.ep,
				      BT_BAP_EP_STATE_CODEC_CONFIGURED)) ||
	    (headsets[channel_index].source_ep != NULL &&
	     !le_audio_ep_state_check(headsets[channel_index].source_stream.ep,
				      BT_BAP_EP_STATE_CODEC_CONFIGURED))) {
		return;
	}

	ret = bt_bap_stream_qos(headsets[channel_index].headset_conn, unicast_group);
	if (ret) {
		LOG_ERR("QoS not set for %s headset: %d", headsets[channel_index].ch_name, ret);
	}
}

static void stream_qos_set_cb(struct bt_bap_stream *stream)
{
	int ret;
	uint8_t channel_index;

	ret = channel_index_get(stream->conn, &channel_index);

	if (headsets[channel_index].qos_reconfigure) {
		LOG_DBG("Reconfiguring: %s to PD: %d", headsets[channel_index].ch_name,
			headsets[channel_index].reconfigure_pd);

		headsets[channel_index].qos_reconfigure = false;
		headsets[channel_index].sink_stream.qos->pd =
			headsets[channel_index].reconfigure_pd;

		ret = bt_bap_stream_qos(headsets[channel_index].headset_conn, unicast_group);
		if (ret) {
			LOG_ERR("Unable to reconfigure %s: %d", headsets[channel_index].ch_name,
				ret);
		}
	} else {
		LOG_DBG("Set %s to PD: %d", headsets[channel_index].ch_name, stream->qos->pd);

		if (playing_state) {
			ret = bt_bap_stream_enable(stream, lc3_preset_sink.codec_cfg.meta,
						   lc3_preset_sink.codec_cfg.meta_len);
			if (ret) {
				LOG_ERR("Unable to enable stream: %d", ret);
				return;
			}

			LOG_INF("Enable stream %p", stream);
		}
	}
}

static void stream_enabled_cb(struct bt_bap_stream *stream)
{
	int ret;
	uint8_t channel_index;
	struct worker_data work_data;
	enum bt_audio_dir dir;

	dir = le_audio_stream_dir_get(stream);
	if (dir <= 0) {
		LOG_ERR("Failed to get dir of stream %p", stream);
		return;
	}

	LOG_DBG("Stream enabled: %p", stream);

	ret = channel_index_get(stream->conn, &channel_index);
	if (ret) {
		LOG_ERR("Error getting channel index");
		return;
	}

	if (dir == BT_AUDIO_DIR_SINK &&
	    le_audio_ep_state_check(headsets[channel_index].sink_stream.ep,
				    BT_BAP_EP_STATE_ENABLING)) {
		if (!k_work_delayable_is_pending(&headsets[channel_index].stream_start_sink_work)) {
			work_data.channel_index = channel_index;
			work_data.retries = 0;
			work_data.dir = BT_AUDIO_DIR_SINK;

			LOG_DBG("k_msg_put: ch: %d, dir: %d, retries %d", work_data.channel_index,
				work_data.dir, work_data.retries);

			ret = k_msgq_put(&kwork_msgq, &work_data, K_NO_WAIT);
			if (ret) {
				LOG_ERR("No space in the queue for work_data");
				return;
			}

			k_work_schedule(&headsets[channel_index].stream_start_sink_work, K_NO_WAIT);
		}
	}

	if (dir == BT_AUDIO_DIR_SOURCE &&
	    le_audio_ep_state_check(headsets[channel_index].source_stream.ep,
				    BT_BAP_EP_STATE_ENABLING)) {
		if (!k_work_delayable_is_pending(
			    &headsets[channel_index].stream_start_source_work)) {
			work_data.channel_index = channel_index;
			work_data.retries = 0;
			work_data.dir = BT_AUDIO_DIR_SOURCE;

			LOG_DBG("k_msg_put: ch: %d, dir: %d, retries %d", work_data.channel_index,
				work_data.dir, work_data.retries);

			ret = k_msgq_put(&kwork_msgq, &work_data, K_NO_WAIT);
			if (ret) {
				LOG_ERR("No space in the queue for work_data");
				return;
			}

			k_work_schedule(&headsets[channel_index].stream_start_source_work,
					K_NO_WAIT);
		}
	}
}

static void stream_started_cb(struct bt_bap_stream *stream)
{
	int ret;
	uint8_t channel_index;
	enum bt_audio_dir dir;

	dir = le_audio_stream_dir_get(stream);
	if (dir <= 0) {
		LOG_ERR("Failed to get dir of stream %p", stream);
		return;
	}

	ret = channel_index_get(stream->conn, &channel_index);
	if (ret) {
		LOG_ERR("Channel index not found");
	} else {
		ERR_CHK(bt_le_audio_tx_stream_started(channel_index));
	}

	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Stream %p started", (void *)stream);

	le_audio_event_publish(LE_AUDIO_EVT_STREAMING, stream->conn, dir);
}

static void stream_metadata_updated_cb(struct bt_bap_stream *stream)
{
	LOG_DBG("Audio Stream %p metadata updated", (void *)stream);
}

static void stream_disabled_cb(struct bt_bap_stream *stream)
{
	LOG_DBG("Audio Stream %p disabled", (void *)stream);
}

static void stream_stopped_cb(struct bt_bap_stream *stream, uint8_t reason)
{
	int ret;
	uint8_t channel_index;

	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Stream %p stopped. Reason %d", (void *)stream, reason);

	ret = channel_index_get(stream->conn, &channel_index);
	if (ret) {
		LOG_ERR("Channel index not found");
	} else {
		ERR_CHK(bt_le_audio_tx_stream_stopped(channel_index));
	}

	/* Check if the other stream is streaming, send event if not */
	if (stream == &headsets[AUDIO_CH_L].sink_stream) {
		if (!le_audio_ep_state_check(headsets[AUDIO_CH_R].sink_stream.ep,
					     BT_BAP_EP_STATE_STREAMING)) {
			le_audio_event_publish(LE_AUDIO_EVT_NOT_STREAMING, stream->conn,
					       BT_AUDIO_DIR_SINK);
		}
	} else if (stream == &headsets[AUDIO_CH_R].sink_stream) {
		if (!le_audio_ep_state_check(headsets[AUDIO_CH_L].sink_stream.ep,
					     BT_BAP_EP_STATE_STREAMING)) {
			le_audio_event_publish(LE_AUDIO_EVT_NOT_STREAMING, stream->conn,
					       BT_AUDIO_DIR_SINK);
		}
	} else {
		LOG_WRN("Unknown stream");
	}
}

static void stream_released_cb(struct bt_bap_stream *stream)
{
	LOG_DBG("Audio Stream %p released", (void *)stream);

	/* Check if the other stream is streaming, send event if not */
	if (stream == &headsets[AUDIO_CH_L].sink_stream) {
		if (!le_audio_ep_state_check(headsets[AUDIO_CH_R].sink_stream.ep,
					     BT_BAP_EP_STATE_STREAMING)) {
			le_audio_event_publish(LE_AUDIO_EVT_NOT_STREAMING, stream->conn,
					       BT_AUDIO_DIR_SINK);
		}

		LOG_DBG("Left sink stream released");
	} else if (stream == &headsets[AUDIO_CH_R].sink_stream) {
		if (!le_audio_ep_state_check(headsets[AUDIO_CH_L].sink_stream.ep,
					     BT_BAP_EP_STATE_STREAMING)) {
			le_audio_event_publish(LE_AUDIO_EVT_NOT_STREAMING, stream->conn,
					       BT_AUDIO_DIR_SINK);
		}

		LOG_DBG("Right sink stream released");
	} else if (stream == &headsets[AUDIO_CH_L].source_stream) {
		LOG_DBG("Left source stream released");
	} else if (stream == &headsets[AUDIO_CH_R].source_stream) {
		LOG_DBG("Right source stream released");
	} else {
		LOG_WRN("Unknown stream");
	}
}

#if (CONFIG_BT_AUDIO_RX)
static void stream_recv_cb(struct bt_bap_stream *stream, const struct bt_iso_recv_info *info,
			   struct net_buf *buf)
{
	int ret;
	bool bad_frame = false;
	uint8_t channel_index;

	if (receive_cb == NULL) {
		LOG_ERR("The RX callback has not been set");
		return;
	}

	if (!(info->flags & BT_ISO_FLAGS_VALID)) {
		bad_frame = true;
	}

	ret = channel_index_get(stream->conn, &channel_index);
	if (ret) {
		LOG_ERR("Channel index not found");
		return;
	}

	receive_cb(buf->data, buf->len, bad_frame, info->ts, channel_index,
		   bt_audio_codec_cfg_get_octets_per_frame(stream->codec_cfg));
}
#endif /* (CONFIG_BT_AUDIO_RX) */

static struct bt_bap_stream_ops stream_ops = {
	.configured = stream_configured_cb,
	.qos_set = stream_qos_set_cb,
	.enabled = stream_enabled_cb,
	.started = stream_started_cb,
	.metadata_updated = stream_metadata_updated_cb,
	.disabled = stream_disabled_cb,
	.stopped = stream_stopped_cb,
	.released = stream_released_cb,
#if (CONFIG_BT_AUDIO_RX)
	.recv = stream_recv_cb,
#endif /* (CONFIG_BT_AUDIO_RX) */
#if (CONFIG_BT_AUDIO_TX)
	.sent = stream_sent_cb,
#endif /* (CONFIG_BT_AUDIO_TX) */
};

static void work_stream_start(struct k_work *work)
{
	int ret;
	struct worker_data work_data;

	ret = k_msgq_get(&kwork_msgq, &work_data, K_NO_WAIT);
	if (ret) {
		LOG_ERR("Cannot get info for start stream");
		return;
	}

	LOG_DBG("k_msg_get: ch: %d, dir: %d, retries %d", work_data.channel_index, work_data.dir,
		work_data.retries);

	if (work_data.dir == BT_AUDIO_DIR_SINK) {
		if (!le_audio_ep_state_check(headsets[work_data.channel_index].sink_stream.ep,
					     BT_BAP_EP_STATE_STREAMING)) {
			ret = bt_bap_stream_start(&headsets[work_data.channel_index].sink_stream);
		}
	} else if (work_data.dir == BT_AUDIO_DIR_SOURCE) {
		if (!le_audio_ep_state_check(headsets[work_data.channel_index].source_stream.ep,
					     BT_BAP_EP_STATE_STREAMING)) {
			ret = bt_bap_stream_start(&headsets[work_data.channel_index].source_stream);
		}
	} else {
		LOG_ERR("Trying to use unknown direction: %d", work_data.dir);
		le_audio_event_publish(LE_AUDIO_EVT_NO_VALID_CFG,
				       headsets[work_data.channel_index].headset_conn,
				       work_data.dir);

		return;
	}

	work_data.retries++;

	if ((ret == -EBUSY) && (work_data.retries < CIS_CONN_RETRY_TIMES)) {
		LOG_DBG("Got connect error from stream %d Retrying. code: %d count: %d",
			work_data.channel_index, ret, work_data.retries);
		LOG_DBG("k_msg_put: ch: %d, dir: %d, retries %d", work_data.channel_index,
			work_data.dir, work_data.retries);
		ret = k_msgq_put(&kwork_msgq, &work_data, K_NO_WAIT);
		if (ret) {
			LOG_ERR("No space in the queue for work_data");
			return;
		}
		/* Delay added to prevent controller overloading */
		if (work_data.dir == BT_AUDIO_DIR_SINK) {
			k_work_reschedule(&headsets[work_data.channel_index].stream_start_sink_work,
					  K_MSEC(CIS_CONN_RETRY_DELAY_MS));
		} else if (work_data.dir == BT_AUDIO_DIR_SOURCE) {
			k_work_reschedule(
				&headsets[work_data.channel_index].stream_start_source_work,
				K_MSEC(CIS_CONN_RETRY_DELAY_MS));
		}
	} else if (ret != 0) {
		LOG_WRN("Failed to establish CIS, ret = %d", ret);
		/** The connection could have invalid configs, or abnormal behavior cause the CIS
		 * failed to establish. Sending an event for triggering disconnection could clean up
		 * the abnormal state and restart the connection.
		 */
		le_audio_event_publish(LE_AUDIO_EVT_NO_VALID_CFG,
				       headsets[work_data.channel_index].headset_conn,
				       work_data.dir);
	} else if (k_msgq_peek(&kwork_msgq, &work_data) != -ENOMSG) {
		if (work_data.dir == BT_AUDIO_DIR_SINK &&
		    !k_work_delayable_is_pending(
			    &headsets[work_data.channel_index].stream_start_sink_work)) {
			k_work_reschedule(&headsets[work_data.channel_index].stream_start_sink_work,
					  K_MSEC(CIS_CONN_RETRY_DELAY_MS));
		} else if (work_data.dir == BT_AUDIO_DIR_SOURCE &&
			   !k_work_delayable_is_pending(
				   &headsets[work_data.channel_index].stream_start_source_work)) {
			k_work_reschedule(
				&headsets[work_data.channel_index].stream_start_source_work,
				K_MSEC(CIS_CONN_RETRY_DELAY_MS));
		}
	}
}

static void disconnected_headset_cleanup(uint8_t chan_idx)
{
	headsets[chan_idx].headset_conn = NULL;
	k_work_cancel_delayable(&headsets[chan_idx].stream_start_sink_work);
	headsets[chan_idx].sink_ep = NULL;
	memset(headsets[chan_idx].sink_codec_cap, 0, sizeof(headsets[chan_idx].sink_codec_cap));
	k_work_cancel_delayable(&headsets[chan_idx].stream_start_source_work);
	headsets[chan_idx].source_ep = NULL;
	memset(headsets[chan_idx].source_codec_cap, 0, sizeof(headsets[chan_idx].source_codec_cap));

	headsets[chan_idx].num_sink_eps = 0;
	headsets[chan_idx].num_source_eps = 0;
}

int unicast_client_config_get(struct bt_conn *conn, enum bt_audio_dir dir, uint32_t *bitrate,
			      uint32_t *sampling_rate_hz)
{
	int ret;
	uint8_t headset_idx;

	if (conn == NULL) {
		LOG_ERR("No valid connection pointer received");
		return -EINVAL;
	}

	if (bitrate == NULL && sampling_rate_hz == NULL) {
		LOG_ERR("No valid pointers received");
		return -ENXIO;
	}

	ret = channel_index_get(conn, &headset_idx);
	if (ret) {
		LOG_WRN("No configured streams found");
		return ret;
	}

	if (dir == BT_AUDIO_DIR_SINK) {
		if (headsets[headset_idx].sink_stream.codec_cfg == NULL) {
			LOG_ERR("No codec found for the stream");

			return -ENXIO;
		}

		if (sampling_rate_hz != NULL) {
			ret = le_audio_freq_hz_get(headsets[headset_idx].sink_stream.codec_cfg,
						   sampling_rate_hz);
			if (ret) {
				LOG_ERR("Invalid sampling frequency: %d", ret);
				return -ENXIO;
			}
		}

		if (bitrate != NULL) {
			ret = le_audio_bitrate_get(headsets[headset_idx].sink_stream.codec_cfg,
						   bitrate);
			if (ret) {
				LOG_ERR("Unable to calculate bitrate: %d", ret);
				return -ENXIO;
			}
		}
	} else if (dir == BT_AUDIO_DIR_SOURCE) {
		if (headsets[headset_idx].source_stream.codec_cfg == NULL) {
			LOG_ERR("No codec found for the stream");
			return -ENXIO;
		}

		if (sampling_rate_hz != NULL) {
			ret = le_audio_freq_hz_get(headsets[headset_idx].source_stream.codec_cfg,
						   sampling_rate_hz);
			if (ret) {
				LOG_ERR("Invalid sampling frequency: %d", ret);
				return -ENXIO;
			}
		}

		if (bitrate != NULL) {
			ret = le_audio_bitrate_get(headsets[headset_idx].source_stream.codec_cfg,
						   bitrate);
			if (ret) {
				LOG_ERR("Unable to calculate bitrate: %d", ret);
				return -ENXIO;
			}
		}
	}

	return 0;
}

void unicast_client_conn_disconnected(struct bt_conn *conn)
{
	int ret;
	uint8_t channel_index;

	/* Make sure discovery_list is purged for the disconnected conn */
	ret = discover_list_remove(conn);
	if (ret) {
		LOG_WRN("Failed to remove conn from discover_list: %d", ret);
	}

	ret = channel_index_get(conn, &channel_index);
	if (ret) {
		LOG_WRN("Unknown connection disconnected");
	} else {
		disconnected_headset_cleanup(channel_index);
	}
}

int unicast_client_discover(struct bt_conn *conn, enum unicast_discover_dir dir)
{
	int ret;

	ret = discover_list_add(conn, dir);
	if (ret) {
		LOG_ERR("Failed to add to discover_list: %d", ret);
		return ret;
	}

	if (dir == UNICAST_SERVER_BIDIR) {
		/* If we need to discover both source and sink, do sink first */
		ret = bt_bap_unicast_client_discover(conn, BT_AUDIO_DIR_SINK);
		return ret;
	}

	ret = bt_bap_unicast_client_discover(conn, dir);
	return ret;
}

int unicast_client_start(void)
{
	int ret_left = 0;
	int ret_right = 0;

	if (le_audio_ep_state_check(headsets[AUDIO_CH_L].sink_stream.ep,
				    BT_BAP_EP_STATE_QOS_CONFIGURED)) {
		ret_left = bt_bap_stream_enable(&headsets[AUDIO_CH_L].sink_stream,
						lc3_preset_sink.codec_cfg.meta,
						lc3_preset_sink.codec_cfg.meta_len);

		if (ret_left) {
			LOG_WRN("Failed to enable left stream: %d", ret_left);
		}
	}

	if (le_audio_ep_state_check(headsets[AUDIO_CH_R].sink_stream.ep,
				    BT_BAP_EP_STATE_QOS_CONFIGURED)) {
		ret_right = bt_bap_stream_enable(&headsets[AUDIO_CH_R].sink_stream,
						 lc3_preset_sink.codec_cfg.meta,
						 lc3_preset_sink.codec_cfg.meta_len);

		if (ret_right) {
			LOG_WRN("Failed to enable right stream: %d", ret_right);
		}
	}

	if (ret_left || ret_right) {
		return -EIO;
	}

	playing_state = true;

	return 0;
}

int unicast_client_stop(void)
{
	int ret_left = 0;
	int ret_right = 0;

	le_audio_event_publish(LE_AUDIO_EVT_NOT_STREAMING, NULL, 0);

	if (le_audio_ep_state_check(headsets[AUDIO_CH_L].sink_stream.ep,
				    BT_BAP_EP_STATE_STREAMING)) {
		ret_left = bt_bap_stream_disable(&headsets[AUDIO_CH_L].sink_stream);

		if (ret_left) {
			LOG_WRN("Failed to disable left stream: %d", ret_left);
		}
	}

	if (le_audio_ep_state_check(headsets[AUDIO_CH_R].sink_stream.ep,
				    BT_BAP_EP_STATE_STREAMING)) {
		ret_right = bt_bap_stream_disable(&headsets[AUDIO_CH_R].sink_stream);

		if (ret_right) {
			LOG_WRN("Failed to disable right stream: %d", ret_right);
		}
	}

	if (ret_left || ret_right) {
		return -EIO;
	}

	playing_state = false;

	return 0;
}

int unicast_client_send(struct le_audio_encoded_audio enc_audio)
{
	int ret;
#if CONFIG_BT_AUDIO_TX
	struct bt_bap_stream *bap_tx_streams[CONFIG_BT_BAP_UNICAST_CLIENT_ASE_SNK_COUNT];

	for (int i = 0; i < CONFIG_BT_BAP_UNICAST_CLIENT_ASE_SNK_COUNT; i++) {
		bap_tx_streams[i] = &headsets[i].sink_stream;
	}

	ret = bt_le_audio_tx_send(bap_tx_streams, enc_audio,
				  CONFIG_BT_BAP_UNICAST_CLIENT_ASE_SNK_COUNT);
	if (ret) {
		return ret;
	}
#endif /*CONFIG_BT_AUDIO_TX*/

	return 0;
}

int unicast_client_disable(void)
{
	return -ENOTSUP;
}

int unicast_client_enable(le_audio_receive_cb recv_cb)
{
	int ret;
	static bool initialized;
	int headset_iterator = 0;
	int stream_iterator = 0;
	struct bt_bap_unicast_group_stream_pair_param pair_params[ARRAY_SIZE(headsets)];
	/* 2 streams (one sink and one source stream) for each headset */
	struct bt_bap_unicast_group_stream_param group_stream_params[(ARRAY_SIZE(headsets) * 2)];
	struct bt_bap_unicast_group_param group_param;

	if (initialized) {
		LOG_WRN("Already initialized");
		return -EALREADY;
	}

	if (recv_cb == NULL) {
		LOG_ERR("Receive callback is NULL");
		return -EINVAL;
	}

	receive_cb = recv_cb;

	LOG_DBG("Start workers");

	for (int i = 0; i < ARRAY_SIZE(headsets); i++) {
		headsets[i].sink_stream.ops = &stream_ops;
		headsets[i].source_stream.ops = &stream_ops;
		k_work_init_delayable(&headsets[i].stream_start_sink_work, work_stream_start);
		k_work_init_delayable(&headsets[i].stream_start_source_work, work_stream_start);
	}

	ret = bt_bap_unicast_client_register_cb(&unicast_client_cbs);
	if (ret != 0) {
		LOG_ERR("Failed to register client callbacks: %d", ret);
		return ret;
	}

	ret = bt_le_audio_tx_init();
	if (ret) {
		return ret;
	}

	for (int i = 0; i < ARRAY_SIZE(headsets); i++) {
		switch (i) {
		case AUDIO_CH_L:
			headsets[i].ch_name = "LEFT";
			break;
		case AUDIO_CH_R:
			headsets[i].ch_name = "RIGHT";
			break;
		default:
			LOG_WRN("Trying to set name to undefined channel");
			headsets[i].ch_name = "UNDEFINED";
			break;
		}
	}

	for (int i = 0; i < ARRAY_SIZE(group_stream_params); i++) {
		/* Every other stream should be sink or source */
		if ((i % 2) == 0) {
			group_stream_params[i].qos = &lc3_preset_max.qos;
			group_stream_params[i].stream = &headsets[headset_iterator].sink_stream;
		} else {
			group_stream_params[i].qos = &lc3_preset_max.qos;
			group_stream_params[i].stream = &headsets[headset_iterator].source_stream;
			headset_iterator++;
		}
	}

	for (int i = 0; i < ARRAY_SIZE(pair_params); i++) {
		pair_params[i].tx_param = &group_stream_params[stream_iterator];
		stream_iterator++;

		if (IS_ENABLED(CONFIG_BT_AUDIO_RX)) {
			pair_params[i].rx_param = &group_stream_params[stream_iterator];
		} else {
			pair_params[i].rx_param = NULL;
		}

		stream_iterator++;
	}

	group_param.params = pair_params;
	group_param.params_count = ARRAY_SIZE(pair_params);

	if (IS_ENABLED(CONFIG_BT_AUDIO_PACKING_INTERLEAVED)) {
		group_param.packing = BT_ISO_PACKING_INTERLEAVED;
	} else {
		group_param.packing = BT_ISO_PACKING_SEQUENTIAL;
	}

	ret = bt_bap_unicast_group_create(&group_param, &unicast_group);
	if (ret) {
		LOG_ERR("Failed to create unicast group: %d", ret);
		return ret;
	}

	initialized = true;

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_stream/unicast/unicast_server.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _UNICAST_SERVER_H_
#define _UNICAST_SERVER_H_

#include "bt_le_audio_tx.h"
#include "le_audio.h"

#include <audio_defines.h>

/**
 * @brief	Get configuration for audio stream.
 *
 * @param[in]	conn			Pointer to the connection to get the configuration for.
 * @param[in]	dir			Direction to get the configuration from.
 * @param[out]	bitrate			Pointer to the bit rate used; can be NULL.
 * @param[out]	sampling_rate_hz	Pointer to the sampling rate used; can be NULL.
 * @param[out]	pres_delay_us		Pointer to the presentation delay used; can be NULL. Only
 *					valid for the sink direction.
 *
 * @retval	0		Operation successful.
 * @retval	-ENXIO		The feature is disabled.
 */
int unicast_server_config_get(struct bt_conn *conn, enum bt_audio_dir dir, uint32_t *bitrate,
			      uint32_t *sampling_rate_hz, uint32_t *pres_delay_us);

/**
 * @brief	Put the UUIDs from this module into the buffer.
 *
 * @note	This partial data is used to build a complete extended advertising packet.
 *
 * @param[out]	uuid_buf	Buffer being populated with UUIDs.
 *
 * @return	0 for success, error otherwise.
 */
int unicast_server_uuid_populate(struct net_buf_simple *uuid_buf);

/**
 * @brief	Put the advertising data from this module into the buffer.
 *
 * @note	This partial data is used to build a complete extended advertising packet.
 *
 * @param[out]	adv_buf		Buffer being populated with ext adv elements.
 * @param[in]	adv_buf_vacant	Number of vacant elements in @p adv_buf.
 *
 * @return	Negative values for errors or number of elements added to @p adv_buf.
 */
int unicast_server_adv_populate(struct bt_data *adv_buf, uint8_t adv_buf_vacant);

/**
 * @brief	Send data from the LE Audio unicast (CIS) server, if configured as a source.
 *
 * @param[in]	enc_audio	Encoded audio struct.
 *
 * @return	0 for success, error otherwise.
 */
int unicast_server_send(struct le_audio_encoded_audio enc_audio);

/**
 * @brief	Disable the Bluetooth LE Audio unicast (CIS) server.
 *
 * @return	0 for success, error otherwise.
 */
int unicast_server_disable(void);

/**
 * @brief	Enable the Bluetooth LE Audio unicast (CIS) server.
 *
 * @return	0 for success, error otherwise.
 */
int unicast_server_enable(le_audio_receive_cb rx_cb);

#endif /* _UNICAST_SERVER_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_stream/unicast/Kconfig
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

rsource "Kconfig.defaults"

menu "Unicast"

choice BT_BAP_UNICAST_BAP_CONFIGURATION
	prompt "Unicast codec configuration"
	depends on TRANSPORT_CIS
	default BT_BAP_UNICAST_CONFIGURABLE
	help
	  Select the unicast codec configuration as given in
	  Table 5.2 of the Bluetooth Audio Profile Specification.
	  USB only supports 48 kHz samplig rate.

config BT_BAP_UNICAST_CONFIGURABLE
	bool "Configurable unicast settings"
	depends on TRANSPORT_CIS
	help
	  Configurable option that doesn't follow any preset. Allows for more flexibility.

config BT_BAP_UNICAST_16_2_1
	bool "16_2_1"
	depends on TRANSPORT_CIS
	help
	  Unicast mandatory codec capability 16_2_1.
	  16kHz, 32kbps, 2 retransmits, 10ms transport latency, and 40ms presentation delay.

config BT_BAP_UNICAST_24_2_1
	bool "24_2_1"
	depends on TRANSPORT_CIS
	help
	  Unicast codec capability 24_2_1.
	  24kHz, 48kbps, 2 retransmits, 10ms transport latency, and 40ms presentation delay.

config BT_BAP_UNICAST_48_4_1
	bool "48_4_1"
	depends on TRANSPORT_CIS
	help
	  Unicast codec capability 48_4_1.
	  48kHz, 96kbps, 5 retransmits, 20ms transport latency, and 40ms presentation delay.
endchoice

choice	BT_AUDIO_PRES_DLY_SRCH
	prompt "Default search mode for the presentation delay"
	default BT_AUDIO_PRES_DELAY_SRCH_PREF_MIN
	help
	  Set the default search mode for the presentation delay.

config BT_AUDIO_PRES_DELAY_SRCH_MIN
	bool "Largest minimum delay over all audio receivers"
	help
	  Search for the largest minimum delay over all audio receivers.

config BT_AUDIO_PRES_DELAY_SRCH_MAX
	bool "Smallest maximum delay over all audio receivers"
	help
	  Search for the smallest maximum delay over all audio receivers.

config BT_AUDIO_PRES_DELAY_SRCH_PREF_MIN
	bool "Largest minimum preferred delay over all audio receivers"
	help
	  Search for the largest minimum preferred delay over all audio receivers.

config BT_AUDIO_PRES_DELAY_SRCH_PREF_MAX
	bool "Smallest maximum preferred delay over all audio receivers"
	help
	  Search for the smallest maximum preferred delay over all audio receivers.

config BT_AUDIO_PRES_DELAY_SRCH_SOURCE
	bool "Use the presentation delay of audio source or client"
	help
	  Use the presentation delay defined by the broadcast_source or unicast_client if it
	  is within the range set by AUDIO_MIN_PRES_DLY_US and AUDIO_MAX_PRES_DLY_US. This will
	  override the audio receiver presentation delay as long as it is in range of
	  the max and min supported by the audio receivers. If it is outside this range,
	  then it will revert to the closest supported value.
endchoice

config CODEC_CAP_COUNT_MAX
	int "Max storage of codec capabilities"
	default 5
	help
	  Max number of codec capabilities to store per stream.

config BT_AUDIO_PREFERRED_MIN_PRES_DLY_US
	int "The preferred minimum presentation delay"
	range AUDIO_MIN_PRES_DLY_US AUDIO_MAX_PRES_DLY_US
	default 10000
	help
	  The preferred minimum presentation delay in microseconds. This can not
	  be less than the absolute minimum presentation delay.

config BT_AUDIO_PREFERRED_MAX_PRES_DLY_US
	int "The preferred maximum presentation delay"
	range BT_AUDIO_PREFERRED_MIN_PRES_DLY_US AUDIO_MAX_PRES_DLY_US
	default 40000
	help
	  The preferred maximum presentation delay in microseconds. This can not
	  be less than the absolute maximum presentation delay.

config BT_AUDIO_BITRATE_UNICAST_SINK
	int "ISO stream bitrate"
	depends on TRANSPORT_CIS
	default 64000 if BT_BAP_UNICAST_CONFIGURABLE && STREAM_BIDIRECTIONAL
	default 96000 if BT_BAP_UNICAST_CONFIGURABLE
	default 32000 if BT_BAP_UNICAST_16_2_1
	default 48000 if BT_BAP_UNICAST_24_2_1
	help
	  Bitrate for the unicast sink ISO stream.

config BT_AUDIO_BITRATE_UNICAST_SRC
	int "ISO stream bitrate"
	depends on TRANSPORT_CIS
	default 32000 if BT_BAP_UNICAST_16_2_1
	default 48000 if BT_BAP_UNICAST_24_2_1
	default 64000
	help
	  Bitrate for the unicast source ISO stream.

#----------------------------------------------------------------------------#
menu "Log levels"

module = UNICAST_SERVER
module-str = unicast_server
source "subsys/logging/Kconfig.template.log_config"

module = UNICAST_CLIENT
module-str = unicast_client
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log levels
endmenu # Unicast


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_stream/unicast/unicast_client.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _UNICAST_CLIENT_H_
#define _UNICAST_CLIENT_H_

#include "bt_le_audio_tx.h"

#include <zephyr/bluetooth/audio/audio.h>
#include <audio_defines.h>

enum unicast_discover_dir {
	UNICAST_SERVER_SINK = BT_AUDIO_DIR_SINK,
	UNICAST_SERVER_SOURCE = BT_AUDIO_DIR_SOURCE,
	UNICAST_SERVER_BIDIR = (BT_AUDIO_DIR_SINK | BT_AUDIO_DIR_SOURCE)
};

#if CONFIG_BT_BAP_UNICAST_CONFIGURABLE
#define BT_BAP_LC3_UNICAST_PRESET_NRF5340_AUDIO_SINK                                               \
	BT_BAP_LC3_PRESET_CONFIGURABLE(BT_AUDIO_LOCATION_FRONT_LEFT, BT_AUDIO_CONTEXT_TYPE_MEDIA,  \
				       CONFIG_BT_AUDIO_BITRATE_UNICAST_SINK)

#define BT_BAP_LC3_UNICAST_PRESET_NRF5340_AUDIO_SOURCE                                             \
	BT_BAP_LC3_PRESET_CONFIGURABLE(BT_AUDIO_LOCATION_FRONT_LEFT, BT_AUDIO_CONTEXT_TYPE_MEDIA,  \
				       CONFIG_BT_AUDIO_BITRATE_UNICAST_SRC)

#elif CONFIG_BT_BAP_UNICAST_16_2_1
#define BT_BAP_LC3_UNICAST_PRESET_NRF5340_AUDIO_SINK                                               \
	BT_BAP_LC3_UNICAST_PRESET_16_2_1(BT_AUDIO_LOCATION_FRONT_LEFT, BT_AUDIO_CONTEXT_TYPE_MEDIA)

#define BT_BAP_LC3_UNICAST_PRESET_NRF5340_AUDIO_SOURCE                                             \
	BT_BAP_LC3_UNICAST_PRESET_16_2_1(BT_AUDIO_LOCATION_FRONT_LEFT, BT_AUDIO_CONTEXT_TYPE_MEDIA)

#elif CONFIG_BT_BAP_UNICAST_24_2_1
#define BT_BAP_LC3_UNICAST_PRESET_NRF5340_AUDIO_SINK                                               \
	BT_BAP_LC3_UNICAST_PRESET_24_2_1(BT_AUDIO_LOCATION_FRONT_LEFT, BT_AUDIO_CONTEXT_TYPE_MEDIA)

#define BT_BAP_LC3_UNICAST_PRESET_NRF5340_AUDIO_SOURCE                                             \
	BT_BAP_LC3_UNICAST_PRESET_24_2_1(BT_AUDIO_LOCATION_FRONT_LEFT, BT_AUDIO_CONTEXT_TYPE_MEDIA)
#elif CONFIG_BT_BAP_UNICAST_48_4_1
#define BT_BAP_LC3_UNICAST_PRESET_NRF5340_AUDIO_SINK                                               \
	BT_BAP_LC3_UNICAST_PRESET_48_4_1(BT_AUDIO_LOCATION_ANY, BT_AUDIO_CONTEXT_TYPE_MEDIA)

#define BT_BAP_LC3_UNICAST_PRESET_NRF5340_AUDIO_SOURCE                                             \
	BT_BAP_LC3_UNICAST_PRESET_48_4_1(BT_AUDIO_LOCATION_ANY, BT_AUDIO_CONTEXT_TYPE_MEDIA)
#else
#error Unsupported LC3 codec preset for unicast
#endif /* CONFIG_BT_BAP_UNICAST_CONFIGURABLE */

/**
 * @brief	Get configuration for the audio stream.
 *
 * @param[in]	conn			Pointer to the connection to get the configuration for.
 * @param[in]	dir			Direction to get the configuration from.
 * @param[out]	bitrate			Pointer to the bit rate used; can be NULL.
 * @param[out]	sampling_rate_hz	Pointer to the sampling rate used; can be NULL.
 *
 * @return	0 for success, error otherwise.
 */
int unicast_client_config_get(struct bt_conn *conn, enum bt_audio_dir dir, uint32_t *bitrate,
			      uint32_t *sampling_rate_hz);

/**
 * @brief	Start service discovery for a Bluetooth LE Audio unicast (CIS) server.
 *
 * @param[in]	conn	Pointer to the connection.
 * @param[in]	dir	Direction of the stream.
 *
 * @return 0 for success, error otherwise.
 */
int unicast_client_discover(struct bt_conn *conn, enum unicast_discover_dir dir);

/**
 * @brief	Handle a disconnected Bluetooth LE Audio unicast (CIS) server.
 *
 * @param[in]	conn	Pointer to the connection.
 */
void unicast_client_conn_disconnected(struct bt_conn *conn);

/**
 * @brief	Start the Bluetooth LE Audio unicast (CIS) client.
 *
 * @return	0 for success, error otherwise.
 */
int unicast_client_start(void);

/**
 * @brief	Stop the Bluetooth LE Audio unicast (CIS) client.
 *
 * @return	0 for success, error otherwise.
 */
int unicast_client_stop(void);

/**
 * @brief	Send encoded audio using the Bluetooth LE Audio unicast.
 *
 * @param[in]	enc_audio	Encoded audio struct.
 *
 * @return	0 for success, error otherwise.
 */
int unicast_client_send(struct le_audio_encoded_audio enc_audio);

/**
 * @brief       Disable the Bluetooth LE Audio unicast (CIS) client.
 *
 * @return      0 for success, error otherwise.
 */
int unicast_client_disable(void);

/**
 * @brief	Enable the Bluetooth LE Audio unicast (CIS) client.
 *
 * @param[in]   recv_cb	Callback for handling received data.
 *
 * @return	0 for success, error otherwise.
 */
int unicast_client_enable(le_audio_receive_cb recv_cb);

#endif /* _UNICAST_CLIENT_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_stream/unicast/unicast_server.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "unicast_server.h"

#include <zephyr/zbus/zbus.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/conn.h>
#include <zephyr/bluetooth/audio/audio.h>
#include <zephyr/bluetooth/audio/pacs.h>
#include <zephyr/bluetooth/audio/csip.h>
#include <zephyr/bluetooth/audio/cap.h>
#include <zephyr/bluetooth/audio/lc3.h>

#include "macros_common.h"
#include "nrf5340_audio_common.h"
#include "channel_assignment.h"
#include "bt_le_audio_tx.h"
#include "le_audio.h"

#include <../subsys/bluetooth/audio/bap_endpoint.h>

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(unicast_server, CONFIG_UNICAST_SERVER_LOG_LEVEL);

BUILD_ASSERT(CONFIG_BT_ASCS_ASE_SRC_COUNT <= 1,
	     "A maximum of one source stream is currently supported");

ZBUS_CHAN_DEFINE(le_audio_chan, struct le_audio_msg, NULL, NULL, ZBUS_OBSERVERS_EMPTY,
		 ZBUS_MSG_INIT(0));

#define BLE_ISO_LATENCY_MS 10
#define CSIP_SET_SIZE	   2
enum csip_set_rank {
	CSIP_HL_RANK = 1,
	CSIP_HR_RANK = 2
};

static le_audio_receive_cb receive_cb;
static struct bt_csip_set_member_svc_inst *csip;
/* Left or right channel headset */
static enum audio_channel channel;

/* Advertising data for peer connection */
static uint8_t csip_rsi_adv_data[BT_CSIP_RSI_SIZE];

static uint8_t flags_adv_data[] = {BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR};

static uint8_t gap_appear_adv_data[] = {BT_BYTES_LIST_LE16(CONFIG_BT_DEVICE_APPEARANCE)};

static const uint8_t cap_adv_data[] = {
	BT_UUID_16_ENCODE(BT_UUID_CAS_VAL),
	BT_AUDIO_UNICAST_ANNOUNCEMENT_TARGETED,
};

#if defined(CONFIG_BT_AUDIO_RX)
#define AVAILABLE_SINK_CONTEXT                                                                     \
	(BT_AUDIO_CONTEXT_TYPE_UNSPECIFIED | BT_AUDIO_CONTEXT_TYPE_MEDIA |                         \
	 BT_AUDIO_CONTEXT_TYPE_CONVERSATIONAL)
#else
#define AVAILABLE_SINK_CONTEXT BT_AUDIO_CONTEXT_TYPE_PROHIBITED
#endif /* CONFIG_BT_AUDIO_RX */

#if defined(CONFIG_BT_AUDIO_TX)
static struct bt_bap_stream *bap_tx_streams[CONFIG_BT_ASCS_ASE_SRC_COUNT];
#define AVAILABLE_SOURCE_CONTEXT                                                                   \
	(BT_AUDIO_CONTEXT_TYPE_UNSPECIFIED | BT_AUDIO_CONTEXT_TYPE_CONVERSATIONAL)
#else
#define AVAILABLE_SOURCE_CONTEXT BT_AUDIO_CONTEXT_TYPE_PROHIBITED
#endif /* CONFIG_BT_AUDIO_TX */

static uint8_t unicast_server_adv_data[] = {
	BT_UUID_16_ENCODE(BT_UUID_ASCS_VAL),
	BT_AUDIO_UNICAST_ANNOUNCEMENT_TARGETED,
	BT_BYTES_LIST_LE16(AVAILABLE_SINK_CONTEXT),
	BT_BYTES_LIST_LE16(AVAILABLE_SOURCE_CONTEXT),
	0x00, /* Metadata length */
};

static void le_audio_event_publish(enum le_audio_evt_type event, struct bt_conn *conn,
				   enum bt_audio_dir dir)
{
	int ret;
	struct le_audio_msg msg;

	msg.event = event;
	msg.conn = conn;
	msg.dir = dir;

	ret = zbus_chan_pub(&le_audio_chan, &msg, LE_AUDIO_ZBUS_EVENT_WAIT_TIME);
	ERR_CHK(ret);
}

/* Callback for locking state change from server side */
static void csip_lock_changed_cb(struct bt_conn *conn, struct bt_csip_set_member_svc_inst *csip,
				 bool locked)
{
	LOG_DBG("Client %p %s the lock", (void *)conn, locked ? "locked" : "released");
}

/* Callback for SIRK read request from peer side */
static uint8_t sirk_read_req_cb(struct bt_conn *conn, struct bt_csip_set_member_svc_inst *csip)
{
	/* Accept the request to read the SIRK, but return encrypted SIRK instead of plaintext */
	return BT_CSIP_READ_SIRK_REQ_RSP_ACCEPT_ENC;
}

static struct bt_csip_set_member_cb csip_callbacks = {
	.lock_changed = csip_lock_changed_cb,
	.sirk_read_req = sirk_read_req_cb,
};
struct bt_csip_set_member_register_param csip_param = {
	.set_size = CSIP_SET_SIZE,
	.lockable = true,
#if !CONFIG_BT_CSIP_SET_MEMBER_TEST_SAMPLE_DATA
	/* CSIP SIRK for demo is used, must be changed before production */
	.set_sirk = {'N', 'R', 'F', '5', '3', '4', '0', '_', 'T', 'W', 'S', '_', 'D', 'E', 'M',
		     'O'},
#else
#warning "CSIP test sample data is used, must be changed before production"
#endif
	.cb = &csip_callbacks,
};

static struct bt_audio_codec_cap lc3_codec_sink = BT_AUDIO_CODEC_CAP_LC3(
	BT_AUDIO_CODEC_CAPABILIY_FREQ,
	(BT_AUDIO_CODEC_LC3_DURATION_10 | BT_AUDIO_CODEC_LC3_DURATION_PREFER_10),
	BT_AUDIO_CODEC_LC3_CHAN_COUNT_SUPPORT(1), LE_AUDIO_SDU_SIZE_OCTETS(CONFIG_LC3_BITRATE_MIN),
	LE_AUDIO_SDU_SIZE_OCTETS(CONFIG_LC3_BITRATE_MAX), 1u, AVAILABLE_SINK_CONTEXT);

static struct bt_audio_codec_cap lc3_codec_source = BT_AUDIO_CODEC_CAP_LC3(
	BT_AUDIO_CODEC_CAPABILIY_FREQ,
	(BT_AUDIO_CODEC_LC3_DURATION_10 | BT_AUDIO_CODEC_LC3_DURATION_PREFER_10),
	BT_AUDIO_CODEC_LC3_CHAN_COUNT_SUPPORT(1), LE_AUDIO_SDU_SIZE_OCTETS(CONFIG_LC3_BITRATE_MIN),
	LE_AUDIO_SDU_SIZE_OCTETS(CONFIG_LC3_BITRATE_MAX), 1u, AVAILABLE_SOURCE_CONTEXT);

static enum bt_audio_dir caps_dirs[] = {
	BT_AUDIO_DIR_SINK,
#if (CONFIG_BT_AUDIO_TX)
	BT_AUDIO_DIR_SOURCE,
#endif /* (CONFIG_BT_AUDIO_TX) */
};

static const struct bt_audio_codec_qos_pref qos_pref = BT_AUDIO_CODEC_QOS_PREF(
	true, BT_GAP_LE_PHY_2M, CONFIG_BT_AUDIO_RETRANSMITS, BLE_ISO_LATENCY_MS,
	CONFIG_AUDIO_MIN_PRES_DLY_US, CONFIG_AUDIO_MAX_PRES_DLY_US,
	CONFIG_BT_AUDIO_PREFERRED_MIN_PRES_DLY_US, CONFIG_BT_AUDIO_PREFERRED_MAX_PRES_DLY_US);

/* clang-format off */
static struct bt_pacs_cap caps[] = {
#if (CONFIG_BT_AUDIO_RX)
				{
					 .codec_cap = &lc3_codec_sink,
				},
#endif
#if (CONFIG_BT_AUDIO_TX)
				{
					 .codec_cap = &lc3_codec_source,
				}
#endif /* (CONFIG_BT_AUDIO_TX) */
};
/* clang-format on */

static struct bt_bap_stream
	audio_streams[CONFIG_BT_ASCS_ASE_SNK_COUNT + CONFIG_BT_ASCS_ASE_SRC_COUNT];

#if (CONFIG_BT_AUDIO_TX)
BUILD_ASSERT(CONFIG_BT_ASCS_ASE_SRC_COUNT <= 1,
	     "CIS headset only supports one source stream for now");
#endif /* (CONFIG_BT_AUDIO_TX) */

static void print_codec(const struct bt_audio_codec_cfg *codec, enum bt_audio_dir dir)
{
	if (codec->id == BT_HCI_CODING_FORMAT_LC3) {
		/* LC3 uses the generic LTV format - other codecs might do as well */
		int ret;
		enum bt_audio_location chan_allocation;
		int freq_hz;
		int dur_us;
		uint32_t octets_per_sdu;
		int frame_blks_per_sdu;
		uint32_t bitrate;

		ret = le_audio_freq_hz_get(codec, &freq_hz);
		if (ret) {
			LOG_ERR("Error retrieving sampling frequency: %d", ret);
			return;
		}

		ret = le_audio_duration_us_get(codec, &dur_us);
		if (ret) {
			LOG_ERR("Error retrieving frame duration: %d", ret);
			return;
		}

		ret = le_audio_octets_per_frame_get(codec, &octets_per_sdu);
		if (ret) {
			LOG_ERR("Error retrieving octets per frame: %d", ret);
			return;
		}

		ret = le_audio_frame_blocks_per_sdu_get(codec, &frame_blks_per_sdu);
		if (ret) {
			LOG_ERR("Error retrieving frame blocks per SDU: %d", ret);
			return;
		}

		ret = bt_audio_codec_cfg_get_chan_allocation(codec, &chan_allocation);
		if (ret) {
			LOG_ERR("Error retrieving channel allocation: %d", ret);
			return;
		}

		ret = le_audio_bitrate_get(codec, &bitrate);
		if (ret) {
			LOG_ERR("Unable to calculate bitrate: %d", ret);
			return;
		}

		if (dir == BT_AUDIO_DIR_SINK) {
			LOG_INF("LC3 codec config for sink:");
		} else if (dir == BT_AUDIO_DIR_SOURCE) {
			LOG_INF("LC3 codec config for source:");
		} else {
			LOG_INF("LC3 codec config for <unknown dir>:");
		}

		LOG_INF("\tFrequency: %d Hz", freq_hz);
		LOG_INF("\tDuration: %d us", dur_us);
		LOG_INF("\tChannel allocation: 0x%x", chan_allocation);
		LOG_INF("\tOctets per frame: %d (%d bps)", octets_per_sdu, bitrate);
		LOG_INF("\tFrames per SDU: %d", frame_blks_per_sdu);
	} else {
		LOG_WRN("Codec is not LC3, codec_id: 0x%2x", codec->id);
	}
}

static int lc3_config_cb(struct bt_conn *conn, const struct bt_bap_ep *ep, enum bt_audio_dir dir,
			 const struct bt_audio_codec_cfg *codec, struct bt_bap_stream **stream,
			 struct bt_audio_codec_qos_pref *const pref, struct bt_bap_ascs_rsp *rsp)
{
	LOG_DBG("LC3 config callback");

	for (int i = 0; i < ARRAY_SIZE(audio_streams); i++) {
		struct bt_bap_stream *audio_stream = &audio_streams[i];

		if (!audio_stream->conn) {
			LOG_DBG("ASE Codec Config stream %p", (void *)audio_stream);

			int ret;
			uint32_t octets_per_sdu;

			ret = le_audio_octets_per_frame_get(codec, &octets_per_sdu);
			if (ret) {
				LOG_ERR("Error retrieving octets frame:, %d", ret);
				return ret;
			}

			if (octets_per_sdu > LE_AUDIO_SDU_SIZE_OCTETS(CONFIG_LC3_BITRATE_MAX)) {
				LOG_ERR("Too high bitrate");
				return -EINVAL;
			} else if (octets_per_sdu <
				   LE_AUDIO_SDU_SIZE_OCTETS(CONFIG_LC3_BITRATE_MIN)) {
				LOG_ERR("Too low bitrate");
				return -EINVAL;
			}

			if (dir == BT_AUDIO_DIR_SINK) {
				LOG_DBG("BT_AUDIO_DIR_SINK");
				print_codec(codec, dir);
				le_audio_event_publish(LE_AUDIO_EVT_CONFIG_RECEIVED, conn, dir);
			}
#if (CONFIG_BT_AUDIO_TX)
			else if (dir == BT_AUDIO_DIR_SOURCE) {
				LOG_DBG("BT_AUDIO_DIR_SOURCE");
				print_codec(codec, dir);
				le_audio_event_publish(LE_AUDIO_EVT_CONFIG_RECEIVED, conn, dir);

				/* CIS headset only supports one source stream for now */
				bap_tx_streams[0] = audio_stream;
			}
#endif /* (CONFIG_BT_AUDIO_TX) */
			else {
				LOG_ERR("UNKNOWN DIR");
				return -EINVAL;
			}

			*stream = audio_stream;
			*pref = qos_pref;

			return 0;
		}
	}

	LOG_WRN("No audio_stream available");
	return -ENOMEM;
}

static int lc3_reconfig_cb(struct bt_bap_stream *stream, enum bt_audio_dir dir,
			   const struct bt_audio_codec_cfg *codec,
			   struct bt_audio_codec_qos_pref *const pref, struct bt_bap_ascs_rsp *rsp)
{
	LOG_DBG("ASE Codec Reconfig: stream %p", (void *)stream);

	return 0;
}

static int lc3_qos_cb(struct bt_bap_stream *stream, const struct bt_audio_codec_qos *qos,
		      struct bt_bap_ascs_rsp *rsp)
{
	enum bt_audio_dir dir;

	dir = le_audio_stream_dir_get(stream);
	if (dir <= 0) {
		LOG_ERR("Failed to get dir of stream %p", stream);
		return -EIO;
	}

	le_audio_event_publish(LE_AUDIO_EVT_PRES_DELAY_SET, stream->conn, dir);

	LOG_DBG("QoS: stream %p qos %p", (void *)stream, (void *)qos);

	return 0;
}

static int lc3_enable_cb(struct bt_bap_stream *stream, const uint8_t *meta, size_t meta_len,
			 struct bt_bap_ascs_rsp *rsp)
{
	LOG_DBG("Enable: stream %p meta_len %d", (void *)stream, meta_len);

	return 0;
}

static int lc3_start_cb(struct bt_bap_stream *stream, struct bt_bap_ascs_rsp *rsp)
{
	LOG_DBG("Start stream %p", (void *)stream);
	return 0;
}

static int lc3_metadata_cb(struct bt_bap_stream *stream, const uint8_t *meta, size_t meta_len,
			   struct bt_bap_ascs_rsp *rsp)
{
	LOG_DBG("Metadata: stream %p meta_len %d", (void *)stream, meta_len);
	return 0;
}

static int lc3_disable_cb(struct bt_bap_stream *stream, struct bt_bap_ascs_rsp *rsp)
{
	enum bt_audio_dir dir;

	dir = le_audio_stream_dir_get(stream);
	if (dir <= 0) {
		LOG_ERR("Failed to get dir of stream %p", stream);
		return -EIO;
	}

	LOG_DBG("Disable: stream %p", (void *)stream);

	le_audio_event_publish(LE_AUDIO_EVT_NOT_STREAMING, stream->conn, dir);

	return 0;
}

static int lc3_stop_cb(struct bt_bap_stream *stream, struct bt_bap_ascs_rsp *rsp)
{
	enum bt_audio_dir dir;

	dir = le_audio_stream_dir_get(stream);
	if (dir <= 0) {
		LOG_ERR("Failed to get dir of stream %p", stream);
		return -EIO;
	}

	LOG_DBG("Stop: stream %p", (void *)stream);

	le_audio_event_publish(LE_AUDIO_EVT_NOT_STREAMING, stream->conn, dir);

	return 0;
}

static int lc3_release_cb(struct bt_bap_stream *stream, struct bt_bap_ascs_rsp *rsp)
{
	enum bt_audio_dir dir;

	dir = le_audio_stream_dir_get(stream);
	if (dir <= 0) {
		LOG_ERR("Failed to get dir of stream %p", stream);
		return -EIO;
	}

	LOG_DBG("Release: stream %p", (void *)stream);

	le_audio_event_publish(LE_AUDIO_EVT_NOT_STREAMING, stream->conn, dir);

	return 0;
}

static const struct bt_bap_unicast_server_cb unicast_server_cb = {
	.config = lc3_config_cb,
	.reconfig = lc3_reconfig_cb,
	.qos = lc3_qos_cb,
	.enable = lc3_enable_cb,
	.start = lc3_start_cb,
	.metadata = lc3_metadata_cb,
	.disable = lc3_disable_cb,
	.stop = lc3_stop_cb,
	.release = lc3_release_cb,
};

#if (CONFIG_BT_AUDIO_RX)
static void stream_recv_cb(struct bt_bap_stream *stream, const struct bt_iso_recv_info *info,
			   struct net_buf *buf)
{
	bool bad_frame = false;

	if (receive_cb == NULL) {
		LOG_ERR("The RX callback has not been set");
		return;
	}

	if (!(info->flags & BT_ISO_FLAGS_VALID)) {
		bad_frame = true;
	}

	receive_cb(buf->data, buf->len, bad_frame, info->ts, channel,
		   bt_audio_codec_cfg_get_octets_per_frame(stream->codec_cfg));
}
#endif /* (CONFIG_BT_AUDIO_RX) */

#if (CONFIG_BT_AUDIO_TX)
static void stream_sent_cb(struct bt_bap_stream *stream)
{
	/* Unicast server/CIS headset only supports one source stream for now */
	ERR_CHK(bt_le_audio_tx_stream_sent(0));
}
#endif /* (CONFIG_BT_AUDIO_TX) */

static void stream_enabled_cb(struct bt_bap_stream *stream)
{
	int ret;
	enum bt_audio_dir dir;

	dir = le_audio_stream_dir_get(stream);
	if (dir <= 0) {
		LOG_ERR("Failed to get dir of stream %p", stream);
		return;
	}

	LOG_DBG("Stream %p enabled", stream);

	if (dir == BT_AUDIO_DIR_SINK) {
		/* Automatically do the receiver start ready operation */
		ret = bt_bap_stream_start(stream);
		if (ret != 0) {
			LOG_ERR("Failed to start stream: %d", ret);
			return;
		}
	}
}

static void stream_disabled_cb(struct bt_bap_stream *stream)
{
	LOG_INF("Stream %p disabled", stream);
}

static void stream_started_cb(struct bt_bap_stream *stream)
{
	enum bt_audio_dir dir;

	dir = le_audio_stream_dir_get(stream);
	if (dir <= 0) {
		LOG_ERR("Failed to get dir of stream %p", stream);
		return;
	}

	LOG_INF("Stream %p started", stream);

	if (dir == BT_AUDIO_DIR_SOURCE) {
		ERR_CHK(bt_le_audio_tx_stream_started(0));
	}

	le_audio_event_publish(LE_AUDIO_EVT_STREAMING, stream->conn, dir);
}

static void stream_stopped_cb(struct bt_bap_stream *stream, uint8_t reason)
{
	enum bt_audio_dir dir;

	dir = le_audio_stream_dir_get(stream);
	if (dir <= 0) {
		LOG_ERR("Failed to get dir of stream %p", stream);
		return;
	}

	LOG_DBG("Stream %p stopped. Reason: %d", stream, reason);

	if (dir == BT_AUDIO_DIR_SOURCE) {
		ERR_CHK(bt_le_audio_tx_stream_stopped(0));
	}

	le_audio_event_publish(LE_AUDIO_EVT_NOT_STREAMING, stream->conn, dir);
}

static void stream_released_cb(struct bt_bap_stream *stream)
{
	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Stream %p released", stream);
}

static struct bt_bap_stream_ops stream_ops = {
#if (CONFIG_BT_AUDIO_RX)
	.recv = stream_recv_cb,
#endif /* (CONFIG_BT_AUDIO_RX) */
#if (CONFIG_BT_AUDIO_TX)
	.sent = stream_sent_cb,
#endif /* (CONFIG_BT_AUDIO_TX) */
	.enabled = stream_enabled_cb,
	.disabled = stream_disabled_cb,
	.started = stream_started_cb,
	.stopped = stream_stopped_cb,
	.released = stream_released_cb,
};

static int adv_buf_put(struct bt_data *adv_buf, uint8_t adv_buf_vacant, int *index, uint8_t type,
		       size_t data_len, const uint8_t *data)
{
	if ((adv_buf_vacant - *index) <= 0) {
		return -ENOMEM;
	}

	adv_buf[*index].type = type;
	adv_buf[*index].data_len = data_len;
	adv_buf[*index].data = data;
	(*index)++;

	return 0;
}

int unicast_server_config_get(struct bt_conn *conn, enum bt_audio_dir dir, uint32_t *bitrate,
			      uint32_t *sampling_rate_hz, uint32_t *pres_delay_us)
{
	int ret;

	if (bitrate == NULL && sampling_rate_hz == NULL && pres_delay_us == NULL) {
		LOG_ERR("No valid pointers received");
		return -ENXIO;
	}

	if (dir == BT_AUDIO_DIR_SINK) {
		/* If multiple sink streams exists, they should have the same configurations,
		 * hence we only check the first one.
		 */
		if (audio_streams[0].codec_cfg == NULL) {
			LOG_ERR("No codec found for the stream");

			return -ENXIO;
		}

		if (sampling_rate_hz != NULL) {
			ret = le_audio_freq_hz_get(audio_streams[0].codec_cfg, sampling_rate_hz);
			if (ret) {
				LOG_ERR("Invalid sampling frequency: %d", ret);
				return -ENXIO;
			}
		}

		if (bitrate != NULL) {
			ret = le_audio_bitrate_get(audio_streams[0].codec_cfg, bitrate);
			if (ret) {
				LOG_ERR("Unable to calculate bitrate: %d", ret);
				return -ENXIO;
			}
		}

		if (pres_delay_us != NULL) {
			if (audio_streams[0].qos == NULL) {
				LOG_ERR("No QoS found for the stream");
				return -ENXIO;
			}

			*pres_delay_us = audio_streams[0].qos->pd;
		}
	} else if (dir == BT_AUDIO_DIR_SOURCE) {
		/* If multiple source streams exists, they should have the same configurations,
		 * hence we only check the first one.
		 */
		if (bap_tx_streams[0]->codec_cfg == NULL) {
			LOG_ERR("No codec found for the stream");
			return -ENXIO;
		}

		if (sampling_rate_hz != NULL) {
			ret = le_audio_freq_hz_get(bap_tx_streams[0]->codec_cfg, sampling_rate_hz);
			if (ret) {
				LOG_ERR("Invalid sampling frequency: %d", ret);
				return -ENXIO;
			}
		}

		if (bitrate != NULL) {
			ret = le_audio_bitrate_get(bap_tx_streams[0]->codec_cfg, bitrate);
			if (ret) {
				LOG_ERR("Unable to calculate bitrate: %d", ret);
				return -ENXIO;
			}
		}

		if (pres_delay_us != NULL) {
			if (bap_tx_streams[0]->qos == NULL) {
				LOG_ERR("No QoS found for the stream");
				return -ENXIO;
			}

			*pres_delay_us = bap_tx_streams[0]->qos->pd;
			LOG_ERR("pres_delay_us: %d", *pres_delay_us);
		}
	}

	return 0;
}

int unicast_server_uuid_populate(struct net_buf_simple *uuid_buf)
{
	if (net_buf_simple_tailroom(uuid_buf) >= (BT_UUID_SIZE_16 * 2)) {
		net_buf_simple_add_le16(uuid_buf, BT_UUID_ASCS_VAL);
		net_buf_simple_add_le16(uuid_buf, BT_UUID_PACS_VAL);

	} else {
		LOG_ERR("Not enough space for UUIDS");
		return -ENOMEM;
	}

	return 0;
}

int unicast_server_adv_populate(struct bt_data *adv_buf, uint8_t adv_buf_vacant)
{
	int ret;
	int adv_buf_cnt = 0;

	ret = adv_buf_put(adv_buf, adv_buf_vacant, &adv_buf_cnt, BT_DATA_SVC_DATA16,
			  ARRAY_SIZE(unicast_server_adv_data), &unicast_server_adv_data[0]);
	if (ret) {
		return ret;
	}

	if (IS_ENABLED(CONFIG_BT_CSIP_SET_MEMBER)) {
		ret = adv_buf_put(adv_buf, adv_buf_vacant, &adv_buf_cnt, BT_DATA_CSIS_RSI,
				  ARRAY_SIZE(csip_rsi_adv_data), &csip_rsi_adv_data[0]);
		if (ret) {
			return ret;
		}
	}

	ret = adv_buf_put(adv_buf, adv_buf_vacant, &adv_buf_cnt, BT_DATA_GAP_APPEARANCE,
			  ARRAY_SIZE(gap_appear_adv_data), &gap_appear_adv_data[0]);
	if (ret) {
		return ret;
	}

	ret = adv_buf_put(adv_buf, adv_buf_vacant, &adv_buf_cnt, BT_DATA_FLAGS,
			  ARRAY_SIZE(flags_adv_data), &flags_adv_data[0]);
	if (ret) {
		return ret;
	}

	ret = adv_buf_put(adv_buf, adv_buf_vacant, &adv_buf_cnt, BT_DATA_SVC_DATA16,
			  ARRAY_SIZE(cap_adv_data), &cap_adv_data[0]);
	if (ret) {
		return ret;
	}

	return adv_buf_cnt;
}

int unicast_server_send(struct le_audio_encoded_audio enc_audio)
{
#if (CONFIG_BT_AUDIO_TX)
	int ret;

	ret = bt_le_audio_tx_send(bap_tx_streams, enc_audio, CONFIG_BT_ASCS_ASE_SRC_COUNT);
	if (ret) {
		return ret;
	}

	return 0;
#else
	return -ENOTSUP;
#endif /* (CONFIG_BT_AUDIO_TX) */
}

int unicast_server_disable(void)
{
	return -ENOTSUP;
}

int unicast_server_enable(le_audio_receive_cb recv_cb)
{
	int ret;
	static bool initialized;

	if (initialized) {
		LOG_WRN("Already initialized");
		return -EALREADY;
	}

	if (recv_cb == NULL) {
		LOG_ERR("Receive callback is NULL");
		return -EINVAL;
	}

	receive_cb = recv_cb;

	bt_bap_unicast_server_register_cb(&unicast_server_cb);

	channel_assignment_get(&channel);

	for (int i = 0; i < ARRAY_SIZE(caps); i++) {
		ret = bt_pacs_cap_register(caps_dirs[i], &caps[i]);
		if (ret) {
			LOG_ERR("Capability register failed");
			return ret;
		}
	}

	if (channel == AUDIO_CH_L) {
		csip_param.rank = CSIP_HL_RANK;

		ret = bt_pacs_set_location(BT_AUDIO_DIR_SINK, BT_AUDIO_LOCATION_FRONT_LEFT);
		if (ret) {
			LOG_ERR("Location set failed");
			return ret;
		}

	} else if (channel == AUDIO_CH_R) {
		csip_param.rank = CSIP_HR_RANK;

		ret = bt_pacs_set_location(BT_AUDIO_DIR_SINK, BT_AUDIO_LOCATION_FRONT_RIGHT);
		if (ret) {
			LOG_ERR("Location set failed");
			return ret;
		}

	} else {
		LOG_ERR("Channel not supported");
		return -ECANCELED;
	}

	if (IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL)) {
		ret = bt_le_audio_tx_init();
		if (ret) {
			return ret;
		}
		ret = bt_pacs_set_supported_contexts(BT_AUDIO_DIR_SINK,
						     BT_AUDIO_CONTEXT_TYPE_MEDIA |
							     BT_AUDIO_CONTEXT_TYPE_CONVERSATIONAL |
							     BT_AUDIO_CONTEXT_TYPE_UNSPECIFIED);

		if (ret) {
			LOG_ERR("Supported context set failed. Err: %d", ret);
			return ret;
		}

		ret = bt_pacs_set_available_contexts(BT_AUDIO_DIR_SINK,
						     BT_AUDIO_CONTEXT_TYPE_MEDIA |
							     BT_AUDIO_CONTEXT_TYPE_CONVERSATIONAL |
							     BT_AUDIO_CONTEXT_TYPE_UNSPECIFIED);
		if (ret) {
			LOG_ERR("Available context set failed. Err: %d", ret);
			return ret;
		}

		ret = bt_pacs_set_supported_contexts(BT_AUDIO_DIR_SOURCE,
						     BT_AUDIO_CONTEXT_TYPE_MEDIA |
							     BT_AUDIO_CONTEXT_TYPE_CONVERSATIONAL |
							     BT_AUDIO_CONTEXT_TYPE_UNSPECIFIED);

		if (ret) {
			LOG_ERR("Supported context set failed. Err: %d", ret);
			return ret;
		}

		ret = bt_pacs_set_available_contexts(BT_AUDIO_DIR_SOURCE,
						     BT_AUDIO_CONTEXT_TYPE_MEDIA |
							     BT_AUDIO_CONTEXT_TYPE_CONVERSATIONAL |
							     BT_AUDIO_CONTEXT_TYPE_UNSPECIFIED);
		if (ret) {
			LOG_ERR("Available context set failed. Err: %d", ret);
			return ret;
		}

		if (channel == AUDIO_CH_L) {
			ret = bt_pacs_set_location(BT_AUDIO_DIR_SOURCE,
						   BT_AUDIO_LOCATION_FRONT_LEFT);
			if (ret) {
				LOG_ERR("Location set failed");
				return ret;
			}
		} else if (channel == AUDIO_CH_R) {
			ret = bt_pacs_set_location(BT_AUDIO_DIR_SOURCE,
						   BT_AUDIO_LOCATION_FRONT_RIGHT);
			if (ret) {
				LOG_ERR("Location set failed");
				return ret;
			}
		} else {
			LOG_ERR("Channel not supported");
			return -ECANCELED;
		}
	} else {
		ret = bt_pacs_set_supported_contexts(BT_AUDIO_DIR_SINK,
						     BT_AUDIO_CONTEXT_TYPE_MEDIA |
							     BT_AUDIO_CONTEXT_TYPE_UNSPECIFIED);

		if (ret) {
			LOG_ERR("Supported context set failed. Err: %d ", ret);
			return ret;
		}

		ret = bt_pacs_set_available_contexts(BT_AUDIO_DIR_SINK,
						     BT_AUDIO_CONTEXT_TYPE_MEDIA |
							     BT_AUDIO_CONTEXT_TYPE_UNSPECIFIED);

		if (ret) {
			LOG_ERR("Available context set failed. Err: %d", ret);
			return ret;
		}
	}

	for (int i = 0; i < ARRAY_SIZE(audio_streams); i++) {
		bt_bap_stream_cb_register(&audio_streams[i], &stream_ops);
	}

	if (IS_ENABLED(CONFIG_BT_CSIP_SET_MEMBER)) {
		ret = bt_cap_acceptor_register(&csip_param, &csip);
		if (ret) {
			LOG_ERR("Failed to register CAP acceptor");
			return ret;
		}

		ret = bt_csip_set_member_generate_rsi(csip, csip_rsi_adv_data);
		if (ret) {
			LOG_ERR("Failed to generate RSI (ret %d)", ret);
			return ret;
		}
	}

	initialized = true;

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_stream/bt_le_audio_tx/CMakeLists.txt
#
# Copyright (c) 2024 Nordic Semiconductor
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

if (CONFIG_BT_AUDIO_TX)
	target_sources(app PRIVATE
		${CMAKE_CURRENT_SOURCE_DIR}/bt_le_audio_tx.c)
endif()


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_stream/bt_le_audio_tx/bt_le_audio_tx.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _LE_AUDIO_TX_H_
#define _LE_AUDIO_TX_H_

#include <zephyr/bluetooth/audio/audio.h>
#include <zephyr/bluetooth/audio/bap.h>

#include "le_audio.h"

/**
 * @brief Allocates buffers and sends data to the controller.
 *
 * @note	Send all available channels in a single call.
 *		Do not call this for each channel.
 *
 * @param bap_streams	Pointer to an array of BAP streams.
 * @param enc_audio	Encoded audio data.
 * @param streams_to_tx	Number of streams to send.
 *
 * @return 0 if successful, error otherwise.
 */
int bt_le_audio_tx_send(struct bt_bap_stream **bap_streams, struct le_audio_encoded_audio enc_audio,
			uint8_t streams_to_tx);

/**
 * @brief Resets TX buffers. Must be called when a TX stream is stopped.
 *
 * @param stream_idx	Stream index
 *
 * @retval  -EACCES  The module has not been initialized.
 * @retval  0 Success.
 */
int bt_le_audio_tx_stream_stopped(uint8_t stream_idx);

/**
 * @brief Initializes a stream. Must be called when a TX stream is started.
 *
 * @param stream_idx	Stream index.
 *
 * @retval  -EACCES  The module has not been initialized.
 * @retval  0 Success.
 */
int bt_le_audio_tx_stream_started(uint8_t stream_idx);

/**
 * @brief Frees a TX buffer. Must be called when a TX stream has been sent.
 *
 * @param stream_idx	Stream index.
 *
 * @retval  -EACCES  The module has not been initialized.
 * @retval  0 Success.
 */
int bt_le_audio_tx_stream_sent(uint8_t stream_idx);

/**
 * @brief Initializes the TX path for ISO transmission.
 *
 * @retval  -EALREADY  The module has already been initialized.
 * @retval  0 Success.
 */
int bt_le_audio_tx_init(void);

#endif /* _LE_AUDIO_TX_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_stream/bt_le_audio_tx/bt_le_audio_tx.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "bt_le_audio_tx.h"

#include <zephyr/bluetooth/audio/bap.h>
#include <zephyr/zbus/zbus.h>
#include <../subsys/bluetooth/audio/bap_stream.h>

#include "nrf5340_audio_common.h"
#include "audio_sync_timer.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(bt_le_audio_tx, CONFIG_BLE_LOG_LEVEL);

ZBUS_CHAN_DEFINE(sdu_ref_chan, struct sdu_ref_msg, NULL, NULL, ZBUS_OBSERVERS_EMPTY,
		 ZBUS_MSG_INIT(0));

#ifdef CONFIG_BT_BAP_UNICAST_SERVER
#define SRC_STREAM_COUNT CONFIG_BT_ASCS_ASE_SRC_COUNT
#elif CONFIG_BT_BAP_UNICAST_CLIENT
#define SRC_STREAM_COUNT CONFIG_BT_BAP_UNICAST_CLIENT_ASE_SNK_COUNT
#elif CONFIG_BT_BAP_BROADCAST_SOURCE
#define SRC_STREAM_COUNT CONFIG_BT_BAP_BROADCAST_SRC_STREAM_COUNT
#else
#define SRC_STREAM_COUNT 0
#endif

#define HCI_ISO_BUF_ALLOC_PER_CHAN 2

/* For being able to dynamically define iso_tx_pools */
#define NET_BUF_POOL_ITERATE(i, _)                                                                 \
	NET_BUF_POOL_FIXED_DEFINE(iso_tx_pool_##i, HCI_ISO_BUF_ALLOC_PER_CHAN,                     \
				  BT_ISO_SDU_BUF_SIZE(CONFIG_BT_ISO_TX_MTU), 8, NULL);
#define NET_BUF_POOL_PTR_ITERATE(i, ...) IDENTITY(&iso_tx_pool_##i)
LISTIFY(SRC_STREAM_COUNT, NET_BUF_POOL_ITERATE, (;))
/* clang-format off */
static struct net_buf_pool *iso_tx_pools[] = { LISTIFY(SRC_STREAM_COUNT,
						       NET_BUF_POOL_PTR_ITERATE, (,)) };
/* clang-format on */

struct tx_inf {
	struct bt_iso_tx_info iso_tx;
	struct bt_iso_tx_info iso_tx_readback;
	struct net_buf_pool *iso_tx_pool;
	atomic_t iso_tx_pool_alloc;
	bool hci_wrn_printed;
};

static bool initialized;
static struct tx_inf tx_info_arr[SRC_STREAM_COUNT];

/**
 * @brief Sends audio data over a single BAP stream.
 *
 * @param data			Audio data to send.
 * @param size			Size of data.
 * @param bap_stream		Pointer to BAP stream to use.
 * @param tx_info		Pointer to tx_info struct.
 * @param ts_tx		Timestamp to send. Note that for some controllers, BT_ISO_TIMESTAMP_NONE
 *			is used. This timestamp is used to ensure that SDUs are sent in the same
 *			connection interval.
 * @return		0 if successful, error otherwise.
 */
static int iso_stream_send(uint8_t const *const data, size_t size, struct bt_bap_stream *bap_stream,
			   struct tx_inf *tx_info, uint32_t ts_tx)
{
	int ret;
	struct net_buf *buf;

	/* net_buf_alloc allocates buffers for APP->NET transfer over HCI RPMsg,
	 * but when these buffers are released it is not guaranteed that the
	 * data has actually been sent. The data might be queued on the NET core,
	 * and this can cause delays in the audio.
	 * When the sent callback is called the data has been sent, and we can free the buffer.
	 * Data will be discarded if allocation becomes too high, to avoid audio delays.
	 * If the NET and APP core operates in clock sync, discarding should not occur.
	 */
	if (atomic_get(&tx_info->iso_tx_pool_alloc) >= HCI_ISO_BUF_ALLOC_PER_CHAN) {
		if (!tx_info->hci_wrn_printed) {
			struct bt_iso_chan *iso_chan;

			iso_chan = bt_bap_stream_iso_chan_get(bap_stream);

			LOG_WRN("HCI ISO TX overrun on stream %p - Single print",
				(void *)bap_stream);
			tx_info->hci_wrn_printed = true;
		}
		return -ENOMEM;
	}

	tx_info->hci_wrn_printed = false;

	buf = net_buf_alloc(tx_info->iso_tx_pool, K_NO_WAIT);
	if (buf == NULL) {
		/* This should never occur because of the iso_tx_pool_alloc check above */
		LOG_WRN("Out of TX buffers");
		return -ENOMEM;
	}

	net_buf_reserve(buf, BT_ISO_CHAN_SEND_RESERVE);
	net_buf_add_mem(buf, data, size);

	atomic_inc(&tx_info->iso_tx_pool_alloc);

	if (IS_ENABLED(CONFIG_BT_LL_ACS_NRF53)) {
		ret = bt_bap_stream_send(bap_stream, buf, tx_info->iso_tx.seq_num,
					 BT_ISO_TIMESTAMP_NONE);
	} else {
		ret = bt_bap_stream_send(bap_stream, buf, tx_info->iso_tx.seq_num, ts_tx);
	}

	if (ret < 0) {
		if (ret != -ENOTCONN) {
			LOG_WRN("Failed to send audio data: %d stream %p", ret, bap_stream);
		}
		net_buf_unref(buf);
		atomic_dec(&tx_info->iso_tx_pool_alloc);
		return ret;
	} else {
		tx_info->iso_tx.seq_num++;
	}

	return 0;
}

int bt_le_audio_tx_send(struct bt_bap_stream **bap_streams, struct le_audio_encoded_audio enc_audio,
			uint8_t streams_to_tx)
{
	int ret;
	size_t data_size_pr_stream = 0;

	if (!initialized) {
		return -EACCES;
	}

	if (bap_streams == NULL) {
		return -EINVAL;
	}

	if (streams_to_tx == 0) {
		LOG_INF("No active streams");
		return 0;
	}

	if (streams_to_tx > SRC_STREAM_COUNT) {
		return -ENOMEM;
	}

	if ((enc_audio.num_ch == 1) || (enc_audio.num_ch == streams_to_tx)) {
		data_size_pr_stream = enc_audio.size / enc_audio.num_ch;
	} else {
		LOG_ERR("Num encoded channels must be 1 or equal to num streams");
		return -EINVAL;
	}

	/* When sending ISO data, we always send ts = 0 to the first active transmitting channel.
	 * The controller will populate with a ts which is fetched using bt_iso_chan_get_tx_sync.
	 * This timestamp will be submitted to all the other channels in order to place data on all
	 * channels in the same ISO interval.
	 */

	uint32_t common_tx_sync_ts_us = 0;
	uint32_t curr_ts_us = 0;
	bool ts_common_acquired = false;
	uint32_t common_interval = 0;

	for (int i = 0; i < streams_to_tx; i++) {
		if (tx_info_arr[i].iso_tx.seq_num == 0) {
			/* Temporary fix until /zephyr/pull/68745/ is available
			 */
#if defined(CONFIG_BT_BAP_DEBUG_STREAM_SEQ_NUM)
			bap_streams[i]->_prev_seq_num = 0;
#endif /* CONFIG_BT_BAP_DEBUG_STREAM_SEQ_NUM */
		}

		if (!le_audio_ep_state_check(bap_streams[i]->ep, BT_BAP_EP_STATE_STREAMING)) {
			/* This bap_stream is not streaming*/
			continue;
		}

		uint32_t bitrate;

		ret = le_audio_bitrate_get(bap_streams[i]->codec_cfg, &bitrate);
		if (ret) {
			LOG_ERR("Failed to calculate bitrate: %d", ret);
			return ret;
		}

		if (data_size_pr_stream != LE_AUDIO_SDU_SIZE_OCTETS(bitrate)) {
			LOG_ERR("The encoded data size does not match the SDU size");
			return -EINVAL;
		}

		if (common_interval != 0 && (common_interval != bap_streams[i]->qos->interval)) {
			LOG_ERR("Not all channels have the same ISO interval");
			return -EINVAL;
		}
		common_interval = bap_streams[i]->qos->interval;

		/* Check if same audio is sent to all channels */
		if (enc_audio.num_ch == 1) {
			ret = iso_stream_send(enc_audio.data, data_size_pr_stream, bap_streams[i],
					      &tx_info_arr[i], common_tx_sync_ts_us);
		} else {
			ret = iso_stream_send(&enc_audio.data[data_size_pr_stream * i],
					      data_size_pr_stream, bap_streams[i], &tx_info_arr[i],
					      common_tx_sync_ts_us);
		}

		if (ret) {
			/* DBG used here as prints are handled within iso_stream_send */
			LOG_DBG("Failed to send to idx: %d stream: %p, ret: %d ", i, bap_streams[i],
				ret);
			continue;
		}

		/* Strictly, it is only required to call get_tx_sync on the first streaming channel
		 * to get the timestamp which is sent to all other channels. However, to be able to
		 * detect errors, this is called on each TX.
		 */
		ret = bt_bap_stream_get_tx_sync(bap_streams[i], &tx_info_arr[i].iso_tx_readback);
		if (ret) {
			if (ret != -ENOTCONN) {
				LOG_WRN("Unable to get tx sync. ret: %d stream: %p", ret,
					bap_streams[i]);
			}
			continue;
		}

		if (!ts_common_acquired) {
			curr_ts_us = audio_sync_timer_capture();
			common_tx_sync_ts_us = tx_info_arr[i].iso_tx_readback.ts;
			ts_common_acquired = true;
		}
	}

	if (ts_common_acquired) {
		/*TODO: Disabled for LL_ACS_NRF53 BIS due to timestamp issue */
		if (IS_ENABLED(CONFIG_BT_LL_ACS_NRF53) && IS_ENABLED(CONFIG_TRANSPORT_BIS)) {
			return 0;
		}

		struct sdu_ref_msg msg;

		msg.tx_sync_ts_us = common_tx_sync_ts_us;
		msg.curr_ts_us = curr_ts_us;
		msg.adjust = true;

		ret = zbus_chan_pub(&sdu_ref_chan, &msg, K_NO_WAIT);
		if (ret) {
			LOG_WRN("Failed to publish timestamp: %d", ret);
		}
	}

	return 0;
}

int bt_le_audio_tx_stream_stopped(uint8_t stream_idx)
{
	if (!initialized) {
		return -EACCES;
	}

	atomic_clear(&tx_info_arr[stream_idx].iso_tx_pool_alloc);
	tx_info_arr[stream_idx].hci_wrn_printed = false;

	return 0;
}

int bt_le_audio_tx_stream_started(uint8_t stream_idx)
{
	if (!initialized) {
		return -EACCES;
	}

	tx_info_arr[stream_idx].iso_tx.seq_num = 0;
	tx_info_arr[stream_idx].iso_tx_readback.seq_num = 0;
	return 0;
}

int bt_le_audio_tx_stream_sent(uint8_t stream_idx)
{
	if (!initialized) {
		return -EACCES;
	}

	atomic_dec(&tx_info_arr[stream_idx].iso_tx_pool_alloc);
	return 0;
}

int bt_le_audio_tx_init(void)
{
	if (initialized) {
		return -EALREADY;
	}

	for (int i = 0; i < SRC_STREAM_COUNT; i++) {
		tx_info_arr[i].iso_tx_pool = iso_tx_pools[i];
		tx_info_arr[i].hci_wrn_printed = false;
		tx_info_arr[i].iso_tx.ts = 0;
		tx_info_arr[i].iso_tx.offset = 0;
		tx_info_arr[i].iso_tx.seq_num = 0;
		tx_info_arr[i].iso_tx_readback.ts = 0;
		tx_info_arr[i].iso_tx_readback.offset = 0;
		tx_info_arr[i].iso_tx_readback.seq_num = 0;
	}

	initialized = true;
	return 0;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_stream/broadcast/Kconfig.defaults
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

config BT_BUF_ACL_RX_SIZE
	default 502 if (AUDIO_DFU > 0)

config BT_AUDIO_CODEC_CFG_MAX_METADATA_SIZE
	default 80


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_stream/broadcast/broadcast_sink.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BROADCAST_SINK_H_
#define _BROADCAST_SINK_H_

#include "bt_le_audio_tx.h"

/**
 * @brief	Change the active audio stream if the broadcast isochronous group (BIG) contains
 *              more than one broadcast isochronous stream (BIS).
 *
 * @note	Only streams within the same broadcast source are relevant, meaning
 *		that the broadcast source is not changed.
 *		The active stream will iterate every time this function is called.
 *
 * @return	0 for success, error otherwise.
 */
int broadcast_sink_change_active_audio_stream(void);

/**
 * @brief	Get configuration for the audio stream.
 *
 * @param[out]	bitrate		Pointer to the bitrate used; can be NULL.
 * @param[out]	sampling_rate	Pointer to the sampling rate used; can be NULL.
 * @param[out]	pres_delay	Pointer to the presentation delay used; can be NULL.
 *
 * @retval	0		Operation successful.
 * @retval	-ENXIO		The feature is disabled.
 */
int broadcast_sink_config_get(uint32_t *bitrate, uint32_t *sampling_rate, uint32_t *pres_delay);

/**
 * @brief	Set periodic advertising sync.
 *
 * @param[in]	pa_sync		Pointer to the periodic advertising sync.
 * @param[in]	broadcast_id	Broadcast ID of the periodic advertising.
 *
 * @return	0 for success, error otherwise.
 */
int broadcast_sink_pa_sync_set(struct bt_le_per_adv_sync *pa_sync, uint32_t broadcast_id);

/**
 * @brief	Start the Bluetooth LE Audio broadcast sink.
 *
 * @return	0 for success, error otherwise.
 */
int broadcast_sink_start(void);

/**
 * @brief	Stop the Bluetooth LE Audio broadcast sink.
 *
 * @return	0 for success, error otherwise.
 */
int broadcast_sink_stop(void);

/**
 * @brief	Disable the LE Audio broadcast (BIS) sink.
 *
 * @return	0 for success, error otherwise.
 */
int broadcast_sink_disable(void);

/**
 * @brief	Enable the LE Audio broadcast (BIS) sink.
 *
 * @param[in]	recv_cb		Callback for receiving Bluetooth LE Audio data.
 *
 * @return	0 for success, error otherwise.
 */
int broadcast_sink_enable(le_audio_receive_cb recv_cb);

#endif /* _BROADCAST_SINK_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_stream/broadcast/Kconfig
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

rsource "Kconfig.defaults"

menu "Broadcast"

choice BT_AUDIO_BROADCAST_BAP_CONFIGURATION
	prompt "Broadcast codec configuration"
	depends on TRANSPORT_BIS
	default BT_AUDIO_BROADCAST_CONFIGURABLE
	help
	  Select the broadcast codec configuration as given
	  in Table 6.4 of the Bluetooth Audio Profile specification.
	  USB only supports 48-kHz sampling rate.

config BT_AUDIO_BROADCAST_CONFIGURABLE
	bool "Configurable broadcast settings"
	depends on TRANSPORT_BIS
	help
	  Configurable option that doesn't follow any preset. Allows for more flexibility.

config BT_BAP_BROADCAST_16_2_1
	bool "16_2_1"
	depends on TRANSPORT_BIS
	help
	  Broadcast mandatory codec capability 16_2_1.
	  16kHz, 32kbps, 2 retransmits, 10ms transport latency, and 40ms presentation delay.

config BT_BAP_BROADCAST_24_2_1
	bool "24_2_1"
	depends on TRANSPORT_BIS
	help
	  Broadcast codec capability 24_2_1.
	  24kHz, 48kbps, 2 retransmits, 10ms transport latency, and 40ms presentation delay.

config BT_BAP_BROADCAST_16_2_2
	bool "16_2_2"
	depends on TRANSPORT_BIS
	help
	  Broadcast mandatory codec capability 16_2_2.
	  16kHz, 32kbps, 4 retransmits, 60ms transport latency, and 40ms presentation delay.

config BT_BAP_BROADCAST_24_2_2
	bool "24_2_2"
	depends on TRANSPORT_BIS
	help
	  Broadcast codec capability 24_2_2.
	  24kHz, 48kbps, 4 retransmits, 60ms transport latency, and 40ms presentation delay.
endchoice

config BT_AUDIO_BROADCAST_NAME
	string "Broadcast name"
	default "NRF5340_BROADCASTER"
	# TODO: Add back 'depends on TRANSPORT_BIS' once applications are ready
	help
	  Name of the broadcast; not the same as BT_DEVICE_NAME.

config BT_AUDIO_BROADCAST_NAME_ALT
	string "Alternative broadcast name"
	default "NRF5340_BROADCASTER_ALT"
	# TODO: Add back 'depends on TRANSPORT_BIS' once applications are ready
	help
	  Alternative name of the broadcast.

config BT_AUDIO_USE_BROADCAST_NAME_ALT
	bool "Use the alternative broadcast name"
	default n
	# TODO: Add back 'depends on TRANSPORT_BIS' once applications are ready
	help
	  Use the alternative broadcast name.

config BT_AUDIO_BROADCAST_ENCRYPTED
	bool "Encrypted broadcast"
	depends on TRANSPORT_BIS
	default n
	help
	  Encrypt the broadcast to limit the connection possibilities.

config BT_AUDIO_BROADCAST_ENCRYPTION_KEY
	string "Broadcast encryption key"
	depends on TRANSPORT_BIS
	default "NRF5340_BIS_DEMO"
	help
	  Key to use for encryption and decryption, with maximum BT_ISO_BROADCAST_CODE_SIZE
	  characters. Encryption keys larger than BT_ISO_BROADCAST_CODE_SIZE will be truncated to
	  BT_ISO_BROADCAST_CODE_SIZE.

config BT_AUDIO_USE_BROADCAST_ID_RANDOM
	bool "Use a random broadcast ID"
	depends on TRANSPORT_BIS
	default y
	help
	  Use a randomly generated broadcast ID.

config BT_AUDIO_BROADCAST_ID_FIXED
	hex "Fixed broadcast ID"
	depends on TRANSPORT_BIS
	default 0x123456
	help
	  Fixed broadcast ID; 3 octets. Will only be used if BT_AUDIO_USE_BROADCAST_ID_RANDOM=n.
	  Only use for debugging.

config BT_AUDIO_BROADCAST_PARENTAL_RATING
	hex "Parental rating"
	depends on TRANSPORT_BIS
	default 0x00
	range 0x00 0x0F
	help
	  Set the parental rating for the broadcast.
	  BT_AUDIO_PARENTAL_RATING_NO_RATING        = 0x00,
	  BT_AUDIO_PARENTAL_RATING_AGE_ANY          = 0x01,
	  BT_AUDIO_PARENTAL_RATING_AGE_5_OR_ABOVE   = 0x02,
	  BT_AUDIO_PARENTAL_RATING_AGE_6_OR_ABOVE   = 0x03,
	  BT_AUDIO_PARENTAL_RATING_AGE_7_OR_ABOVE   = 0x04,
	  BT_AUDIO_PARENTAL_RATING_AGE_8_OR_ABOVE   = 0x05,
	  BT_AUDIO_PARENTAL_RATING_AGE_9_OR_ABOVE   = 0x06,
	  BT_AUDIO_PARENTAL_RATING_AGE_10_OR_ABOVE  = 0x07,
	  BT_AUDIO_PARENTAL_RATING_AGE_11_OR_ABOVE  = 0x08,
	  BT_AUDIO_PARENTAL_RATING_AGE_12_OR_ABOVE  = 0x09,
	  BT_AUDIO_PARENTAL_RATING_AGE_13_OR_ABOVE  = 0x0A,
	  BT_AUDIO_PARENTAL_RATING_AGE_14_OR_ABOVE  = 0x0B,
	  BT_AUDIO_PARENTAL_RATING_AGE_15_OR_ABOVE  = 0x0C,
	  BT_AUDIO_PARENTAL_RATING_AGE_16_OR_ABOVE  = 0x0D,
	  BT_AUDIO_PARENTAL_RATING_AGE_17_OR_ABOVE  = 0x0E,
	  BT_AUDIO_PARENTAL_RATING_AGE_18_OR_ABOVE  = 0x0F

config BT_AUDIO_BROADCAST_IMMEDIATE_FLAG
	bool "Immediate rendering flag"
	depends on TRANSPORT_BIS
	default n
	help
	  Set the immediate rendering flag.

config AURACAST
	bool "Enable Auracast"
	depends on TRANSPORT_BIS
	default y
	help
	  When Auracast is enabled, a Public Broadcast Announcement will be included
	  when advertising.

config BT_AUDIO_BITRATE_BROADCAST_SRC
	int "ISO stream bitrate"
	depends on TRANSPORT_BIS
	default 96000 if BT_AUDIO_BROADCAST_CONFIGURABLE
	default 32000 if BT_BAP_BROADCAST_16_2_1 || BT_BAP_BROADCAST_16_2_2
	default 48000 if BT_BAP_BROADCAST_24_2_1 || BT_BAP_BROADCAST_24_2_2
	help
	  Bitrate for the broadcast source ISO stream.

#----------------------------------------------------------------------------#
menu "Log levels"

module = BROADCAST_SOURCE
module-str = broadcast_source
source "subsys/logging/Kconfig.template.log_config"

module = BROADCAST_SINK
module-str = broadcast_sink
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log levels
endmenu # Broadcast


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_stream/broadcast/broadcast_source.c
/*
 * Copyright (c) 2022 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "broadcast_source.h"

#include <zephyr/zbus/zbus.h>
#include <zephyr/sys/byteorder.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/audio/audio.h>
#include <zephyr/bluetooth/audio/cap.h>
#include <../subsys/bluetooth/audio/bap_iso.h>
#include <zephyr/bluetooth/audio/bap_lc3_preset.h>

/* TODO: Remove when a get_info function is implemented in host */
#include <../subsys/bluetooth/audio/bap_endpoint.h>

#include "macros_common.h"
#include "bt_le_audio_tx.h"
#include "nrf5340_audio_common.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(broadcast_source, CONFIG_BROADCAST_SOURCE_LOG_LEVEL);

/* Length-type-value size for channel allocation */
#define LTV_CHAN_ALLOC_SIZE 6

BUILD_ASSERT(CONFIG_BT_BAP_BROADCAST_SRC_STREAM_COUNT <= 2,
	     "A maximum of two audio streams are currently supported");

ZBUS_CHAN_DEFINE(le_audio_chan, struct le_audio_msg, NULL, NULL, ZBUS_OBSERVERS_EMPTY,
		 ZBUS_MSG_INIT(0));

#if CONFIG_BT_AUDIO_BROADCAST_CONFIGURABLE
#define BT_BAP_LC3_BROADCAST_PRESET_NRF5340_AUDIO                                                  \
	BT_BAP_LC3_PRESET_CONFIGURABLE(                                                            \
		BT_AUDIO_LOCATION_FRONT_LEFT | BT_AUDIO_LOCATION_FRONT_RIGHT,                      \
		BT_AUDIO_CONTEXT_TYPE_MEDIA, CONFIG_BT_AUDIO_BITRATE_BROADCAST_SRC)

#elif CONFIG_BT_BAP_BROADCAST_16_2_1
#define BT_BAP_LC3_BROADCAST_PRESET_NRF5340_AUDIO                                                  \
	BT_BAP_LC3_BROADCAST_PRESET_16_2_1(BT_AUDIO_LOCATION_FRONT_LEFT |                          \
						   BT_AUDIO_LOCATION_FRONT_RIGHT,                  \
					   BT_AUDIO_CONTEXT_TYPE_MEDIA)

#elif CONFIG_BT_BAP_BROADCAST_24_2_1
#define BT_BAP_LC3_BROADCAST_PRESET_NRF5340_AUDIO                                                  \
	BT_BAP_LC3_BROADCAST_PRESET_24_2_1(BT_AUDIO_LOCATION_FRONT_LEFT |                          \
						   BT_AUDIO_LOCATION_FRONT_RIGHT,                  \
					   BT_AUDIO_CONTEXT_TYPE_MEDIA)

#elif CONFIG_BT_BAP_BROADCAST_16_2_2
#define BT_BAP_LC3_BROADCAST_PRESET_NRF5340_AUDIO                                                  \
	BT_BAP_LC3_BROADCAST_PRESET_16_2_2(BT_AUDIO_LOCATION_FRONT_LEFT |                          \
						   BT_AUDIO_LOCATION_FRONT_RIGHT,                  \
					   BT_AUDIO_CONTEXT_TYPE_MEDIA)

#elif CONFIG_BT_BAP_BROADCAST_24_2_2
#define BT_BAP_LC3_BROADCAST_PRESET_NRF5340_AUDIO                                                  \
	BT_BAP_LC3_BROADCAST_PRESET_24_2_2(BT_AUDIO_LOCATION_FRONT_LEFT |                          \
						   BT_AUDIO_LOCATION_FRONT_RIGHT,                  \
					   BT_AUDIO_CONTEXT_TYPE_MEDIA)

#else
#error Unsupported LC3 codec preset for broadcast
#endif /* CONFIG_BT_AUDIO_BROADCAST_CONFIGURABLE */

static struct bt_cap_broadcast_source *broadcast_source;
static struct bt_cap_stream cap_streams[CONFIG_BT_BAP_BROADCAST_SRC_STREAM_COUNT];
static struct bt_bap_lc3_preset lc3_preset = BT_BAP_LC3_BROADCAST_PRESET_NRF5340_AUDIO;
static struct bt_le_ext_adv *adv;
static bool initialized;
static bool delete_broadcast_src;

#if (CONFIG_AURACAST)
/* Make sure pba_buf is large enough for a 16bit UUID and meta data
 * (any addition to pba_buf requires an increase of this value)
 */
NET_BUF_SIMPLE_DEFINE(pba_buf, BT_UUID_SIZE_16 + 8);
static struct bt_data ext_ad[4];
#else
static struct bt_data ext_ad[3];
#endif /* (CONFIG_AURACAST) */

static struct bt_data per_ad[1];

static void le_audio_event_publish(enum le_audio_evt_type event)
{
	int ret;
	struct le_audio_msg msg;

	msg.event = event;

	ret = zbus_chan_pub(&le_audio_chan, &msg, LE_AUDIO_ZBUS_EVENT_WAIT_TIME);
	ERR_CHK(ret);
}

static int get_stream_index(struct bt_bap_stream *stream, uint8_t *index)
{
	for (int i = 0; i < ARRAY_SIZE(cap_streams); i++) {
		if (&cap_streams[i].bap_stream == stream) {
			*index = i;
			return 0;
		}
	}

	LOG_WRN("Stream %p not found", (void *)stream);

	return -EINVAL;
}

static void stream_sent_cb(struct bt_bap_stream *stream)
{
	uint8_t index = 0;

	get_stream_index(stream, &index);
	ERR_CHK(bt_le_audio_tx_stream_sent(index));
}

static void stream_started_cb(struct bt_bap_stream *stream)
{
	uint8_t index = 0;

	get_stream_index(stream, &index);
	ERR_CHK(bt_le_audio_tx_stream_started(index));

	le_audio_event_publish(LE_AUDIO_EVT_STREAMING);

	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Broadcast source %p started", (void *)stream);
}

static void stream_stopped_cb(struct bt_bap_stream *stream, uint8_t reason)
{
	int ret;
	uint8_t index = 0;

	get_stream_index(stream, &index);

	le_audio_event_publish(LE_AUDIO_EVT_NOT_STREAMING);

	ERR_CHK(bt_le_audio_tx_stream_stopped(index));

	LOG_INF("Broadcast source %p stopped. Reason: %d", (void *)stream, reason);

	if (delete_broadcast_src && broadcast_source != NULL) {
		ret = bt_cap_initiator_broadcast_audio_delete(broadcast_source);
		if (ret) {
			LOG_ERR("Unable to delete broadcast source %p", (void *)stream);
			delete_broadcast_src = false;
			return;
		}

		broadcast_source = NULL;

		LOG_INF("Broadcast source %p deleted", (void *)stream);

		delete_broadcast_src = false;
	}
}

static struct bt_bap_stream_ops stream_ops = {
	.sent = stream_sent_cb,
	.started = stream_started_cb,
	.stopped = stream_stopped_cb,
};

#if (CONFIG_AURACAST)
static void public_broadcast_features_set(uint8_t *features)
{
	int freq = bt_audio_codec_cfg_get_freq(&lc3_preset.codec_cfg);

	if (features == NULL) {
		LOG_ERR("No pointer to features");
		return;
	}

	if (IS_ENABLED(CONFIG_BT_AUDIO_BROADCAST_ENCRYPTED)) {
		*features |= 0x01;
	}

	if (freq == BT_AUDIO_CODEC_CONFIG_LC3_FREQ_16KHZ ||
	    freq == BT_AUDIO_CODEC_CONFIG_LC3_FREQ_24KHZ) {
		*features |= 0x02;
	} else if (freq == BT_AUDIO_CODEC_CONFIG_LC3_FREQ_48KHZ) {
		*features |= 0x04;
	} else {
		LOG_WRN("%dkHz is not compatible with Auracast, choose 16kHz, 24kHz or 48kHz",
			freq);
	}
}
#endif /* (CONFIG_AURACAST) */

static int adv_create(void)
{
	int ret;
	uint32_t broadcast_id = 0;

	/* Broadcast Audio Streaming Endpoint advertising data */
	NET_BUF_SIMPLE_DEFINE_STATIC(brdcst_id_buf, BT_UUID_SIZE_16 + BT_AUDIO_BROADCAST_ID_SIZE);
	/* Buffer for Appearance */
	NET_BUF_SIMPLE_DEFINE_STATIC(brdcst_appearance_buf, BT_UUID_SIZE_16);
	/* Buffer for Public Broadcast Announcement */
	NET_BUF_SIMPLE_DEFINE_STATIC(base_buf, 128);

	if (IS_ENABLED(CONFIG_BT_AUDIO_USE_BROADCAST_ID_RANDOM)) {
		ret = bt_cap_initiator_broadcast_get_id(broadcast_source, &broadcast_id);
		if (ret) {
			LOG_ERR("Unable to get broadcast ID: %d", ret);
			return ret;
		}
	} else {
		broadcast_id = CONFIG_BT_AUDIO_BROADCAST_ID_FIXED;
	}

	if (IS_ENABLED(CONFIG_BT_AUDIO_USE_BROADCAST_NAME_ALT)) {
		ext_ad[0] = (struct bt_data)BT_DATA(BT_DATA_BROADCAST_NAME,
						    CONFIG_BT_AUDIO_BROADCAST_NAME_ALT,
						    sizeof(CONFIG_BT_AUDIO_BROADCAST_NAME_ALT) - 1);
	} else {
		ext_ad[0] = (struct bt_data)BT_DATA(BT_DATA_BROADCAST_NAME,
						    CONFIG_BT_AUDIO_BROADCAST_NAME,
						    sizeof(CONFIG_BT_AUDIO_BROADCAST_NAME) - 1);
	}

	/* Setup extended advertising data */
	net_buf_simple_add_le16(&brdcst_id_buf, BT_UUID_BROADCAST_AUDIO_VAL);
	net_buf_simple_add_le24(&brdcst_id_buf, broadcast_id);

	ext_ad[1].data_len = brdcst_id_buf.len;
	ext_ad[1].type = BT_DATA_SVC_DATA16;
	ext_ad[1].data = brdcst_id_buf.data;

	net_buf_simple_add_le16(&brdcst_appearance_buf, CONFIG_BT_DEVICE_APPEARANCE);

	ext_ad[2].data_len = brdcst_appearance_buf.len;
	ext_ad[2].type = BT_DATA_GAP_APPEARANCE;
	ext_ad[2].data = brdcst_appearance_buf.data;

#if (CONFIG_AURACAST)
	uint8_t pba_features = 0;
	public_broadcast_features_set(&pba_features);

	net_buf_simple_add_le16(&pba_buf, 0x1856);
	net_buf_simple_add_u8(&pba_buf, pba_features);

	/* Metadata */
	/* 3 bytes for parental_rating and 3 bytes for active_flag LTVs */
	net_buf_simple_add_u8(&pba_buf, 0x06);

	/* Parental rating*/
	/* Length */
	net_buf_simple_add_u8(&pba_buf, 0x02);
	/* Type */
	net_buf_simple_add_u8(&pba_buf, BT_AUDIO_METADATA_TYPE_PARENTAL_RATING);
	/* Value */
	net_buf_simple_add_u8(&pba_buf, CONFIG_BT_AUDIO_BROADCAST_PARENTAL_RATING);

	/* Active flag */
	/* Length */
	net_buf_simple_add_u8(&pba_buf, 0x02);
	/* Type */
	net_buf_simple_add_u8(&pba_buf, BT_AUDIO_METADATA_TYPE_AUDIO_STATE);
	/* Value */
	net_buf_simple_add_u8(&pba_buf, BT_AUDIO_ACTIVE_STATE_ENABLED);

	/* If any additional data is to be added, remember to increase NET_BUF size */

	ext_ad[3].data_len = pba_buf.len;
	ext_ad[3].type = BT_DATA_SVC_DATA16;
	ext_ad[3].data = pba_buf.data;
#endif /* (CONFIG_AURACAST) */

	/* Setup periodic advertising data */
	ret = bt_cap_initiator_broadcast_get_base(broadcast_source, &base_buf);
	if (ret) {
		LOG_ERR("Failed to get encoded BASE: %d", ret);
		return ret;
	}

	per_ad[0].data_len = base_buf.len;
	per_ad[0].type = BT_DATA_SVC_DATA16;
	per_ad[0].data = base_buf.data;

	return 0;
}

/**
 * @brief Set the channel allocation to a preset codec configuration.
 *
 * @param	data		The preset codec configuration.
 * @param	data_len	Length of @p data
 * @param	loc		Location bitmask setting.
 */
static void bt_audio_codec_allocation_set(uint8_t *data, uint8_t data_len,
					  enum bt_audio_location loc)
{
	data[0] = data_len - 1;
	data[1] = BT_AUDIO_CODEC_CONFIG_LC3_CHAN_ALLOC;
	sys_put_le32((const uint32_t)loc, &data[2]);
}

void broadcast_source_adv_get(const struct bt_data **ext_adv, size_t *ext_adv_size,
			      const struct bt_data **per_adv, size_t *per_adv_size)
{
	*ext_adv = ext_ad;
	*ext_adv_size = ARRAY_SIZE(ext_ad);
	*per_adv = per_ad;
	*per_adv_size = ARRAY_SIZE(per_ad);
}

int broadcast_source_start(struct bt_le_ext_adv *ext_adv)
{
	int ret;

	if (ext_adv != NULL) {
		adv = ext_adv;
	}

	if (adv == NULL) {
		LOG_ERR("No advertising set available");
		return -EINVAL;
	}

	LOG_DBG("Starting broadcast source");

	/* All streams in a broadcast source is in the same state,
	 * so we can just check the first stream
	 */
	if (cap_streams[0].bap_stream.ep == NULL) {
		LOG_ERR("stream->ep is NULL");
		return -ECANCELED;
	}

	if (cap_streams[0].bap_stream.ep->status.state == BT_BAP_EP_STATE_STREAMING) {
		LOG_WRN("Already streaming");
		return -EALREADY;
	}

	ret = bt_cap_initiator_broadcast_audio_start(broadcast_source, adv);
	if (ret) {
		LOG_WRN("Failed to start broadcast, ret: %d", ret);
		return ret;
	}

	return 0;
}

int broadcast_source_stop(void)
{
	int ret;

	/* All streams in a broadcast source is in the same state,
	 * so we can just check the first stream
	 */
	if (cap_streams[0].bap_stream.ep == NULL) {
		LOG_ERR("stream->ep is NULL");
		return -ECANCELED;
	}

	if (cap_streams[0].bap_stream.ep->status.state == BT_BAP_EP_STATE_STREAMING) {
		ret = bt_cap_initiator_broadcast_audio_stop(broadcast_source);
		if (ret) {
			LOG_WRN("Failed to stop broadcast, ret: %d", ret);
			return ret;
		}
	} else {
		LOG_WRN("Not in a streaming state");
		return -EINVAL;
	}

	return 0;
}

int broadcast_source_send(struct le_audio_encoded_audio enc_audio)
{
	int ret;
	struct bt_bap_stream *bap_tx_streams[CONFIG_BT_BAP_BROADCAST_SRC_STREAM_COUNT];

	for (int i = 0; i < ARRAY_SIZE(cap_streams); i++) {
		bap_tx_streams[i] = &cap_streams[i].bap_stream;
	}

	ret = bt_le_audio_tx_send(bap_tx_streams, enc_audio, ARRAY_SIZE(cap_streams));
	if (ret) {
		return ret;
	}

	return 0;
}

int broadcast_source_disable(void)
{
	int ret;

	if (cap_streams[0].bap_stream.ep->status.state == BT_BAP_EP_STATE_STREAMING) {
		/* Deleting broadcast source in stream_stopped_cb() */
		delete_broadcast_src = true;

		ret = bt_cap_initiator_broadcast_audio_stop(broadcast_source);
		if (ret) {
			return ret;
		}
	} else if (broadcast_source != NULL) {
		ret = bt_cap_initiator_broadcast_audio_delete(broadcast_source);
		if (ret) {
			return ret;
		}

		broadcast_source = NULL;
	}

	initialized = false;

	LOG_DBG("Broadcast source disabled");

	return 0;
}

int broadcast_source_enable(void)
{
	int ret;

	struct bt_cap_initiator_broadcast_stream_param stream_params[ARRAY_SIZE(cap_streams)];
	uint8_t bis_codec_data[ARRAY_SIZE(stream_params)][LTV_CHAN_ALLOC_SIZE];
	struct bt_cap_initiator_broadcast_subgroup_param
		subgroup_params[CONFIG_BT_BAP_BROADCAST_SRC_SUBGROUP_COUNT];
	struct bt_cap_initiator_broadcast_create_param create_param;

	if (initialized) {
		LOG_WRN("Already initialized");
		return -EALREADY;
	}

	ret = bt_le_audio_tx_init();
	if (ret) {
		return ret;
	}

	LOG_INF("Enabling broadcast_source %s", CONFIG_BT_AUDIO_BROADCAST_NAME);

	(void)memset(cap_streams, 0, sizeof(cap_streams));

	/* Populate BISes */
	for (size_t i = 0; i < ARRAY_SIZE(stream_params); i++) {
		stream_params[i].stream = &cap_streams[i];

		bt_cap_stream_ops_register(stream_params[i].stream, &stream_ops);
		/* TODO: Remove this once the fixed call above has been upstreamed */
		bt_bap_stream_cb_register(&stream_params[i].stream->bap_stream, &stream_ops);

		stream_params[i].data_len = ARRAY_SIZE(bis_codec_data[i]);
		stream_params[i].data = bis_codec_data[i];

		/* The channel allocation is set incrementally */
		bt_audio_codec_allocation_set(stream_params[i].data, stream_params[i].data_len,
					      BIT(i));
	}

	/* Create BIGs */
	for (size_t i = 0U; i < ARRAY_SIZE(subgroup_params); i++) {
		subgroup_params[i].stream_count = ARRAY_SIZE(stream_params);
		subgroup_params[i].stream_params = &stream_params[i];
		subgroup_params[i].codec_cfg = &lc3_preset.codec_cfg;
#if (CONFIG_BT_AUDIO_BROADCAST_IMMEDIATE_FLAG)
		bt_audio_codec_cfg_meta_set_bcast_audio_immediate_rend_flag(
			subgroup_params[i].codec_cfg);
#endif /* (CONFIG_BT_AUDIO_BROADCAST_IMMEDIATE_FLAG) */
	}

	/* Create broadcast_source */
	create_param.subgroup_count = ARRAY_SIZE(subgroup_params);
	create_param.subgroup_params = subgroup_params;
	create_param.qos = &lc3_preset.qos;

	if (IS_ENABLED(CONFIG_BT_AUDIO_PACKING_INTERLEAVED)) {
		create_param.packing = BT_ISO_PACKING_INTERLEAVED;
	} else {
		create_param.packing = BT_ISO_PACKING_SEQUENTIAL;
	}

	if (IS_ENABLED(CONFIG_BT_AUDIO_BROADCAST_ENCRYPTED)) {
		create_param.encryption = true;
		memset(create_param.broadcast_code, 0, sizeof(create_param.broadcast_code));
		memcpy(create_param.broadcast_code, CONFIG_BT_AUDIO_BROADCAST_ENCRYPTION_KEY,
		       MIN(sizeof(CONFIG_BT_AUDIO_BROADCAST_ENCRYPTION_KEY),
			   sizeof(create_param.broadcast_code)));
	} else {
		create_param.encryption = false;
	}

	LOG_DBG("Creating broadcast source");

	ret = bt_cap_initiator_broadcast_audio_create(&create_param, &broadcast_source);
	if (ret) {
		LOG_ERR("Failed to create broadcast source, ret: %d", ret);
		return ret;
	}

	/* Create advertising set */
	ret = adv_create();
	if (ret) {
		LOG_ERR("Failed to create advertising set");
		return ret;
	}

	initialized = true;

	LOG_DBG("Broadcast source enabled");

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_stream/broadcast/broadcast_sink.c
/*
 * Copyright (c) 2022 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "broadcast_sink.h"

#include <zephyr/zbus/zbus.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/audio/audio.h>
#include <zephyr/bluetooth/audio/pacs.h>
#include <zephyr/sys/byteorder.h>

/* TODO: Remove when a get_info function is implemented in host */
#include <../subsys/bluetooth/audio/bap_endpoint.h>

#include "macros_common.h"
#include "nrf5340_audio_common.h"
#include "channel_assignment.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(broadcast_sink, CONFIG_BROADCAST_SINK_LOG_LEVEL);

BUILD_ASSERT(CONFIG_BT_BAP_BROADCAST_SNK_STREAM_COUNT <= 2,
	     "A maximum of two broadcast streams are currently supported");

ZBUS_CHAN_DEFINE(le_audio_chan, struct le_audio_msg, NULL, NULL, ZBUS_OBSERVERS_EMPTY,
		 ZBUS_MSG_INIT(0));

struct audio_codec_info {
	uint8_t id;
	uint16_t cid;
	uint16_t vid;
	int frequency;
	int frame_duration_us;
	enum bt_audio_location chan_allocation;
	int octets_per_sdu;
	int bitrate;
	int blocks_per_sdu;
};

struct active_audio_stream {
	struct bt_bap_stream *stream;
	struct audio_codec_info *codec;
	uint32_t pd;
};

static struct bt_bap_broadcast_sink *broadcast_sink;
static struct bt_bap_stream audio_streams[CONFIG_BT_BAP_BROADCAST_SNK_STREAM_COUNT];
static struct audio_codec_info audio_codec_info[CONFIG_BT_BAP_BROADCAST_SNK_STREAM_COUNT];
static uint32_t bis_index_bitfields[CONFIG_BT_BAP_BROADCAST_SNK_STREAM_COUNT];

static struct bt_le_per_adv_sync *pa_sync_stored;

static struct active_audio_stream active_stream;

/* The values of sync_stream_cnt and active_stream_index must never become larger
 * than the sizes of the arrays above (audio_streams etc.)
 */
static uint8_t sync_stream_cnt;
static uint8_t active_stream_index;

static struct bt_audio_codec_cap codec_cap = BT_AUDIO_CODEC_CAP_LC3(
	BT_AUDIO_CODEC_CAPABILIY_FREQ,
	(BT_AUDIO_CODEC_LC3_DURATION_10 | BT_AUDIO_CODEC_LC3_DURATION_PREFER_10),
	BT_AUDIO_CODEC_LC3_CHAN_COUNT_SUPPORT(1), LE_AUDIO_SDU_SIZE_OCTETS(CONFIG_LC3_BITRATE_MIN),
	LE_AUDIO_SDU_SIZE_OCTETS(CONFIG_LC3_BITRATE_MAX), 1u, BT_AUDIO_CONTEXT_TYPE_MEDIA);

static struct bt_pacs_cap capabilities = {
	.codec_cap = &codec_cap,
};

static le_audio_receive_cb receive_cb;

static bool init_routine_completed;
static bool paused;

static int broadcast_sink_cleanup(void)
{
	int ret;

	init_routine_completed = false;

	active_stream.pd = 0;
	active_stream.stream = NULL;
	active_stream.codec = NULL;

	if (broadcast_sink != NULL) {
		ret = bt_bap_broadcast_sink_delete(broadcast_sink);
		if (ret && ret != -EALREADY) {
			return ret;
		}

		broadcast_sink = NULL;
	}

	return 0;
}

static void bis_cleanup_worker(struct k_work *work)
{
	int ret;

	ret = broadcast_sink_cleanup();
	if (ret) {
		LOG_WRN("Failed to clean up BISes: %d", ret);
	}
}

K_WORK_DEFINE(bis_cleanup_work, bis_cleanup_worker);

static void le_audio_event_publish(enum le_audio_evt_type event)
{
	int ret;
	struct le_audio_msg msg;

	if (event == LE_AUDIO_EVT_SYNC_LOST) {
		msg.pa_sync = pa_sync_stored;
		pa_sync_stored = NULL;
	}

	msg.event = event;

	ret = zbus_chan_pub(&le_audio_chan, &msg, LE_AUDIO_ZBUS_EVENT_WAIT_TIME);
	ERR_CHK(ret);
}

static void print_codec(const struct audio_codec_info *codec)
{
	if (codec->id == BT_HCI_CODING_FORMAT_LC3) {
		LOG_INF("Codec config for LC3:");
		LOG_INF("\tFrequency: %d Hz", codec->frequency);
		LOG_INF("\tFrame Duration: %d us", codec->frame_duration_us);
		LOG_INF("\tOctets per frame: %d (%d kbps)", codec->octets_per_sdu, codec->bitrate);
		LOG_INF("\tFrames per SDU: %d", codec->blocks_per_sdu);
		if (codec->chan_allocation >= 0) {
			LOG_INF("\tChannel allocation: 0x%x", codec->chan_allocation);
		}
	} else {
		LOG_WRN("Codec is not LC3, codec_id: 0x%2hhx", codec->id);
	}
}

static void get_codec_info(const struct bt_audio_codec_cfg *codec,
			   struct audio_codec_info *codec_info)
{
	int ret;

	if (codec->id == BT_HCI_CODING_FORMAT_LC3) {
		/* LC3 uses the generic LTV format - other codecs might do as well */
		LOG_DBG("Retrieve the codec configuration for LC3");
		codec_info->id = codec->id;
		codec_info->cid = codec->cid;
		codec_info->vid = codec->vid;

		ret = le_audio_freq_hz_get(codec, &codec_info->frequency);
		if (ret) {
			LOG_ERR("Error retrieving sampling frequency: %d", ret);
			return;
		}

		ret = le_audio_duration_us_get(codec, &codec_info->frame_duration_us);
		if (ret) {
			LOG_ERR("Error retrieving frame duration: %d", ret);
			return;
		}

		ret = bt_audio_codec_cfg_get_chan_allocation(codec, &codec_info->chan_allocation);
		if (ret) {
			LOG_ERR("Error retrieving channel allocation: %d", ret);
			return;
		}

		ret = le_audio_octets_per_frame_get(codec, &codec_info->octets_per_sdu);
		if (ret) {
			LOG_ERR("Error retrieving octets per frame: %d", ret);
			return;
		}

		ret = le_audio_bitrate_get(codec, &codec_info->bitrate);
		if (ret) {
			LOG_ERR("Error calculating bitrate: %d", ret);
			return;
		}

		ret = le_audio_frame_blocks_per_sdu_get(codec, &codec_info->blocks_per_sdu);
		if (codec_info->octets_per_sdu < 0) {
			LOG_ERR("Error retrieving frame blocks per SDU: %d",
				codec_info->octets_per_sdu);
			return;
		}
	} else {
		LOG_WRN("Codec is not LC3, codec_id: 0x%2hhx", codec->id);
	}
}

static bool bitrate_check(const struct bt_audio_codec_cfg *codec)
{
	int ret;
	uint32_t octets_per_sdu;

	ret = le_audio_octets_per_frame_get(codec, &octets_per_sdu);
	if (ret) {
		LOG_ERR("Error retrieving octets per frame: %d", ret);
		return false;
	}

	if (octets_per_sdu < LE_AUDIO_SDU_SIZE_OCTETS(CONFIG_LC3_BITRATE_MIN)) {
		LOG_WRN("Bitrate too low");
		return false;
	} else if (octets_per_sdu > LE_AUDIO_SDU_SIZE_OCTETS(CONFIG_LC3_BITRATE_MAX)) {
		LOG_WRN("Bitrate too high");
		return false;
	}

	return true;
}

static void stream_started_cb(struct bt_bap_stream *stream)
{
	le_audio_event_publish(LE_AUDIO_EVT_STREAMING);

	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Stream index %d started", active_stream_index);
	print_codec(&audio_codec_info[active_stream_index]);
}

static void stream_stopped_cb(struct bt_bap_stream *stream, uint8_t reason)
{

	switch (reason) {
	case BT_HCI_ERR_LOCALHOST_TERM_CONN:
		LOG_INF("Stream stopped by user");
		le_audio_event_publish(LE_AUDIO_EVT_NOT_STREAMING);

		break;

	case BT_HCI_ERR_CONN_FAIL_TO_ESTAB:
		/* Fall-through */
	case BT_HCI_ERR_CONN_TIMEOUT:
		LOG_INF("Stream sync lost");
		k_work_submit(&bis_cleanup_work);

		le_audio_event_publish(LE_AUDIO_EVT_SYNC_LOST);

		break;

	case BT_HCI_ERR_REMOTE_USER_TERM_CONN:
		LOG_INF("Broadcast source stopped streaming");
		le_audio_event_publish(LE_AUDIO_EVT_NOT_STREAMING);

		break;

	default:
		LOG_WRN("Unhandled reason: %d", reason);

		break;
	}

	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Stream index %d stopped. Reason: %d", active_stream_index, reason);
}

static void stream_recv_cb(struct bt_bap_stream *stream, const struct bt_iso_recv_info *info,
			   struct net_buf *buf)
{
	bool bad_frame = false;

	if (receive_cb == NULL) {
		LOG_ERR("The RX callback has not been set");
		return;
	}

	if (!(info->flags & BT_ISO_FLAGS_VALID)) {
		bad_frame = true;
	}

	receive_cb(buf->data, buf->len, bad_frame, info->ts, active_stream_index,
		   active_stream.codec->octets_per_sdu);
}

static struct bt_bap_stream_ops stream_ops = {
	.started = stream_started_cb,
	.stopped = stream_stopped_cb,
	.recv = stream_recv_cb,
};

static bool parse_cb(struct bt_data *data, void *codec)
{
	if (data->type == BT_AUDIO_CODEC_CONFIG_LC3_CHAN_ALLOC) {
		((struct audio_codec_info *)codec)->chan_allocation = sys_get_le32(data->data);
		return false;
	}

	return true;
}

/**
 * @brief	Function which overwrites BIS specific codec information.
 *		I.e. level 3 specific information overwrites general level 2 information.
 *
 * @note	This will change when new host APIs are available.
 *
 * @return	0 for success, error otherwise.
 */
static int bis_specific_codec_config(struct bt_bap_base_bis_data bis_data,
				     struct audio_codec_info *codec)
{
	int ret;

	ret = bt_audio_data_parse(bis_data.data, bis_data.data_len, parse_cb, codec);
	if (ret && ret != -ECANCELED) {
		LOG_WRN("Could not overwrite BIS specific codec info: %d", ret);
		return -ENXIO;
	}

	return 0;
}

static void base_recv_cb(struct bt_bap_broadcast_sink *sink, const struct bt_bap_base *base)
{
	bool suitable_stream_found = false;

	if (init_routine_completed) {
		return;
	}

	LOG_DBG("Received BASE with %zu subgroup(s) from broadcast sink", base->subgroup_count);

	sync_stream_cnt = 0;

	/* Search each subgroup for the BIS of interest */
	for (int i = 0; i < base->subgroup_count; i++) {
		for (int j = 0; j < base->subgroups[i].bis_count; j++) {
			const uint8_t index = base->subgroups[i].bis_data[j].index;

			LOG_DBG("Subgroup: %d BIS: %d index = %d", i, j, index);

			if (bitrate_check(&base->subgroups[i].codec_cfg)) {
				suitable_stream_found = true;

				bis_index_bitfields[sync_stream_cnt] = BIT(index);

				/* Get general (level 2) codec config from the subgroup */
				audio_streams[sync_stream_cnt].codec_cfg =
					(struct bt_audio_codec_cfg *)&base->subgroups[i].codec_cfg;
				get_codec_info(audio_streams[sync_stream_cnt].codec_cfg,
					       &audio_codec_info[sync_stream_cnt]);

				/* Overwrite codec config with level 3 BIS specific codec config.
				 * For now, this is only done for channel allocation
				 */
				(void)bis_specific_codec_config(base->subgroups[i].bis_data[j],
								&audio_codec_info[sync_stream_cnt]);

				LOG_DBG("Stream %d in subgroup %d from broadcast sink",
					sync_stream_cnt, i);

				sync_stream_cnt += 1;
				if (sync_stream_cnt >= ARRAY_SIZE(audio_streams)) {
					break;
				}
			}
		}

		if (sync_stream_cnt >= ARRAY_SIZE(audio_streams)) {
			break;
		}
	}

	if (suitable_stream_found) {
		/* Set the initial active stream based on the defined channel of the device */
		channel_assignment_get((enum audio_channel *)&active_stream_index);
		active_stream.stream = &audio_streams[active_stream_index];
		active_stream.codec = &audio_codec_info[active_stream_index];
		active_stream.pd = base->pd;

		le_audio_event_publish(LE_AUDIO_EVT_CONFIG_RECEIVED);

		LOG_DBG("Channel %s active",
			((active_stream_index == AUDIO_CH_L) ? CH_L_TAG : CH_R_TAG));
		LOG_DBG("Waiting for syncable");
	} else {
		LOG_DBG("Found no suitable stream");
		le_audio_event_publish(LE_AUDIO_EVT_NO_VALID_CFG);
	}
}

static void syncable_cb(struct bt_bap_broadcast_sink *sink, bool encrypted)
{
	int ret;
	static uint8_t bis_encryption_key[BT_ISO_BROADCAST_CODE_SIZE] = {0};
	struct bt_bap_stream *audio_streams_p[] = {&audio_streams[active_stream_index]};

	LOG_DBG("Broadcast sink is syncable");

	if (IS_ENABLED(CONFIG_BT_AUDIO_BROADCAST_ENCRYPTED)) {
		memcpy(bis_encryption_key, CONFIG_BT_AUDIO_BROADCAST_ENCRYPTION_KEY,
		       MIN(strlen(CONFIG_BT_AUDIO_BROADCAST_ENCRYPTION_KEY),
			   ARRAY_SIZE(bis_encryption_key)));
	}

	if (active_stream.stream != NULL && active_stream.stream->ep != NULL) {
		if (active_stream.stream->ep->status.state == BT_BAP_EP_STATE_STREAMING) {
			LOG_WRN("Syncable received, but already in a stream");
			return;
		}
	}

	if (paused) {
		LOG_DBG("Syncable received, but in paused state");
		return;
	}

	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Syncing to broadcast stream index %d", active_stream_index);

	if (bis_index_bitfields[active_stream_index] == 0) {
		LOG_ERR("No bits set in bitfield");
		return;
	} else if (!IS_POWER_OF_TWO(bis_index_bitfields[active_stream_index])) {
		/* Check that only one bit is set */
		LOG_ERR("Application syncs to only one stream");
		return;
	}

	ret = bt_bap_broadcast_sink_sync(broadcast_sink, bis_index_bitfields[active_stream_index],
					 audio_streams_p, bis_encryption_key);

	if (ret) {
		LOG_WRN("Unable to sync to broadcast source, ret: %d", ret);
		return;
	}

	/* Only a single stream used for now */
	active_stream.stream = &audio_streams[active_stream_index];

	init_routine_completed = true;
}

static struct bt_bap_broadcast_sink_cb broadcast_sink_cbs = {
	.base_recv = base_recv_cb,
	.syncable = syncable_cb,
};

int broadcast_sink_change_active_audio_stream(void)
{
	int ret;

	if (broadcast_sink == NULL) {
		LOG_WRN("No broadcast sink");
		return -ECANCELED;
	}

	if (active_stream.stream != NULL && active_stream.stream->ep != NULL) {
		if (active_stream.stream->ep->status.state == BT_BAP_EP_STATE_STREAMING) {
			ret = bt_bap_broadcast_sink_stop(broadcast_sink);
			if (ret) {
				LOG_ERR("Failed to stop sink");
			}
		}
	}

	/* Wrap streams */
	if (++active_stream_index >= sync_stream_cnt) {
		active_stream_index = 0;
	}

	active_stream.stream = &audio_streams[active_stream_index];
	active_stream.codec = &audio_codec_info[active_stream_index];

	LOG_INF("Changed to stream %d", active_stream_index);

	return 0;
}

int broadcast_sink_config_get(uint32_t *bitrate, uint32_t *sampling_rate, uint32_t *pres_delay)
{
	if (active_stream.codec == NULL) {
		LOG_WRN("No active stream to get config from");
		return -ENXIO;
	}

	if (bitrate == NULL && sampling_rate == NULL && pres_delay == NULL) {
		LOG_ERR("No valid pointers received");
		return -ENXIO;
	}

	if (sampling_rate != NULL) {
		*sampling_rate = active_stream.codec->frequency;
	}

	if (bitrate != NULL) {
		*bitrate = active_stream.codec->bitrate;
	}

	if (pres_delay != NULL) {
		if (active_stream.stream == NULL) {
			LOG_WRN("No active stream");
			return -ENXIO;
		}

		*pres_delay = active_stream.pd;
	}

	return 0;
}

int broadcast_sink_pa_sync_set(struct bt_le_per_adv_sync *pa_sync, uint32_t broadcast_id)
{
	int ret;

	if (pa_sync == NULL) {
		LOG_ERR("Invalid PA sync received");
		return -EINVAL;
	}

	LOG_DBG("Trying to set PA sync with ID: %d", broadcast_id);

	if (active_stream.stream != NULL && active_stream.stream->ep != NULL) {
		if (active_stream.stream->ep->status.state == BT_BAP_EP_STATE_STREAMING) {
			ret = bt_bap_broadcast_sink_stop(broadcast_sink);
			if (ret) {
				LOG_ERR("Failed to stop broadcast sink: %d", ret);
				return ret;
			}

			broadcast_sink_cleanup();
		}
	}

	/* If broadcast_sink was not in an active stream we still need to clean it up */
	if (broadcast_sink != NULL) {
		broadcast_sink_cleanup();
	}

	ret = bt_bap_broadcast_sink_create(pa_sync, broadcast_id, &broadcast_sink);
	if (ret) {
		LOG_WRN("Failed to create sink: %d", ret);
		return ret;
	}

	pa_sync_stored = pa_sync;

	return 0;
}

int broadcast_sink_start(void)
{
	if (!paused) {
		LOG_WRN("Already playing");
		return -EALREADY;
	}

	paused = false;
	return 0;
}

int broadcast_sink_stop(void)
{
	int ret;

	if (paused) {
		LOG_WRN("Already paused");
		return -EALREADY;
	}

	if (active_stream.stream == NULL || active_stream.stream->ep == NULL) {
		LOG_WRN("Stream or endpoint not set");
		return -EPERM;
	}

	if (active_stream.stream->ep->status.state == BT_BAP_EP_STATE_STREAMING) {
		paused = true;
		ret = bt_bap_broadcast_sink_stop(broadcast_sink);
		if (ret) {
			LOG_ERR("Failed to stop broadcast sink: %d", ret);
			return ret;
		}
	} else {
		LOG_WRN("Current stream not in streaming state");
		return -EALREADY;
	}

	return 0;
}

int broadcast_sink_disable(void)
{
	int ret;

	if (active_stream.stream != NULL && active_stream.stream->ep != NULL) {
		if (active_stream.stream->ep->status.state == BT_BAP_EP_STATE_STREAMING) {
			ret = bt_bap_broadcast_sink_stop(broadcast_sink);
			if (ret) {
				LOG_ERR("Failed to stop sink");
			}
		}
	}

	if (pa_sync_stored != NULL) {
		ret = bt_le_per_adv_sync_delete(pa_sync_stored);
		if (ret) {
			LOG_ERR("Failed to delete pa_sync");
			return ret;
		}
	}

	ret = broadcast_sink_cleanup();
	if (ret) {
		LOG_ERR("Error cleaning up");
		return ret;
	}

	LOG_DBG("Broadcast sink disabled");

	return 0;
}

int broadcast_sink_enable(le_audio_receive_cb recv_cb)
{
	int ret;
	static bool initialized;
	enum audio_channel channel;

	if (initialized) {
		LOG_WRN("Already initialized");
		return -EALREADY;
	}

	if (recv_cb == NULL) {
		LOG_ERR("Receive callback is NULL");
		return -EINVAL;
	}

	receive_cb = recv_cb;

	channel_assignment_get(&channel);

	if (channel == AUDIO_CH_L) {
		ret = bt_pacs_set_location(BT_AUDIO_DIR_SINK, BT_AUDIO_LOCATION_FRONT_LEFT);
	} else {
		ret = bt_pacs_set_location(BT_AUDIO_DIR_SINK, BT_AUDIO_LOCATION_FRONT_RIGHT);
	}

	if (ret) {
		LOG_ERR("Location set failed");
		return ret;
	}

	ret = bt_pacs_cap_register(BT_AUDIO_DIR_SINK, &capabilities);
	if (ret) {
		LOG_ERR("Capability register failed (ret %d)", ret);
		return ret;
	}

	bt_bap_broadcast_sink_register_cb(&broadcast_sink_cbs);

	for (int i = 0; i < ARRAY_SIZE(audio_streams); i++) {
		audio_streams[i].ops = &stream_ops;
	}

	initialized = true;

	LOG_DBG("Broadcast sink enabled");

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_stream/broadcast/broadcast_source.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BROADCAST_SOURCE_H_
#define _BROADCAST_SOURCE_H_

#include "bt_le_audio_tx.h"

/**
 * @brief	Get the data to advertise.
 *
 * @param[out]	ext_adv		Pointer to the pointer of bt_data used for extended advertising.
 * @param[out]	ext_adv_size	Pointer to size of @p ext_adv.
 * @param[out]	per_adv		Pointer to the pointer of bt_data used for periodic advertising.
 * @param[out]	per_adv_size	Pointer to size of @p per_adv.
 */
void broadcast_source_adv_get(const struct bt_data **ext_adv, size_t *ext_adv_size,
			      const struct bt_data **per_adv, size_t *per_adv_size);

/**
 * @brief	Start the Bluetooth LE Audio broadcast (BIS) source.
 *
 * @param[in]	ext_adv		Pointer to the extended advertising set; can be NULL if a stream
 *				is restarted.
 *
 * @return	0 for success, error otherwise.
 */
int broadcast_source_start(struct bt_le_ext_adv *ext_adv);

/**
 * @brief	Stop the Bluetooth LE Audio broadcast (BIS) source.
 *
 * @return	0 for success, error otherwise.
 */
int broadcast_source_stop(void);

/**
 * @brief	Broadcast the Bluetooth LE Audio data.
 *
 * @param[in]	enc_audio	Encoded audio struct.
 *
 * @return	0 for success, error otherwise.
 */
int broadcast_source_send(struct le_audio_encoded_audio enc_audio);

/**
 * @brief	Disable the LE Audio broadcast (BIS) source.
 *
 * @return	0 for success, error otherwise.
 */
int broadcast_source_disable(void);

/**
 * @brief	Enable the LE Audio broadcast (BIS) source.
 *
 * @return	0 for success, error otherwise.
 */
int broadcast_source_enable(void);

#endif /* _BROADCAST_SOURCE_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_management/CMakeLists.txt
#
# Copyright (c) 2023 Nordic Semiconductor
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

zephyr_library_include_directories(
    advertising
    controller_config
    dfu
    scanning
    ${ZEPHYR_BASE}/subsys/bluetooth/host/
)

target_sources(app PRIVATE
	       ${CMAKE_CURRENT_SOURCE_DIR}/bt_mgmt.c
	       ${CMAKE_CURRENT_SOURCE_DIR}/controller_config/bt_mgmt_ctlr_cfg.c
)

if (CONFIG_BT_CENTRAL)
	target_sources(app PRIVATE
		${CMAKE_CURRENT_SOURCE_DIR}/scanning/bt_mgmt_scan_for_conn.c)
endif()

if (CONFIG_BT_BAP_BROADCAST_SINK)
target_sources(app PRIVATE
		${CMAKE_CURRENT_SOURCE_DIR}/scanning/bt_mgmt_scan_for_broadcast.c)
endif()

if (CONFIG_BT_OBSERVER)
target_sources(app PRIVATE
	        ${CMAKE_CURRENT_SOURCE_DIR}/scanning/bt_mgmt_scan.c)
endif()

if (CONFIG_BT_PERIPHERAL OR CONFIG_BT_BROADCASTER)
	target_sources(app PRIVATE
	       ${CMAKE_CURRENT_SOURCE_DIR}/advertising/bt_mgmt_adv.c)
endif()

if (CONFIG_AUDIO_DFU_ENABLE)
	target_sources(app PRIVATE
	       ${CMAKE_CURRENT_SOURCE_DIR}/dfu/bt_mgmt_dfu.c
	)
endif()


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_management/bt_mgmt.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "bt_mgmt.h"

#include <zephyr/zbus/zbus.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/conn.h>
#include <zephyr/bluetooth/hci.h>
#include <zephyr/settings/settings.h>
#include <zephyr/sys/byteorder.h>

#include "macros_common.h"
#include "nrf5340_audio_common.h"
#include "button_handler.h"
#include "button_assignments.h"
#include "bt_mgmt_ctlr_cfg_internal.h"
#include "bt_mgmt_adv_internal.h"

#if defined(CONFIG_AUDIO_DFU_ENABLE)
#include "bt_mgmt_dfu_internal.h"
#endif

#if (CONFIG_BT_LL_ACS_NRF53)
#include "ble_hci_vsc.h"
#endif /* (CONFIG_BT_LL_ACS_NRF53) */

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(bt_mgmt, CONFIG_BT_MGMT_LOG_LEVEL);

ZBUS_CHAN_DEFINE(bt_mgmt_chan, struct bt_mgmt_msg, NULL, NULL, ZBUS_OBSERVERS_EMPTY,
		 ZBUS_MSG_INIT(0));

/* The bt_enable should take less than 15 ms.
 * Buffer added as this will not add to bootup time
 */
#define BT_ENABLE_TIMEOUT_MS 100

#ifndef CONFIG_BT_MAX_CONN
#define MAX_CONN_NUM 0
#else
#define MAX_CONN_NUM CONFIG_BT_MAX_CONN
#endif

K_SEM_DEFINE(sem_bt_enabled, 0, 1);

/**
 * @brief	Iterative function used to find connected conns
 *
 * @param[in]	conn	The connection to check
 * @param[out]	data	Pointer to store number of valid conns
 */
static void conn_state_connected_check(struct bt_conn *conn, void *data)
{
	int ret;
	uint8_t *num_conn = (uint8_t *)data;
	struct bt_conn_info info;

	ret = bt_conn_get_info(conn, &info);
	if (ret) {
		LOG_ERR("Failed to get conn info for %p: %d", (void *)conn, ret);
		return;
	}

	if (info.state != BT_CONN_STATE_CONNECTED) {
		return;
	}

	(*num_conn)++;
}

static void connected_cb(struct bt_conn *conn, uint8_t err)
{
	int ret;
	char addr[BT_ADDR_LE_STR_LEN] = {0};
	uint8_t num_conn = 0;
	struct bt_mgmt_msg msg;

	if (err == BT_HCI_ERR_ADV_TIMEOUT && IS_ENABLED(CONFIG_BT_PERIPHERAL)) {
		LOG_INF("Directed adv timed out with no connection, reverting to normal adv");

		bt_mgmt_dir_adv_timed_out();

		ret = bt_mgmt_adv_start(NULL, 0, NULL, 0, true);
		if (ret) {
			LOG_ERR("Failed to restart advertising: %d", ret);
		}

		return;
	}

	(void)bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));

	if (err) {
		LOG_ERR("ACL connection to addr: %s, conn: %p, failed, error %d", addr,
			(void *)conn, err);

		bt_conn_unref(conn);

		if (IS_ENABLED(CONFIG_BT_CENTRAL)) {
			ret = bt_mgmt_scan_start(0, 0, BT_MGMT_SCAN_TYPE_CONN, NULL,
						 BRDCAST_ID_NOT_USED);
			if (ret && ret != -EALREADY) {
				LOG_ERR("Failed to restart scanning: %d", ret);
			}
		}

		if (IS_ENABLED(CONFIG_BT_PERIPHERAL)) {
			ret = bt_mgmt_adv_start(NULL, 0, NULL, 0, true);
			if (ret) {
				LOG_ERR("Failed to restart advertising: %d", ret);
			}
		}

		return;
	}

	bt_conn_foreach(BT_CONN_TYPE_LE, conn_state_connected_check, (void *)&num_conn);

	/* ACL connection established */
	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Connected: %s", addr);

	if (IS_ENABLED(CONFIG_BT_CENTRAL) && (num_conn < MAX_CONN_NUM)) {
		/* Room for more connections, start scanning again */
		ret = bt_mgmt_scan_start(0, 0, BT_MGMT_SCAN_TYPE_CONN, NULL, BRDCAST_ID_NOT_USED);
		if (ret) {
			LOG_ERR("Failed to resume scanning: %d", ret);
		}
	}

#if (CONFIG_BT_LL_ACS_NRF53)
	enum ble_hci_vs_tx_power conn_tx_pwr;
	uint16_t conn_handle;

	ret = bt_hci_get_conn_handle(conn, &conn_handle);
	if (ret) {
		LOG_ERR("Unable to get conn handle");
	} else {
		if (IS_ENABLED(CONFIG_NRF_21540_ACTIVE)) {
			conn_tx_pwr = CONFIG_NRF_21540_MAIN_DBM;
		} else {
			conn_tx_pwr = CONFIG_BLE_CONN_TX_POWER_DBM;
		}

		ret = ble_hci_vsc_conn_tx_pwr_set(conn_handle, conn_tx_pwr);
		if (ret) {
			LOG_ERR("Failed to set TX power for conn");
		} else {
			LOG_DBG("TX power set to %d dBm for connection %p", conn_tx_pwr,
				(void *)conn);
		}
	}
#endif /* (CONFIG_BT_LL_ACS_NRF53) */

	msg.event = BT_MGMT_CONNECTED;
	msg.conn = conn;

	ret = zbus_chan_pub(&bt_mgmt_chan, &msg, K_NO_WAIT);
	ERR_CHK(ret);

	if (IS_ENABLED(CONFIG_BT_CENTRAL)) {
		ret = bt_conn_set_security(conn, BT_SECURITY_L2);
		if (ret) {
			LOG_ERR("Failed to set security to L2: %d", ret);
		}
	}
}

K_MUTEX_DEFINE(mtx_duplicate_scan);

static void disconnected_cb(struct bt_conn *conn, uint8_t reason)
{
	int ret;
	char addr[BT_ADDR_LE_STR_LEN];
	struct bt_mgmt_msg msg;

	(void)bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));

	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Disconnected: %s (reason 0x%02x)", addr, reason);

	if (IS_ENABLED(CONFIG_BT_CENTRAL)) {
		bt_conn_unref(conn);
	}

	/* Publish disconnected */
	msg.event = BT_MGMT_DISCONNECTED;
	msg.conn = conn;

	ret = zbus_chan_pub(&bt_mgmt_chan, &msg, K_NO_WAIT);
	ERR_CHK(ret);

	if (IS_ENABLED(CONFIG_BT_PERIPHERAL)) {
		ret = bt_mgmt_adv_start(NULL, 0, NULL, 0, true);
		ERR_CHK(ret);
	}

	/* The mutex for preventing the racing condition if two headset disconnected too close,
	 * cause the disconnected_cb() triggered in short time leads to duplicate scanning
	 * operation.
	 */
	k_mutex_lock(&mtx_duplicate_scan, K_FOREVER);
	if (IS_ENABLED(CONFIG_BT_CENTRAL)) {
		ret = bt_mgmt_scan_start(0, 0, BT_MGMT_SCAN_TYPE_CONN, NULL, BRDCAST_ID_NOT_USED);
		if (ret && ret != -EALREADY) {
			LOG_ERR("Failed to restart scanning: %d", ret);
		}
	}
	k_mutex_unlock(&mtx_duplicate_scan);
}

#if defined(CONFIG_BT_SMP)
static void security_changed_cb(struct bt_conn *conn, bt_security_t level, enum bt_security_err err)
{
	int ret;
	struct bt_mgmt_msg msg;

	if (err) {
		LOG_WRN("Security failed: level %d err %d", level, err);
		ret = bt_conn_disconnect(conn, err);
		if (ret) {
			LOG_WRN("Failed to disconnect %d", ret);
		}
	} else {
		LOG_DBG("Security changed: level %d", level);
		/* Publish connected */
		msg.event = BT_MGMT_SECURITY_CHANGED;
		msg.conn = conn;

		ret = zbus_chan_pub(&bt_mgmt_chan, &msg, K_NO_WAIT);
		ERR_CHK(ret);
	}
}
#endif /* defined(CONFIG_BT_SMP) */

static struct bt_conn_cb conn_callbacks = {
	.connected = connected_cb,
	.disconnected = disconnected_cb,
#if defined(CONFIG_BT_SMP)
	.security_changed = security_changed_cb,
#endif /* defined(CONFIG_BT_SMP) */
};

static void bt_enabled_cb(int err)
{
	if (err) {
		LOG_ERR("Bluetooth init failed (err code: %d)", err);
		ERR_CHK(err);
	}

	k_sem_give(&sem_bt_enabled);

	LOG_DBG("Bluetooth initialized");
}

static int bonding_clear_check(void)
{
	int ret;
	bool pressed;

	ret = button_pressed(BUTTON_5, &pressed);
	if (ret) {
		return ret;
	}

	if (pressed) {
		ret = bt_mgmt_bonding_clear();
		return ret;
	}

	return 0;
}

static int ficr_static_addr_set(void)
{
	int ret;
	static bt_addr_le_t addr;

	if ((NRF_FICR->INFO.DEVICEID[0] != UINT32_MAX) ||
	    ((NRF_FICR->INFO.DEVICEID[1] & UINT16_MAX) != UINT16_MAX)) {
		/* Put the device ID from FICR into address */
		sys_put_le32(NRF_FICR->INFO.DEVICEID[0], &addr.a.val[0]);
		sys_put_le16(NRF_FICR->INFO.DEVICEID[1], &addr.a.val[4]);

		/* The FICR value is a just a random number, with no knowledge
		 * of the Bluetooth Specification requirements for random
		 * static addresses.
		 */
		BT_ADDR_SET_STATIC(&addr.a);

		addr.type = BT_ADDR_LE_RANDOM;

		ret = bt_id_create(&addr, NULL);
		if (ret < 0) {
			LOG_ERR("Failed to create ID %d", ret);
			return ret;
		}

		return 0;
	}

	/* If no address can be created (e.g. based on
	 * FICR), then a random address is created
	 */
	LOG_WRN("Unable to read from FICR");

	return 0;
}

/* This function generates a random address for bonding testing */
static int random_static_addr_set(void)
{
	int ret;
	static bt_addr_le_t addr;

	ret = bt_addr_le_create_static(&addr);
	if (ret < 0) {
		LOG_ERR("Failed to create address %d", ret);
		return ret;
	}

	ret = bt_id_create(&addr, NULL);
	if (ret < 0) {
		LOG_ERR("Failed to create ID %d", ret);
		return ret;
	}

	return 0;
}

static int local_identity_addr_print(void)
{
	size_t num_ids = 0;
	bt_addr_le_t addrs[CONFIG_BT_ID_MAX];
	char addr_str[BT_ADDR_LE_STR_LEN];

	bt_id_get(NULL, &num_ids);
	if (num_ids != CONFIG_BT_ID_MAX) {
		LOG_ERR("The default config supports %d ids, but %d was found", CONFIG_BT_ID_MAX,
			num_ids);
		return -ENOMEM;
	}

	bt_id_get(addrs, &num_ids);

	for (int i = 0; i < num_ids; i++) {
		(void)bt_addr_le_to_str(&(addrs[i]), addr_str, BT_ADDR_LE_STR_LEN);
		LOG_INF("Local identity addr: %s", addr_str);
	}

	return 0;
}

int bt_mgmt_bonding_clear(void)
{
	int ret;

	if (IS_ENABLED(CONFIG_SETTINGS)) {
		LOG_INF("Clearing all bonds");

		ret = bt_unpair(BT_ID_DEFAULT, NULL);
		if (ret) {
			LOG_ERR("Failed to clear bonding: %d", ret);
			return ret;
		}
	}

	return 0;
}

int bt_mgmt_pa_sync_delete(struct bt_le_per_adv_sync *pa_sync)
{
	if (IS_ENABLED(CONFIG_BT_PER_ADV_SYNC)) {
		int ret;

		ret = bt_le_per_adv_sync_delete(pa_sync);
		if (ret) {
			LOG_ERR("Failed to delete PA sync");
			return ret;
		}
	} else {
		LOG_WRN("Periodic advertisement sync not enabled");
		return -ENOTSUP;
	}

	return 0;
}

int bt_mgmt_conn_disconnect(struct bt_conn *conn, uint8_t reason)
{
	if (IS_ENABLED(CONFIG_BT_CONN)) {
		int ret;

		ret = bt_conn_disconnect(conn, reason);
		if (ret) {
			LOG_ERR("Failed to disconnect connection %p (%d)", (void *)conn, ret);
			return ret;
		}
	} else {
		LOG_WRN("BT conn not enabled");
		return -ENOTSUP;
	}

	return 0;
}

int bt_mgmt_init(void)
{
	int ret;

	if (!IS_ENABLED(CONFIG_BT_PRIVACY)) {
		ret = ficr_static_addr_set();
		if (ret) {
			return ret;
		}
	}

	ret = bt_enable(bt_enabled_cb);
	if (ret) {
		return ret;
	}

	ret = k_sem_take(&sem_bt_enabled, K_MSEC(BT_ENABLE_TIMEOUT_MS));
	if (ret) {
		LOG_ERR("bt_enable timed out");
		return ret;
	}

	if (IS_ENABLED(CONFIG_TESTING_BLE_ADDRESS_RANDOM)) {
		ret = random_static_addr_set();
		if (ret) {
			return ret;
		}
	}

	if (IS_ENABLED(CONFIG_SETTINGS)) {
		ret = settings_load();
		if (ret) {
			return ret;
		}

		ret = bonding_clear_check();
		if (ret) {
			return ret;
		}

		if (IS_ENABLED(CONFIG_TESTING_BLE_ADDRESS_RANDOM)) {
			ret = bt_mgmt_bonding_clear();
			if (ret) {
				return ret;
			}
		}
	}

#if defined(CONFIG_AUDIO_DFU_ENABLE)
	bool pressed;

	ret = button_pressed(BUTTON_4, &pressed);
	if (ret) {
		return ret;
	}

	if (pressed) {
		ret = bt_mgmt_ctlr_cfg_init(false);
		if (ret) {
			return ret;
		}
		/* This call will not return */
		bt_mgmt_dfu_start();
	}
#endif

	ret = bt_mgmt_ctlr_cfg_init(IS_ENABLED(CONFIG_WDT_CTLR));
	if (ret) {
		return ret;
	}

	ret = local_identity_addr_print();
	if (ret) {
		return ret;
	}

	if (IS_ENABLED(CONFIG_BT_CONN)) {
		bt_conn_cb_register(&conn_callbacks);
	}

	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) || IS_ENABLED(CONFIG_BT_BROADCASTER)) {
		bt_mgmt_adv_init();
	}

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_management/Kconfig
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

menu "BT management"

rsource "controller_config/Kconfig"

#----------------------------------------------------------------------------#
menu "Power control"

config BLE_LE_POWER_CONTROL_ENABLED
	bool "Enable the Bluetooth LE power control feature"
	default n
	help
	  The Bluetooth LE power control feature makes devices be able to change TX power
	  dynamically and automatically during connection, which may reduce power consumption.

config WDT_CTLR
	bool "Enable watchdog for controller"
	default y
	help
	  When true, the controller will be polled at regular intervals to check that it is alive.
	  Turn off to reduce overhead, or HCI traffic.
	  The watchdog will be deactivated automatically for DFU procedures.

choice	BLE_CONN_TX_POWER
	prompt "Default TX power for the Bluetooth LE connections"
	default BLE_CONN_TX_POWER_0DBM
	help
	  Set the default TX power for Bluetooth LE connections.

config BLE_CONN_TX_POWER_0DBM
	bool "0dBm"

config BLE_CONN_TX_POWER_NEG_1DBM
	bool "-1dBm"

config BLE_CONN_TX_POWER_NEG_2DBM
	bool "-2dBm"

config BLE_CONN_TX_POWER_NEG_3DBM
	bool "-3dBm"

config BLE_CONN_TX_POWER_NEG_4DBM
	bool "-4dBm"

config BLE_CONN_TX_POWER_NEG_5DBM
	bool "-5dBm"

config BLE_CONN_TX_POWER_NEG_6DBM
	bool "-6dBm"

config BLE_CONN_TX_POWER_NEG_7DBM
	bool "-7dBm"

config BLE_CONN_TX_POWER_NEG_8DBM
	bool "-8dBm"

config BLE_CONN_TX_POWER_NEG_12DBM
	bool "-12dBm"

config BLE_CONN_TX_POWER_NEG_16DBM
	bool "-14dBm"

config BLE_CONN_TX_POWER_NEG_20DBM
	bool "-20dBm"

config BLE_CONN_TX_POWER_NEG_40DBM
	bool "-40dBm"

endchoice

config BLE_CONN_TX_POWER_DBM
	int
	default 0 if BLE_CONN_TX_POWER_0DBM
	default -1 if BLE_CONN_TX_POWER_NEG_1DBM
	default -2 if BLE_CONN_TX_POWER_NEG_2DBM
	default -3 if BLE_CONN_TX_POWER_NEG_3DBM
	default -4 if BLE_CONN_TX_POWER_NEG_4DBM
	default -5 if BLE_CONN_TX_POWER_NEG_5DBM
	default -6 if BLE_CONN_TX_POWER_NEG_6DBM
	default -7 if BLE_CONN_TX_POWER_NEG_7DBM
	default -8 if BLE_CONN_TX_POWER_NEG_8DBM
	default -12 if BLE_CONN_TX_POWER_NEG_12DBM
	default -16 if BLE_CONN_TX_POWER_NEG_16DBM
	default -20 if BLE_CONN_TX_POWER_NEG_20DBM
	default -40 if BLE_CONN_TX_POWER_NEG_40DBM

choice	BLE_ADV_TX_POWER
	prompt "Default TX power for the Bluetooth LE advertising"
	default BLE_ADV_TX_POWER_0DBM
	help
	  Set the default TX power for the Bluetooth LE advertising.

config BLE_ADV_TX_POWER_0DBM
	bool "0dBm"

config BLE_ADV_TX_POWER_NEG_1DBM
	bool "-1dBm"

config BLE_ADV_TX_POWER_NEG_2DBM
	bool "-2dBm"

config BLE_ADV_TX_POWER_NEG_3DBM
	bool "-3dBm"

config BLE_ADV_TX_POWER_NEG_4DBM
	bool "-4dBm"

config BLE_ADV_TX_POWER_NEG_5DBM
	bool "-5dBm"

config BLE_ADV_TX_POWER_NEG_6DBM
	bool "-6dBm"

config BLE_ADV_TX_POWER_NEG_7DBM
	bool "-7dBm"

config BLE_ADV_TX_POWER_NEG_8DBM
	bool "-8dBm"

config BLE_ADV_TX_POWER_NEG_12DBM
	bool "-12dBm"

config BLE_ADV_TX_POWER_NEG_16DBM
	bool "-14dBm"

config BLE_ADV_TX_POWER_NEG_20DBM
	bool "-20dBm"

config BLE_ADV_TX_POWER_NEG_40DBM
	bool "-40dBm"

endchoice

config BLE_ADV_TX_POWER_DBM
	int
	default 0 if BLE_ADV_TX_POWER_0DBM
	default -1 if BLE_ADV_TX_POWER_NEG_1DBM
	default -2 if BLE_ADV_TX_POWER_NEG_2DBM
	default -3 if BLE_ADV_TX_POWER_NEG_3DBM
	default -4 if BLE_ADV_TX_POWER_NEG_4DBM
	default -5 if BLE_ADV_TX_POWER_NEG_5DBM
	default -6 if BLE_ADV_TX_POWER_NEG_6DBM
	default -7 if BLE_ADV_TX_POWER_NEG_7DBM
	default -8 if BLE_ADV_TX_POWER_NEG_8DBM
	default -12 if BLE_ADV_TX_POWER_NEG_12DBM
	default -16 if BLE_ADV_TX_POWER_NEG_16DBM
	default -20 if BLE_ADV_TX_POWER_NEG_20DBM
	default -40 if BLE_ADV_TX_POWER_NEG_40DBM

endmenu # Power control

menu "Thread priorities"

config CTLR_POLL_WORK_Q_PRIO
	int "Work queue priority for controller poll"
	default 6
	help
	  This is a preemptible work queue.
	  This work queue will poll the controller to check it is alive.

endmenu # Thread priorities

rsource "dfu/Kconfig"
rsource "advertising/Kconfig"
rsource "scanning/Kconfig"

#----------------------------------------------------------------------------#
menu "Log level"

module = BT_MGMT
module-str = bt-mgmt
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log level
endmenu # BT management


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_management/bt_mgmt.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BT_MGMT_H_
#define _BT_MGMT_H_

#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/conn.h>
#include <zephyr/bluetooth/audio/audio.h>

#define LE_AUDIO_EXTENDED_ADV_NAME                                                                 \
	BT_LE_ADV_PARAM(BT_LE_ADV_OPT_EXT_ADV | BT_LE_ADV_OPT_USE_NAME,                            \
			CONFIG_BLE_ACL_EXT_ADV_INT_MIN, CONFIG_BLE_ACL_EXT_ADV_INT_MAX, NULL)

#define LE_AUDIO_EXTENDED_ADV_CONN_NAME                                                            \
	BT_LE_ADV_PARAM(BT_LE_ADV_OPT_EXT_ADV | BT_LE_ADV_OPT_CONNECTABLE |                        \
				BT_LE_ADV_OPT_USE_NAME,                                            \
			CONFIG_BLE_ACL_EXT_ADV_INT_MIN, CONFIG_BLE_ACL_EXT_ADV_INT_MAX, NULL)

#define LE_AUDIO_EXTENDED_ADV_CONN_NAME_FILTER                                                     \
	BT_LE_ADV_PARAM(BT_LE_ADV_OPT_EXT_ADV | BT_LE_ADV_OPT_CONNECTABLE |                        \
				BT_LE_ADV_OPT_USE_NAME | BT_LE_ADV_OPT_FILTER_CONN,                \
			CONFIG_BLE_ACL_EXT_ADV_INT_MIN, CONFIG_BLE_ACL_EXT_ADV_INT_MAX, NULL)

#define LE_AUDIO_PERIODIC_ADV                                                                      \
	BT_LE_PER_ADV_PARAM(CONFIG_BLE_ACL_PER_ADV_INT_MIN, CONFIG_BLE_ACL_PER_ADV_INT_MAX,        \
			    BT_LE_PER_ADV_OPT_NONE)

#define BT_LE_ADV_FAST_CONN                                                                        \
	BT_LE_ADV_PARAM(BT_LE_ADV_OPT_CONNECTABLE, BT_GAP_ADV_FAST_INT_MIN_1,                      \
			BT_GAP_ADV_FAST_INT_MAX_1, NULL)

/* Broadcast name can be max 32 bytes long, so this will be the limit for both.
 * Add one for '\0' at the end.
 */
#define BLE_SEARCH_NAME_MAX_LEN 33

#if (CONFIG_SCAN_MODE_ACTIVE)
#define NRF5340_AUDIO_GATEWAY_SCAN_TYPE	  BT_LE_SCAN_TYPE_ACTIVE
#define NRF5340_AUDIO_GATEWAY_SCAN_PARAMS BT_LE_SCAN_ACTIVE
#elif (CONFIG_SCAN_MODE_PASSIVE)
#define NRF5340_AUDIO_GATEWAY_SCAN_TYPE	  BT_LE_SCAN_TYPE_PASSIVE
#define NRF5340_AUDIO_GATEWAY_SCAN_PARAMS BT_LE_SCAN_PASSIVE
#else
#error "Select either CONFIG_SCAN_MODE_ACTIVE or CONFIG_SCAN_MODE_PASSIVE"
#endif

enum bt_mgmt_scan_type {
	BT_MGMT_SCAN_TYPE_CONN = 1,
	BT_MGMT_SCAN_TYPE_BROADCAST = 2,
};

#define BRDCAST_ID_NOT_USED (BT_AUDIO_BROADCAST_ID_MAX + 1)

/**
 * @brief	Start scanning for advertisements.
 *
 * @param[in]	scan_intvl	Scan interval in units of 0.625ms.
 *				Valid range: 0x4 - 0xFFFF; can be 0.
 * @param[in]	scan_win	Scan window in units of 0.625ms.
 *				Valid range: 0x4 - 0xFFFF; can be 0.
 * @param[in]	type		Type to scan for: ACL connection or broadcaster.
 * @param[in]	name		Name to search for. Depending on @p type of search,
 *				device name or broadcast name. Can be max
 *				BLE_SEARCH_NAME_MAX_LEN long; everything beyond that value
 *				will be cropped. Can be NULL. Shall be '\0' terminated.
 * @param[in]	brdcast_id	Broadcast ID to search for. Only valid if @p type is
 *				BT_MGMT_SCAN_TYPE_BROADCAST. If both @p name and @p brdcast_id are
 *				provided, then brdcast_id will be used.
 *				Set to BRDCAST_ID_NOT_USED if not in use.
 *
 * @note	To restart scanning, call this function with all 0s and NULL, except for @p type.
 *		The same scanning parameters as when bt_mgmt_scan_start was last called will then
 *		be used.
 *
 * @return	0 if success, error otherwise.
 */
int bt_mgmt_scan_start(uint16_t scan_intvl, uint16_t scan_win, enum bt_mgmt_scan_type type,
		       char const *const name, uint32_t brdcast_id);
/**
 * @brief	Create and start advertising for ACL connection.
 *
 * @param[in]	ext_adv		The data to be put in the extended advertisement.
 * @param[in]	ext_adv_size	Size of @p ext_adv.
 * @param[in]	per_adv		The data for the periodic advertisement; can be NULL.
 * @param[in]	per_adv_size	Size of @p per_adv.
 * @param[in]	connectable	Specify if advertisement should be connectable or not.
 *
 * @note	To restart advertising, call this function with all 0s and NULL, except for
 *		connectable. The same advertising parameters as when bt_mgmt_adv_start was last
 *		called will then be used.
 *
 * @return	0 if success, error otherwise.
 */
int bt_mgmt_adv_start(const struct bt_data *ext_adv, size_t ext_adv_size,
		      const struct bt_data *per_adv, size_t per_adv_size, bool connectable);

/**
 * @brief	Clear all bonded devices.
 *
 * @return	0 if success, error otherwise.
 */
int bt_mgmt_bonding_clear(void);

/**
 * @brief	Delete a periodic advertisement sync.
 *
 * @param[in]	pa_sync	Pointer to the periodic advertisement sync to delete.
 *
 * @return	0 if success, error otherwise.
 */
int bt_mgmt_pa_sync_delete(struct bt_le_per_adv_sync *pa_sync);

/**
 * @brief	Disconnect from a remote device or cancel the pending connection.
 *
 * @param[in]	conn	Connection to disconnect.
 * @param[in]	reason	Reason code for the disconnection, as specified in
 *			HCI Error Codes, BT Core Spec v5.4 [Vol 1, Part F].
 *
 * @return	0 if success, error otherwise.
 */
int bt_mgmt_conn_disconnect(struct bt_conn *conn, uint8_t reason);

/**
 * @brief	Initialize the Bluetooth management module.
 *
 * @return	0 if success, error otherwise.
 */
int bt_mgmt_init(void);

#endif /* _BT_MGMT_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_management/dfu/Kconfig
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

menu "DFU"

#----------------------------------------------------------------------------#
menu "Log level"

module = BT_MGMT_DFU
module-str = bt-mgmt-dfu
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log level
endmenu # DFU


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_management/dfu/bt_mgmt_dfu.c
/*
 * Copyright (c) 2022 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

/* Override compiler definition to use size-bounded string copying and concatenation function */
#define _BSD_SOURCE
#include "bt_mgmt_dfu_internal.h"

#include <zephyr/kernel.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/conn.h>

#include "string.h"
#include "macros_common.h"
#include "channel_assignment.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(bt_mgmt_dfu, CONFIG_BT_MGMT_DFU_LOG_LEVEL);

/* These defined name only used by DFU */
#define DEVICE_NAME_DFU	    CONFIG_BT_DFU_DEVICE_NAME
#define DEVICE_NAME_DFU_LEN (sizeof(DEVICE_NAME_DFU) - 1)

/* Advertising data for SMP_SVR UUID */
static struct bt_le_adv_param adv_param;
static const struct bt_data ad_peer[] = {
	BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)),
	BT_DATA_BYTES(BT_DATA_UUID128_ALL, 0x84, 0xaa, 0x60, 0x74, 0x52, 0x8a, 0x8b, 0x86, 0xd3,
		      0x4c, 0xb7, 0x1d, 0x1d, 0xdc, 0x53, 0x8d),
};

static void smp_adv(void)
{
	int ret;

	ret = bt_le_adv_start(&adv_param, ad_peer, ARRAY_SIZE(ad_peer), NULL, 0);
	if (ret) {
		LOG_ERR("SMP_SVR Advertising failed to start (ret %d)", ret);
		return;
	}

	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Regular SMP_SVR advertising started");
}

/* These callbacks are to override callback registed in module le_audio_ */
static void dfu_connected_cb(struct bt_conn *conn, uint8_t err)
{
	LOG_INF("SMP connected\n");
}

static void dfu_disconnected_cb(struct bt_conn *conn, uint8_t reason)
{
	LOG_INF("SMP disconnected 0x%02x\n", reason);
}

static struct bt_conn_cb dfu_conn_callbacks = {
	.connected = dfu_connected_cb,
	.disconnected = dfu_disconnected_cb,
};

static void dfu_set_bt_name(void)
{
	char name[CONFIG_BT_DEVICE_NAME_MAX] = {0};

	strlcpy(name, CONFIG_BT_DEVICE_NAME, CONFIG_BT_DEVICE_NAME_MAX);
	strlcat(name, "_", CONFIG_BT_DEVICE_NAME_MAX);
#if (CONFIG_AUDIO_DEV == GATEWAY)
	strlcat(name, GW_TAG, CONFIG_BT_DEVICE_NAME_MAX);
#else
	enum audio_channel channel;

	channel_assignment_get(&channel);

	if (channel == AUDIO_CH_L) {
		strlcat(name, CH_L_TAG, CONFIG_BT_DEVICE_NAME_MAX);
	} else {
		strlcat(name, CH_R_TAG, CONFIG_BT_DEVICE_NAME_MAX);
	}

#endif
	strlcat(name, "_DFU", CONFIG_BT_DEVICE_NAME_MAX);
	bt_set_name(name);
}

void bt_mgmt_dfu_start(void)
{
	LOG_INF("Entering SMP server mode");

	bt_conn_cb_register(&dfu_conn_callbacks);
	adv_param = *BT_LE_ADV_CONN_NAME;
	dfu_set_bt_name();
	smp_adv();

	while (1) {
		k_sleep(K_MSEC(100));
	}
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_management/dfu/bt_mgmt_dfu_internal.h
/*
 * Copyright (c) 2022 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BT_MGMT_DFU_INTERNAL_H_
#define _BT_MGMT_DFU_INTERNAL_H_

/**
 * @brief Enter the DFU mode. Advertise the SMP_SVR service only.
 *
 * @note This call does not return.
 */
void bt_mgmt_dfu_start(void);

#endif /* _BT_MGMT_DFU_INTERNAL_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_management/scanning/bt_mgmt_scan_for_conn_internal.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BT_MGMT_SCAN_FOR_CONN_INTERNAL_H_
#define _BT_MGMT_SCAN_FOR_CONN_INTERNAL_H_

#include <zephyr/bluetooth/bluetooth.h>

/**
 * @brief	Scan for a connection with the given device @p name.
 *
 * @param[in]	scan_param	Scan parameters to use.
 * @param[in]	name		Device name to search for.
 *
 * @return	0 if success, error otherwise.
 */
int bt_mgmt_scan_for_conn_start(struct bt_le_scan_param *scan_param, char const *const name);

#endif /* _BT_MGMT_SCAN_FOR_CONN_INTERNAL_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_management/scanning/Kconfig.defaults
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

if BT_OBSERVER

config BT_BACKGROUND_SCAN_INTERVAL
	default 32

config BT_BACKGROUND_SCAN_WINDOW
	default 32

endif # BT_OBSERVER

config BT_SCAN_WITH_IDENTITY
	default y


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_management/scanning/Kconfig
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

rsource "Kconfig.defaults"

menu "Scanning"

choice NRF5340_AUDIO_GATEWAY_SCAN_MODE
	prompt "Select Scan Mode to find Unicast Headset"
	default SCAN_MODE_PASSIVE

config SCAN_MODE_PASSIVE
	bool "Passive Scan"

config SCAN_MODE_ACTIVE
	bool "Active Scan"

endchoice

#----------------------------------------------------------------------------#
menu "Connection"

config BLE_ACL_CONN_INTERVAL
	int "Bluetooth LE ACL Connection Interval (x*1.25ms)"
	default 32
	help
	  When the LE Audio Controller Subsystem for nRF53 is used, this
	  interval should be a multiple of the ISO interval and maximum 4x
	  larger than the lowest interval.

config BLE_ACL_SLAVE_LATENCY
	int "Bluetooth LE Slave Latency"
	default 0

config BLE_ACL_SUP_TIMEOUT
	int "Bluetooth LE Supervision Timeout (x*10ms)"
	default 100

endmenu # Connection

#----------------------------------------------------------------------------#
menu "Log level"

module = BT_MGMT_SCAN
module-str = bt-mgmt-scan
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log level
endmenu # Scanning


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_management/scanning/bt_mgmt_scan_for_broadcast_internal.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BT_MGMT_SCAN_FOR_BROADCAST_INTERNAL_H_
#define _BT_MGMT_SCAN_FOR_BROADCAST_INTERNAL_H_

#include <zephyr/bluetooth/bluetooth.h>

/**
 * @brief	Scan for a broadcaster with the given @p name.
 *
 * @param[in]	scan_param	Pointer to the struct containing parameters to use.
 * @param[in]	name		Broadcast name to search for.
 * @param[in]	brdcast_id	Broadcast ID to search for.
 *
 * @return	0 if success, error otherwise.
 */
int bt_mgmt_scan_for_broadcast_start(struct bt_le_scan_param *scan_param, char const *const name,
				     uint32_t brdcast_id);

#endif /* _BT_MGMT_SCAN_FOR_BROADCAST_INTERNAL_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_management/scanning/bt_mgmt_scan.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "bt_mgmt.h"

#include <zephyr/bluetooth/bluetooth.h>
#include <hci_core.h>

#include "bt_mgmt_scan_for_broadcast_internal.h"
#include "bt_mgmt_scan_for_conn_internal.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(bt_mgmt_scan, CONFIG_BT_MGMT_SCAN_LOG_LEVEL);

static char srch_name[BLE_SEARCH_NAME_MAX_LEN];

static void addr_print(void)
{
	char addr_str[BT_ADDR_LE_STR_LEN];
	static struct bt_le_oob _oob = {.addr = 0};

	/* NOTE: We are using an internal struct here to get the address without forcing the
	 * RPA to time out, should be changed once k_forever bug (DRGN-21459) has been fixed
	 */
	bt_addr_le_copy(&_oob.addr, &bt_dev.random_addr);

	(void)bt_addr_le_to_str(&_oob.addr, addr_str, BT_ADDR_LE_STR_LEN);
	LOG_INF("Local addr: %s. May time out. Updates not printed", addr_str);
}

int bt_mgmt_scan_start(uint16_t scan_intvl, uint16_t scan_win, enum bt_mgmt_scan_type type,
		       char const *const name, uint32_t brdcast_id)
{
	int ret;

	static int scan_interval = CONFIG_BT_BACKGROUND_SCAN_INTERVAL;
	static int scan_window = CONFIG_BT_BACKGROUND_SCAN_WINDOW;

	/* Only change search name if a new name has been supplied */
	if (name != NULL) {
		size_t name_size = MIN(strlen(name), BLE_SEARCH_NAME_MAX_LEN - 1);

		memcpy(srch_name, name, name_size);
		srch_name[name_size] = '\0';
	}

	if (scan_intvl != 0) {
		scan_interval = scan_intvl;
	}

	if (scan_win != 0) {
		scan_window = scan_win;
	}

	struct bt_le_scan_param *scan_param =
		BT_LE_SCAN_PARAM(NRF5340_AUDIO_GATEWAY_SCAN_TYPE, BT_LE_SCAN_OPT_FILTER_DUPLICATE,
				 scan_interval, scan_window);

	if (type == BT_MGMT_SCAN_TYPE_CONN && IS_ENABLED(CONFIG_BT_CENTRAL)) {
		ret = bt_mgmt_scan_for_conn_start(scan_param, srch_name);
	} else if (type == BT_MGMT_SCAN_TYPE_BROADCAST &&
		   IS_ENABLED(CONFIG_BT_BAP_BROADCAST_SINK)) {
		ret = bt_mgmt_scan_for_broadcast_start(scan_param, srch_name, brdcast_id);
	} else {
		LOG_WRN("Invalid scan type: %d, scan not started", type);
		return -EINVAL;
	}

	if (ret) {
		return ret;
	}

	addr_print();

	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Scanning successfully started");
	return 0;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_management/scanning/bt_mgmt_scan_for_conn.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "bt_mgmt_scan_for_conn_internal.h"

#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/conn.h>

#include "bt_mgmt.h"

#include <zephyr/logging/log.h>
LOG_MODULE_DECLARE(bt_mgmt_scan);

#define CONNECTION_PARAMETERS                                                                      \
	BT_LE_CONN_PARAM(CONFIG_BLE_ACL_CONN_INTERVAL, CONFIG_BLE_ACL_CONN_INTERVAL,               \
			 CONFIG_BLE_ACL_SLAVE_LATENCY, CONFIG_BLE_ACL_SUP_TIMEOUT)

static uint8_t bonded_num;
static struct bt_le_scan_cb scan_callback;
static bool cb_registered;
static char const *srch_name;

static void bond_check(const struct bt_bond_info *info, void *user_data)
{
	char addr_buf[BT_ADDR_LE_STR_LEN];

	bt_addr_le_to_str(&info->addr, addr_buf, BT_ADDR_LE_STR_LEN);

	LOG_DBG("Stored bonding found: %s", addr_buf);
	bonded_num++;
}

static void bond_connect(const struct bt_bond_info *info, void *user_data)
{
	int ret;
	const bt_addr_le_t *adv_addr = user_data;
	struct bt_conn *conn;
	char addr_string[BT_ADDR_LE_STR_LEN];

	if (!bt_addr_le_cmp(&info->addr, adv_addr)) {
		LOG_DBG("Found bonded device");

		/* Check if the device is still connected due to waiting for ACL timeout */
		struct bt_conn *bonded_conn = bt_conn_lookup_addr_le(BT_ID_DEFAULT, &info->addr);
		struct bt_conn_info info;

		if (bonded_conn != NULL) {
			ret = bt_conn_get_info(bonded_conn, &info);
			if (ret == 0 && info.state == BT_CONN_STATE_CONNECTED) {
				LOG_DBG("Trying to connect to an already connected conn");
				bt_conn_unref(bonded_conn);
				return;
			}

			/* Unref is needed due to bt_conn_lookup */
			bt_conn_unref(bonded_conn);
		}

		bt_le_scan_cb_unregister(&scan_callback);
		cb_registered = false;

		ret = bt_le_scan_stop();
		if (ret) {
			LOG_WRN("Stop scan failed: %d", ret);
		}

		bt_addr_le_to_str(adv_addr, addr_string, BT_ADDR_LE_STR_LEN);

		LOG_INF("Creating connection to bonded device: %s", addr_string);

		ret = bt_conn_le_create(adv_addr, BT_CONN_LE_CREATE_CONN, CONNECTION_PARAMETERS,
					&conn);
		if (ret) {
			LOG_WRN("Create ACL connection failed: %d", ret);

			ret = bt_mgmt_scan_start(0, 0, BT_MGMT_SCAN_TYPE_CONN, NULL,
						 BRDCAST_ID_NOT_USED);
			if (ret) {
				LOG_ERR("Failed to restart scanning: %d", ret);
			}
		}
	}
}

/**
 * @brief	Check the advertising data for the matching device name.
 *
 * @param[in]	data		The advertising data to be checked.
 * @param[in]	user_data	The user data that contains the pointer to the address.
 *
 * @retval	false	Stop going through adv data.
 * @retval	true	Continue checking the data.
 */
static bool device_name_check(struct bt_data *data, void *user_data)
{
	int ret;
	bt_addr_le_t *addr = user_data;
	struct bt_conn *conn;
	char addr_string[BT_ADDR_LE_STR_LEN];

	/* We only care about LTVs with name */
	if (data->type == BT_DATA_NAME_COMPLETE) {
		size_t srch_name_size = strlen(srch_name);

		if ((data->data_len == srch_name_size) &&
		    (strncmp(srch_name, data->data, srch_name_size) == 0)) {
			LOG_DBG("Device found: %s", srch_name);

			bt_le_scan_cb_unregister(&scan_callback);
			cb_registered = false;

			ret = bt_le_scan_stop();
			if (ret) {
				LOG_ERR("Stop scan failed: %d", ret);
			}

			bt_addr_le_to_str(addr, addr_string, BT_ADDR_LE_STR_LEN);

			LOG_INF("Creating connection to device: %s", addr_string);

			ret = bt_conn_le_create(addr, BT_CONN_LE_CREATE_CONN, CONNECTION_PARAMETERS,
						&conn);
			if (ret) {
				LOG_ERR("Could not init connection");

				ret = bt_mgmt_scan_start(0, 0, BT_MGMT_SCAN_TYPE_CONN, NULL,
							 BRDCAST_ID_NOT_USED);
				if (ret) {
					LOG_ERR("Failed to restart scanning: %d", ret);
				}
			}

			return false;
		}
	}

	return true;
}

/**
 * @brief	Callback handler for scan receive when scanning for connections.
 *
 * @param[in]	info	Advertiser packet and scan response information.
 * @param[in]	ad	Received advertising data.
 */
static void scan_recv_cb(const struct bt_le_scan_recv_info *info, struct net_buf_simple *ad)
{

	/* We only care about connectable advertisers */
	if (!(info->adv_props & BT_GAP_ADV_PROP_CONNECTABLE)) {
		return;
	}

	switch (info->adv_type) {
	case BT_GAP_ADV_TYPE_ADV_DIRECT_IND:
		/* Direct advertising has no payload, so no need to parse */
		bt_foreach_bond(BT_ID_DEFAULT, bond_connect, (void *)info->addr);
		break;
	case BT_GAP_ADV_TYPE_ADV_IND:
		/* Fall through */
	case BT_GAP_ADV_TYPE_EXT_ADV:
		/* Fall through */
	case BT_GAP_ADV_TYPE_SCAN_RSP:
		/* Note: May lead to connection creation */
		if (bonded_num < CONFIG_BT_MAX_PAIRED) {
			bt_data_parse(ad, device_name_check, (void *)info->addr);
		} else {
			/* All bonded slots are taken, so we will only
			 * accept previously bonded devices
			 */
			bt_foreach_bond(BT_ID_DEFAULT, bond_connect, (void *)info->addr);
		}
		break;
	default:
		break;
	}
}

int bt_mgmt_scan_for_conn_start(struct bt_le_scan_param *scan_param, char const *const name)
{
	int ret;

	srch_name = name;

	if (!cb_registered) {
		scan_callback.recv = scan_recv_cb;
		bt_le_scan_cb_register(&scan_callback);
		cb_registered = true;
	} else {
		/* Already scanning, stop current scan to update param in case it has changed */
		ret = bt_le_scan_stop();
		if (ret && ret != -EALREADY) {
			LOG_ERR("Failed to stop scan: %d", ret);
			return ret;
		}
	}

	/* Reset number of bonds found */
	bonded_num = 0;

	bt_foreach_bond(BT_ID_DEFAULT, bond_check, NULL);

	if (bonded_num >= CONFIG_BT_MAX_PAIRED) {
		/* NOTE: The string below is used by the Nordic CI system */
		LOG_INF("All bonded slots filled, will not accept new devices");
	}

	ret = bt_le_scan_start(scan_param, NULL);
	if (ret && ret != -EALREADY) {
		return ret;
	}

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_management/scanning/bt_mgmt_scan_for_broadcast.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "bt_mgmt_scan_for_broadcast_internal.h"

#include <zephyr/zbus/zbus.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/gap.h>
#include <zephyr/bluetooth/uuid.h>
#include <zephyr/bluetooth/audio/audio.h>
#include <zephyr/sys/byteorder.h>

#include "bt_mgmt.h"
#include "macros_common.h"
#include "nrf5340_audio_common.h"

#include <zephyr/logging/log.h>
LOG_MODULE_DECLARE(bt_mgmt_scan);

/* Any value above 0xFFFFFF is invalid, so one can use 0xFFFFFFFF to denote
 * an invalid broadcast ID.
 */
#define INVALID_BROADCAST_ID 0xFFFFFFFF
#define PA_SYNC_SKIP	     2
/* Similar to retries for connections */
#define SYNC_RETRY_COUNT     6

ZBUS_CHAN_DECLARE(bt_mgmt_chan);

struct bt_le_scan_cb scan_callback;
static bool scan_cb_registered;
static bool sync_cb_registered;
static char const *srch_name;
static uint32_t srch_brdcast_id = BRDCAST_ID_NOT_USED;
static struct bt_le_per_adv_sync *pa_sync;
static uint32_t broadcaster_broadcast_id;

struct broadcast_source {
	char name[BLE_SEARCH_NAME_MAX_LEN];
	uint32_t broadcast_id;
};

static void scan_restart_worker(struct k_work *work)
{
	int ret;

	ret = bt_le_scan_stop();
	if (ret && ret != -EALREADY) {
		LOG_WRN("Stop scan failed: %d", ret);
	}

	/* Delete pending PA sync before restarting scan */
	ret = bt_mgmt_pa_sync_delete(pa_sync);
	if (ret) {
		LOG_WRN("Failed to delete pending PA sync: %d", ret);
	}

	ret = bt_mgmt_scan_start(0, 0, BT_MGMT_SCAN_TYPE_BROADCAST, NULL, BRDCAST_ID_NOT_USED);
	if (ret) {
		LOG_WRN("Failed to restart scanning for broadcast: %d", ret);
	}
}

K_WORK_DEFINE(scan_restart_work, scan_restart_worker);

static void pa_sync_timeout(struct k_timer *timer)
{
	LOG_WRN("PA sync create timed out, restarting scanning");

	k_work_submit(&scan_restart_work);
}

K_TIMER_DEFINE(pa_sync_timer, pa_sync_timeout, NULL);

static uint16_t interval_to_sync_timeout(uint16_t interval)
{
	uint16_t timeout;

	/* Ensure that the following calculation does not overflow silently */
	__ASSERT(SYNC_RETRY_COUNT < 10, "SYNC_RETRY_COUNT shall be less than 10");

	/* Add retries and convert to unit in 10s of ms */
	timeout = ((uint32_t)interval * SYNC_RETRY_COUNT) / 10;

	/* Enforce restraints */
	timeout = CLAMP(timeout, BT_GAP_PER_ADV_MIN_TIMEOUT, BT_GAP_PER_ADV_MAX_TIMEOUT);

	return timeout;
}

static void periodic_adv_sync(const struct bt_le_scan_recv_info *info, uint32_t broadcast_id)
{
	int ret;
	struct bt_le_per_adv_sync_param param;

	bt_le_scan_cb_unregister(&scan_callback);
	scan_cb_registered = false;

	bt_addr_le_copy(&param.addr, info->addr);
	param.options = 0;
	param.sid = info->sid;
	param.skip = PA_SYNC_SKIP;
	param.timeout = interval_to_sync_timeout(info->interval);

	broadcaster_broadcast_id = broadcast_id;

	/* Set timeout to same value as PA sync timeout in ms */
	k_timer_start(&pa_sync_timer, K_MSEC(param.timeout * 10), K_NO_WAIT);

	ret = bt_le_per_adv_sync_create(&param, &pa_sync);
	if (ret) {
		LOG_ERR("Could not sync to PA: %d", ret);
		ret = bt_mgmt_pa_sync_delete(pa_sync);
		if (ret) {
			LOG_ERR("Could not delete PA sync: %d", ret);
		}
		return;
	}
}

/**
 * @brief	Check and parse advertising data for broadcast name and ID.
 *
 * @param[in]	data		Advertising data to check and parse.
 * @param[out]	user_data	Will contain pointer to broadcast_source struct to be populated.
 *
 * @retval	true	Continue to parse LTVs.
 * @retval	false	Stop parsing LTVs.
 */
static bool scan_check_broadcast_source(struct bt_data *data, void *user_data)
{
	struct broadcast_source *source = (struct broadcast_source *)user_data;
	struct bt_uuid_16 adv_uuid;

	if (data->type == BT_DATA_BROADCAST_NAME && data->data_len) {
		/* Ensure that broadcast name is at least one character shorter than the value of
		 * BLE_SEARCH_NAME_MAX_LEN
		 */
		if (data->data_len < BLE_SEARCH_NAME_MAX_LEN) {
			memcpy(source->name, data->data, data->data_len);
			source->name[data->data_len] = '\0';
		}

		return true;
	}

	if (data->type != BT_DATA_SVC_DATA16) {
		return true;
	}

	if (data->data_len < BT_UUID_SIZE_16 + BT_AUDIO_BROADCAST_ID_SIZE) {
		return true;
	}

	if (!bt_uuid_create(&adv_uuid.uuid, data->data, BT_UUID_SIZE_16)) {
		return false;
	}

	if (bt_uuid_cmp(&adv_uuid.uuid, BT_UUID_BROADCAST_AUDIO)) {
		return true;
	}

	source->broadcast_id = sys_get_le24(data->data + BT_UUID_SIZE_16);

	return true;
}

/**
 * @brief	Callback handler for scan receive when scanning for broadcasters.
 *
 * @param[in]	info	Advertiser packet and scan response information.
 * @param[in]	ad	Received advertising data.
 */
static void scan_recv_cb(const struct bt_le_scan_recv_info *info, struct net_buf_simple *ad)
{
	struct broadcast_source source = {.broadcast_id = INVALID_BROADCAST_ID};

	/* We are only interested in non-connectable periodic advertisers */
	if ((info->adv_props & BT_GAP_ADV_PROP_CONNECTABLE) || info->interval == 0) {
		return;
	}

	bt_data_parse(ad, scan_check_broadcast_source, (void *)&source);

	if (source.broadcast_id != INVALID_BROADCAST_ID) {
		if (srch_brdcast_id < BRDCAST_ID_NOT_USED) {
			/* Valid srch_brdcast_id supplied */
			if (source.broadcast_id != srch_brdcast_id) {
				/* Broadcaster does not match src_brdcast_id */
				return;
			}

		} else if (strncmp(source.name, srch_name, BLE_SEARCH_NAME_MAX_LEN) != 0) {
			/* Broadcaster does not match src_name */
			return;
		}

		LOG_INF("Broadcast source %s found, id: 0x%06x", source.name, source.broadcast_id);
		periodic_adv_sync(info, source.broadcast_id);
	}
}

static void pa_synced_cb(struct bt_le_per_adv_sync *sync,
			 struct bt_le_per_adv_sync_synced_info *info)
{
	int ret;
	struct bt_mgmt_msg msg;

	if (sync != pa_sync) {
		LOG_WRN("Synced to unknown source");
		return;
	}

	LOG_DBG("PA synced");

	k_timer_stop(&pa_sync_timer);

	ret = bt_le_scan_stop();
	if (ret && ret != -EALREADY) {
		LOG_WRN("Stop scan failed: %d", ret);
	}

	msg.event = BT_MGMT_PA_SYNCED;
	msg.pa_sync = sync;
	msg.broadcast_id = broadcaster_broadcast_id;

	ret = zbus_chan_pub(&bt_mgmt_chan, &msg, K_NO_WAIT);
	ERR_CHK(ret);
}

static void pa_sync_terminated_cb(struct bt_le_per_adv_sync *sync,
				  const struct bt_le_per_adv_sync_term_info *info)
{
	int ret;
	struct bt_mgmt_msg msg;

	LOG_DBG("Periodic advertising sync lost");

	msg.event = BT_MGMT_PA_SYNC_LOST;
	msg.pa_sync = sync;
	msg.pa_sync_term_reason = info->reason;

	ret = zbus_chan_pub(&bt_mgmt_chan, &msg, K_NO_WAIT);
	ERR_CHK(ret);
}

static struct bt_le_per_adv_sync_cb sync_callbacks = {
	.synced = pa_synced_cb,
	.term = pa_sync_terminated_cb,
};

int bt_mgmt_scan_for_broadcast_start(struct bt_le_scan_param *scan_param, char const *const name,
				     uint32_t brdcast_id)
{
	int ret;

	if (!sync_cb_registered) {
		bt_le_per_adv_sync_cb_register(&sync_callbacks);
		sync_cb_registered = true;
	}

	if (!scan_cb_registered) {
		scan_callback.recv = scan_recv_cb;
		bt_le_scan_cb_register(&scan_callback);
		scan_cb_registered = true;
	} else {
		if (name == srch_name) {
			return -EALREADY;
		}
		/* Might already be scanning, stop current scan to update param in case it has
		 * changed.
		 */
		ret = bt_le_scan_stop();
		if (ret && ret != -EALREADY) {
			LOG_ERR("Failed to stop scan: %d", ret);
			return ret;
		}
	}

	srch_name = name;
	if (brdcast_id != BRDCAST_ID_NOT_USED) {
		srch_brdcast_id = brdcast_id;
	}

	ret = bt_le_scan_start(scan_param, NULL);
	if (ret) {
		return ret;
	}

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_management/advertising/Kconfig.default
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

config BT_EXT_ADV
	default y


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_management/advertising/bt_mgmt_adv.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "bt_mgmt.h"

#include <zephyr/zbus/zbus.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/conn.h>

#include "macros_common.h"
#include "nrf5340_audio_common.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(bt_mgmt_adv, CONFIG_BT_MGMT_ADV_LOG_LEVEL);

ZBUS_CHAN_DECLARE(bt_mgmt_chan);

#ifndef CONFIG_BT_MAX_PAIRED
#define BONDS_QUEUE_SIZE 0
#else
#define BONDS_QUEUE_SIZE CONFIG_BT_MAX_PAIRED
#endif

static struct k_work adv_work;
static bool dir_adv_timed_out;
static struct bt_le_ext_adv *ext_adv;

static const struct bt_data *adv_local;
static size_t adv_local_size;
static const struct bt_data *per_adv_local;
static size_t per_adv_local_size;

/* Bonded address queue */
K_MSGQ_DEFINE(bonds_queue, sizeof(bt_addr_le_t), BONDS_QUEUE_SIZE, 4);

static void bond_find(const struct bt_bond_info *info, void *user_data)
{
	int ret;
	struct bt_conn *conn;

	if (!IS_ENABLED(CONFIG_BT_BONDABLE)) {
		return;
	}

	/* Filter already connected peers. */
	conn = bt_conn_lookup_addr_le(BT_ID_DEFAULT, &info->addr);
	if (conn) {
		struct bt_conn_info conn_info;

		ret = bt_conn_get_info(conn, &conn_info);
		if (ret) {
			LOG_WRN("Could not get conn info");
			bt_conn_unref(conn);
			return;
		}

		if (conn_info.state == BT_CONN_STATE_CONNECTED) {
			LOG_WRN("Already connected");
			bt_conn_unref(conn);
			return;
		}

		bt_conn_unref(conn);
	}

	ret = k_msgq_put(&bonds_queue, (void *)&info->addr, K_NO_WAIT);
	if (ret) {
		LOG_WRN("No space in the queue for the bond");
	}
}

static void filter_accept_list_add(const struct bt_bond_info *info, void *user_data)
{
	int ret;

	ret = bt_le_filter_accept_list_add(&info->addr);
	if (ret) {
		LOG_WRN("Could not add peer to Filter Accept List: %d", ret);
		return;
	}
}

/**
 * @brief Prints the address of the local device and the remote device.
 *
 * @note The address of the remote device is only printed if directed advertisement is active.
 */
static int addr_print(bt_addr_le_t const *const local_addr, bt_addr_le_t const *const dir_adv_addr)
{
	char local_addr_str[BT_ADDR_LE_STR_LEN] = {'\0'};
	char directed_to_addr_str[BT_ADDR_LE_STR_LEN] = {'\0'};

	if (local_addr == NULL) {
		return -EINVAL;
	}

	(void)bt_addr_le_to_str(local_addr, local_addr_str, BT_ADDR_LE_STR_LEN);
	LOG_INF("Local addr: %s", local_addr_str);

	if (dir_adv_addr != NULL) {
		(void)bt_addr_le_to_str(dir_adv_addr, directed_to_addr_str, BT_ADDR_LE_STR_LEN);
		LOG_INF("Adv directed to: %s.", directed_to_addr_str);
	}

	return 0;
}

#if defined(CONFIG_BT_PRIVACY)
static bool adv_rpa_expired_cb(struct bt_le_ext_adv *adv)
{
	int ret;
	struct bt_le_ext_adv_info ext_adv_info;

	LOG_INF("RPA (Resolvable Private Address) expired.");

	ret = bt_le_ext_adv_get_info(ext_adv, &ext_adv_info);
	ERR_CHK_MSG(ret, "bt_le_ext_adv_get_info failed");

	ret = addr_print(ext_adv_info.addr, NULL);
	if (ret) {
		LOG_ERR("addr_print failed");
	}

	return true;
}
#endif /* CONFIG_BT_PRIVACY */

static const struct bt_le_ext_adv_cb adv_cb = {
#if defined(CONFIG_BT_PRIVACY)
	.rpa_expired = adv_rpa_expired_cb,
#endif /* CONFIG_BT_PRIVACY */
};

static int direct_adv_create(bt_addr_le_t addr)
{
	int ret;
	struct bt_le_adv_param adv_param;
	struct bt_le_ext_adv_info ext_adv_info;

	adv_param = *BT_LE_ADV_CONN_DIR(&addr);
	adv_param.id = BT_ID_DEFAULT;
	adv_param.options |= BT_LE_ADV_OPT_DIR_ADDR_RPA;

	/* Clear ADV data set before update to direct advertising */
	ret = bt_le_ext_adv_set_data(ext_adv, NULL, 0, NULL, 0);
	if (ret) {
		LOG_ERR("Failed to clear advertising data. Err: %d", ret);
		return ret;
	}

	ret = bt_le_ext_adv_update_param(ext_adv, &adv_param);
	if (ret) {
		LOG_ERR("Failed to update ext_adv to direct advertising. Err = %d", ret);
		return ret;
	}

	ret = bt_le_ext_adv_get_info(ext_adv, &ext_adv_info);
	if (ret) {
		return ret;
	}

	ret = addr_print(ext_adv_info.addr, &addr);
	if (ret) {
		return ret;
	}

	return 0;
}

static int extended_adv_create(void)
{
	int ret;
	struct bt_le_ext_adv_info ext_adv_info;

	if (adv_local == NULL) {
		LOG_ERR("Adv_local not set");
		return -ENXIO;
	}

	if (dir_adv_timed_out) {
		/* If the directed adv has timed out it means we only need to update the adv data */
		bt_le_adv_update_data(adv_local, adv_local_size, NULL, 0);
	} else {
		ret = bt_le_ext_adv_set_data(ext_adv, adv_local, adv_local_size, NULL, 0);
		if (ret) {
			LOG_ERR("Failed to set advertising data: %d", ret);
			return ret;
		}
	}

	if (per_adv_local != NULL && IS_ENABLED(CONFIG_BT_PER_ADV)) {
		/* Set periodic advertising parameters */
		ret = bt_le_per_adv_set_param(ext_adv, LE_AUDIO_PERIODIC_ADV);
		if (ret) {
			LOG_ERR("Failed to set periodic advertising parameters: %d", ret);
			return ret;
		}

		ret = bt_le_per_adv_set_data(ext_adv, per_adv_local, per_adv_local_size);
		if (ret) {
			LOG_ERR("Failed to set periodic advertising data: %d", ret);
			return ret;
		}
	}

	ret = bt_le_ext_adv_get_info(ext_adv, &ext_adv_info);
	if (ret) {
		return ret;
	}

	ret = addr_print(ext_adv_info.addr, NULL);
	if (ret) {
		return ret;
	}

	return 0;
}

static void advertising_process(struct k_work *work)
{
	int ret;
	struct bt_mgmt_msg msg;

	k_msgq_purge(&bonds_queue);

	if (IS_ENABLED(CONFIG_BT_BONDABLE)) {
		bt_foreach_bond(BT_ID_DEFAULT, bond_find, NULL);
		/* Populate Filter Accept List */
		if (IS_ENABLED(CONFIG_BT_FILTER_ACCEPT_LIST)) {
			ret = bt_le_filter_accept_list_clear();
			if (ret) {
				LOG_ERR("Failed to clear filter accept list");
				return;
			}

			bt_foreach_bond(BT_ID_DEFAULT, filter_accept_list_add, NULL);
		}
	}

	bt_addr_le_t addr;

	if (!k_msgq_get(&bonds_queue, &addr, K_NO_WAIT) && !dir_adv_timed_out) {
		ret = direct_adv_create(addr);
		if (ret) {
			LOG_WRN("Failed to create direct advertisement: %d", ret);
			return;
		}

		ret = bt_le_ext_adv_start(
			ext_adv,
			BT_LE_EXT_ADV_START_PARAM(BT_GAP_ADV_HIGH_DUTY_CYCLE_MAX_TIMEOUT, 0));
	} else {
		ret = extended_adv_create();
		if (ret) {
			LOG_WRN("Failed to create extended advertisement: %d", ret);
			return;
		}

		dir_adv_timed_out = false;
		ret = bt_le_ext_adv_start(ext_adv, BT_LE_EXT_ADV_START_DEFAULT);
	}

	if (ret) {
		LOG_ERR("Failed to start advertising set. Err: %d", ret);
		return;
	}

	if (per_adv_local != NULL && IS_ENABLED(CONFIG_BT_PER_ADV)) {
		/* Enable Periodic Advertising */
		ret = bt_le_per_adv_start(ext_adv);
		if (ret) {
			LOG_ERR("Failed to enable periodic advertising: %d", ret);
			return;
		}

		msg.event = BT_MGMT_EXT_ADV_WITH_PA_READY;
		msg.ext_adv = ext_adv;

		ret = zbus_chan_pub(&bt_mgmt_chan, &msg, K_NO_WAIT);
		ERR_CHK(ret);
	}

	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Advertising successfully started");
}

void bt_mgmt_dir_adv_timed_out(void)
{
	int ret;

	dir_adv_timed_out = true;

	LOG_DBG("Clearing ext_adv");

	ret = bt_le_ext_adv_delete(ext_adv);
	if (ret) {
		LOG_ERR("Failed to clear ext_adv");
	}

	if (IS_ENABLED(CONFIG_BT_FILTER_ACCEPT_LIST)) {
		ret = bt_le_ext_adv_create(LE_AUDIO_EXTENDED_ADV_CONN_NAME_FILTER, &adv_cb,
					   &ext_adv);
	} else {
		ret = bt_le_ext_adv_create(LE_AUDIO_EXTENDED_ADV_CONN_NAME, &adv_cb, &ext_adv);
	}

	if (ret) {
		LOG_ERR("Unable to create a connectable extended advertising set: %d", ret);
		return;
	}

	/* Restart normal advertising */
	bt_mgmt_adv_start(NULL, 0, NULL, 0, true);
}

int bt_mgmt_adv_start(const struct bt_data *adv, size_t adv_size, const struct bt_data *per_adv,
		      size_t per_adv_size, bool connectable)
{
	int ret;

	/* Special case for restarting advertising */
	if (adv == NULL && adv_size == 0 && per_adv == NULL && per_adv_size == 0) {
		if (adv_local == NULL) {
			LOG_ERR("No valid advertising data stored");
			return -ENOENT;
		}

		k_work_submit(&adv_work);

		return 0;
	}

	if (adv == NULL) {
		LOG_ERR("No adv struct received");
		return -EINVAL;
	}

	if (adv_size == 0) {
		LOG_ERR("Invalid size of adv struct");
		return -EINVAL;
	}

	adv_local = adv;
	adv_local_size = adv_size;
	per_adv_local = per_adv;
	per_adv_local_size = per_adv_size;

	if (connectable) {
		ret = bt_le_ext_adv_create(LE_AUDIO_EXTENDED_ADV_CONN_NAME, &adv_cb, &ext_adv);
		if (ret) {
			LOG_ERR("Unable to create a connectable extended advertising set: %d", ret);
			return ret;
		}
	} else {
		ret = bt_le_ext_adv_create(LE_AUDIO_EXTENDED_ADV_NAME, &adv_cb, &ext_adv);
		if (ret) {
			LOG_ERR("Unable to create extended advertising set: %d", ret);
			return ret;
		}
	}

	k_work_submit(&adv_work);

	return 0;
}

void bt_mgmt_adv_init(void)
{
	k_work_init(&adv_work, advertising_process);
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_management/advertising/bt_mgmt_adv_internal.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BT_MGMT_ADV_INTERNAL_H_
#define _BT_MGMT_ADV_INTERNAL_H_

#include <zephyr/bluetooth/bluetooth.h>

/**
 * @brief	Initialize the advertising part of the Bluetooth management module.
 */
void bt_mgmt_adv_init(void);

/**
 * @brief	Handle timed-out directed advertisement.
 *
 *		This function deletes the old ext_adv and creates a new one.
 *		It also sets the dir_adv_timed_out flag and restarts advertisement.
 */
void bt_mgmt_dir_adv_timed_out(void);

#endif /* _BT_MGMT_ADV_INTERNAL_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_management/advertising/Kconfig
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

menu "Advertising"

config BLE_ACL_PER_ADV_INT_MIN
	hex "Minimum periodic advertising interval"
	range 0x0018 0x03C0
	default 0x0078
	help
	  Minimum hexadecimal value for the interval of periodic advertisements.
	  For ms, multiply the provided value by 1.25.

config BLE_ACL_PER_ADV_INT_MAX
	hex "Maximum periodic advertising interval"
	range 0x0018 0x03C0
	default 0x00A0
	help
	  Maximum hexadecimal value for the interval of periodic advertisements.
	  For ms, multiply the provided value by 1.25.

config BLE_ACL_EXT_ADV_INT_MIN
	hex "Minimum extended advertising interval"
	range 0x0030 0x0780
	default 0x30 if TRANSPORT_BIS
	default 0x00A0
	help
	  Minimum hexadecimal value for the interval of extended advertisements.
	  When the LE Audio Controller Subsystem for nRF53 is used, this interval
	  should be a multiple of the ISO interval and maximum 4x larger than the
	  lowest interval if using BIS.
	  For ms, multiply the provided value by 0.625.

config BLE_ACL_EXT_ADV_INT_MAX
	hex "Maximum extended advertising interval"
	range 0x0030 0x0780
	default 0x40 if TRANSPORT_BIS
	default 0x00F0
	help
	  Maximum hexadecimal value for the interval of extended advertisements.
	  When the LE Audio Controller Subsystem for nRF53 is used, this interval
	  should be a multiple of the ISO interval and maximum 4x larger than the
	  lowest interval if using BIS.
	  For ms, multiply the provided value by 0.625.

config EXT_ADV_BUF_MAX
	int "Maximum number of extended advertising data parameters"
	default 20

config EXT_ADV_UUID_BUF_MAX
	int "Maximum number of UUIDs to add to extended advertisements"
	default 20

#----------------------------------------------------------------------------#
menu "Log level"

module = BT_MGMT_ADV
module-str = bt-mgmt-adv
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log level
endmenu # Advertising


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_management/controller_config/Kconfig.defaults
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

# Bluetooth controller type
if BT_LL_ACS_NRF53

# Not supported on LE Audio Controller Subsystem for nRF53
config BT_ATT_ENFORCE_FLOW
	default n

# Disable Zephyr HCI Vendor-Specific extensions
config BT_HCI_VS_EXT
	default n

# HCI ACL flow control is not supported on BT_LL_ACS_NRF53
config BT_HCI_ACL_FLOW_CONTROL
	default n

endif # BT_LL_ACS_NRF53


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_management/controller_config/Kconfig
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

rsource "Kconfig.defaults"

menu "Controller config"

#----------------------------------------------------------------------------#
menu "nRF21540"

config NRF_21540_ACTIVE
	def_bool $(shields_list_contains,nrf21540ek_fwd)
	select EXPERIMENTAL
	help
	  The front end module can help boost the TX power as high as 20 dBm.

choice NRF_21540_MAIN_TX_POWER
	prompt "TX power for the secondary channels"
	default NRF_21540_MAIN_TX_POWER_10DBM
	help
	  Set the TX power for the secondary Bluetooth LE channels (0-36).
	  Check your local regulations for max output power. If the
	  nRF21540 is used with the nRF5340 Audio DK the actual output power
	  will be about 25% lower due to the VDD being 1.8V instead of the
	  nominal 3.3V.

config NRF_21540_MAIN_TX_POWER_0DBM
	bool "0dBm"

config NRF_21540_MAIN_TX_POWER_10DBM
	bool "+10dBm"

config NRF_21540_MAIN_TX_POWER_20DBM
	bool "+20dBm"

endchoice

config NRF_21540_MAIN_DBM
	int
	default 0 if NRF_21540_MAIN_TX_POWER_0DBM
	default 10 if NRF_21540_MAIN_TX_POWER_10DBM
	default 20 if NRF_21540_MAIN_TX_POWER_20DBM

choice NRF_21540_PRI_ADV_TX_POWER
	prompt "TX power for the primary advertising channels"
	default NRF_21540_PRI_ADV_TX_POWER_10DBM
	help
	  Set the TX power for the primary Bluetooth LE advertising channels
	  (37, 38, 39).
	  Check your local regulations for max output power. If the
	  nRF21540 is used with the nRF5340 Audio DK the actual output power
	  will be about 25% lower due to the VDD being 1.8V instead of the
	  nominal 3.3V.

config NRF_21540_PRI_ADV_TX_POWER_0DBM
	bool "0dBm"

config NRF_21540_PRI_ADV_TX_POWER_10DBM
	bool "+10dBm"

config NRF_21540_PRI_ADV_TX_POWER_20DBM
	bool "+20dBm"

endchoice

config NRF_21540_PRI_ADV_DBM
	int
	default 0 if NRF_21540_PRI_ADV_TX_POWER_0DBM
	default 10 if NRF_21540_PRI_ADV_TX_POWER_10DBM
	default 20 if NRF_21540_PRI_ADV_TX_POWER_20DBM

endmenu # nRF21540

#----------------------------------------------------------------------------#
menu "Log level"

module = BT_MGMT_CTLR_CFG
module-str = bt-mgmt-ctlr-cfg
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log level
endmenu # Controller config


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_management/controller_config/bt_mgmt_ctlr_cfg_internal.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BT_MGMT_CTRL_CFG_INTERNAL_H_
#define _BT_MGMT_CTRL_CFG_INTERNAL_H_

#include <stdbool.h>
#include <stdint.h>

/**
 * @brief	Get the Bluetooth controller manufacturer.
 *
 * @param[in]   print_version   Print the controller version.
 * @param[out]	manufacturer	The controller manufacturer.
 *
 * @return	0 if success, error otherwise.
 */
int bt_mgmt_ctlr_cfg_manufacturer_get(bool print_version, uint16_t *manufacturer);

/**
 * @brief	Configure the Bluetooth controller.
 *
 * @param[in]	watchdog_enable	If true, the function will, at given intervals, poll the controller
 *				to ensure it is still alive.
 *
 * @return	0 if success, error otherwise.
 */
int bt_mgmt_ctlr_cfg_init(bool watchdog_enable);

#endif /* _BT_MGMT_CTRL_CFG_INTERNAL_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_management/controller_config/bt_mgmt_ctlr_cfg.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "bt_mgmt_ctlr_cfg_internal.h"

#include <zephyr/bluetooth/hci.h>
#include <zephyr/sys/byteorder.h>
#include <zephyr/drivers/watchdog.h>
#include <zephyr/task_wdt/task_wdt.h>

#include "macros_common.h"
#if (CONFIG_BT_LL_ACS_NRF53)
#include "ble_hci_vsc.h"
#endif /* (CONFIG_BT_LL_ACS_NRF53) */

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(bt_mgmt_ctlr_cfg, CONFIG_BT_MGMT_CTLR_CFG_LOG_LEVEL);

#define COMPANY_ID_NORDIC      0x0059
#define COMPANY_ID_PACKETCRAFT 0x07E8

#define WDT_TIMEOUT_MS	      1500
#define CTLR_POLL_INTERVAL_MS (WDT_TIMEOUT_MS - 500)

static struct k_work work_ctlr_poll;

#define CTLR_POLL_WORK_STACK_SIZE 1024

K_THREAD_STACK_DEFINE(ctlr_poll_stack_area, CTLR_POLL_WORK_STACK_SIZE);

struct k_work_q ctrl_poll_work_q;

struct k_work_queue_config ctrl_poll_work_q_config = {
	.name = "ctlr_poll",
	.no_yield = false,
};

static void ctlr_poll_timer_handler(struct k_timer *timer_id);
static int wdt_ch_id;

K_TIMER_DEFINE(ctlr_poll_timer, ctlr_poll_timer_handler, NULL);

static int bt_ll_acs_nrf53_cfg(void)
{
#if (CONFIG_BT_LL_ACS_NRF53)
	int ret;
	/* Enable notification of lost ISO packets */
	ret = ble_hci_vsc_op_flag_set(BLE_HCI_VSC_OP_ISO_LOST_NOTIFY, 1);
	if (ret) {
		return ret;
	}

#if (CONFIG_NRF_21540_ACTIVE)
	/* Indexes for the pins gotten from nrf21540ek_fwd.overlay */
	uint8_t tx_pin = NRF_DT_GPIOS_TO_PSEL_BY_IDX(DT_PATH(nrf_gpio_forwarder, nrf21540_gpio_if),
						     gpios, 0);
	uint8_t rx_pin = NRF_DT_GPIOS_TO_PSEL_BY_IDX(DT_PATH(nrf_gpio_forwarder, nrf21540_gpio_if),
						     gpios, 1);
	uint8_t pdn_pin = NRF_DT_GPIOS_TO_PSEL_BY_IDX(DT_PATH(nrf_gpio_forwarder, nrf21540_gpio_if),
						      gpios, 2);
	uint8_t ant_pin = NRF_DT_GPIOS_TO_PSEL_BY_IDX(DT_PATH(nrf_gpio_forwarder, nrf21540_gpio_if),
						      gpios, 3);
	uint8_t mode_pin = NRF_DT_GPIOS_TO_PSEL_BY_IDX(
		DT_PATH(nrf_gpio_forwarder, nrf21540_gpio_if), gpios, 4);

	struct ble_hci_vs_cp_nrf21540_pins nrf21540_pins = {
		.mode = mode_pin,
		.txen = tx_pin,
		.rxen = rx_pin,
		.antsel = ant_pin,
		.pdn = pdn_pin,
		/* Set CS pin to ffff since we are not using the SPI */
		.csn = 0xffff};

	ret = ble_hci_vsc_nrf21540_pins_set(&nrf21540_pins);
	if (ret) {
		return ret;
	}

	ret = ble_hci_vsc_radio_high_pwr_mode_set(
		MAX(CONFIG_NRF_21540_MAIN_DBM, CONFIG_NRF_21540_PRI_ADV_DBM));
	if (ret) {
		return ret;
	}

	ret = ble_hci_vsc_adv_tx_pwr_set(CONFIG_NRF_21540_MAIN_DBM);
	if (ret) {
		return ret;
	}

	LOG_DBG("TX power set to %d", CONFIG_NRF_21540_MAIN_DBM);

	ret = ble_hci_vsc_pri_adv_chan_max_tx_pwr_set(CONFIG_NRF_21540_PRI_ADV_DBM);
	if (ret) {
		return ret;
	}

	LOG_DBG("Primary advertising TX power set to %d", CONFIG_NRF_21540_PRI_ADV_DBM);
#else
	ret = ble_hci_vsc_adv_tx_pwr_set(CONFIG_BLE_ADV_TX_POWER_DBM);
	if (ret) {
		return ret;
	}

	LOG_DBG("TX power set to %d", CONFIG_BLE_ADV_TX_POWER_DBM);

	/* Disabled by default, only used if another TX power for primary adv channels is needed */
	ret = ble_hci_vsc_pri_adv_chan_max_tx_pwr_set(BLE_HCI_VSC_PRI_EXT_ADV_MAX_TX_PWR_DISABLE);
	if (ret) {
		return ret;
	}

#endif /*CONFIG_NRF_21540_ACTIVE*/

	/* Map controller LEDs*/

	ret = ble_hci_vsc_led_pin_map(PAL_LED_ID_CPU_ACTIVE,
				      DT_GPIO_FLAGS_BY_IDX(DT_NODELABEL(rgb2_green), gpios, 0),
				      DT_GPIO_PIN_BY_IDX(DT_NODELABEL(rgb2_green), gpios, 0));
	if (ret) {
		return ret;
	}

	ret = ble_hci_vsc_led_pin_map(PAL_LED_ID_ERROR,
				      DT_GPIO_FLAGS_BY_IDX(DT_NODELABEL(rgb2_red), gpios, 0),
				      DT_GPIO_PIN_BY_IDX(DT_NODELABEL(rgb2_red), gpios, 0));
	if (ret) {
		return ret;
	}

	return 0;
#else
	return -ENODEV;
#endif /* CONFIG_BT_LL_ACS_NRF53*/
}

static void work_ctlr_poll_handler(struct k_work *work)
{
	int ret;
	uint16_t manufacturer = 0;

	ret = bt_mgmt_ctlr_cfg_manufacturer_get(false, &manufacturer);
	ERR_CHK_MSG(ret, "Failed to contact net core");

	ret = task_wdt_feed(wdt_ch_id);
	ERR_CHK_MSG(ret, "Failed to feed watchdog");
}

static void ctlr_poll_timer_handler(struct k_timer *timer_id)
{
	int ret;

	ret = k_work_submit_to_queue(&ctrl_poll_work_q, &work_ctlr_poll);
	if (ret < 0) {
		LOG_ERR("Work q submit failed: %d", ret);
	}
}

static void wdt_timeout_cb(int channel_id, void *user_data)
{
	ERR_CHK_MSG(-ETIMEDOUT, "No response from IPC or controller");
}

int bt_mgmt_ctlr_cfg_manufacturer_get(bool print_version, uint16_t *manufacturer)
{
	int ret;
	struct net_buf *rsp;

	ret = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_VERSION_INFO, NULL, &rsp);
	if (ret) {
		return ret;
	}

	struct bt_hci_rp_read_local_version_info *rp = (void *)rsp->data;

	if (print_version) {
		if (rp->manufacturer == COMPANY_ID_PACKETCRAFT) {
			/* NOTE: The string below is used by the Nordic CI system */
			LOG_INF("Controller: LL_ACS_NRF53: Version %s (0x%02x), Revision %d",
				bt_hci_get_ver_str(rp->hci_version), rp->hci_version,
				rp->hci_revision);
		} else if (rp->manufacturer == COMPANY_ID_NORDIC) {
			/* NOTE: The string below is used by the Nordic CI system */
			LOG_INF("Controller: SoftDevice: Version %s (0x%02x), Revision %d",
				bt_hci_get_ver_str(rp->hci_version), rp->hci_version,
				rp->hci_revision);
		} else {
			LOG_ERR("Unsupported controller");
			return -EPERM;
		}
	}

	*manufacturer = sys_le16_to_cpu(rp->manufacturer);

	net_buf_unref(rsp);

	return 0;
}

int bt_mgmt_ctlr_cfg_init(bool watchdog_enable)
{
	int ret;
	uint16_t manufacturer = 0;

	ret = bt_mgmt_ctlr_cfg_manufacturer_get(true, &manufacturer);
	if (ret) {
		return ret;
	}

	if ((IS_ENABLED(CONFIG_BT_LL_ACS_NRF53) && (manufacturer != COMPANY_ID_PACKETCRAFT)) ||
	    (!IS_ENABLED(CONFIG_BT_LL_ACS_NRF53) && (manufacturer == COMPANY_ID_PACKETCRAFT))) {
		LOG_ERR("Controller config on APP and controller on NET mismatch.");
	}

	if (IS_ENABLED(CONFIG_BT_LL_ACS_NRF53) && (manufacturer == COMPANY_ID_PACKETCRAFT)) {
		ret = bt_ll_acs_nrf53_cfg();
		if (ret) {
			return ret;
		}
	}

	if (watchdog_enable) {
		ret = task_wdt_init(NULL);
		if (ret != 0) {
			LOG_ERR("task wdt init failure: %d\n", ret);
			return ret;
		}

		wdt_ch_id = task_wdt_add(WDT_TIMEOUT_MS, wdt_timeout_cb, NULL);
		if (wdt_ch_id < 0) {
			return wdt_ch_id;
		}
		k_work_queue_init(&ctrl_poll_work_q);

		k_work_queue_start(&ctrl_poll_work_q, ctlr_poll_stack_area,
				   K_THREAD_STACK_SIZEOF(ctlr_poll_stack_area),
				   K_PRIO_PREEMPT(CONFIG_CTLR_POLL_WORK_Q_PRIO),
				   &ctrl_poll_work_q_config);

		k_work_init(&work_ctlr_poll, work_ctlr_poll_handler);
		k_timer_start(&ctlr_poll_timer, K_MSEC(CTLR_POLL_INTERVAL_MS),
			      K_MSEC(CTLR_POLL_INTERVAL_MS));
	}

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_renderer/CMakeLists.txt
#
# Copyright (c) 2023 Nordic Semiconductor
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

zephyr_library_include_directories(
    volume
)

target_sources(app PRIVATE
	       ${CMAKE_CURRENT_SOURCE_DIR}/bt_rend.c)

if (CONFIG_BT_VCP_VOL_CTLR OR CONFIG_BT_VCP_VOL_REND)
target_sources(app PRIVATE
	        ${CMAKE_CURRENT_SOURCE_DIR}/volume/bt_rend_vol.c)
endif()


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_renderer/bt_rend.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "bt_rend.h"

#include <zephyr/zbus/zbus.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/uuid.h>

#include "bt_rend_vol_internal.h"
#include "nrf5340_audio_common.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(bt_rend, CONFIG_BT_REND_LOG_LEVEL);

ZBUS_CHAN_DEFINE(volume_chan, struct volume_msg, NULL, NULL, ZBUS_OBSERVERS_EMPTY,
		 ZBUS_MSG_INIT(0));

int bt_rend_volume_up(void)
{
	int ret;
	struct volume_msg msg;

	if (IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR) || IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) {
		ret = bt_rend_vol_up();
		return ret;
	}

	msg.event = VOLUME_UP;

	ret = zbus_chan_pub(&volume_chan, &msg, K_NO_WAIT);
	return ret;
}

int bt_rend_volume_down(void)
{
	int ret;
	struct volume_msg msg;

	if (IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR) || IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) {
		ret = bt_rend_vol_down();
		return ret;
	}

	msg.event = VOLUME_DOWN;

	ret = zbus_chan_pub(&volume_chan, &msg, K_NO_WAIT);
	return ret;
}

int bt_rend_volume_set(uint8_t volume, bool from_vcp)
{
	int ret;
	struct volume_msg msg;

	if ((IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR) || IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) &&
	    !from_vcp) {
		ret = bt_rend_vol_set(volume);
		return ret;
	}

	msg.event = VOLUME_SET;
	msg.volume = volume;

	ret = zbus_chan_pub(&volume_chan, &msg, K_NO_WAIT);
	return ret;
}

int bt_rend_volume_mute(bool from_vcp)
{
	int ret;
	struct volume_msg msg;

	if ((IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR) || IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) &&
	    !from_vcp) {
		ret = bt_rend_vol_mute();
		return ret;
	}

	msg.event = VOLUME_MUTE;

	ret = zbus_chan_pub(&volume_chan, &msg, K_NO_WAIT);
	return ret;
}

int bt_rend_volume_unmute(void)
{
	int ret;
	struct volume_msg msg;

	if (IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR) || IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) {
		ret = bt_rend_vol_unmute();
		return ret;
	}

	msg.event = VOLUME_UNMUTE;

	ret = zbus_chan_pub(&volume_chan, &msg, K_NO_WAIT);
	return ret;
}

int bt_rend_discover(struct bt_conn *conn)
{
	int ret;

	/* Only do a VCS discover if we are volume controller */
	if (IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR)) {
		ret = bt_rend_vol_discover(conn);
		if (ret) {
			LOG_WRN("Failed to discover VCS: %d", ret);
			return ret;
		}
	}

	return 0;
}

int bt_rend_uuid_populate(struct net_buf_simple *uuid_buf)
{
	if (IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) {
		if (net_buf_simple_tailroom(uuid_buf) >= BT_UUID_SIZE_16) {
			net_buf_simple_add_le16(uuid_buf, BT_UUID_VCS_VAL);
		} else {
			return -ENOMEM;
		}
	}

	return 0;
}

int bt_rend_init(void)
{
	int ret;

	if (IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR)) {
		ret = bt_rend_vol_ctlr_init();

		if (ret) {
			LOG_WRN("Failed to initialize VCS controller: %d", ret);
			return ret;
		}
	}

	if (IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) {
		ret = bt_rend_vol_rend_init();

		if (ret) {
			LOG_WRN("Failed to initialize VCS renderer: %d", ret);
			return ret;
		}
	}

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_renderer/Kconfig
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

menu "BT renderer"

rsource "volume/Kconfig"

#----------------------------------------------------------------------------#
menu "Log level"

module = BT_REND
module-str = bt-rend
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log level
endmenu # BT renderer


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_renderer/bt_rend.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BT_REND_H_
#define _BT_REND_H_

#include <zephyr/bluetooth/conn.h>

/**
 * @brief	Adjust volume up by one step.
 *
 * @return	0 if success, error otherwise.
 */
int bt_rend_volume_up(void);

/**
 * @brief	Adjust volume down by one step.
 *
 * @return	0 if success, error otherwise.
 */
int bt_rend_volume_down(void);

/**
 * @brief	Set the volume to the given @p volume value.
 *
 * @param[in]	volume		Value to set the volume to (0-255).
 * @param[in]	from_vcp	Describe if the function was called from a service
 *				or from somewhere else (buttons, shell, etc).
 *
 * @return	0 if success, error otherwise.
 */
int bt_rend_volume_set(uint8_t volume, bool from_vcp);

/**
 * @brief	Mute the volume.
 *
 * @param[in]	from_vcp	Describe if the function was called from a service
 *				or from somewhere else (buttons, shell, etc).
 *
 * @return	0 if success, error otherwise.
 */
int bt_rend_volume_mute(bool from_vcp);

/**
 * @brief	Unmute the volume.
 *
 * @return	0 if success, error otherwise.
 */
int bt_rend_volume_unmute(void);

/**
 * @brief	Discover the rendering services.
 *
 * @param[in]	conn	Pointer to the connection on which to do the discovery.
 *
 * @return	0 if success, error otherwise.
 */
int bt_rend_discover(struct bt_conn *conn);

/**
 * @brief	Put the UUIDs from this module into the buffer.
 *
 * @note	This partial data is used to build a complete extended advertising packet.
 *
 * @param[out]	uuid_buf	Buffer being populated with UUIDs.
 *
 * @return	0 for success, error otherwise.
 */
int bt_rend_uuid_populate(struct net_buf_simple *uuid_buf);

/**
 * @brief	Initialize the rendering services or profiles, or both.
 *
 * @return	0 if success, error otherwise.
 */
int bt_rend_init(void);

#endif /* _BT_REND_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_renderer/volume/bt_rend_vol_internal.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BT_REND_VOL_INTERNAL_H_
#define _BT_REND_VOL_INTERNAL_H_

#include <zephyr/bluetooth/conn.h>

/**
 * @brief	Set volume to a specific value.
 *
 * @param[in]	volume	The absolute volume to be set.
 *
 * @retval	0	Volume change success.
 * @retval	-ENXIO	The feature is disabled.
 * @retval	other	Errors from underlying drivers.
 */
int bt_rend_vol_set(uint8_t volume);

/**
 * @brief	Turn the volume up by one step.
 *
 * @retval	0	Volume change success.
 * @retval	-ENXIO	The feature is disabled.
 * @retval	other	Errors from underlying drivers.
 */
int bt_rend_vol_up(void);

/**
 * @brief	Turn the volume down by one step.
 *
 * @retval	0	Volume change success.
 * @retval	-ENXIO	The feature is disabled.
 * @retval	other	Errors from underlying drivers.
 */
int bt_rend_vol_down(void);

/**
 * @brief	Mute the output volume of the device.
 *
 * @retval	0	Volume change success.
 * @retval	-ENXIO	The feature is disabled.
 * @retval	other	Errors from underlying drivers.
 */
int bt_rend_vol_mute(void);

/**
 * @brief	Unmute the output volume of the device.
 *
 * @retval	0	Volume change success.
 * @retval	-ENXIO	The feature is disabled.
 * @retval	other	Errors from underlying drivers.
 */
int bt_rend_vol_unmute(void);

/**
 * @brief	Discover Volume Control Service and included services.
 *
 * @param[in]	conn	Pointer to the connection on which to discover the services.
 *
 * @note	This function starts a GATT discovery and sets up handles and
 *		subscriptions for the VCS and included services.
 *		Call it once before any other actions related to the VCS.
 *
 * @return	0 for success, error otherwise.
 */
int bt_rend_vol_discover(struct bt_conn *conn);

/**
 * @brief	Initialize the Volume Control Service client.
 *
 * @return	0 for success, error otherwise.
 */
int bt_rend_vol_ctlr_init(void);

/**
 * @brief	Initialize the Volume renderer.
 *
 * @return	0 for success, error otherwise.
 */
int bt_rend_vol_rend_init(void);

#endif /* _BT_REND_VOL_INTERNAL_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_renderer/volume/Kconfig
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

menu "Volume"

config BT_AUDIO_VOL_DEFAULT
	int "Default volume"
	range 0 255
	default 195
	help
	  The default volume when starting a volume control renderer.

config BT_AUDIO_VOL_STEP_SIZE
	int "Volume adjust step size"
	range 6 32
	default 16

#----------------------------------------------------------------------------#
menu "Log level"

module = BT_REND_VOL
module-str = bt-rend-vol
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log level
endmenu # Volume


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/bluetooth/bt_renderer/volume/bt_rend_vol.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "bt_rend_vol_internal.h"

#include <zephyr/kernel.h>
#include <zephyr/types.h>
#include <zephyr/bluetooth/conn.h>
#include <zephyr/bluetooth/audio/vcp.h>

#include "macros_common.h"
#include "bt_rend.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(bt_rend_vol, CONFIG_BT_REND_VOL_LOG_LEVEL);

static struct bt_vcp_vol_ctlr *vcs_client_peer[CONFIG_BT_MAX_CONN];

/**
 * @brief	Get the index of the first available vcs_client_peer.
 *
 * @retval	Index if success.
 * @retval	-ENOMEM if no available indexes.
 */
static int vcs_client_peer_index_free_get(void)
{
	for (int i = 0; i < ARRAY_SIZE(vcs_client_peer); i++) {
		if (vcs_client_peer[i] == NULL) {
			return i;
		}
	}

	LOG_WRN("No more indexes for VCS peer clients");

	return -ENOMEM;
}

/**
 * @brief	Check if the given @p conn has a vcs_client_peer pointer.
 *
 * @param[in]	conn	The connection pointer to be checked.
 *
 * @retval	True if vcs_client_peer exists.
 * @retval	False otherwise.
 */
static bool vcs_client_peer_exists(struct bt_conn *conn)
{
	int ret;

	struct bt_conn *result_conn = NULL;

	for (int i = 0; i < ARRAY_SIZE(vcs_client_peer); i++) {
		ret = bt_vcp_vol_ctlr_conn_get(vcs_client_peer[i], &result_conn);

		if (!ret && conn == result_conn) {
			return true;
		}

		if (ret == -ENOTCONN) {
			/* VCS client no longer connected, free the index */
			vcs_client_peer[i] = NULL;
			return false;
		}
	}

	return false;
}

/**
 * @brief	Callback handler for the volume state.
 *
 * @note	This callback handler will be triggered if volume state has changed,
 *		or the playback was muted or unmuted.
 */
static void vcs_state_ctlr_cb_handler(struct bt_vcp_vol_ctlr *vcs, int err, uint8_t volume,
				      uint8_t mute)
{
	int ret;

	if (err) {
		LOG_ERR("VCS state callback error: %d", err);
		return;
	}

	for (int i = 0; i < ARRAY_SIZE(vcs_client_peer); i++) {
		if (vcs == vcs_client_peer[i]) {
			LOG_DBG("VCS state from remote device %d:", i);
			continue;
		}

		LOG_DBG("Sync with other devices %d", i);

		if (vcs_client_peer[i] == NULL) {
			/* Skip */
			continue;
		}

		ret = bt_vcp_vol_ctlr_set_vol(vcs_client_peer[i], volume);
		if (ret) {
			LOG_DBG("Failed to sync volume to remote device %d, err = "
				"%d",
				i, ret);
		}
	}
}

/**
 * @brief	Callback handler for the VCS controller flags.
 *
 * @note	This callback handler will be triggered if VCS flags changed.
 */
static void vcs_flags_ctlr_cb_handler(struct bt_vcp_vol_ctlr *vcs, int err, uint8_t flags)
{
	if (err) {
		LOG_ERR("VCS flag callback error: %d", err);
	} else {
		LOG_DBG("Volume flags = 0x%01X", flags);
	}
}

/**
 * @brief	Callback handler for the volume state.
 *
 * @note	This callback handler will be triggered if volume state has changed,
 *		or the playback was muted or unmuted from the volume_controller.
 */
static void vcs_state_rend_cb_handler(int err, uint8_t volume, uint8_t mute)
{
	int ret;

	if (err) {
		LOG_ERR("VCS state callback error: %d", err);
		return;
	}
	LOG_INF("Volume = %d, mute state = %d", volume, mute);

	/* Send to bt_rend */
	ret = bt_rend_volume_set(volume, true);
	if (ret) {
		LOG_WRN("Failed to set volume");
	}

	if (mute) {
		ret = bt_rend_volume_mute(true);
		if (ret) {
			LOG_WRN("Error muting volume");
		}
	}
}

/**
 * @brief	Callback handler for the changed VCS renderer flags.
 *
 * @note	This callback handler will be triggered if the VCS flags has changed.
 */
static void vcs_flags_rend_cb_handler(int err, uint8_t flags)
{
	if (err) {
		LOG_ERR("VCS flag callback error: %d", err);
	} else {
		LOG_DBG("Volume flags = 0x%01X", flags);
	}
}

/**
 * @brief	Callback handler for the finished VCS discovery.
 *
 * @note	This callback handler will be triggered when the VCS discovery has finished.
 */
static void vcs_discover_cb_handler(struct bt_vcp_vol_ctlr *vcs, int err, uint8_t vocs_count,
				    uint8_t aics_count)
{
	if (err) {
		LOG_WRN("VCS discover finished callback error: %d", err);
	} else {
		LOG_INF("VCS discover finished");
	}
}

int bt_rend_vol_set(uint8_t volume)
{
	if (IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR)) {
		int ret;

		for (int i = 0; i < ARRAY_SIZE(vcs_client_peer); i++) {
			if (vcs_client_peer[i] != NULL) {
				ret = bt_vcp_vol_ctlr_set_vol(vcs_client_peer[i], volume);
				if (ret) {
					LOG_WRN("Failed to set volume for remote channel %d, ret = "
						"%d",
						i, ret);
				}
			}
		}

		return 0;
	} else if (IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) {
		return bt_vcp_vol_rend_set_vol(volume);
	}

	LOG_WRN("VCP not enabled");
	return -EIO;
}

int bt_rend_vol_up(void)
{
	if (IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR)) {
		int ret;

		for (int i = 0; i < ARRAY_SIZE(vcs_client_peer); i++) {
			if (vcs_client_peer[i] != NULL) {
				ret = bt_vcp_vol_ctlr_unmute_vol_up(vcs_client_peer[i]);
				if (ret) {
					LOG_WRN("Failed to volume up for remote channel %d, ret = "
						"%d",
						i, ret);
				}
			}
		}

		return 0;
	} else if (IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) {
		return bt_vcp_vol_rend_unmute_vol_up();
	}

	LOG_WRN("VCP not enabled");
	return -EIO;
}

int bt_rend_vol_down(void)
{
	if (IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR)) {
		int ret;

		for (int i = 0; i < ARRAY_SIZE(vcs_client_peer); i++) {
			if (vcs_client_peer[i] != NULL) {
				ret = bt_vcp_vol_ctlr_unmute_vol_down(vcs_client_peer[i]);
				if (ret) {
					LOG_WRN("Failed to volume down for remote channel %d, ret "
						"= %d",
						i, ret);
				}
			}
		}

		return 0;
	} else if (IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) {
		return bt_vcp_vol_rend_unmute_vol_down();
	}

	LOG_WRN("VCP not enabled");
	return -EIO;
}

int bt_rend_vol_mute(void)
{
	if (IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR)) {
		int ret;

		for (int i = 0; i < ARRAY_SIZE(vcs_client_peer); i++) {
			if (vcs_client_peer[i] != NULL) {
				ret = bt_vcp_vol_ctlr_mute(vcs_client_peer[i]);
				if (ret) {
					LOG_WRN("Failed to mute for remote channel %d, ret "
						"= %d",
						i, ret);
				}
			}
		}

		return 0;
	} else if (IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) {
		return bt_vcp_vol_rend_mute();
	}

	LOG_WRN("VCP not enabled");
	return -EIO;
}

int bt_rend_vol_unmute(void)
{
	if (IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR)) {
		int ret;

		for (int i = 0; i < ARRAY_SIZE(vcs_client_peer); i++) {
			if (vcs_client_peer[i] != NULL) {
				ret = bt_vcp_vol_ctlr_unmute(vcs_client_peer[i]);
				if (ret) {
					LOG_WRN("Failed to unmute for remote channel %d, "
						"ret = %d",
						i, ret);
				}
			}
		}

		return 0;
	} else if (IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) {
		return bt_vcp_vol_rend_unmute();
	}

	LOG_WRN("VCP not enabled");
	return -EIO;
}

int bt_rend_vol_discover(struct bt_conn *conn)
{
	if (IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR)) {

		int ret, index;

		if (vcs_client_peer_exists(conn)) {
			return -EAGAIN;
		}

		index = vcs_client_peer_index_free_get();
		if (index < 0) {
			return index;
		}

		ret = bt_vcp_vol_ctlr_discover(conn, &vcs_client_peer[index]);
		return ret;
	}

	LOG_ERR("VCP volume controller not enabled");
	return -ECANCELED;
}

int bt_rend_vol_ctlr_init(void)
{
	if (!IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR)) {
		LOG_ERR("VCP volume controller not enabled");
		return -ECANCELED;
	}

	static struct bt_vcp_vol_ctlr_cb vcs_client_callback;

	vcs_client_callback.discover = vcs_discover_cb_handler;
	vcs_client_callback.state = vcs_state_ctlr_cb_handler;
	vcs_client_callback.flags = vcs_flags_ctlr_cb_handler;

	return bt_vcp_vol_ctlr_cb_register(&vcs_client_callback);
}

int bt_rend_vol_rend_init(void)
{
	if (!IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) {
		LOG_ERR("VCP volume renderer not enabled");
		return -ECANCELED;
	}

	int ret;
	struct bt_vcp_vol_rend_register_param vcs_param;
	static struct bt_vcp_vol_rend_cb vcs_server_callback;

	vcs_server_callback.state = vcs_state_rend_cb_handler;
	vcs_server_callback.flags = vcs_flags_rend_cb_handler;
	vcs_param.cb = &vcs_server_callback;
	vcs_param.mute = BT_VCP_STATE_UNMUTED;
	vcs_param.step = CONFIG_BT_AUDIO_VOL_STEP_SIZE;
	vcs_param.volume = CONFIG_BT_AUDIO_VOL_DEFAULT;

	ret = bt_vcp_vol_rend_register(&vcs_param);
	if (ret) {
		return ret;
	}

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/modules/led.c
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "led.h"

#include <zephyr/kernel.h>
#include <zephyr/devicetree.h>
#include <zephyr/drivers/gpio.h>
#include <string.h>
#include <stdlib.h>
#include <zephyr/device.h>

#include "macros_common.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(led, CONFIG_MODULE_LED_LOG_LEVEL);

#define BLINK_FREQ_MS			    1000
/* Maximum number of LED_UNITS. 1 RGB LED = 1 UNIT of 3 LEDS */
#define LED_UNIT_MAX			    10
#define NUM_COLORS_RGB			    3
#define BASE_10				    10
#define DT_LABEL_AND_COMMA(node_id)	    DT_PROP(node_id, label),
#define GPIO_DT_SPEC_GET_AND_COMMA(node_id) GPIO_DT_SPEC_GET(node_id, gpios),

/* The following arrays are populated compile time from the .dts*/
static const char *const led_labels[] = {DT_FOREACH_CHILD(DT_PATH(leds), DT_LABEL_AND_COMMA)};

static const struct gpio_dt_spec leds[] = {
	DT_FOREACH_CHILD(DT_PATH(leds), GPIO_DT_SPEC_GET_AND_COMMA)};

enum led_type {
	LED_MONOCHROME,
	LED_COLOR,
};

struct user_config {
	bool blink;
	enum led_color color;
};

struct led_unit_cfg {
	uint8_t led_no;
	enum led_type unit_type;
	union {
		const struct gpio_dt_spec *mono;
		const struct gpio_dt_spec *color[NUM_COLORS_RGB];
	} type;
	struct user_config user_cfg;
};

static uint8_t leds_num;
static bool initialized;
static struct led_unit_cfg led_units[LED_UNIT_MAX];

/**
 * @brief Configures fields for a RGB LED
 */
static int configure_led_color(uint8_t led_unit, uint8_t led_color, uint8_t led)
{
	if (!device_is_ready(leds[led].port)) {
		LOG_ERR("LED GPIO controller not ready");
		return -ENODEV;
	}

	led_units[led_unit].type.color[led_color] = &leds[led];
	led_units[led_unit].unit_type = LED_COLOR;

	return gpio_pin_configure_dt(led_units[led_unit].type.color[led_color],
				     GPIO_OUTPUT_INACTIVE);
}

/**
 * @brief Configures fields for a monochrome LED
 */
static int config_led_monochrome(uint8_t led_unit, uint8_t led)
{
	if (!device_is_ready(leds[led].port)) {
		LOG_ERR("LED GPIO controller not ready");
		return -ENODEV;
	}

	led_units[led_unit].type.mono = &leds[led];
	led_units[led_unit].unit_type = LED_MONOCHROME;

	return gpio_pin_configure_dt(led_units[led_unit].type.mono, GPIO_OUTPUT_INACTIVE);
}

/**
 * @brief Parses the device tree for LED settings.
 */
static int led_device_tree_parse(void)
{
	int ret;

	for (uint8_t i = 0; i < leds_num; i++) {
		char *end_ptr = NULL;
		uint32_t led_unit = strtoul(led_labels[i], &end_ptr, BASE_10);

		if (led_labels[i] == end_ptr) {
			LOG_ERR("No match for led unit. The dts is likely not properly formatted");
			return -ENXIO;
		}

		if (strstr(led_labels[i], "LED_RGB_RED")) {
			ret = configure_led_color(led_unit, RED, i);
			if (ret) {
				return ret;
			}

		} else if (strstr(led_labels[i], "LED_RGB_GREEN")) {
			ret = configure_led_color(led_unit, GRN, i);
			if (ret) {
				return ret;
			}

		} else if (strstr(led_labels[i], "LED_RGB_BLUE")) {
			ret = configure_led_color(led_unit, BLU, i);
			if (ret) {
				return ret;
			}

		} else if (strstr(led_labels[i], "LED_MONO")) {
			ret = config_led_monochrome(led_unit, i);
			if (ret) {
				return ret;
			}
		} else {
			LOG_ERR("No color identifier for LED %d LED unit %d", i, led_unit);
			return -ENODEV;
		}
	}
	return 0;
}

/**
 * @brief Internal handling to set the status of a led unit
 */
static int led_set_int(uint8_t led_unit, enum led_color color)
{
	int ret;

	if (led_units[led_unit].unit_type == LED_MONOCHROME) {
		if (color) {
			ret = gpio_pin_set_dt(led_units[led_unit].type.mono, 1);
			if (ret) {
				return ret;
			}
		} else {
			ret = gpio_pin_set_dt(led_units[led_unit].type.mono, 0);
			if (ret) {
				return ret;
			}
		}
	} else {
		for (uint8_t i = 0; i < NUM_COLORS_RGB; i++) {
			if (color & BIT(i)) {
				ret = gpio_pin_set_dt(led_units[led_unit].type.color[i], 1);
				if (ret) {
					return ret;
				}
			} else {
				ret = gpio_pin_set_dt(led_units[led_unit].type.color[i], 0);
				if (ret) {
					return ret;
				}
			}
		}
	}

	return 0;
}

static void led_blink_work_handler(struct k_work *work);

K_WORK_DEFINE(led_blink_work, led_blink_work_handler);

/**
 * @brief Submit a k_work on timer expiry.
 */
void led_blink_timer_handler(struct k_timer *dummy)
{
	k_work_submit(&led_blink_work);
}

K_TIMER_DEFINE(led_blink_timer, led_blink_timer_handler, NULL);

/**
 * @brief Periodically invoked by the timer to blink LEDs.
 */
static void led_blink_work_handler(struct k_work *work)
{
	int ret;
	static bool on_phase;

	for (uint8_t i = 0; i < leds_num; i++) {
		if (led_units[i].user_cfg.blink) {
			if (on_phase) {
				ret = led_set_int(i, led_units[i].user_cfg.color);
				ERR_CHK(ret);
			} else {
				ret = led_set_int(i, LED_COLOR_OFF);
				ERR_CHK(ret);
			}
		}
	}

	on_phase = !on_phase;
}

static int led_set(uint8_t led_unit, enum led_color color, bool blink)
{
	int ret;

	if (!initialized) {
		return -EPERM;
	}

	ret = led_set_int(led_unit, color);
	if (ret) {
		return ret;
	}

	led_units[led_unit].user_cfg.blink = blink;
	led_units[led_unit].user_cfg.color = color;

	return 0;
}

int led_on(uint8_t led_unit, ...)
{
	if (led_units[led_unit].unit_type == LED_MONOCHROME) {
		return led_set(led_unit, LED_ON, LED_SOLID);
	}

	va_list args;

	va_start(args, led_unit);
	int color = va_arg(args, int);

	va_end(args);

	if (color <= 0 || color >= LED_COLOR_NUM) {
		LOG_ERR("Invalid color code %d", color);
		return -EINVAL;
	}
	return led_set(led_unit, color, LED_SOLID);
}

int led_blink(uint8_t led_unit, ...)
{
	if (led_units[led_unit].unit_type == LED_MONOCHROME) {
		return led_set(led_unit, LED_ON, LED_BLINK);
	}

	va_list args;

	va_start(args, led_unit);

	int color = va_arg(args, int);

	va_end(args);

	if (color <= 0 || color >= LED_COLOR_NUM) {
		LOG_ERR("Invalid color code %d", color);
		return -EINVAL;
	}

	return led_set(led_unit, color, LED_BLINK);
}

int led_off(uint8_t led_unit)
{
	return led_set(led_unit, LED_COLOR_OFF, LED_SOLID);
}

int led_init(void)
{
	int ret;

	if (initialized) {
		return -EPERM;
	}

	__ASSERT(ARRAY_SIZE(leds) != 0, "No LEDs found in dts");

	leds_num = ARRAY_SIZE(leds);

	ret = led_device_tree_parse();
	if (ret) {
		return ret;
	}

	k_timer_start(&led_blink_timer, K_MSEC(BLINK_FREQ_MS / 2), K_MSEC(BLINK_FREQ_MS / 2));
	initialized = true;
	return 0;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/modules/audio_sync_timer.c
/*
 *  Copyright (c) 2021, PACKETCRAFT, INC.
 *
 *  SPDX-License-Identifier: LicenseRef-PCFT
 */

#include "audio_sync_timer.h"

#include <zephyr/kernel.h>
#include <zephyr/init.h>
#include <nrfx_dppi.h>
#include <nrfx_i2s.h>
#include <nrfx_ipc.h>
#include <nrfx_timer.h>


#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(audio_sync_timer, CONFIG_AUDIO_SYNC_TIMER_LOG_LEVEL);

#define AUDIO_SYNC_TIMER_INSTANCE_NUMBER 1

#define AUDIO_SYNC_TIMER_I2S_FRAME_START_EVT_CAPTURE_CHANNEL 0
#define AUDIO_SYNC_TIMER_CURR_TIME_CAPTURE_CHANNEL	     1
#define AUDIO_SYNC_TIMER_I2S_FRAME_START_EVT_CAPTURE NRF_TIMER_TASK_CAPTURE0

#define AUDIO_SYNC_TIMER_NET_APP_IPC_EVT NRF_IPC_EVENT_RECEIVE_4

static const nrfx_timer_t audio_sync_timer_instance =
	NRFX_TIMER_INSTANCE(AUDIO_SYNC_TIMER_INSTANCE_NUMBER);

static uint8_t dppi_channel_timer_clear;
static uint8_t dppi_channel_i2s_frame_start;

static nrfx_timer_config_t cfg = {.frequency = NRFX_MHZ_TO_HZ(1UL),
				  .mode = NRF_TIMER_MODE_TIMER,
				  .bit_width = NRF_TIMER_BIT_WIDTH_32,
				  .interrupt_priority = NRFX_TIMER_DEFAULT_CONFIG_IRQ_PRIORITY,
				  .p_context = NULL};

uint32_t audio_sync_timer_capture(void)
{
	return nrfx_timer_capture(&audio_sync_timer_instance,
				  AUDIO_SYNC_TIMER_CURR_TIME_CAPTURE_CHANNEL);
}

uint32_t audio_sync_timer_capture_get(void)
{
	return nrfx_timer_capture_get(&audio_sync_timer_instance,
				      AUDIO_SYNC_TIMER_I2S_FRAME_START_EVT_CAPTURE_CHANNEL);
}

static void event_handler(nrf_timer_event_t event_type, void *ctx)
{
}

/**
 * @brief Initialize audio sync timer
 *
 * @note Clearing of the nRF5340 APP core sync
 * timer is initialized here. The sync timers on
 * APP core and NET core are cleared at exactly
 * the same time using an IPC signal sent from
 * the NET core. This makes the two timers
 * synchronized.
 *
 * @param unused Unused
 *
 * @return 0 if successful, error otherwise
 */
static int audio_sync_timer_init(void)
{
	nrfx_err_t ret;

	ret = nrfx_timer_init(&audio_sync_timer_instance, &cfg, event_handler);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx timer init error - Return value: %d", ret);
		return ret;
	}

	nrfx_timer_enable(&audio_sync_timer_instance);

	/* Initialize capturing of I2S frame start event timestamps */
	ret = nrfx_dppi_channel_alloc(&dppi_channel_i2s_frame_start);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx DPPI channel alloc error (I2S frame start) - Return value: %d", ret);
		return ret;
	}

	nrf_timer_subscribe_set(audio_sync_timer_instance.p_reg,
				AUDIO_SYNC_TIMER_I2S_FRAME_START_EVT_CAPTURE,
				dppi_channel_i2s_frame_start);
	nrf_i2s_publish_set(NRF_I2S0, NRF_I2S_EVENT_FRAMESTART, dppi_channel_i2s_frame_start);
	ret = nrfx_dppi_channel_enable(dppi_channel_i2s_frame_start);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx DPPI channel enable error (I2S frame start) - Return value: %d", ret);
		return ret;
	}

	/* Initialize functionality for synchronization between APP and NET core */
	ret = nrfx_dppi_channel_alloc(&dppi_channel_timer_clear);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx DPPI channel alloc error (timer clear) - Return value: %d", ret);
		return ret;
	}

	nrf_ipc_publish_set(NRF_IPC, AUDIO_SYNC_TIMER_NET_APP_IPC_EVT, dppi_channel_timer_clear);
	nrf_timer_subscribe_set(audio_sync_timer_instance.p_reg, NRF_TIMER_TASK_CLEAR,
				dppi_channel_timer_clear);
	ret = nrfx_dppi_channel_enable(dppi_channel_timer_clear);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx DPPI channel enable error (timer clear) - Return value: %d", ret);
		return ret;
	}

	LOG_DBG("Audio sync timer initialized");

	return 0;
}

SYS_INIT(audio_sync_timer_init, POST_KERNEL, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/modules/audio_i2s.c
/*
 *  Copyright (c) 2021, PACKETCRAFT, INC.
 *
 *  SPDX-License-Identifier: LicenseRef-PCFT
 */

#include "audio_i2s.h"

#include <zephyr/kernel.h>
#include <zephyr/device.h>
#include <zephyr/drivers/pinctrl.h>
#include <nrfx_i2s.h>
#include <nrfx_clock.h>

#include "audio_sync_timer.h"

#define I2S_NL DT_NODELABEL(i2s0)

#define HFCLKAUDIO_12_288_MHZ 0x9BAE

enum audio_i2s_state {
	AUDIO_I2S_STATE_UNINIT,
	AUDIO_I2S_STATE_IDLE,
	AUDIO_I2S_STATE_STARTED,
};

static enum audio_i2s_state state = AUDIO_I2S_STATE_UNINIT;

PINCTRL_DT_DEFINE(I2S_NL);

#if CONFIG_AUDIO_SAMPLE_RATE_16000_HZ
#define CONFIG_AUDIO_RATIO NRF_I2S_RATIO_384X
#elif CONFIG_AUDIO_SAMPLE_RATE_24000_HZ
#define CONFIG_AUDIO_RATIO NRF_I2S_RATIO_256X
#elif CONFIG_AUDIO_SAMPLE_RATE_48000_HZ
#define CONFIG_AUDIO_RATIO NRF_I2S_RATIO_128X
#else
#error "Current AUDIO_SAMPLE_RATE_HZ setting not supported"
#endif

static nrfx_i2s_t i2s_inst = NRFX_I2S_INSTANCE(0);

static nrfx_i2s_config_t cfg = {
	/* Pins are configured by pinctrl. */
	.skip_gpio_cfg = true,
	.skip_psel_cfg = true,
	.irq_priority = DT_IRQ(I2S_NL, priority),
	.mode = NRF_I2S_MODE_MASTER,
	.format = NRF_I2S_FORMAT_I2S,
	.alignment = NRF_I2S_ALIGN_LEFT,
	.ratio = CONFIG_AUDIO_RATIO,
	.mck_setup = 0x66666000,
#if (CONFIG_AUDIO_BIT_DEPTH_16)
	.sample_width = NRF_I2S_SWIDTH_16BIT,
#elif (CONFIG_AUDIO_BIT_DEPTH_32)
	.sample_width = NRF_I2S_SWIDTH_32BIT,
#else
#error Invalid bit depth selected
#endif /* (CONFIG_AUDIO_BIT_DEPTH_16) */
	.channels = NRF_I2S_CHANNELS_STEREO,
	.clksrc = NRF_I2S_CLKSRC_ACLK,
	.enable_bypass = false,
};

static i2s_blk_comp_callback_t i2s_blk_comp_callback;

static void i2s_comp_handler(nrfx_i2s_buffers_t const *released_bufs, uint32_t status)
{
	uint32_t frame_start_ts = audio_sync_timer_capture_get();

	if ((status == NRFX_I2S_STATUS_NEXT_BUFFERS_NEEDED) && released_bufs &&
	    i2s_blk_comp_callback && (released_bufs->p_rx_buffer || released_bufs->p_tx_buffer)) {
		i2s_blk_comp_callback(frame_start_ts, released_bufs->p_rx_buffer,
				      released_bufs->p_tx_buffer);
	}
}

void audio_i2s_set_next_buf(const uint8_t *tx_buf, uint32_t *rx_buf)
{
	__ASSERT_NO_MSG(state == AUDIO_I2S_STATE_STARTED);
	if (IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL) || (CONFIG_AUDIO_DEV == GATEWAY)) {
		__ASSERT_NO_MSG(rx_buf != NULL);
	}

	if (IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL) || (CONFIG_AUDIO_DEV == HEADSET)) {
		__ASSERT_NO_MSG(tx_buf != NULL);
	}

	const nrfx_i2s_buffers_t i2s_buf = { .p_rx_buffer = rx_buf,
					     .p_tx_buffer = (uint32_t *)tx_buf };

	nrfx_err_t ret;

	ret = nrfx_i2s_next_buffers_set(&i2s_inst, &i2s_buf);
	__ASSERT_NO_MSG(ret == NRFX_SUCCESS);
}

void audio_i2s_start(const uint8_t *tx_buf, uint32_t *rx_buf)
{
	__ASSERT_NO_MSG(state == AUDIO_I2S_STATE_IDLE);
	if (IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL) || (CONFIG_AUDIO_DEV == GATEWAY)) {
		__ASSERT_NO_MSG(rx_buf != NULL);
	}

	if (IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL) || (CONFIG_AUDIO_DEV == HEADSET)) {
		__ASSERT_NO_MSG(tx_buf != NULL);
	}

	const nrfx_i2s_buffers_t i2s_buf = { .p_rx_buffer = rx_buf,
					     .p_tx_buffer = (uint32_t *)tx_buf };

	nrfx_err_t ret;

	/* Buffer size in 32-bit words */
	ret = nrfx_i2s_start(&i2s_inst, &i2s_buf, I2S_SAMPLES_NUM, 0);
	__ASSERT_NO_MSG(ret == NRFX_SUCCESS);

	state = AUDIO_I2S_STATE_STARTED;
}

void audio_i2s_stop(void)
{
	__ASSERT_NO_MSG(state == AUDIO_I2S_STATE_STARTED);

	nrfx_i2s_stop(&i2s_inst);

	state = AUDIO_I2S_STATE_IDLE;
}

void audio_i2s_blk_comp_cb_register(i2s_blk_comp_callback_t blk_comp_callback)
{
	i2s_blk_comp_callback = blk_comp_callback;
}

void audio_i2s_init(void)
{
	__ASSERT_NO_MSG(state == AUDIO_I2S_STATE_UNINIT);

	nrfx_err_t ret;

	nrfx_clock_hfclkaudio_config_set(HFCLKAUDIO_12_288_MHZ);

	NRF_CLOCK->TASKS_HFCLKAUDIOSTART = 1;

	/* Wait for ACLK to start */
	while (!NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED) {
		k_sleep(K_MSEC(1));
	}

	ret = pinctrl_apply_state(PINCTRL_DT_DEV_CONFIG_GET(I2S_NL), PINCTRL_STATE_DEFAULT);
	__ASSERT_NO_MSG(ret == 0);

	IRQ_CONNECT(DT_IRQN(I2S_NL), DT_IRQ(I2S_NL, priority), nrfx_isr, nrfx_i2s_0_irq_handler, 0);
	irq_enable(DT_IRQN(I2S_NL));

	ret = nrfx_i2s_init(&i2s_inst, &cfg, i2s_comp_handler);
	__ASSERT_NO_MSG(ret == NRFX_SUCCESS);

	state = AUDIO_I2S_STATE_IDLE;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/modules/sd_card.c
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "sd_card.h"

#include <zephyr/kernel.h>
#include <zephyr/device.h>
#include <zephyr/storage/disk_access.h>
#include <zephyr/fs/fs.h>
#include <ff.h>
#include <string.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/devicetree.h>

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(sd_card, CONFIG_MODULE_SD_CARD_LOG_LEVEL);

#define SD_ROOT_PATH	      "/SD:/"
/* Maximum length for path support by Windows file system */
#define PATH_MAX_LEN	      260
#define K_SEM_OPER_TIMEOUT_MS 100

K_SEM_DEFINE(m_sem_sd_oper_ongoing, 1, 1);

static const char *sd_root_path = "/SD:";
static FATFS fat_fs;
static bool sd_init_success;

static struct fs_mount_t mnt_pt = {
	.type = FS_FATFS,
	.fs_data = &fat_fs,
};

int sd_card_list_files(char const *const path, char *buf, size_t *buf_size)
{
	int ret;
	struct fs_dir_t dirp;
	static struct fs_dirent entry;
	char abs_path_name[PATH_MAX_LEN + 1] = SD_ROOT_PATH;
	size_t used_buf_size = 0;

	ret = k_sem_take(&m_sem_sd_oper_ongoing, K_MSEC(K_SEM_OPER_TIMEOUT_MS));
	if (ret) {
		LOG_ERR("Sem take failed. Ret: %d", ret);
		return ret;
	}

	if (!sd_init_success) {
		k_sem_give(&m_sem_sd_oper_ongoing);
		return -ENODEV;
	}

	fs_dir_t_init(&dirp);

	if (path == NULL) {
		ret = fs_opendir(&dirp, sd_root_path);
		if (ret) {
			LOG_ERR("Open SD card root dir failed");
			k_sem_give(&m_sem_sd_oper_ongoing);
			return ret;
		}
	} else {
		if (strlen(path) > CONFIG_FS_FATFS_MAX_LFN) {
			LOG_ERR("Path is too long");
			k_sem_give(&m_sem_sd_oper_ongoing);
			return -FR_INVALID_NAME;
		}

		strcat(abs_path_name, path);

		ret = fs_opendir(&dirp, abs_path_name);
		if (ret) {
			LOG_ERR("Open assigned path failed");
			k_sem_give(&m_sem_sd_oper_ongoing);
			return ret;
		}
	}

	while (1) {
		ret = fs_readdir(&dirp, &entry);
		if (ret) {
			k_sem_give(&m_sem_sd_oper_ongoing);
			return ret;
		}

		if (entry.name[0] == 0) {
			break;
		}

		if (buf != NULL) {
			size_t remaining_buf_size = *buf_size - used_buf_size;
			ssize_t len = snprintk(
				&buf[used_buf_size], remaining_buf_size, "[%s]\t%s\n",
				entry.type == FS_DIR_ENTRY_DIR ? "DIR " : "FILE", entry.name);

			if (len >= remaining_buf_size) {
				LOG_ERR("Failed to append to buffer, error: %d", len);
				k_sem_give(&m_sem_sd_oper_ongoing);
				return -EINVAL;
			}

			used_buf_size += len;
		}

		LOG_INF("[%s] %s", entry.type == FS_DIR_ENTRY_DIR ? "DIR " : "FILE", entry.name);
	}

	ret = fs_closedir(&dirp);
	if (ret) {
		LOG_ERR("Close SD card root dir failed");
		k_sem_give(&m_sem_sd_oper_ongoing);
		return ret;
	}

	*buf_size = used_buf_size;
	k_sem_give(&m_sem_sd_oper_ongoing);
	return 0;
}

int sd_card_open_write_close(char const *const filename, char const *const data, size_t *size)
{
	int ret;
	struct fs_file_t f_entry;
	char abs_path_name[PATH_MAX_LEN + 1] = SD_ROOT_PATH;

	ret = k_sem_take(&m_sem_sd_oper_ongoing, K_MSEC(K_SEM_OPER_TIMEOUT_MS));
	if (ret) {
		LOG_ERR("Sem take failed. Ret: %d", ret);
		return ret;
	}

	if (!sd_init_success) {
		k_sem_give(&m_sem_sd_oper_ongoing);
		return -ENODEV;
	}

	if (strlen(filename) > CONFIG_FS_FATFS_MAX_LFN) {
		LOG_ERR("Filename is too long");
		k_sem_give(&m_sem_sd_oper_ongoing);
		return -ENAMETOOLONG;
	}

	strcat(abs_path_name, filename);
	fs_file_t_init(&f_entry);

	ret = fs_open(&f_entry, abs_path_name, FS_O_CREATE | FS_O_WRITE | FS_O_APPEND);
	if (ret) {
		LOG_ERR("Create file failed");
		k_sem_give(&m_sem_sd_oper_ongoing);
		return ret;
	}

	/* If the file exists, moves the file position pointer to the end of the file */
	ret = fs_seek(&f_entry, 0, FS_SEEK_END);
	if (ret) {
		LOG_ERR("Seek file pointer failed");
		k_sem_give(&m_sem_sd_oper_ongoing);
		return ret;
	}

	ret = fs_write(&f_entry, data, *size);
	if (ret < 0) {
		LOG_ERR("Write file failed");
		k_sem_give(&m_sem_sd_oper_ongoing);
		return ret;
	}

	*size = ret;

	ret = fs_close(&f_entry);
	if (ret) {
		LOG_ERR("Close file failed");
		k_sem_give(&m_sem_sd_oper_ongoing);
		return ret;
	}

	k_sem_give(&m_sem_sd_oper_ongoing);
	return 0;
}

int sd_card_open_read_close(char const *const filename, char *const buf, size_t *size)
{
	int ret;
	struct fs_file_t f_entry;
	char abs_path_name[PATH_MAX_LEN + 1] = SD_ROOT_PATH;

	ret = k_sem_take(&m_sem_sd_oper_ongoing, K_MSEC(K_SEM_OPER_TIMEOUT_MS));
	if (ret) {
		LOG_ERR("Sem take failed. Ret: %d", ret);
		return ret;
	}

	if (!sd_init_success) {
		k_sem_give(&m_sem_sd_oper_ongoing);
		return -ENODEV;
	}

	if (strlen(filename) > CONFIG_FS_FATFS_MAX_LFN) {
		LOG_ERR("Filename is too long");
		k_sem_give(&m_sem_sd_oper_ongoing);
		return -FR_INVALID_NAME;
	}

	strcat(abs_path_name, filename);
	fs_file_t_init(&f_entry);

	ret = fs_open(&f_entry, abs_path_name, FS_O_READ);
	if (ret) {
		LOG_ERR("Open file failed");
		k_sem_give(&m_sem_sd_oper_ongoing);
		return ret;
	}

	ret = fs_read(&f_entry, buf, *size);
	if (ret < 0) {
		LOG_ERR("Read file failed. Ret: %d", ret);
		k_sem_give(&m_sem_sd_oper_ongoing);
		return ret;
	}

	*size = ret;
	if (*size == 0) {
		LOG_WRN("File is empty");
	}

	ret = fs_close(&f_entry);
	if (ret) {
		LOG_ERR("Close file failed");
		k_sem_give(&m_sem_sd_oper_ongoing);
		return ret;
	}

	k_sem_give(&m_sem_sd_oper_ongoing);
	return 0;
}

int sd_card_open(char const *const filename, struct fs_file_t *f_seg_read_entry)
{
	int ret;
	char abs_path_name[PATH_MAX_LEN + 1] = SD_ROOT_PATH;
	size_t avilable_path_space = PATH_MAX_LEN - strlen(SD_ROOT_PATH);

	ret = k_sem_take(&m_sem_sd_oper_ongoing, K_MSEC(K_SEM_OPER_TIMEOUT_MS));
	if (ret) {
		LOG_ERR("Sem take failed. Ret: %d", ret);
		return ret;
	}

	if (!sd_init_success) {
		k_sem_give(&m_sem_sd_oper_ongoing);
		return -ENODEV;
	}

	if (strlen(filename) > CONFIG_FS_FATFS_MAX_LFN) {
		LOG_ERR("Filename is too long");
		k_sem_give(&m_sem_sd_oper_ongoing);
		return -ENAMETOOLONG;
	}

	if ((strlen(abs_path_name) + strlen(filename)) > PATH_MAX_LEN) {
		LOG_ERR("Filepath is too long");
		k_sem_give(&m_sem_sd_oper_ongoing);
		return -EINVAL;
	}

	strncat(abs_path_name, filename, avilable_path_space);

	LOG_INF("abs path name:\t%s", abs_path_name);

	fs_file_t_init(f_seg_read_entry);

	ret = fs_open(f_seg_read_entry, abs_path_name, FS_O_READ);
	if (ret) {
		LOG_ERR("Open file failed: %d", ret);
		k_sem_give(&m_sem_sd_oper_ongoing);
		return ret;
	}

	return 0;
}

int sd_card_read(char *buf, size_t *size, struct fs_file_t *f_seg_read_entry)
{
	int ret;

	if (!(k_sem_count_get(&m_sem_sd_oper_ongoing) <= 0)) {
		LOG_ERR("SD operation not ongoing");
		return -EPERM;
	}

	ret = fs_read(f_seg_read_entry, buf, *size);
	if (ret < 0) {
		LOG_ERR("Read file failed. Ret: %d", ret);
		k_sem_give(&m_sem_sd_oper_ongoing);
		return ret;
	}

	*size = ret;

	return 0;
}

int sd_card_close(struct fs_file_t *f_seg_read_entry)
{
	int ret;

	if (k_sem_count_get(&m_sem_sd_oper_ongoing) != 0) {
		LOG_ERR("SD operation not ongoing");
		return -EPERM;
	}

	ret = fs_close(f_seg_read_entry);
	if (ret) {
		LOG_ERR("Close file failed: %d", ret);
		k_sem_give(&m_sem_sd_oper_ongoing);
		return ret;
	}

	k_sem_give(&m_sem_sd_oper_ongoing);
	return 0;
}

int sd_card_init(void)
{
	int ret;
	static const char *sd_dev = "SD";
	uint64_t sd_card_size_bytes;
	uint32_t sector_count;
	size_t sector_size;

	ret = disk_access_init(sd_dev);
	if (ret) {
		LOG_DBG("SD card init failed, please check if SD card inserted");
		return -ENODEV;
	}

	ret = disk_access_ioctl(sd_dev, DISK_IOCTL_GET_SECTOR_COUNT, &sector_count);
	if (ret) {
		LOG_ERR("Unable to get sector count");
		return ret;
	}

	LOG_DBG("Sector count: %d", sector_count);

	ret = disk_access_ioctl(sd_dev, DISK_IOCTL_GET_SECTOR_SIZE, &sector_size);
	if (ret) {
		LOG_ERR("Unable to get sector size");
		return ret;
	}

	LOG_DBG("Sector size: %d bytes", sector_size);

	sd_card_size_bytes = (uint64_t)sector_count * sector_size;

	LOG_INF("SD card volume size: %d MB", (uint32_t)(sd_card_size_bytes >> 20));

	mnt_pt.mnt_point = sd_root_path;

	ret = fs_mount(&mnt_pt);
	if (ret) {
		LOG_ERR("Mnt. disk failed, could be format issue. should be FAT/exFAT");
		return ret;
	}

	sd_init_success = true;

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/modules/CMakeLists.txt
#
# Copyright (c) 2022 Nordic Semiconductor
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

set(SRCS
  ${CMAKE_CURRENT_SOURCE_DIR}/audio_i2s.c
  ${CMAKE_CURRENT_SOURCE_DIR}/audio_usb.c
  ${CMAKE_CURRENT_SOURCE_DIR}/button_handler.c
  ${CMAKE_CURRENT_SOURCE_DIR}/hw_codec.c
  ${CMAKE_CURRENT_SOURCE_DIR}/led.c
  ${CMAKE_CURRENT_SOURCE_DIR}/power_meas.c
  ${CMAKE_CURRENT_SOURCE_DIR}/sd_card.c
)

if (CONFIG_AUDIO_SYNC_TIMER_USES_RTC)
  list(APPEND SRCS ${CMAKE_CURRENT_SOURCE_DIR}/audio_sync_timer_rtc.c)
else()
  list(APPEND SRCS ${CMAKE_CURRENT_SOURCE_DIR}/audio_sync_timer.c)
endif()

if (CONFIG_SD_CARD_PLAYBACK)
  list(APPEND SRCS ${CMAKE_CURRENT_SOURCE_DIR}/sd_card_playback.c)
endif()

target_sources(app PRIVATE ${SRCS})


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/modules/Kconfig.defaults
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

# GATEWAY
if AUDIO_DEV = 2

if AUDIO_SOURCE_USB

config USB_DEVICE_STACK
	default y

# Net buf options needed for USB stack
config NET_BUF
	default y

config USB_DEVICE_AUDIO
	default y

## TODO: Nordic VID, change accordingly
config USB_DEVICE_VID
	default 0x1915

## TODO: Change for final product
config USB_DEVICE_PID
	default 0x530A

config USB_DEVICE_PRODUCT
	default "nRF5340 USB Audio"

config USB_DEVICE_MANUFACTURER
	default "Nordic Semiconductor AS"

## Avoid redundant warnings for endpoint setting in USB stack
config USB_DRIVER_LOG_LEVEL
	default 1

config USB_DEVICE_LOG_LEVEL
	default 1

endif # AUDIO_SOURCE_USB

endif # AUDIO_DEV = 2 (GATEWAY)


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/modules/power_meas.c
/*
 * Copyright (c) 2022 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include <zephyr/kernel.h>
#include <zephyr/device.h>
#include <zephyr/drivers/sensor.h>
#include <zephyr/logging/log.h>
#include <zephyr/shell/shell.h>
#include <zephyr/sys/util.h>

LOG_MODULE_REGISTER(power_meas, CONFIG_MODULE_POWER_LOG_LEVEL);

#define POWER_RAIL_NUM 4U
static k_tid_t pwr_meas_thread_id;

struct power_rail_config {
	const char *name;
	const struct device *sensor;
};

static const struct power_rail_config rail_config[POWER_RAIL_NUM] = {
	{"VBAT", DEVICE_DT_GET(DT_NODELABEL(vbat_sensor))},
	{"VDD1_CODEC", DEVICE_DT_GET(DT_NODELABEL(vdd1_codec_sensor))},
	{"VDD2_CODEC", DEVICE_DT_GET(DT_NODELABEL(vdd2_codec_sensor))},
	{"VDD2_NRF", DEVICE_DT_GET(DT_NODELABEL(vdd2_nrf_sensor))},
};
static bool rail_enabled[POWER_RAIL_NUM];

K_THREAD_STACK_DEFINE(meas_stack, CONFIG_POWER_MEAS_STACK_SIZE);
static struct k_thread meas_thread;
K_SEM_DEFINE(meas_sem, 0, 1);
static bool meas_enabled;

/**
 * @brief Read a power rail data (voltage/current/power) and log results.
 *
 * @param[in] config Power rail configuration.
 *
 * @retval 0 on success
 * @retval -errno on sensor fetch/get error.
 */
static int read_and_log(const struct power_rail_config *config)
{
	int ret;
	struct sensor_value voltage, current, power;

	ret = sensor_sample_fetch(config->sensor);
	if (ret < 0) {
		return ret;
	}

	ret = sensor_channel_get(config->sensor, SENSOR_CHAN_VOLTAGE, &voltage);
	if (ret < 0) {
		return ret;
	}

	ret = sensor_channel_get(config->sensor, SENSOR_CHAN_CURRENT, &current);
	if (ret < 0) {
		return ret;
	}

	ret = sensor_channel_get(config->sensor, SENSOR_CHAN_POWER, &power);
	if (ret < 0) {
		return ret;
	}

	LOG_INF("%-10s:\t%.3fV, %06.3fmA, %06.3fmW", config->name, sensor_value_to_double(&voltage),
		sensor_value_to_double(&current) * 1000.0f,
		sensor_value_to_double(&power) * 1000.0f);

	return 0;
}

/** @brief Measurement thread */
static void meas_thread_fn(void *dummy1, void *dummy2, void *dummy3)
{
	ARG_UNUSED(dummy1);
	ARG_UNUSED(dummy2);
	ARG_UNUSED(dummy3);

	while (1) {
		if (!meas_enabled) {
			k_sem_take(&meas_sem, K_FOREVER);
		}

		for (size_t i = 0U; i < POWER_RAIL_NUM; i++) {
			int ret;

			if (!rail_enabled[i]) {
				continue;
			}

			ret = read_and_log(&rail_config[i]);
			if (ret < 0) {
				LOG_ERR("Could not read %s", rail_config->name);
			}
		}

		k_msleep(CONFIG_POWER_MEAS_INTERVAL_MS);
	}
}

static int power_meas_init(void)
{
	int ret;

	/* check if all sensors are ready */
	for (size_t i = 0U; i < POWER_RAIL_NUM; i++) {
		if (!device_is_ready(rail_config[i].sensor)) {
			LOG_ERR("INA231 device not ready: %s\n", rail_config->name);
			return -ENODEV;
		}
	}

	/* enable all sensors and measurement if configured */
	if (IS_ENABLED(CONFIG_POWER_MEAS_START_ON_BOOT)) {
		meas_enabled = true;

		for (size_t i = 0U; i < POWER_RAIL_NUM; i++) {
			rail_enabled[i] = true;
		}
	}

	/* start measurement thread */
	pwr_meas_thread_id = k_thread_create(
		&meas_thread, meas_stack, CONFIG_POWER_MEAS_STACK_SIZE, meas_thread_fn, NULL, NULL,
		NULL, K_PRIO_PREEMPT(CONFIG_POWER_MEAS_THREAD_PRIO), 0, K_NO_WAIT);
	ret = k_thread_name_set(pwr_meas_thread_id, "pwr_meas");
	if (ret) {
		return ret;
	}

	return 0;
}

SYS_INIT(power_meas_init, APPLICATION, CONFIG_APPLICATION_INIT_PRIORITY);

static int cmd_info(const struct shell *shell, size_t argc, char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	for (size_t i = 0U; i < POWER_RAIL_NUM; i++) {
		shell_print(shell, "%-10s: %s", rail_config[i].name,
			    rail_enabled[i] ? "enabled" : "disabled");
	}

	return 0;
}

static int cmd_config(const struct shell *shell, size_t argc, const char **argv)
{
	bool enable;

	if (argc != 3) {
		shell_error(shell, "Usage: power config RAIL|all enable|disable");
		return -EINVAL;
	}

	enable = strcmp(argv[2], "enable") == 0;

	if (strcmp(argv[1], "all") == 0) {
		for (size_t i = 0U; i < POWER_RAIL_NUM; i++) {
			rail_enabled[i] = enable;
		}

		shell_print(shell, "All rails %s", enable ? "enabled" : "disabled");
	} else {
		size_t i;

		for (i = 0U; i < POWER_RAIL_NUM; i++) {
			if (strcmp(argv[1], rail_config[i].name) == 0) {
				break;
			}
		}

		if (i == POWER_RAIL_NUM) {
			shell_error(shell, "Invalid power rail");
			return -EINVAL;
		}

		rail_enabled[i] = enable;

		shell_print(shell, "Rail %s %s", rail_config[i].name,
			    enable ? "enabled" : "disabled");
	}

	return 0;
}

static int cmd_meas_start(const struct shell *shell, size_t argc, const char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	if (meas_enabled) {
		shell_error(shell, "Measurement already started");
		return -EALREADY;
	}

	meas_enabled = true;
	k_sem_give(&meas_sem);

	shell_print(shell, "Measurement started");

	return 0;
}

static int cmd_meas_stop(const struct shell *shell, size_t argc, const char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	meas_enabled = false;

	shell_print(shell, "Measurement stopped");

	return 0;
}

SHELL_STATIC_SUBCMD_SET_CREATE(
	power_meas_cmd, SHELL_COND_CMD(CONFIG_SHELL, info, NULL, "Show power rails info", cmd_info),
	SHELL_COND_CMD(CONFIG_SHELL, config, NULL, "Configure power rails", cmd_config),
	SHELL_COND_CMD(CONFIG_SHELL, start, NULL, "Start measurements", cmd_meas_start),
	SHELL_COND_CMD(CONFIG_SHELL, stop, NULL, "Stop measurements", cmd_meas_stop),
	SHELL_SUBCMD_SET_END);

SHELL_CMD_REGISTER(power, &power_meas_cmd, "Configure power measurements", NULL);


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/modules/sd_card_playback.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _SD_CARD_PLAYBACK_H_
#define _SD_CARD_PLAYBACK_H_

/**
 * @file
 * @defgroup sd_card_playback SD card playback.
 * @{
 * @brief The SD card playback module for nRF5340 Audio.
 */

#include <zephyr/kernel.h>

/**
 * @brief	Check whether or not the SD card playback module is active.
 *
 * @retval	true    Active.
 * @retval	false   Not active.
 */
bool sd_card_playback_is_active(void);

/**
 * @brief	Play audio from a WAV file from the SD card. Only support for mono files.
 *
 * @note	Supports only 48k mono files.
 *
 * @param[in]	filename	Name of file to be played. Path from the root of the SD card is
 *                              accepted.
 *
 * @retval	0       Success.
 * @retval	-EACCES SW codec is not initialized.
 */
int sd_card_playback_wav(char *filename);

/**
 * @brief	Play audio from an LC3 file from the SD card.
 *
 * @note	Supports only mono files.
 *
 * @param[in]	filename	Name of file to be played. Path from the root of the SD card is
 * accepted.
 *
 * @retval	0       Success.
 * @retval	-EACCES SW codec is not initialized.
 */
int sd_card_playback_lc3(char *filename);

/**
 * @brief	Mix the PCM data from the SD card playback module with the audio stream out.
 *
 * @param[in, out]	pcm_a           Buffer into which to mix PCM data from the LC3 module.
 * @param[in]		pcm_a_size	Size of the input buffer.
 *
 * @retval	0       Success.
 * @retval      -EACCES SD card playback is not active.
 * @retval      Otherwise, error from underlying drivers.
 */
int sd_card_playback_mix_with_stream(void *const pcm_a, size_t pcm_a_size);

/**
 * @brief	Initialize the SD card playback module. Create the SD card playback thread.
 *
 * @return	0 on success, otherwise, error from underlying drivers.
 */
int sd_card_playback_init(void);

/**
 * @}
 */

#endif /* _SD_CARD_PLAYBACK_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/modules/button_handler.c
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "button_handler.h"
#include "button_assignments.h"

#include <zephyr/kernel.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/sys/util.h>
#include <zephyr/shell/shell.h>
#include <zephyr/zbus/zbus.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>

#include "macros_common.h"
#include "nrf5340_audio_common.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(button_handler, CONFIG_MODULE_BUTTON_HANDLER_LOG_LEVEL);

ZBUS_CHAN_DEFINE(button_chan, struct button_msg, NULL, NULL, ZBUS_OBSERVERS_EMPTY,
		 ZBUS_MSG_INIT(0));

/* How many buttons does the module support. Increase at memory cost */
#define BUTTONS_MAX 5
#define BASE_10	    10

/* Only allow one button msg at a time, as a mean of debounce */
K_MSGQ_DEFINE(button_queue, sizeof(struct button_msg), 1, 4);

static bool debounce_is_ongoing;
static struct gpio_callback btn_callback[BUTTONS_MAX];

/* clang-format off */
const static struct btn_config btn_cfg[] = {
	{
		.btn_name = STRINGIFY(BUTTON_VOLUME_DOWN),
		.btn_pin = BUTTON_VOLUME_DOWN,
		.btn_cfg_mask = DT_GPIO_FLAGS(DT_ALIAS(sw0), gpios),
	},
	{
		.btn_name = STRINGIFY(BUTTON_VOLUME_UP),
		.btn_pin = BUTTON_VOLUME_UP,
		.btn_cfg_mask = DT_GPIO_FLAGS(DT_ALIAS(sw1), gpios),
	},
	{
		.btn_name = STRINGIFY(BUTTON_PLAY_PAUSE),
		.btn_pin = BUTTON_PLAY_PAUSE,
		.btn_cfg_mask = DT_GPIO_FLAGS(DT_ALIAS(sw2), gpios),
	},
	{
		.btn_name = STRINGIFY(BUTTON_4),
		.btn_pin = BUTTON_4,
		.btn_cfg_mask = DT_GPIO_FLAGS(DT_ALIAS(sw3), gpios),
	},
	{
		.btn_name = STRINGIFY(BUTTON_5),
		.btn_pin = BUTTON_5,
		.btn_cfg_mask = DT_GPIO_FLAGS(DT_ALIAS(sw4), gpios),
	}
};
/* clang-format on */

static const struct device *gpio_53_dev;

/**@brief Simple debouncer for buttons
 *
 * @note Needed as low-level driver debouce is not
 * implemented in Zephyr for nRF53 yet
 */
static void on_button_debounce_timeout(struct k_timer *timer)
{
	debounce_is_ongoing = false;
}

K_TIMER_DEFINE(button_debounce_timer, on_button_debounce_timeout, NULL);

/** @brief Find the index of a button from the pin number
 */
static int pin_to_btn_idx(uint8_t btn_pin, uint32_t *pin_idx)
{
	for (uint8_t i = 0; i < ARRAY_SIZE(btn_cfg); i++) {
		if (btn_pin == btn_cfg[i].btn_pin) {
			*pin_idx = i;
			return 0;
		}
	}

	LOG_WRN("Button idx not found");
	return -ENODEV;
}

/** @brief Convert from mask to pin
 *
 * @note: Will check that a single bit and a single bit only is set in the mask.
 */
static int pin_msk_to_pin(uint32_t pin_msk, uint32_t *pin_out)
{
	if (!pin_msk) {
		LOG_ERR("Mask is empty");
		return -EACCES;
	}

	if (pin_msk & (pin_msk - 1)) {
		LOG_ERR("Two or more buttons set in mask");
		return -EACCES;
	}

	*pin_out = 0;

	while (pin_msk) {
		pin_msk = pin_msk >> 1;
		(*pin_out)++;
	}

	/* Deduct 1 for zero indexing */
	(*pin_out)--;

	return 0;
}

static void button_publish_thread(void)
{
	int ret;
	struct button_msg msg;

	while (1) {
		k_msgq_get(&button_queue, &msg, K_FOREVER);

		ret = zbus_chan_pub(&button_chan, &msg, K_NO_WAIT);
		if (ret) {
			LOG_ERR("Failed to publish button msg, ret: %d", ret);
		}
	}
}

K_THREAD_DEFINE(button_publish, CONFIG_BUTTON_PUBLISH_STACK_SIZE, button_publish_thread, NULL, NULL,
		NULL, K_PRIO_PREEMPT(CONFIG_BUTTON_PUBLISH_THREAD_PRIO), 0, 0);

/*  ISR triggered by GPIO when assigned button(s) are pushed */
static void button_isr(const struct device *port, struct gpio_callback *cb, uint32_t pin_msk)
{
	int ret;
	struct button_msg msg;

	if (debounce_is_ongoing) {
		LOG_DBG("Btn debounce in action");
		return;
	}

	uint32_t btn_pin = 0;
	uint32_t btn_idx = 0;

	ret = pin_msk_to_pin(pin_msk, &btn_pin);
	ERR_CHK(ret);

	ret = pin_to_btn_idx(btn_pin, &btn_idx);
	ERR_CHK(ret);

	LOG_DBG("Pushed button idx: %d pin: %d name: %s", btn_idx, btn_pin,
		btn_cfg[btn_idx].btn_name);

	msg.button_pin = btn_pin;
	msg.button_action = BUTTON_PRESS;

	ret = k_msgq_put(&button_queue, (void *)&msg, K_NO_WAIT);
	if (ret == -EAGAIN) {
		LOG_WRN("Btn msg queue full");
	}

	debounce_is_ongoing = true;
	k_timer_start(&button_debounce_timer, K_MSEC(CONFIG_BUTTON_DEBOUNCE_MS), K_NO_WAIT);
}

int button_pressed(gpio_pin_t button_pin, bool *button_pressed)
{
	int ret;

	if (!device_is_ready(gpio_53_dev)) {
		return -ENODEV;
	}

	if (button_pressed == NULL) {
		return -EINVAL;
	}

	ret = gpio_pin_get(gpio_53_dev, button_pin);
	switch (ret) {
	case 0:
		*button_pressed = false;
		break;
	case 1:
		*button_pressed = true;
		break;
	default:
		return ret;
	}

	return 0;
}

int button_handler_init(void)
{
	int ret;

	if (ARRAY_SIZE(btn_cfg) == 0) {
		LOG_WRN("No buttons assigned");
		return -EINVAL;
	}

	gpio_53_dev = DEVICE_DT_GET(DT_NODELABEL(gpio0));

	if (!device_is_ready(gpio_53_dev)) {
		LOG_ERR("Device driver not ready.");
		return -ENODEV;
	}

	for (uint8_t i = 0; i < ARRAY_SIZE(btn_cfg); i++) {
		ret = gpio_pin_configure(gpio_53_dev, btn_cfg[i].btn_pin,
					 GPIO_INPUT | btn_cfg[i].btn_cfg_mask);
		if (ret) {
			return ret;
		}

		gpio_init_callback(&btn_callback[i], button_isr, BIT(btn_cfg[i].btn_pin));

		ret = gpio_add_callback(gpio_53_dev, &btn_callback[i]);
		if (ret) {
			return ret;
		}

		ret = gpio_pin_interrupt_configure(gpio_53_dev, btn_cfg[i].btn_pin,
						   GPIO_INT_EDGE_TO_INACTIVE);
		if (ret) {
			return ret;
		}
	}

	return 0;
}

/* Shell functions */
static int cmd_print_all_btns(const struct shell *shell, size_t argc, char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	for (uint8_t i = 0; i < ARRAY_SIZE(btn_cfg); i++) {
		shell_print(shell, "Id %d: pin: %d %s", i, btn_cfg[i].btn_pin, btn_cfg[i].btn_name);
	}

	return 0;
}

static int cmd_push_btn(const struct shell *shell, size_t argc, char **argv)
{
	int ret;
	uint8_t btn_idx;
	struct button_msg msg;

	/* First argument is function, second is button idx */
	if (argc != 2) {
		shell_error(shell, "Wrong number of arguments provided");
		return -EINVAL;
	}

	if (!isdigit((int)argv[1][0])) {
		shell_error(shell, "Supplied argument is not numeric");
		return -EINVAL;
	}

	btn_idx = strtoul(argv[1], NULL, BASE_10);

	if (btn_idx >= ARRAY_SIZE(btn_cfg)) {
		shell_error(shell, "Selected button ID out of range");
		return -EINVAL;
	}

	msg.button_pin = btn_cfg[btn_idx].btn_pin;
	msg.button_action = BUTTON_PRESS;

	ret = zbus_chan_pub(&button_chan, &msg, K_NO_WAIT);
	if (ret) {
		LOG_ERR("Failed to publish button msg, ret: %d", ret);
	}

	shell_print(shell, "Pushed button idx: %d pin: %d : %s", btn_idx, btn_cfg[btn_idx].btn_pin,
		    btn_cfg[btn_idx].btn_name);

	return 0;
}

/* Creating subcommands (level 1 command) array for command "demo". */
SHELL_STATIC_SUBCMD_SET_CREATE(buttons_cmd,
			       SHELL_COND_CMD(CONFIG_SHELL, print, NULL, "Print all buttons.",
					      cmd_print_all_btns),
			       SHELL_COND_CMD(CONFIG_SHELL, push, NULL, "Push button.",
					      cmd_push_btn),
			       SHELL_SUBCMD_SET_END);
/* Creating root (level 0) command "demo" without a handler */
SHELL_CMD_REGISTER(buttons, &buttons_cmd, "List and push buttons", NULL);


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/modules/Kconfig
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

rsource "Kconfig.defaults"

menu "Modules"

config BUTTON_DEBOUNCE_MS
	int "Button debounce time in ms"
	default 50

config AUDIO_SYNC_TIMER_USES_RTC
	bool
	default !BT_LL_ACS_NRF53
	select NRFX_RTC0

#----------------------------------------------------------------------------#
menu "Power measurement"

config POWER_MEAS_INTERVAL_MS
	int "Power measurement interval in milliseconds"
	default 8500
	help
	  Power measurement runs continuously, this option just establishes the
	  results polling period. Note that this value needs to be >= the configured
	  sampling interval on the current sensor. When below, repeated measurements
	  will be observed.

config POWER_MEAS_START_ON_BOOT
	bool "Start power measurements for all rails on boot"
	help
	  This option will automatically start and periodically print
	  the voltage, current consumption, and power usage for the
	  following rails: VBAT, VDD1_CODEC, VDD2_CODEC, and VDD2_NRF

endmenu # Power measurement

#----------------------------------------------------------------------------#
menu "I2S"

config I2S_LRCK_FREQ_HZ
	int
	default AUDIO_SAMPLE_RATE_HZ
	help
	 The sample rate of I2S. For now this is tied directly to
	 AUDIO_SAMPLE_RATE_HZ
	 Note that this setting is only valid in I2S master mode.

config I2S_CH_NUM
	int
	default 2
	help
	 The I2S driver itself supports both mono and stereo.
	 Parts of the implementation are configured for only stereo.

endmenu # I2S

#----------------------------------------------------------------------------#
menu "Log levels"

module = MODULE_AUDIO_USB
module-str = module-audio-usb
source "subsys/logging/Kconfig.template.log_config"

module = MODULE_BUTTON_HANDLER
module-str = module-button-handler
source "subsys/logging/Kconfig.template.log_config"

module = MODULE_HW_CODEC
module-str = module-hw-codec
source "subsys/logging/Kconfig.template.log_config"

module = MODULE_LED
module-str = module-led
source "subsys/logging/Kconfig.template.log_config"

module = MODULE_POWER
module-str = module-power
source "subsys/logging/Kconfig.template.log_config"

module = MODULE_SD_CARD
module-str = module-sd-card
source "subsys/logging/Kconfig.template.log_config"

module = MODULE_SD_CARD_PLAYBACK
module-str = module-sd-card-playback
source "subsys/logging/Kconfig.template.log_config"

module = MODULE_NRF5340_AUDIO_DK
module-str = module-nrf5340-audio_dk
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log levels

#----------------------------------------------------------------------------#
menu "Thread priorities"

config POWER_MEAS_THREAD_PRIO
	int "Priority for power measurement thread"
	default 6
	help
	  This is a preemptible thread.

config BUTTON_PUBLISH_THREAD_PRIO
	int "Priority for button publish thread"
	default 5
	help
	  This is a preemptible thread.
	  This thread will publish button events to zbus.

config VOLUME_MSG_SUB_THREAD_PRIO
	int "Priority for volume message subscribe thread"
	default 5
	help
	  This is a preemptible thread.
	  This thread will subscribe to volume events from zbus.

endmenu # Thread priorities

#----------------------------------------------------------------------------#
menu "Stack sizes"

config POWER_MEAS_STACK_SIZE
	int "Stack size for power measurement thread"
	default 1152

config BUTTON_PUBLISH_STACK_SIZE
	int "Stack size for button publish thread"
	default 450

config VOLUME_MSG_SUB_STACK_SIZE
	int "Stack size for volume message subscribe thread"
	default 768

endmenu # Stack sizes

#----------------------------------------------------------------------------#
menu "Zbus"

config VOLUME_MSG_SUB_QUEUE_SIZE
	int "Queue size for volume message subscriber"
	default 4

endmenu # Zbus

#----------------------------------------------------------------------------#
menuconfig SD_CARD_PLAYBACK
	bool "Enable playback from SD card"
	select EXPERIMENTAL
	default n
	select RING_BUFFER

if SD_CARD_PLAYBACK

config SD_CARD_PLAYBACK_STACK_SIZE
	int "Stack size for the SD card playback thread"
	default 4096

config SD_CARD_PLAYBACK_RING_BUF_SIZE
	int "Size of the ring buffer for the SD card playback module"
	default 960

config SD_CARD_PLAYBACK_THREAD_PRIORITY
	int "Priority for the SD card playback thread"
	default 7

endif # SD_CARD_PLAYBACK

endmenu # Modules


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/modules/audio_usb.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _AUDIO_USB_H_
#define _AUDIO_USB_H_

#include "data_fifo.h"

#if (CONFIG_AUDIO_SOURCE_USB && !CONFIG_AUDIO_SAMPLE_RATE_48000_HZ)
/* Only 48kHz is supported when using USB */
#error USB only supports 48kHz
#endif /* (CONFIG_AUDIO_SOURCE_USB && !CONFIG_AUDIO_SAMPLE_RATE_48000_HZ) */

/**
 * @brief Set fifo buffers to be used by USB module and start sending/receiving data
 *
 * @param fifo_tx_in  Pointer to fifo structure for tx
 * @param fifo_rx_in  Pointer to fifo structure for rx
 *
 * @return 0 if successful, error otherwise
 */
int audio_usb_start(struct data_fifo *fifo_tx_in, struct data_fifo *fifo_rx_in);

/**
 * @brief Stop sending/receiving data
 *
 * @note The USB device will still be running, but all data sent to
 *       it will be discarded
 */
void audio_usb_stop(void);

/**
 * @brief Stop and disable USB device
 *
 * @return 0 if successful, error otherwise
 */
int audio_usb_disable(void);

/**
 * @brief Register and enable USB device
 *
 * @return 0 if successful, error otherwise
 */
int audio_usb_init(void);

#endif /* _AUDIO_USB_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/modules/hw_codec.c
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "hw_codec.h"

#include <zephyr/kernel.h>
#include <stdlib.h>
#include <stdint.h>
#include <ctype.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/device.h>
#include <zephyr/shell/shell.h>
#include <zephyr/zbus/zbus.h>

#include "macros_common.h"
#include "nrf5340_audio_common.h"
#include "cs47l63.h"
#include "cs47l63_spec.h"
#include "cs47l63_reg_conf.h"
#include "cs47l63_comm.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(hw_codec, CONFIG_MODULE_HW_CODEC_LOG_LEVEL);

#define VOLUME_ADJUST_STEP_DB 3
#define BASE_10		      10

ZBUS_SUBSCRIBER_DEFINE(volume_evt_sub, CONFIG_VOLUME_MSG_SUB_QUEUE_SIZE);

static uint32_t prev_volume_reg_val = OUT_VOLUME_DEFAULT;

static cs47l63_t cs47l63_driver;

static k_tid_t volume_msg_sub_thread_id;
static struct k_thread volume_msg_sub_thread_data;

K_THREAD_STACK_DEFINE(volume_msg_sub_thread_stack, CONFIG_VOLUME_MSG_SUB_STACK_SIZE);

/**
 * @brief	Convert the zbus volume to the actual volume setting for the HW codec.
 *
 * @note	The range for zbus volume is from 0 to 255 and the
 *		range for HW codec volume is from 0 to 128.
 */
static uint16_t zbus_vol_conversion(uint8_t volume)
{
	return (((uint16_t)volume + 1) / 2);
}

/**
 * @brief	Handle volume events from zbus.
 */
static void volume_msg_sub_thread(void)
{
	int ret;

	const struct zbus_channel *chan;

	while (1) {
		ret = zbus_sub_wait(&volume_evt_sub, &chan, K_FOREVER);
		ERR_CHK(ret);

		struct volume_msg msg;

		ret = zbus_chan_read(chan, &msg, ZBUS_READ_TIMEOUT_MS);
		if (ret) {
			LOG_ERR("Failed to read from zbus: %d", ret);
		}

		uint8_t event = msg.event;
		uint8_t volume = msg.volume;

		LOG_DBG("Received event = %d, volume = %d", event, volume);

		switch (event) {
		case VOLUME_UP:
			LOG_DBG("Volume up received");
			ret = hw_codec_volume_increase();
			if (ret) {
				LOG_ERR("Failed to increase volume, ret: %d", ret);
			}
			break;
		case VOLUME_DOWN:
			LOG_DBG("Volume down received");
			ret = hw_codec_volume_decrease();
			if (ret) {
				LOG_ERR("Failed to decrease volume, ret: %d", ret);
			}
			break;
		case VOLUME_SET:
			LOG_DBG("Volume set received");
			ret = hw_codec_volume_set(zbus_vol_conversion(volume));
			if (ret) {
				LOG_ERR("Failed to set the volume to %d, ret: %d", volume, ret);
			}
			break;
		case VOLUME_MUTE:
			LOG_DBG("Volume mute received");
			ret = hw_codec_volume_mute();
			if (ret) {
				LOG_ERR("Failed to mute volume, ret: %d", ret);
			}
			break;
		case VOLUME_UNMUTE:
			LOG_DBG("Volume unmute received");
			ret = hw_codec_volume_unmute();
			if (ret) {
				LOG_ERR("Failed to unmute volume, ret: %d", ret);
			}
			break;
		default:
			LOG_WRN("Unexpected/unhandled volume event: %d", event);
			break;
		}

		STACK_USAGE_PRINT("volume_msg_thread", &volume_msg_sub_thread_data);
	}
}

/**
 * @brief Write to multiple registers in CS47L63.
 */
static int cs47l63_comm_reg_conf_write(const uint32_t config[][2], uint32_t num_of_regs)
{
	int ret;
	uint32_t reg;
	uint32_t value;

	for (int i = 0; i < num_of_regs; i++) {
		reg = config[i][0];
		value = config[i][1];

		if (reg == SPI_BUSY_WAIT) {
			LOG_DBG("Busy waiting instead of writing to CS47L63");
			/* Wait for us defined in value */
			k_busy_wait(value);
		} else {
			ret = cs47l63_write_reg(&cs47l63_driver, reg, value);
			if (ret) {
				return ret;
			}
		}
	}

	return 0;
}

int hw_codec_volume_set(uint8_t set_val)
{
	int ret;
	uint32_t volume_reg_val;

	volume_reg_val = set_val;
	if (volume_reg_val == 0) {
		LOG_WRN("Volume at MIN (-64dB)");
	} else if (volume_reg_val >= MAX_VOLUME_REG_VAL) {
		LOG_WRN("Volume at MAX (0dB)");
		volume_reg_val = MAX_VOLUME_REG_VAL;
	}

	ret = cs47l63_write_reg(&cs47l63_driver, CS47L63_OUT1L_VOLUME_1,
				volume_reg_val | CS47L63_OUT_VU);
	if (ret) {
		return ret;
	}

	prev_volume_reg_val = volume_reg_val;

	/* This is rounded down to nearest integer */
	LOG_DBG("Volume: %" PRId32 " dB", (volume_reg_val / 2) - MAX_VOLUME_DB);

	return 0;
}

int hw_codec_volume_adjust(int8_t adjustment_db)
{
	int ret;
	int32_t new_volume_reg_val;

	LOG_DBG("Adj dB in: %d", adjustment_db);

	if (adjustment_db == 0) {
		new_volume_reg_val = prev_volume_reg_val;
	} else {
		uint32_t volume_reg_val;

		ret = cs47l63_read_reg(&cs47l63_driver, CS47L63_OUT1L_VOLUME_1, &volume_reg_val);
		if (ret) {
			LOG_ERR("Failed to get volume from CS47L63");
			return ret;
		}

		volume_reg_val &= CS47L63_OUT1L_VOL_MASK;

		/* The adjustment is in dB, 1 bit equals 0.5 dB,
		 * so multiply by 2 to get increments of 1 dB
		 */
		new_volume_reg_val = volume_reg_val + (adjustment_db * 2);
		if (new_volume_reg_val <= 0) {
			LOG_WRN("Volume at MIN (-64dB)");
			new_volume_reg_val = 0;
		} else if (new_volume_reg_val >= MAX_VOLUME_REG_VAL) {
			LOG_WRN("Volume at MAX (0dB)");
			new_volume_reg_val = MAX_VOLUME_REG_VAL;
		}
	}

	ret = hw_codec_volume_set(new_volume_reg_val);
	if (ret) {
		return ret;
	}

	return 0;
}

int hw_codec_volume_decrease(void)
{
	int ret;

	ret = hw_codec_volume_adjust(-VOLUME_ADJUST_STEP_DB);
	if (ret) {
		return ret;
	}

	return 0;
}

int hw_codec_volume_increase(void)
{
	int ret;

	ret = hw_codec_volume_adjust(VOLUME_ADJUST_STEP_DB);
	if (ret) {
		return ret;
	}

	return 0;
}

int hw_codec_volume_mute(void)
{
	int ret;
	uint32_t volume_reg_val;

	ret = cs47l63_read_reg(&cs47l63_driver, CS47L63_OUT1L_VOLUME_1, &volume_reg_val);
	if (ret) {
		return ret;
	}

	BIT_SET(volume_reg_val, CS47L63_OUT1L_MUTE_MASK);

	ret = cs47l63_write_reg(&cs47l63_driver, CS47L63_OUT1L_VOLUME_1,
				volume_reg_val | CS47L63_OUT_VU);
	if (ret) {
		return ret;
	}

	return 0;
}

int hw_codec_volume_unmute(void)
{
	int ret;
	uint32_t volume_reg_val;

	ret = cs47l63_read_reg(&cs47l63_driver, CS47L63_OUT1L_VOLUME_1, &volume_reg_val);
	if (ret) {
		return ret;
	}

	BIT_CLEAR(volume_reg_val, CS47L63_OUT1L_MUTE_MASK);

	ret = cs47l63_write_reg(&cs47l63_driver, CS47L63_OUT1L_VOLUME_1,
				volume_reg_val | CS47L63_OUT_VU);
	if (ret) {
		return ret;
	}

	return 0;
}

int hw_codec_default_conf_enable(void)
{
	int ret;

	ret = cs47l63_comm_reg_conf_write(clock_configuration, ARRAY_SIZE(clock_configuration));
	if (ret) {
		return ret;
	}

	ret = cs47l63_comm_reg_conf_write(GPIO_configuration, ARRAY_SIZE(GPIO_configuration));
	if (ret) {
		return ret;
	}

	ret = cs47l63_comm_reg_conf_write(asp1_enable, ARRAY_SIZE(asp1_enable));
	if (ret) {
		return ret;
	}

	ret = cs47l63_comm_reg_conf_write(output_enable, ARRAY_SIZE(output_enable));
	if (ret) {
		return ret;
	}

	ret = hw_codec_volume_adjust(0);
	if (ret) {
		return ret;
	}

#if ((CONFIG_AUDIO_DEV == GATEWAY) && (CONFIG_AUDIO_SOURCE_I2S))
	if (IS_ENABLED(CONFIG_WALKIE_TALKIE_DEMO)) {
		ret = cs47l63_comm_reg_conf_write(pdm_mic_enable_configure,
						  ARRAY_SIZE(pdm_mic_enable_configure));
		if (ret) {
			return ret;
		}
	} else {
		ret = cs47l63_comm_reg_conf_write(line_in_enable, ARRAY_SIZE(line_in_enable));
		if (ret) {
			return ret;
		}
	}
#endif /* ((CONFIG_AUDIO_DEV == GATEWAY) && (CONFIG_AUDIO_SOURCE_I2S)) */

#if ((CONFIG_AUDIO_DEV == HEADSET) && CONFIG_STREAM_BIDIRECTIONAL)
	ret = cs47l63_comm_reg_conf_write(pdm_mic_enable_configure,
					  ARRAY_SIZE(pdm_mic_enable_configure));
	if (ret) {
		return ret;
	}
#endif /* ((CONFIG_AUDIO_DEV == HEADSET) && CONFIG_STREAM_BIDIRECTIONAL) */

	/* Toggle FLL to start up CS47L63 */
	ret = cs47l63_comm_reg_conf_write(FLL_toggle, ARRAY_SIZE(FLL_toggle));
	if (ret) {
		return ret;
	}

	return 0;
}

int hw_codec_soft_reset(void)
{
	int ret;

	ret = cs47l63_comm_reg_conf_write(output_disable, ARRAY_SIZE(output_disable));
	if (ret) {
		return ret;
	}

	ret = cs47l63_comm_reg_conf_write(soft_reset, ARRAY_SIZE(soft_reset));
	if (ret) {
		return ret;
	}

	return 0;
}

int hw_codec_init(void)
{
	int ret;

	ret = cs47l63_comm_init(&cs47l63_driver);
	if (ret) {
		return ret;
	}

	/* Run a soft reset on start to make sure all registers are default values */
	ret = cs47l63_comm_reg_conf_write(soft_reset, ARRAY_SIZE(soft_reset));
	if (ret) {
		return ret;
	}
	cs47l63_driver.state = CS47L63_STATE_STANDBY;

	volume_msg_sub_thread_id = k_thread_create(
		&volume_msg_sub_thread_data, volume_msg_sub_thread_stack,
		CONFIG_VOLUME_MSG_SUB_STACK_SIZE, (k_thread_entry_t)volume_msg_sub_thread, NULL,
		NULL, NULL, K_PRIO_PREEMPT(CONFIG_VOLUME_MSG_SUB_THREAD_PRIO), 0, K_NO_WAIT);
	ret = k_thread_name_set(volume_msg_sub_thread_id, "VOLUME_MSG_SUB");
	ERR_CHK(ret);

	return 0;
}

static int cmd_input(const struct shell *shell, size_t argc, char **argv)
{
	int ret;
	uint8_t idx;

	enum hw_codec_input {
		LINE_IN,
		PDM_MIC,
		NUM_INPUTS,
	};

	if (argc != 2) {
		shell_error(shell, "Only one argument required, provided: %d", argc);
		return -EINVAL;
	}

	if ((CONFIG_AUDIO_DEV == GATEWAY) && IS_ENABLED(CONFIG_AUDIO_SOURCE_USB)) {
		shell_error(shell, "Can't select PDM mic if audio source is USB");
		return -EINVAL;
	}

	if ((CONFIG_AUDIO_DEV == HEADSET) && !IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL)) {
		shell_error(shell, "Can't select input if headset is not in bidirectional stream");
		return -EINVAL;
	}

	if (!isdigit((int)argv[1][0])) {
		shell_error(shell, "Supplied argument is not numeric");
		return -EINVAL;
	}

	idx = strtoul(argv[1], NULL, BASE_10);

	switch (idx) {
	case LINE_IN: {
		if (CONFIG_AUDIO_DEV == HEADSET) {
			ret = cs47l63_comm_reg_conf_write(line_in_enable,
							  ARRAY_SIZE(line_in_enable));
			if (ret) {
				shell_error(shell, "Failed to enable LINE-IN");
				return ret;
			}
		}

		ret = cs47l63_write_reg(&cs47l63_driver, CS47L63_ASP1TX1_INPUT1, 0x800012);
		if (ret) {
			shell_error(shell, "Failed to route LINE-IN to I2S");
			return ret;
		}

		ret = cs47l63_write_reg(&cs47l63_driver, CS47L63_ASP1TX2_INPUT1, 0x800013);
		if (ret) {
			shell_error(shell, "Failed to route LINE-IN to I2S");
			return ret;
		}

		shell_print(shell, "Selected LINE-IN as input");
		break;
	}
	case PDM_MIC: {
		if (CONFIG_AUDIO_DEV == GATEWAY) {
			ret = cs47l63_comm_reg_conf_write(pdm_mic_enable_configure,
							  ARRAY_SIZE(pdm_mic_enable_configure));
			if (ret) {
				shell_error(shell, "Failed to enable PDM mic");
				return ret;
			}
		}

		ret = cs47l63_write_reg(&cs47l63_driver, CS47L63_ASP1TX1_INPUT1, 0x800010);
		if (ret) {
			shell_error(shell, "Failed to route PDM mic to I2S");
			return ret;
		}

		ret = cs47l63_write_reg(&cs47l63_driver, CS47L63_ASP1TX2_INPUT1, 0x800011);
		if (ret) {
			shell_error(shell, "Failed to route PDM mic to I2S");
			return ret;
		}

		shell_print(shell, "Selected PDM mic as input");
		break;
	}
	default:
		shell_error(shell, "Invalid input");
		return -EINVAL;
	}

	return 0;
}

SHELL_STATIC_SUBCMD_SET_CREATE(hw_codec_cmd,
			       SHELL_COND_CMD(CONFIG_SHELL, input, NULL,
					      " Select input\n\t0: LINE_IN\n\t\t1: PDM_MIC",
					      cmd_input),
			       SHELL_SUBCMD_SET_END);

SHELL_CMD_REGISTER(hw_codec, &hw_codec_cmd, "Change settings on HW codec", NULL);


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/modules/audio_i2s.h
/*
 *  Copyright (c) 2021, PACKETCRAFT, INC.
 *
 *  SPDX-License-Identifier: LicenseRef-PCFT
 */

#ifndef _AUDIO_I2S_H_
#define _AUDIO_I2S_H_

#include <zephyr/kernel.h>
#include <stdint.h>

/*
 * Calculate the number of bytes of one frame, as per now, this frame can either
 * be 10 or 7.5 ms. Since we can't have floats in a define we use 15/2 instead
 */

#if ((CONFIG_AUDIO_FRAME_DURATION_US == 7500) && CONFIG_SW_CODEC_LC3)

#define FRAME_SIZE_BYTES                                                                           \
	((CONFIG_I2S_LRCK_FREQ_HZ / 1000 * 15 / 2) * CONFIG_I2S_CH_NUM *                           \
	 CONFIG_AUDIO_BIT_DEPTH_OCTETS)
#else
#define FRAME_SIZE_BYTES                                                                           \
	((CONFIG_I2S_LRCK_FREQ_HZ / 1000 * 10) * CONFIG_I2S_CH_NUM * CONFIG_AUDIO_BIT_DEPTH_OCTETS)
#endif /* ((CONFIG_AUDIO_FRAME_DURATION_US == 7500) && CONFIG_SW_CODEC_LC3) */

#define BLOCK_SIZE_BYTES (FRAME_SIZE_BYTES / CONFIG_FIFO_FRAME_SPLIT_NUM)

/*
 * Calculate the number of samples in a block, divided by the number of samples
 * that will fit within a 32-bit word
 */
#define I2S_SAMPLES_NUM                                                                            \
	(BLOCK_SIZE_BYTES / (CONFIG_AUDIO_BIT_DEPTH_OCTETS) / (32 / CONFIG_AUDIO_BIT_DEPTH_BITS))

/**
 * @brief I2S block complete event callback type
 *
 * @param frame_start_ts I2S frame start timestamp
 * @param rx_buf_released Pointer to the released buffer containing received data
 * @param tx_buf_released Pointer to the released buffer that was used to sent data
 */
typedef void (*i2s_blk_comp_callback_t)(uint32_t frame_start_ts, uint32_t *rx_buf_released,
					uint32_t const *tx_buf_released);

/**
 * @brief Supply the buffers to be used in the next part of the I2S transfer
 *
 * @param tx_buf Pointer to the buffer with data to be sent
 * @param rx_buf Pointer to the buffer for received data
 */
void audio_i2s_set_next_buf(const uint8_t *tx_buf, uint32_t *rx_buf);

/**
 * @brief Start the continuous I2S transfer
 *
 * @param tx_buf Pointer to the buffer with data to be sent
 * @param rx_buf Pointer to the buffer for received data
 */
void audio_i2s_start(const uint8_t *tx_buf, uint32_t *rx_buf);

/**
 * @brief Stop the continuous I2S transfer
 */
void audio_i2s_stop(void);

/**
 * @brief Register callback function for I2S block complete event
 *
 * @param blk_comp_callback Callback function
 */
void audio_i2s_blk_comp_cb_register(i2s_blk_comp_callback_t blk_comp_callback);

/**
 * @brief Initialize I2S module
 */
void audio_i2s_init(void);

#endif /* _AUDIO_I2S_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/modules/audio_sync_timer.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _AUDIO_SYNC_TIMER_H_
#define _AUDIO_SYNC_TIMER_H_

#include <zephyr/kernel.h>
#include <stdint.h>

/**
 * @brief Capture a timestamp on the sync timer.
 *
 * @retval The current timestamp of the audio sync timer.
 */
uint32_t audio_sync_timer_capture(void);

/**
 * @brief Returns the last captured value of the sync timer.
 *
 * The captured time is corresponding to the I2S frame start.
 *
 * See @ref audio_sync_timer_capture().
 *
 * @retval The last captured timestamp of the audio sync timer.
 */
uint32_t audio_sync_timer_capture_get(void);

#endif /* _AUDIO_SYNC_TIMER_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/modules/led.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _LED_H_
#define _LED_H_

#include <stdint.h>

#define LED_APP_RGB 0
#define LED_NET_RGB 1
#define LED_APP_1_BLUE 2
#define LED_APP_2_GREEN 3
#define LED_APP_3_GREEN 4

#define RED 0
#define GREEN 1
#define BLUE 2

#define GRN GREEN
#define BLU BLUE

enum led_color {
	LED_COLOR_OFF, /* 000 */
	LED_COLOR_RED, /* 001 */
	LED_COLOR_GREEN, /* 010 */
	LED_COLOR_YELLOW, /* 011 */
	LED_COLOR_BLUE, /* 100 */
	LED_COLOR_MAGENTA, /* 101 */
	LED_COLOR_CYAN, /* 110 */
	LED_COLOR_WHITE, /* 111 */
	LED_COLOR_NUM,
};

#define LED_ON LED_COLOR_WHITE

#define LED_BLINK true
#define LED_SOLID false

/**
 * @brief Set the state of a given LED unit to blink.
 *
 * @note A led unit is defined as an RGB LED or a monochrome LED.
 *
 * @param led_unit	Selected LED unit. Defines are located in board.h
 * @note		If the given LED unit is an RGB LED, color must be
 *			provided as a single vararg. See led_color.
 *			For monochrome LEDs, the vararg will be ignored.
 *			Using a LED unit assigned to another core will do nothing and return 0.
 * @return		0 on success
 *			-EPERM if the module has not been initialised
 *			-EINVAL if the color argument is illegal
 *			Other errors from underlying drivers.
 */
int led_blink(uint8_t led_unit, ...);

/**
 * @brief Turn the given LED unit on.
 *
 * @note A led unit is defined as an RGB LED or a monochrome LED.
 *
 * @param led_unit	Selected LED unit. Defines are located in board.h
 * @note		If the given LED unit is an RGB LED, color must be
 *			provided as a single vararg. See led_color.
 *			For monochrome LEDs, the vararg will be ignored.
*			Using a LED unit assigned to another core will do nothing and return 0.
 * @return		0 on success
 *			-EPERM if the module has not been initialised
 *			-EINVAL if the color argument is illegal
 *			Other errors from underlying drivers.
 */
int led_on(uint8_t led_unit, ...);

/**
 * @brief Set the state of a given LED unit to off.
 *
 * @note A led unit is defined as an RGB LED or a monochrome LED.
 *		Using a LED unit assigned to another core will do nothing and return 0.
 *
 * @param led_unit	Selected LED unit. Defines are located in board.h
 * @return		0 on success
 *			-EPERM if the module has not been initialised
 *			-EINVAL if the color argument is illegal
 *			Other errors from underlying drivers.
 */
int led_off(uint8_t led_unit);

/**
 * @brief Initialise the LED module
 *
 * @note This will parse the .dts files and configure all LEDs.
 *
 * @return	0 on success
 *		-EPERM if already initialsed
 *		-ENXIO if a LED is missing unit number in dts
 *		-ENODEV if a LED is missing color identifier
 */
int led_init(void);

#endif /* _LED_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/modules/sd_card_playback.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "sd_card_playback.h"

#include <stdint.h>
#include <math.h>
#include <zephyr/sys/ring_buffer.h>
#include <zephyr/shell/shell.h>

#include "sd_card.h"
#include "sw_codec_lc3.h"
#include "sw_codec_select.h"
#include "pcm_mix.h"
#include "audio_system.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(sd_card_playback, CONFIG_MODULE_SD_CARD_PLAYBACK_LOG_LEVEL);

#define MAX_PATH_LEN	    (CONFIG_FS_FATFS_MAX_LFN)
#define LIST_FILES_BUF_SIZE 512
#define FRAME_DURATION_MS   (CONFIG_AUDIO_FRAME_DURATION_US / 1000)

#define WAV_FORMAT_PCM	    1
#define WAV_SAMPLE_RATE_48K 48000

/* WAV header */
struct wav_header {
	/* RIFF Header */
	char riff_header[4];
	uint32_t wav_size;  /* File size excluding first eight bytes */
	char wav_header[4]; /* Contains "WAVE" */

	/* Format Header */
	char fmt_header[4];
	uint32_t wav_chunk_size; /* Should be 16 for PCM */
	short audio_format;	 /* Should be 1 for PCM */
	short num_channels;
	uint32_t sample_rate;
	uint32_t byte_rate;
	short block_alignment; /* num_channels * Bytes Per Sample */
	short bit_depth;

	/* Data */
	char data_header[4];
	uint32_t data_bytes; /* Number of bytes in data */
} __packed;

/* LC3 header */
struct lc3_header {
	uint16_t file_id;	 /* Constant value, 0xCC1C */
	uint16_t hdr_size;	 /* Header size, 0x0012 */
	uint16_t sample_rate;	 /* Sample frequency / 100 */
	uint16_t bit_rate;	 /* Bit rate / 100 (total for all channels) */
	uint16_t channels;	 /* Number of channels */
	uint16_t frame_duration; /* Frame duration in ms * 100 */
	uint16_t rfu;		 /* Reserved for future use */
	uint16_t signal_len_lsb; /* Number of samples in signal, 16 LSB */
	uint16_t signal_len_msb; /* Number of samples in signal, 16 MSB (>> 16) */
} __packed;

struct lc3_playback_config {
	uint16_t lc3_frames_num;
	uint16_t lc3_frame_length_bytes;
};

enum audio_formats {
	SD_CARD_PLAYBACK_WAV,
	SD_CARD_PLAYBACK_LC3,
};

RING_BUF_DECLARE(m_ringbuf_audio_data_lc3, CONFIG_SD_CARD_PLAYBACK_RING_BUF_SIZE);
K_SEM_DEFINE(m_sem_ringbuf_space_available, 0, 1);
K_MUTEX_DEFINE(mtx_ringbuf);
K_SEM_DEFINE(m_sem_playback, 0, 1);
K_THREAD_STACK_DEFINE(sd_card_playback_thread_stack, CONFIG_SD_CARD_PLAYBACK_STACK_SIZE);

/* Thread */
static struct k_thread sd_card_playback_thread_data;
static k_tid_t sd_card_playback_thread_id;

/* Playback */
static bool sd_card_playback_active;
static char *playback_file_name;
static enum audio_formats playback_file_format;
static uint16_t pcm_frame_size;
static char playback_file_path[MAX_PATH_LEN] = "";
static struct lc3_header lc3_file_header;
static struct wav_header wav_file_header;
static struct lc3_playback_config lc3_playback_cfg;

static struct fs_file_t f_seg_read_entry;

static int sd_card_playback_ringbuf_read(uint8_t *buf, size_t *size)
{
	int ret;
	uint16_t read_size;

	ret = k_mutex_lock(&mtx_ringbuf, K_NO_WAIT);
	if (ret) {
		LOG_ERR("Unable to take mutex. Ret: %d", ret);
		return ret;
	}

	read_size = ring_buf_get(&m_ringbuf_audio_data_lc3, buf, *size);
	if (read_size != *size) {
		LOG_WRN("Read size (%d) not equal requested size (%d)", read_size, *size);
	}

	ret = k_mutex_unlock(&mtx_ringbuf);
	if (ret) {
		LOG_ERR("Mutex unlock err: %d", ret);
		return ret;
	}

	if (ring_buf_space_get(&m_ringbuf_audio_data_lc3) >= pcm_frame_size) {
		k_sem_give(&m_sem_ringbuf_space_available);
	}

	*size = read_size;

	return 0;
}

static int sd_card_playback_ringbuf_write(uint8_t *buffer, size_t numbytes)
{
	int ret;
	uint8_t *buf_ptr;

	/* The ringbuffer is read every 10 ms by audio datapath when SD card playback is enabled.
	 * Timeout value should therefore not be less than 10 ms
	 */
	ret = k_sem_take(&m_sem_ringbuf_space_available, K_MSEC(20));
	if (ret) {
		LOG_ERR("Sem take err: %d. Skipping frame", ret);
		return ret;
	}

	ret = k_mutex_lock(&mtx_ringbuf, K_NO_WAIT);
	if (ret) {
		LOG_ERR("Unable to take mutex. Ret: %d", ret);
		return ret;
	}

	numbytes = ring_buf_put_claim(&m_ringbuf_audio_data_lc3, &buf_ptr, numbytes);
	memcpy(buf_ptr, buffer, numbytes);
	ret = ring_buf_put_finish(&m_ringbuf_audio_data_lc3, numbytes);
	if (ret) {
		LOG_ERR("Ring buf put finish err: %d", ret);
		return ret;
	}

	ret = k_mutex_unlock(&mtx_ringbuf);
	if (ret) {
		LOG_ERR("Mutex unlock err: %d", ret);
		return ret;
	}

	return numbytes;
}

static int sd_card_playback_check_wav_header(struct wav_header wav_file_header)
{
	if (wav_file_header.audio_format != WAV_FORMAT_PCM) {
		LOG_ERR("This is not a PCM file");
		return -EPERM;
	}

	if (wav_file_header.num_channels != SW_CODEC_MONO) {
		LOG_ERR("This is not a MONO file");
		return -EPERM;
	}

	if (wav_file_header.sample_rate != WAV_SAMPLE_RATE_48K) {
		LOG_ERR("Unsupported sample rate: %d", wav_file_header.sample_rate);
		return -EPERM;
	}

	if (wav_file_header.bit_depth != CONFIG_AUDIO_BIT_DEPTH_BITS) {
		LOG_ERR("Bit depth in WAV file is not 16, but %d", wav_file_header.bit_depth);
		return -EPERM;
	}

	return 0;
}

static int sd_card_playback_play_wav(void)
{
	int ret;
	int ret_sd_card_close;
	size_t wav_read_size;
	size_t wav_file_header_size = sizeof(wav_file_header);
	int audio_length_bytes;
	int n_iter;

	ret = sd_card_open(playback_file_name, &f_seg_read_entry);
	if (ret) {
		LOG_ERR("Open SD card file err: %d", ret);
		return ret;
	}

	ret = sd_card_read((char *)&wav_file_header, &wav_file_header_size, &f_seg_read_entry);
	if (ret) {
		LOG_ERR("Read SD card err: %d", ret);
		ret_sd_card_close = sd_card_close(&f_seg_read_entry);
		if (ret_sd_card_close) {
			LOG_ERR("Close SD card err: %d", ret_sd_card_close);
			return ret_sd_card_close;
		}
		return ret;
	}

	/* Verify that there is support for playing the specified file */
	ret = sd_card_playback_check_wav_header(wav_file_header);
	if (ret) {
		LOG_ERR("WAV header check failed. Ret: %d", ret);
		ret_sd_card_close = sd_card_close(&f_seg_read_entry);
		if (ret_sd_card_close) {
			LOG_ERR("Close SD card err: %d", ret_sd_card_close);
			return ret_sd_card_close;
		}
		return ret;
	}

	/* Size corresponding to frame size of audio BT stream */
	pcm_frame_size = wav_file_header.byte_rate * FRAME_DURATION_MS / 1000;
	wav_read_size = pcm_frame_size;
	uint8_t pcm_mono_frame[wav_read_size];

	audio_length_bytes = wav_file_header.wav_size + 8 - sizeof(wav_file_header);
	n_iter = ceil((float)audio_length_bytes / (float)wav_read_size);

	for (int i = 0; i < n_iter; i++) {
		/* Read a chunk of audio data from file */
		ret = sd_card_read(pcm_mono_frame, &wav_read_size, &f_seg_read_entry);
		if (ret < 0) {
			LOG_ERR("SD card read err: %d", ret);
			break;
		}

		/* Write audio data to the ringbuffer */
		ret = sd_card_playback_ringbuf_write(pcm_mono_frame, wav_read_size);
		if (ret < 0) {
			LOG_ERR("Load ringbuf err: %d", ret);
			break;
		}

		if (i == 0) {
			/* Data can now be read from the ringbuffer */
			sd_card_playback_active = true;
		}
	}

	sd_card_playback_active = false;

	ret_sd_card_close = sd_card_close(&f_seg_read_entry);
	/* Check if something inside the for loop failed */
	if (ret < 0) {
		LOG_ERR("WAV playback err: %d", ret);
		return ret;
	}

	if (ret_sd_card_close) {
		LOG_ERR("SD card close err: %d", ret);
		return ret;
	}

	return 0;
}

static int sd_card_playback_play_lc3(void)
{
	int ret;
	int ret_sd_card_close;
	uint16_t pcm_mono_write_size;
	uint8_t decoder_num_ch = audio_system_decoder_num_ch_get();
	size_t lc3_file_header_size = sizeof(lc3_file_header);
	size_t lc3_frame_header_size = sizeof(uint16_t);

	ret = sd_card_open(playback_file_name, &f_seg_read_entry);
	if (ret) {
		LOG_ERR("Open SD card file err: %d", ret);
		return ret;
	}

	/* Read the file header */
	ret = sd_card_read((char *)&lc3_file_header, &lc3_file_header_size, &f_seg_read_entry);
	if (ret < 0) {
		LOG_ERR("Read SD card file err: %d", ret);
		ret_sd_card_close = sd_card_close(&f_seg_read_entry);
		if (ret_sd_card_close) {
			LOG_ERR("Close SD card err: %d", ret_sd_card_close);
			return ret_sd_card_close;
		}
		return ret;
	}

	pcm_frame_size = sizeof(uint16_t) * lc3_file_header.sample_rate *
			 lc3_file_header.frame_duration / 1000;
	lc3_playback_cfg.lc3_frames_num =
		sizeof(uint16_t) *
		((lc3_file_header.signal_len_msb << 16) + lc3_file_header.signal_len_lsb) /
		pcm_frame_size;

	uint8_t pcm_mono_frame[pcm_frame_size];

	for (int i = 0; i < lc3_playback_cfg.lc3_frames_num; i++) {
		/* Read the frame header */
		ret = sd_card_read((char *)&lc3_playback_cfg.lc3_frame_length_bytes,
				   &lc3_frame_header_size, &f_seg_read_entry);
		if (ret < 0) {
			LOG_ERR("SD card read err: %d", ret);
			break;
		}

		char lc3_frame[lc3_playback_cfg.lc3_frame_length_bytes];
		size_t lc3_fr_len = lc3_playback_cfg.lc3_frame_length_bytes;

		/* Read the audio data frame to be decoded */
		ret = sd_card_read(lc3_frame, &lc3_fr_len, &f_seg_read_entry);
		if (ret < 0) {
			LOG_ERR("SD card read err: %d", ret);
			break;
		}

		if (lc3_fr_len != lc3_playback_cfg.lc3_frame_length_bytes) {
			LOG_ERR("SD card read size (%d) not equal requested size (%d)", lc3_fr_len,
				lc3_playback_cfg.lc3_frame_length_bytes);
			ret = -EPERM;
			break;
		}

		/* Decode audio data frame */
		ret = sw_codec_lc3_dec_run(lc3_frame, lc3_playback_cfg.lc3_frame_length_bytes,
					   pcm_frame_size, decoder_num_ch - 1, pcm_mono_frame,
					   &pcm_mono_write_size, false);
		if (ret) {
			LOG_ERR("Decoding err: %d", ret);
			break;
		}

		ret = sd_card_playback_ringbuf_write((char *)pcm_mono_frame, pcm_mono_write_size);
		if (ret < 0) {
			LOG_ERR("Load ringbuf err: %d", ret);
			break;
		}

		if (i == 0) {
			sd_card_playback_active = true;
		}
	}

	sd_card_playback_active = false;
	ret_sd_card_close = sd_card_close(&f_seg_read_entry);
	if (ret < 0) {
		LOG_ERR("LC3 playback err: %d", ret);
		sd_card_playback_active = false;
		return ret;
	}

	if (ret_sd_card_close) {
		LOG_ERR("SD card close err: %d", ret);
		sd_card_playback_active = false;
		return ret;
	}

	return 0;
}

static void sd_card_playback_thread(void *arg1, void *arg2, void *arg3)
{
	int ret;

	while (1) {
		k_sem_take(&m_sem_playback, K_FOREVER);
		switch (playback_file_format) {
		case SD_CARD_PLAYBACK_WAV:
			ring_buf_reset(&m_ringbuf_audio_data_lc3);
			k_sem_reset(&m_sem_ringbuf_space_available);
			k_sem_give(&m_sem_ringbuf_space_available);
			ret = sd_card_playback_play_wav();
			if (ret) {
				LOG_ERR("Wav playback err: %d", ret);
			}

			break;

		case SD_CARD_PLAYBACK_LC3:
			ring_buf_reset(&m_ringbuf_audio_data_lc3);
			k_sem_reset(&m_sem_ringbuf_space_available);
			k_sem_give(&m_sem_ringbuf_space_available);
			ret = sd_card_playback_play_lc3();
			if (ret) {
				LOG_ERR("LC3 playback err: %d", ret);
			}

			break;
		}
	}
}

bool sd_card_playback_is_active(void)
{
	return sd_card_playback_active;
}

int sd_card_playback_wav(char *filename)
{
	if (!sw_codec_is_initialized()) {
		LOG_ERR("Sw codec not initialized");
		return -EACCES;
	}

	playback_file_format = SD_CARD_PLAYBACK_WAV;
	playback_file_name = filename;
	k_sem_give(&m_sem_playback);

	return 0;
}

int sd_card_playback_lc3(char *filename)
{
	if (!sw_codec_is_initialized()) {
		LOG_ERR("Sw codec not initialized");
		return -EACCES;
	}

	playback_file_format = SD_CARD_PLAYBACK_LC3;
	playback_file_name = filename;
	k_sem_give(&m_sem_playback);

	return 0;
}

int sd_card_playback_mix_with_stream(void *const pcm_a, size_t pcm_a_size)
{
	int ret;
	uint8_t pcm_b[pcm_frame_size];
	size_t read_size = pcm_frame_size;

	if (!sd_card_playback_active) {
		LOG_ERR("SD card playback is not active");
		return -EACCES;
	}

	ret = sd_card_playback_ringbuf_read(pcm_b, &read_size);
	if (ret) {
		LOG_ERR("Loading data into buffer err: %d", ret);
		return ret;
	}

	if (read_size > 0) {
		ret = pcm_mix(pcm_a, pcm_a_size, pcm_b, read_size, B_MONO_INTO_A_STEREO_L);
		if (ret) {
			LOG_ERR("Pcm mix err: %d", ret);
			return ret;
		}
	} else {
		LOG_WRN("Size read from ringbuffer: %d. Skipping", read_size);
	}

	return 0;
}

int sd_card_playback_init(void)
{
	int ret;

	sd_card_playback_thread_id = k_thread_create(
		&sd_card_playback_thread_data, sd_card_playback_thread_stack,
		CONFIG_SD_CARD_PLAYBACK_STACK_SIZE, (k_thread_entry_t)sd_card_playback_thread, NULL,
		NULL, NULL, K_PRIO_PREEMPT(CONFIG_SD_CARD_PLAYBACK_THREAD_PRIORITY), 0, K_NO_WAIT);
	ret = k_thread_name_set(sd_card_playback_thread_id, "sd_card_playback");
	if (ret) {
		return ret;
	}

	return 0;
}

/* Shell functions */
static int cmd_play_wav_file(const struct shell *shell, size_t argc, char **argv)
{
	int ret;

	char file_loc[MAX_PATH_LEN] = "";

	if (argc != 2) {
		shell_error(shell, "Incorrect number of args");
		return -EINVAL;
	}

	if ((strlen(playback_file_path) + strlen(argv[1])) >= ARRAY_SIZE(file_loc)) {
		return -ENOMEM;
	}

	strcat(file_loc, playback_file_path);
	strcat(file_loc, argv[1]);
	ret = sd_card_playback_wav(file_loc);
	if (ret) {
		shell_error(shell, "WAV playback err: %d", ret);
		return ret;
	}

	return 0;
}

static int cmd_play_lc3_file(const struct shell *shell, size_t argc, char **argv)
{
	int ret;

	if (argc != 2) {
		shell_error(shell, "Incorrect number of args");
		return -EINVAL;
	}

	char file_loc[MAX_PATH_LEN] = "";

	if ((strlen(playback_file_path) + strlen(argv[1])) >= ARRAY_SIZE(file_loc)) {
		return -ENOMEM;
	}

	strcat(file_loc, playback_file_path);
	strcat(file_loc, argv[1]);
	ret = sd_card_playback_lc3(file_loc);
	if (ret) {
		shell_error(shell, "LC3 playback err: %d", ret);
		return ret;
	}

	return 0;
}

static int cmd_change_dir(const struct shell *shell, size_t argc, char **argv)
{
	if (argc != 2) {
		shell_error(shell, "Incorrect number of args");
		return -EINVAL;
	}

	if (argv[1][0] == '/') {
		playback_file_path[0] = '\0';
		shell_print(shell, "Current directory: root");
	} else {
		if ((strlen(playback_file_path) + strlen(argv[1])) >=
		    ARRAY_SIZE(playback_file_path)) {
			return -ENOMEM;
		}

		strcat(playback_file_path, argv[1]);
		strcat(playback_file_path, "/");
		shell_print(shell, "Current directory: %s", playback_file_path);
	}

	return 0;
}

static int cmd_list_files(const struct shell *shell, size_t argc, char **argv)
{
	int ret;
	char buf[LIST_FILES_BUF_SIZE];
	size_t buf_size = LIST_FILES_BUF_SIZE;

	ret = sd_card_list_files(playback_file_path, buf, &buf_size);
	if (ret) {
		shell_error(shell, "List files err: %d", ret);
		return ret;
	}

	shell_print(shell, "%s", buf);

	return 0;
}

SHELL_STATIC_SUBCMD_SET_CREATE(
	sd_card_playback_cmd,
	SHELL_COND_CMD(CONFIG_SHELL, play_lc3, NULL, "Play LC3 file", cmd_play_lc3_file),
	SHELL_COND_CMD(CONFIG_SHELL, play_wav, NULL, "Play WAV file", cmd_play_wav_file),
	SHELL_COND_CMD(CONFIG_SHELL, cd, NULL, "Change directory", cmd_change_dir),
	SHELL_COND_CMD(CONFIG_SHELL, list_files, NULL, "List files", cmd_list_files),
	SHELL_SUBCMD_SET_END);

SHELL_CMD_REGISTER(sd_card_playback, &sd_card_playback_cmd, "Play audio files from SD card", NULL);


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/modules/sd_card.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _SD_CARD_H_
#define _SD_CARD_H_

#include <stddef.h>
#include <zephyr/fs/fs.h>

/**
 * @brief	Print out the contents under SD card root path and write the content to buffer.
 *
 * @param[in]		path		Path of the folder which is going to be listed.
 *					If assigned path is null, then listing the contents under
 *					root. If assigned path doesn't exist, an error will be
 *					returned.
 * @param[out]		buf		Buffer where data is written. If set to NULL, it will be
 *					ignored.
 * @param[in, out]	buf_size	Buffer size.
 *
 * @retval	0 on success.
 * @retval	-EPERM SD card operation is ongoing somewhere else.
 * @retval	-ENODEV SD init failed. SD card likely not inserted.
 * @retval	-EINVAL Failed to append to buffer.
 * @retval	-FR_INVALID_NAME Path is too long.
 * @retval	Otherwise, error from underlying drivers.
 */
int sd_card_list_files(char const *const path, char *buf, size_t *buf_size);

/**
 * @brief	Write data from buffer into the file.
 *
 * @note	If the file already exists, data will be appended to the end of the file.
 *
 * @param[in]		filename	Name of the target file for writing, the default
 *					location is the root directoy of SD card, accept
					absolute path under root of SD card.
 * @param[in]		data		which is going to be written into the file.
 * @param[in, out]	size		Pointer to the number of bytes which is going to be written.
 *					The actual written size will be returned.
 *
 * @retval	0 on success.
 * @retval	-EPERM SD card operation is ongoing somewhere else.
 * @retval	-ENODEV SD init failed. SD card likely not inserted.
 * @retval	Otherwise, error from underlying drivers.
 */
int sd_card_open_write_close(char const *const filename, char const *const data, size_t *size);

/**
 * @brief	Read data from file into the buffer.
 *
 * @param[in]		filename	Name of the target file for reading, the default location is
 *					the root directoy of SD card, accept absolute path under
 *					root of SD card.
 * @param[out]		buf		Pointer to the buffer to write the read data into.
 * @param[in, out]	size		Pointer to the number of bytes which wait to be read from
 *					the file. The actual read size will be returned. If the
 *					actual read size is 0, there will be a warning message which
					indicates that the file is empty.
 *
 * @retval	0 on success.
 * @retval	-EPERM SD card operation is ongoing somewhere else.
 * @retval	-ENODEV SD init failed. SD card likely not inserted.
 * @retval	Otherwise, error from underlying drivers.
 */
int sd_card_open_read_close(char const *const filename, char *const buf, size_t *size);

/**
 * @brief	Open file on SD card.
 *
 * @param[in]		filename		Name of file to open. Default
 *						location is the root directoy of SD card.
 *						Absolute path under root of SD card is accepted.
 * @param[in, out]	f_seg_read_entry	Pointer to a file object.
 *						The pointer gets initialized and ready for use.
 *
 *
 * @retval	0 on success.
 * @retval	-EPERM SD card operation is ongoing somewhere else.
 * @retval	-ENODEV SD init failed. SD likely not inserted.
 * @retval	Otherwise, error from underlying drivers.
 */
int sd_card_open(char const *const filename, struct fs_file_t *f_seg_read_entry);

/**
 * @brief	Read segment on the open file on the SD card.
 *
 * @param[out]		buf			Pointer to the buffer to write the read data into.
 * @param[in, out]	size			Number of bytes to be read from file.
 *						The actual read size will be returned.
 *						If the actual read size is 0, there will be a
 *						warning message which indicates that the file is
 *						empty.
 * @param[in, out]	f_seg_read_entry	Pointer to a file object. After call to this
 *						function, the pointer gets updated and can be used
 *						as entry in next function call.
 *
 * @retval	0 on success.
 * @retval	-EPERM SD card operation is not ongoing.
 * @retval	-ENODEV SD init failed. SD likely not inserted.
 * @retval	Otherwise, error from underlying drivers.
 */
int sd_card_read(char *buf, size_t *size, struct fs_file_t *f_seg_read_entry);

/**
 * @brief	Close the file opened by the sd_card_segment_read_open function.
 *
 * @param[in, out]	f_seg_read_entry	Pointer to a file object. After call to this
 *						function, the pointer is reset and can be used for
 *						another file.
 *
 *
 * @retval	0 on success.
 * @retval	-EPERM SD card operation is not ongoing.
 * @retval	-EBUSY Segment read operation has not started.
 * @retval	Otherwise, error from underlying drivers.
 */
int sd_card_close(struct fs_file_t *f_seg_read_entry);

/**
 * @brief	Initialize the SD card interface and print out SD card details.
 *
 * @retval	0 on success.
 * @retval	-ENODEV SD init failed. SD card likely not inserted.
 * @retval	Otherwise, error from underlying drivers.
 */
int sd_card_init(void);

#endif /* _SD_CARD_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/modules/button_handler.h
/*
 * Copyright (c) 2022 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BUTTON_HANDLER_H_
#define _BUTTON_HANDLER_H_

#include <stdint.h>
#include <zephyr/drivers/gpio.h>

struct btn_config {
	const char *btn_name;
	uint8_t btn_pin;
	uint32_t btn_cfg_mask;
};

/** @brief Initialize button handler, with buttons defined in button_assignments.h.
 *
 * @note This function may only be called once - there is no reinitialize.
 *
 * @return 0 if successful.
 * @return -ENODEV	gpio driver not found
 */
int button_handler_init(void);

/** @brief Check button state.
 *
 * @param[in] button_pin Button pin
 * @param[out] button_pressed Button state. True if currently pressed, false otherwise
 *
 * @return 0 if success, an error code otherwise.
 */
int button_pressed(gpio_pin_t button_pin, bool *button_pressed);

#endif /* _BUTTON_HANDLER_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/modules/board.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef __BOARD_H__
#define __BOARD_H__

#include <zephyr/kernel.h>

/* Voltage divider PCA10121 board versions.
 * The defines give what value the ADC will read back.
 * This is determined by the on-board voltage divider.
 */

struct board_version {
	char name[10];
	uint32_t mask;
	uint32_t adc_reg_val;
};

#define BOARD_PCA10121_0_0_0_MSK (BIT(0))
#define BOARD_PCA10121_0_6_0_MSK (BIT(1))
#define BOARD_PCA10121_0_7_0_MSK (BIT(2))
#define BOARD_PCA10121_0_7_1_MSK (BIT(3))
#define BOARD_PCA10121_0_8_0_MSK (BIT(4))
#define BOARD_PCA10121_0_8_1_MSK (BIT(5))
#define BOARD_PCA10121_0_8_2_MSK (BIT(6))
#define BOARD_PCA10121_0_9_0_MSK (BIT(7))
#define BOARD_PCA10121_0_10_0_MSK (BIT(8))
#define BOARD_PCA10121_1_0_0_MSK (BIT(9))
#define BOARD_PCA10121_1_1_0_MSK (BIT(10))
#define BOARD_PCA10121_1_2_0_MSK (BIT(11))

static const struct board_version BOARD_VERSION_ARR[] = {
	{ "0.0.0", BOARD_PCA10121_0_0_0_MSK, INT_MIN },
	{ "0.6.0", BOARD_PCA10121_0_6_0_MSK, 61 },
	{ "0.7.0", BOARD_PCA10121_0_7_0_MSK, 102 },
	{ "0.7.1", BOARD_PCA10121_0_7_1_MSK, 303 },
	{ "0.8.0", BOARD_PCA10121_0_8_0_MSK, 534 },
	{ "0.8.1", BOARD_PCA10121_0_8_1_MSK, 780 },
	{ "0.8.2", BOARD_PCA10121_0_8_2_MSK, 1018 },
	{ "0.9.0", BOARD_PCA10121_0_9_0_MSK, 1260 },
	/* Lower value used on 0.10.0 due to high ohm divider */
	{ "0.10.0", BOARD_PCA10121_0_10_0_MSK, 1480 },
	{ "1.0.0", BOARD_PCA10121_1_0_0_MSK, 1743 },
	{ "1.1.0", BOARD_PCA10121_1_1_0_MSK, 1982 },
	{ "1.2.0", BOARD_PCA10121_1_2_0_MSK, 2219 },
};

#define BOARD_VERSION_VALID_MSK                                                                    \
	(BOARD_PCA10121_0_8_0_MSK | BOARD_PCA10121_0_8_1_MSK | BOARD_PCA10121_0_8_2_MSK |          \
	 BOARD_PCA10121_0_9_0_MSK | BOARD_PCA10121_0_10_0_MSK | BOARD_PCA10121_1_0_0_MSK |         \
	 BOARD_PCA10121_1_1_0_MSK | BOARD_PCA10121_1_2_0_MSK)

#define BOARD_VERSION_VALID_MSK_SD_CARD                                                            \
	(BOARD_PCA10121_0_8_0_MSK | BOARD_PCA10121_0_8_1_MSK | BOARD_PCA10121_0_8_2_MSK |          \
	 BOARD_PCA10121_0_9_0_MSK | BOARD_PCA10121_0_10_0_MSK | BOARD_PCA10121_1_0_0_MSK |         \
	 BOARD_PCA10121_1_1_0_MSK | BOARD_PCA10121_1_2_0_MSK)

#endif


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/modules/button_assignments.h
/*
 * Copyright (c) 2022 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

/** @file
 *  @brief Button assignments
 *
 * Button mappings are listed here.
 *
 */

#ifndef _BUTTON_ASSIGNMENTS_H_
#define _BUTTON_ASSIGNMENTS_H_

#include <zephyr/drivers/gpio.h>

/** @brief List of buttons and associated metadata
 */
enum button_pin_names {
	BUTTON_VOLUME_DOWN = DT_GPIO_PIN(DT_ALIAS(sw0), gpios),
	BUTTON_VOLUME_UP = DT_GPIO_PIN(DT_ALIAS(sw1), gpios),
	BUTTON_PLAY_PAUSE = DT_GPIO_PIN(DT_ALIAS(sw2), gpios),
	BUTTON_4 = DT_GPIO_PIN(DT_ALIAS(sw3), gpios),
	BUTTON_5 = DT_GPIO_PIN(DT_ALIAS(sw4), gpios),
};

#endif /* _BUTTON_ASSIGNMENTS_H_ */


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/modules/audio_usb.c
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "audio_usb.h"

#include <zephyr/kernel.h>
#include <zephyr/usb/usb_device.h>
#include <zephyr/usb/class/usb_audio.h>

#include "macros_common.h"
#include "data_fifo.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(audio_usb, CONFIG_MODULE_AUDIO_USB_LOG_LEVEL);

#define USB_FRAME_SIZE_STEREO                                                                      \
	(((CONFIG_AUDIO_SAMPLE_RATE_HZ * CONFIG_AUDIO_BIT_DEPTH_OCTETS) / 1000) * 2)

static struct data_fifo *fifo_tx;
static struct data_fifo *fifo_rx;

NET_BUF_POOL_FIXED_DEFINE(pool_out, CONFIG_FIFO_FRAME_SPLIT_NUM, USB_FRAME_SIZE_STEREO, 8,
			  net_buf_destroy);

static uint32_t rx_num_overruns;
static bool rx_first_data;
static bool tx_first_data;

#if (CONFIG_STREAM_BIDIRECTIONAL)
static uint32_t tx_num_underruns;

static void data_write(const struct device *dev)
{
	int ret;

	if (fifo_tx == NULL) {
		return;
	}

	void *data_out;
	size_t data_out_size;
	struct net_buf *buf_out;

	buf_out = net_buf_alloc(&pool_out, K_NO_WAIT);

	ret = data_fifo_pointer_last_filled_get(fifo_tx, &data_out, &data_out_size, K_NO_WAIT);
	if (ret) {
		tx_num_underruns++;
		if ((tx_num_underruns % 100) == 1) {
			LOG_WRN("USB TX underrun. Num: %d", tx_num_underruns);
		}
		net_buf_unref(buf_out);

		return;
	}

	memcpy(buf_out->data, data_out, data_out_size);
	data_fifo_block_free(fifo_tx, data_out);

	if (data_out_size == usb_audio_get_in_frame_size(dev)) {
		ret = usb_audio_send(dev, buf_out, data_out_size);
		if (ret) {
			LOG_WRN("USB TX failed, ret: %d", ret);
			net_buf_unref(buf_out);
		}

	} else {
		LOG_WRN("Wrong size write: %d", data_out_size);
	}

	if (!tx_first_data) {
		LOG_INF("USB TX first data sent.");
		tx_first_data = true;
	}
}
#endif /* (CONFIG_STREAM_BIDIRECTIONAL) */

static void data_received(const struct device *dev, struct net_buf *buffer, size_t size)
{
	int ret;
	void *data_in;

	if (fifo_rx == NULL) {
		/* Throwing away data */
		net_buf_unref(buffer);
		return;
	}

	if (buffer == NULL || size == 0 || buffer->data == NULL) {
		/* This should never happen */
		ERR_CHK(-EINVAL);
	}

	/* Receive data from USB */
	if (size != USB_FRAME_SIZE_STEREO) {
		LOG_WRN("Wrong length: %d", size);
		net_buf_unref(buffer);
		return;
	}

	ret = data_fifo_pointer_first_vacant_get(fifo_rx, &data_in, K_NO_WAIT);

	/* RX FIFO can fill up due to retransmissions or disconnect */
	if (ret == -ENOMEM) {
		void *temp;
		size_t temp_size;

		rx_num_overruns++;
		if ((rx_num_overruns % 100) == 1) {
			LOG_WRN("USB RX overrun. Num: %d", rx_num_overruns);
		}

		ret = data_fifo_pointer_last_filled_get(fifo_rx, &temp, &temp_size, K_NO_WAIT);
		ERR_CHK(ret);

		data_fifo_block_free(fifo_rx, temp);

		ret = data_fifo_pointer_first_vacant_get(fifo_rx, &data_in, K_NO_WAIT);
	}

	ERR_CHK_MSG(ret, "RX failed to get block");

	memcpy(data_in, buffer->data, size);

	ret = data_fifo_block_lock(fifo_rx, &data_in, size);
	ERR_CHK_MSG(ret, "Failed to lock block");

	net_buf_unref(buffer);

	if (!rx_first_data) {
		LOG_INF("USB RX first data received.");
		rx_first_data = true;
	}
}

static void feature_update(const struct device *dev, const struct usb_audio_fu_evt *evt)
{
	LOG_DBG("Control selector %d for channel %d updated", evt->cs, evt->channel);
	switch (evt->cs) {
	case USB_AUDIO_FU_MUTE_CONTROL:
		/* Fall through */
	default:
		break;
	}
}

static const struct usb_audio_ops ops = {
	.data_received_cb = data_received,
	.feature_update_cb = feature_update,
#if (CONFIG_STREAM_BIDIRECTIONAL)
	.data_request_cb = data_write,
#endif /* (CONFIG_STREAM_BIDIRECTIONAL) */
};

int audio_usb_start(struct data_fifo *fifo_tx_in, struct data_fifo *fifo_rx_in)
{
	if (fifo_tx_in == NULL || fifo_rx_in == NULL) {
		return -EINVAL;
	}

	fifo_tx = fifo_tx_in;
	fifo_rx = fifo_rx_in;

	return 0;
}

void audio_usb_stop(void)
{
	rx_first_data = false;
	tx_first_data = false;
	fifo_tx = NULL;
	fifo_rx = NULL;
}

int audio_usb_disable(void)
{
	int ret;

	audio_usb_stop();

	ret = usb_disable();
	if (ret) {
		LOG_ERR("Failed to disable USB");
		return ret;
	}

	return 0;
}

int audio_usb_init(void)
{
	int ret;
	const struct device *hs_dev = DEVICE_DT_GET(DT_NODELABEL(hs_0));

	if (!device_is_ready(hs_dev)) {
		LOG_ERR("USB Headset Device not ready");
		return -EIO;
	}

	usb_audio_register(hs_dev, &ops);

	ret = usb_enable(NULL);
	if (ret) {
		LOG_ERR("Failed to enable USB");
		return ret;
	}

	LOG_INF("Ready for USB host to send/receive.");

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/modules/audio_sync_timer_rtc.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "audio_sync_timer.h"

#include <zephyr/kernel.h>
#include <zephyr/init.h>
#include <nrfx_dppi.h>
#include <nrfx_i2s.h>
#include <nrfx_ipc.h>
#include <nrfx_rtc.h>
#include <nrfx_timer.h>
#include <nrfx_egu.h>


#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(audio_sync_timer, CONFIG_AUDIO_SYNC_TIMER_LOG_LEVEL);

#define AUDIO_SYNC_TIMER_NET_APP_IPC_EVT_CHANNEL                4
#define AUDIO_SYNC_TIMER_NET_APP_IPC_EVT                        NRF_IPC_EVENT_RECEIVE_4

#define AUDIO_SYNC_HF_TIMER_INSTANCE_NUMBER                     1

#define AUDIO_SYNC_HF_TIMER_I2S_FRAME_START_EVT_CAPTURE_CHANNEL 0
#define AUDIO_SYNC_HF_TIMER_I2S_FRAME_START_EVT_CAPTURE         NRF_TIMER_TASK_CAPTURE0
#define AUDIO_SYNC_HF_TIMER_CURR_TIME_CAPTURE_CHANNEL           1
#define AUDIO_SYNC_HF_TIMER_CURR_TIME_CAPTURE                   NRF_TIMER_TASK_CAPTURE1

static const nrfx_timer_t audio_sync_hf_timer_instance =
	NRFX_TIMER_INSTANCE(AUDIO_SYNC_HF_TIMER_INSTANCE_NUMBER);

static uint8_t dppi_channel_i2s_frame_start;

#define AUDIO_SYNC_LF_TIMER_INSTANCE_NUMBER                     0

#define AUDIO_SYNC_LF_TIMER_I2S_FRAME_START_EVT_CAPTURE_CHANNEL 0
#define AUDIO_SYNC_LF_TIMER_I2S_FRAME_START_EVT_CAPTURE         NRF_RTC_TASK_CAPTURE_0
#define AUDIO_SYNC_LF_TIMER_CURR_TIME_CAPTURE_CHANNEL           1
#define AUDIO_SYNC_LF_TIMER_CURR_TIME_CAPTURE                   NRF_RTC_TASK_CAPTURE_1

static uint8_t dppi_channel_curr_time_capture;

static const nrfx_rtc_config_t rtc_cfg = NRFX_RTC_DEFAULT_CONFIG;

static const nrfx_rtc_t audio_sync_lf_timer_instance =
	NRFX_RTC_INSTANCE(AUDIO_SYNC_LF_TIMER_INSTANCE_NUMBER);

static uint8_t dppi_channel_timer_sync_with_rtc;
static uint8_t dppi_channel_rtc_start;
static volatile uint32_t num_rtc_overflows;

static nrfx_timer_config_t cfg = {.frequency = NRFX_MHZ_TO_HZ(1UL),
				  .mode = NRF_TIMER_MODE_TIMER,
				  .bit_width = NRF_TIMER_BIT_WIDTH_32,
				  .interrupt_priority = NRFX_TIMER_DEFAULT_CONFIG_IRQ_PRIORITY,
				  .p_context = NULL};

static uint32_t timestamp_from_rtc_and_timer_get(uint32_t ticks, uint32_t remainder_us)
{
	const uint64_t rtc_ticks_in_femto_units = 30517578125UL;
	const uint32_t rtc_overflow_time_us = 512000000UL;

	return ((ticks * rtc_ticks_in_femto_units) / 1000000000UL) +
		(num_rtc_overflows * rtc_overflow_time_us) +
		remainder_us;
}

uint32_t audio_sync_timer_capture(void)
{
	/* Ensure that the follow product specification statement is handled:
	 *
	 * There is a delay of 6 PCLK16M periods from when the TASKS_CAPTURE[n] is triggered
	 * until the corresponding CC[n] register is updated.
	 *
	 * Lets have a stale value in the CC[n] register and compare that it is different when
	 * we capture using DPPI.
	 *
	 * We ensure it is stale by setting it as the previous tick relative to current
	 * counter value.
	 */
	uint32_t tick_stale = nrf_rtc_counter_get(audio_sync_lf_timer_instance.p_reg);

	/* Set a stale value in the CC[n] register */
	tick_stale--;
	nrf_rtc_cc_set(audio_sync_lf_timer_instance.p_reg,
		       AUDIO_SYNC_LF_TIMER_CURR_TIME_CAPTURE_CHANNEL, tick_stale);

	/* Trigger EGU task to capture RTC and TIMER value */
	nrf_egu_task_trigger(NRF_EGU0, NRF_EGU_TASK_TRIGGER0);

	/* Read captured RTC value */
	uint32_t tick = nrf_rtc_cc_get(audio_sync_lf_timer_instance.p_reg,
				       AUDIO_SYNC_LF_TIMER_CURR_TIME_CAPTURE_CHANNEL);

	/* If required, wait until CC[n] register is updated */
	while (tick == tick_stale) {
		tick = nrf_rtc_cc_get(audio_sync_lf_timer_instance.p_reg,
				      AUDIO_SYNC_LF_TIMER_CURR_TIME_CAPTURE_CHANNEL);
	}

	/* Read captured TIMER value */
	uint32_t remainder_us = nrf_timer_cc_get(NRF_TIMER1,
						 AUDIO_SYNC_HF_TIMER_CURR_TIME_CAPTURE_CHANNEL);

	return timestamp_from_rtc_and_timer_get(tick, remainder_us);
}

uint32_t audio_sync_timer_capture_get(void)
{
	uint32_t remainder_us;
	uint32_t tick;

	tick = nrf_rtc_cc_get(audio_sync_lf_timer_instance.p_reg,
			      AUDIO_SYNC_LF_TIMER_I2S_FRAME_START_EVT_CAPTURE_CHANNEL);
	remainder_us = nrf_timer_cc_get(NRF_TIMER1,
					AUDIO_SYNC_HF_TIMER_I2S_FRAME_START_EVT_CAPTURE_CHANNEL);

	return timestamp_from_rtc_and_timer_get(tick, remainder_us);
}

static void unused_timer_isr_handler(nrf_timer_event_t event_type, void *ctx)
{
	ARG_UNUSED(event_type);
	ARG_UNUSED(ctx);
}

static void rtc_isr_handler(nrfx_rtc_int_type_t int_type)
{
	if (int_type == NRFX_RTC_INT_OVERFLOW) {
		num_rtc_overflows++;
	}
}

/**
 * @brief Initialize audio sync timer
 *
 * @note The audio sync timers is replicating the controller's clock.
 * The controller starts or clears the sync timer using a PPI signal
 * sent from the controller. This makes the two clocks synchronized.
 *
 * @return 0 if successful, error otherwise
 */
static int audio_sync_timer_init(void)
{
	nrfx_err_t ret;

	ret = nrfx_timer_init(&audio_sync_hf_timer_instance, &cfg, unused_timer_isr_handler);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx timer init error: %d", ret);
		return -ENODEV;
	}

	ret = nrfx_rtc_init(&audio_sync_lf_timer_instance, &rtc_cfg, rtc_isr_handler);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx rtc init error: %d", ret);
		return -ENODEV;
	}

	IRQ_CONNECT(RTC0_IRQn, IRQ_PRIO_LOWEST, nrfx_rtc_0_irq_handler, NULL, 0);
	nrfx_rtc_overflow_enable(&audio_sync_lf_timer_instance, true);

	/* Initialize capturing of I2S frame start event timestamps */
	ret = nrfx_dppi_channel_alloc(&dppi_channel_i2s_frame_start);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx DPPI channel alloc error (I2S frame start): %d", ret);
		return -ENOMEM;
	}

	nrf_timer_subscribe_set(audio_sync_hf_timer_instance.p_reg,
				AUDIO_SYNC_HF_TIMER_I2S_FRAME_START_EVT_CAPTURE,
				dppi_channel_i2s_frame_start);

	/* Initialize capturing of I2S frame start event timestamps at the RTC as well. */
	nrf_rtc_subscribe_set(audio_sync_lf_timer_instance.p_reg,
			      AUDIO_SYNC_LF_TIMER_I2S_FRAME_START_EVT_CAPTURE,
			      dppi_channel_i2s_frame_start);

	nrf_i2s_publish_set(NRF_I2S0, NRF_I2S_EVENT_FRAMESTART, dppi_channel_i2s_frame_start);
	ret = nrfx_dppi_channel_enable(dppi_channel_i2s_frame_start);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx DPPI channel enable error (I2S frame start): %d", ret);
		return -EIO;
	}

	/* Initialize capturing of current timestamps */
	ret = nrfx_dppi_channel_alloc(&dppi_channel_curr_time_capture);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx DPPI channel alloc error (I2S frame start) - Return value: %d", ret);
		return -ENOMEM;
	}

	nrf_rtc_subscribe_set(audio_sync_lf_timer_instance.p_reg,
			      AUDIO_SYNC_LF_TIMER_CURR_TIME_CAPTURE,
			      dppi_channel_curr_time_capture);

	nrf_timer_subscribe_set(audio_sync_hf_timer_instance.p_reg,
				AUDIO_SYNC_HF_TIMER_CURR_TIME_CAPTURE,
				dppi_channel_curr_time_capture);

	nrf_egu_publish_set(NRF_EGU0, NRF_EGU_EVENT_TRIGGERED0, dppi_channel_curr_time_capture);

	ret = nrfx_dppi_channel_enable(dppi_channel_curr_time_capture);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx DPPI channel enable error (I2S frame start) - Return value: %d", ret);
		return -EIO;
	}

	/* Initialize functionality for synchronization between APP and NET core */
	ret = nrfx_dppi_channel_alloc(&dppi_channel_rtc_start);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx DPPI channel alloc error (timer clear): %d", ret);
		return -ENOMEM;
	}

	nrf_rtc_subscribe_set(audio_sync_lf_timer_instance.p_reg, NRF_RTC_TASK_START,
			      dppi_channel_rtc_start);
	nrf_timer_subscribe_set(audio_sync_hf_timer_instance.p_reg, NRF_TIMER_TASK_START,
				dppi_channel_rtc_start);

	nrf_ipc_receive_config_set(NRF_IPC, AUDIO_SYNC_TIMER_NET_APP_IPC_EVT_CHANNEL,
				   NRF_IPC_CHANNEL_4);
	nrf_ipc_publish_set(NRF_IPC, AUDIO_SYNC_TIMER_NET_APP_IPC_EVT, dppi_channel_rtc_start);

	ret = nrfx_dppi_channel_enable(dppi_channel_rtc_start);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx DPPI channel enable error (timer clear): %d", ret);
		return -EIO;
	}

	/* Initialize functionality for synchronization between RTC and TIMER */
	ret = nrfx_dppi_channel_alloc(&dppi_channel_timer_sync_with_rtc);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx DPPI channel alloc error (timer clear): %d", ret);
		return -ENOMEM;
	}

	nrf_rtc_publish_set(audio_sync_lf_timer_instance.p_reg, NRF_RTC_EVENT_TICK,
			    dppi_channel_timer_sync_with_rtc);
	nrf_timer_subscribe_set(audio_sync_hf_timer_instance.p_reg, NRF_TIMER_TASK_CLEAR,
				dppi_channel_timer_sync_with_rtc);

	nrfx_rtc_tick_enable(&audio_sync_lf_timer_instance, false);

	ret = nrfx_dppi_channel_enable(dppi_channel_timer_sync_with_rtc);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx DPPI channel enable error (timer clear): %d", ret);
		return -EIO;
	}

	LOG_DBG("Audio sync timer initialized");

	return 0;
}

SYS_INIT(audio_sync_timer_init, POST_KERNEL, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);


// File: /Users/devyn/splitr/nrf5340_ble_switching/src/modules/hw_codec.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _HW_CODEC_H_
#define _HW_CODEC_H_

#include <stdint.h>

/**
 * @brief  Set volume on HW_CODEC
 *
 * @details Also unmutes the volume on HW_CODEC
 *
 * @param  set_val  Set the volume to a specific value.
 *                  This range of the value is between 0 to 128.
 *
 * @return 0 if successful, error otherwise
 */
int hw_codec_volume_set(uint8_t set_val);

/**
 * @brief  Adjust volume on HW_CODEC
 *
 * @details Also unmute the volume on HW_CODEC
 *
 * @param  adjustment  The adjustment in dB, can be negative or positive.
 *			If the value 0 is used, the previous known value will be
 *			written, default value will be used if no previous value
 *			exists
 *
 * @return 0 if successful, error otherwise
 */
int hw_codec_volume_adjust(int8_t adjustment);

/**
 * @brief Decrease output volume on HW_CODEC by 3 dB
 *
 * @details Also unmute the volume on HW_CODEC
 *
 * @return 0 if successful, error otherwise
 */
int hw_codec_volume_decrease(void);

/**
 * @brief Increase output volume on HW_CODEC by 3 dB
 *
 * @details Also unmute the volume on HW_CODEC
 *
 * @return 0 if successful, error otherwise
 */
int hw_codec_volume_increase(void);

/**
 * @brief  Mute volume on HW_CODEC
 *
 * @return 0 if successful, error otherwise
 */
int hw_codec_volume_mute(void);

/**
 * @brief  Unmute volume on HW_CODEC
 *
 * @return 0 if successful, error otherwise
 */
int hw_codec_volume_unmute(void);

/**
 * @brief Enable relevant settings in HW_CODEC to
 *        send and receive PCM data over I2S
 *
 * @note  FLL1 must be toggled after I2S has started to enable HW_CODEC
 *
 * @return 0 if successful, error otherwise
 */
int hw_codec_default_conf_enable(void);

/**
 * @brief Reset HW_CODEC
 *
 * @note  This will first disable output, then do a soft reset
 *
 * @return 0 if successful, error otherwise
 */
int hw_codec_soft_reset(void);

/**
 * @brief Initialize HW_CODEC
 *
 * @return 0 if successful, error otherwise
 */
int hw_codec_init(void);

#endif /* _HW_CODEC_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/index.rst
.. _nrf53_audio_app:

nRF5340 Audio applications
##########################

The nRF5340 Audio applications demonstrate audio playback over isochronous channels (ISO) using LC3 codec compression and decompression, as per `Bluetooth LE Audio specifications`_.

.. note::
   nRF5340 Audio applications and their DFU/FOTA functionality are marked as :ref:`experimental <software_maturity>`.

The following table summarizes the differences between the available nRF5340 Audio applications.

.. list-table:: Differences between nRF5340 Audio applications
   :header-rows: 1

   * - Application
     - LE Audio mode and role
     - Minimum amount of nRF5340 Audio DKs recommended for testing
     - FEM support
   * - :ref:`Unicast client<nrf53_audio_unicast_client_app>`
     - CIS gateway
     - 3
     - 
   * - :ref:`Unicast server<nrf53_audio_unicast_server_app>`
     - CIS headset
     - 3
     - 
   * - :ref:`Broadcast sink<nrf53_audio_broadcast_sink_app>`
     - BIS gateway
     - 2
     -
   * - :ref:`Broadcast source<nrf53_audio_broadcast_source_app>`
     - BIS headset
     - 2
     - 

See the subpages for detailed documentation of each of the nRF5340 applications and their internal modules:

.. _nrf53_audio_app_subpages:

.. toctree::
   :maxdepth: 1
   :caption: Subpages:

   doc/firmware_architecture
   doc/feature_support
   doc/requirements
   doc/user_interface
   doc/configuration
   doc/building
   broadcast_sink/README
   broadcast_source/README
   unicast_client/README
   unicast_server/README
   doc/fota
   doc/adapting_application


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/CMakeLists.txt
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

cmake_minimum_required(VERSION 3.20.0)

if(CONFIG_AUDIO_DFU EQUAL 1)
    list(APPEND mcuboot_OVERLAY_CONFIG
        "${CMAKE_CURRENT_LIST_DIR}/dfu/conf/overlay-mcuboot.conf"
        "\\\${ZEPHYR_NRF_MODULE_DIR}/subsys/partition_manager/partition_manager_enabled.conf"
    )
endif()

if(CONFIG_AUDIO_DFU EQUAL 2)
    list(APPEND mcuboot_OVERLAY_CONFIG
        "${CMAKE_CURRENT_LIST_DIR}/dfu/conf/overlay-mcuboot_external_flash.conf"
        "\\\${ZEPHYR_NRF_MODULE_DIR}/subsys/partition_manager/partition_manager_enabled.conf"
    )
    list(APPEND mcuboot_DTC_OVERLAY_FILE
        "${CMAKE_CURRENT_LIST_DIR}/dfu/conf/overlay-dfu_external_flash.overlay"
        "\\\${ZEPHYR_NRF_MODULE_DIR}/modules/mcuboot/flash_sim.overlay"
    )
    set(DTC_OVERLAY_FILE ${CMAKE_CURRENT_LIST_DIR}/dfu/conf/overlay-dfu_external_flash.overlay)
    set(mcuboot_PM_STATIC_YML_FILE ${CMAKE_CURRENT_LIST_DIR}/dfu/conf/pm_dfu_external_flash.yml)
    set(PM_STATIC_YML_FILE ${CMAKE_CURRENT_LIST_DIR}/dfu/conf/pm_dfu_external_flash.yml)
endif()

if (CONFIG_BT_LL_ACS_NRF53)
    if ((CONFIG_AUDIO_DFU EQUAL 1) OR (CONFIG_AUDIO_DFU EQUAL 2))
        list(APPEND empty_net_core_OVERLAY_CONFIG
            "${CMAKE_CURRENT_LIST_DIR}/dfu/conf/overlay-empty_net_core.conf"
        )

        # Disable pretick anomaly workaround. The workaround causes a resource conflict between B0N and
        # the controller, and as the controller does not use RTC to wake up from sleep it is not
        # affected by the anomaly.
        list(APPEND empty_net_core_b0n_CONFIG_SOC_NRF53_RTC_PRETICK n)

        if (CONFIG_B0N_MINIMAL)
            set(min_b0n_flag "-m")
            list(APPEND empty_net_core_b0n_OVERLAY_CONFIG overlay-minimal-size.conf)
        endif()
    endif()
endif()

# Flag which defines whether application is compiled as gateway/dongle or headset
add_compile_definitions(HEADSET=1)
add_compile_definitions(GATEWAY=2)

find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})

project(NRF5340_AUDIO)

string(TIMESTAMP NRF5340_AUDIO_CORE_APP_COMP_DATE "%a %b %d %H:%M:%S %Y")

# Generate fw_info_app.c
configure_file("${CMAKE_CURRENT_SOURCE_DIR}/src/utils/fw_info_app.c.in"
               "${CMAKE_BINARY_DIR}/fw_info_app.c"
               @ONLY)

# Target sources below are specific to the nRF5340 Audio DK HW
target_sources(app PRIVATE
    src/nrf5340_audio_common.c
    ${CMAKE_BINARY_DIR}/fw_info_app.c
    )

if (CONFIG_BT_BAP_BROADCAST_SINK)
	add_subdirectory(broadcast_sink)
endif()

if (CONFIG_BT_BAP_BROADCAST_SOURCE)
	add_subdirectory(broadcast_source)
endif()

if (CONFIG_BT_BAP_UNICAST_CLIENT)
	add_subdirectory(unicast_client)
endif()

if (CONFIG_BT_BAP_UNICAST_SERVER)
	add_subdirectory(unicast_server)
endif()


# Include application events and configuration headers
zephyr_library_include_directories(
    include
    src/audio
    src/bluetooth
    src/drivers
    src/modules
    src/utils
    src/utils/macros
)

zephyr_library_include_directories(app PRIVATE
    ${ZEPHYR_NRF_MODULE_DIR}/boards/arm/nrf5340_audio_dk_nrf5340)

# Application sources
add_subdirectory(src/audio)
add_subdirectory(src/bluetooth)
add_subdirectory(src/drivers)
add_subdirectory(src/modules)
add_subdirectory(src/utils)

## Cirrus Logic
if (CONFIG_HW_CODEC_CIRRUS_LOGIC)
    if (ZEPHYR_CIRRUS_LOGIC_MODULE_DIR)
        add_subdirectory(${ZEPHYR_CIRRUS_LOGIC_MODULE_DIR} cirrus_logic_bin_dir)
    else()
        message(FATAL_ERROR "Cirrus Logic/sdk-mcu-drivers repository not found\n")
    endif()
endif()

if (CONFIG_BT_LL_ACS_NRF53)
    if ((CONFIG_AUDIO_DFU EQUAL 1) OR (CONFIG_AUDIO_DFU EQUAL 2))
        set(BLE5_CTR_SIGN_STEP ${APPLICATION_BINARY_DIR}/dummy)
        file(TO_CMAKE_PATH ${ZEPHYR_NRF_MODULE_DIR}/lib/bin/bt_ll_acs_nrf53/bin CMAKE_STYLE_LL_ACS_NRF53_BIN)

        add_custom_command(
            COMMAND ${PYTHON_EXECUTABLE} ${CMAKE_CURRENT_LIST_DIR}/tools/buildprog/ble5-ctr-rpmsg_sign.py
            -I ${CMAKE_STYLE_LL_ACS_NRF53_BIN} -b ${APPLICATION_BINARY_DIR} ${min_b0n_flag}
            OUTPUT ${BLE5_CTR_SIGN_STEP}
            DEPENDS merged_domains_hex
            COMMENT "Running post-build ble5-ctr signing step..."
        )

        add_custom_target(
            post_bin ALL
            DEPENDS
            ${BLE5_CTR_SIGN_STEP}
        )
    endif()
endif()


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/.DS_Store
// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/Kconfig.defaults
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

config REBOOT
	default y

config MAIN_THREAD_PRIORITY
	default 10

config MAIN_STACK_SIZE
	default 1800 if SD_CARD_PLAYBACK
	default 1600

config SYSTEM_WORKQUEUE_STACK_SIZE
	default 1200

# As long as thread names are used, config must be set to "y"
config THREAD_NAME
	default y

config NCS_INCLUDE_RPMSG_CHILD_IMAGE
	default !BT_LL_ACS_NRF53

# Workaround to not use fatal_error.c in NCS. Note that the system may still
# reset on error depending on the build configuraion
config RESET_ON_FATAL_ERROR
	default n

# Default Config for Debug and Release build
config HW_CODEC_CIRRUS_LOGIC
	default y

config BT
	default y

config BOARD_ENABLE_DCDC_APP
	default y

config BOARD_ENABLE_DCDC_NET
	default y

config BOARD_ENABLE_CPUNET
	default y

config ZBUS
	default y

config ZBUS_RUNTIME_OBSERVERS
	default y

config ZBUS_MSG_SUBSCRIBER
	default y

config SENSOR
	default y

config REGULATOR
	default y

config CONTIN_ARRAY
	default y

config NRFX_I2S0
	default y

config PCM_MIX
	default y

config PSCM
	default y

config DATA_FIFO
	default y

# Enable NRFX_CLOCK for ACLK control
config NRFX_CLOCK
	default y

config I2C
	default y

choice LIBC_IMPLEMENTATION
	# NOTE: Since we are not using minimal libc, error codes from
	#       minimal libc are not used
	default NEWLIB_LIBC
endchoice

# Audio codec LC3 related defines
# FPU_SHARING enables preservation of the hardware floating point registers
# across context switches to allow multiple threads to perform concurrent
# floating point operations.
config FPU
	default y

config FPU_SHARING
	default y

# Enable SDHC interface
config DISK_DRIVERS
	default y

config DISK_DRIVER_SDMMC
	default y

# Enable SPI interface
config SPI
	default y

# Enable ADC for board version readback
config ADC
	default y

# Allocate buffer on RAM for transferring chunck of data
# from Flash to SPI
config SPI_NRFX_RAM_BUFFER_SIZE
	default 8

# Config the file system
config FILE_SYSTEM
	default y

config FAT_FILESYSTEM_ELM
	default y

config FS_FATFS_LFN
	default y
choice FS_FATFS_LFN_MODE
	# Using stack for LFN work queue
	default FS_FATFS_LFN_MODE_STACK
endchoice

# exFAT enabled to support longer file names and higher transfer speed
config FS_FATFS_EXFAT
	default y

# Set the maximum file name length to 255
config FS_FATFS_MAX_LFN
	default 255

config WATCHDOG
	default y

config TASK_WDT
	default y


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/LICENSE
LicenseID:  LicenseRef-PCFT

ExtractedText: <text>
Redistribution and use of the Audio subsystem for nRF5340 Software, in binary
and source code forms, with or without modification, are permitted provided that
the following conditions are met:

1. Redistributions of source code form must retain the above copyright notice,
   this list of conditions, and the following disclaimer.

2. Redistributions in binary code form, except as embedded into a Nordic Semiconductor ASA
   nRF53 chip or a software update for such product, must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation and/or other
   materials provided with the distribution.

3. Neither the name of Packetcraft, Inc. nor Nordic Semiconductor ASA nor the names of its
   contributors may be used to endorse or promote products derived from this software without
   specific prior written permission.

4. This software, with or without modification, must only be used with a Nordic Semiconductor ASA
   nRF53 chip.

5. Any software provided in binary or source code form under this license must not be reverse
   engineered, decompiled, modified and/or disassembled.

THIS SOFTWARE IS PROVIDED BY PACKETCRAFT, INC. AND NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL
PACKETCRAFT, INC., NORDIC SEMICONDUCTOR ASA, OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
OF SUCH DAMAGE.

</text>


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/prj.conf
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

# nRF5340 Audio
CONFIG_NRF5340_AUDIO=y

CONFIG_SAMPLE_RATE_CONVERTER=y
CONFIG_SAMPLE_RATE_CONVERTER_FILTER_SIMPLE=y

# General
CONFIG_DEBUG=y
CONFIG_DEBUG_INFO=y
CONFIG_ASSERT=y
CONFIG_STACK_USAGE=y
CONFIG_THREAD_RUNTIME_STATS=y
CONFIG_STACK_SENTINEL=y
CONFIG_INIT_STACKS=y

# Uart driver
CONFIG_SERIAL=y

# Logging
CONFIG_LOG=y
CONFIG_NEWLIB_LIBC_FLOAT_PRINTF=y
CONFIG_LOG_TAG_MAX_LEN=2
CONFIG_LOG_TAG_DEFAULT="--"
CONFIG_LOG_BACKEND_UART=y

# Use this for debugging thread usage
#CONFIG_LOG_THREAD_ID_PREFIX=y

# Console related defines
CONFIG_CONSOLE=y
CONFIG_RTT_CONSOLE=y
CONFIG_UART_CONSOLE=y

# Shell related defines
CONFIG_SHELL=y
CONFIG_KERNEL_SHELL=y
CONFIG_USE_SEGGER_RTT=y
## Disable logs on RTT
CONFIG_SHELL_RTT_INIT_LOG_LEVEL_NONE=y
CONFIG_SHELL_BACKEND_RTT=y
CONFIG_SHELL_BACKEND_SERIAL=n
CONFIG_SHELL_VT100_COMMANDS=y
CONFIG_SHELL_VT100_COLORS=y
CONFIG_SHELL_STACK_SIZE=4096
CONFIG_SHELL_CMD_BUFF_SIZE=128
## Reduce shell memory usage
CONFIG_SHELL_WILDCARD=n
CONFIG_SHELL_HELP_ON_WRONG_ARGUMENT_COUNT=n
CONFIG_SHELL_STATS=n
CONFIG_SHELL_CMDS=n
CONFIG_SHELL_HISTORY=y

# Turn off default shell commands
CONFIG_I2C_SHELL=n
CONFIG_HWINFO_SHELL=n
CONFIG_CLOCK_CONTROL_NRF_SHELL=n
CONFIG_FLASH_SHELL=n
CONFIG_DEVICE_SHELL=n

# Suppress LOG_ERR messages from sd_check_card_type. Because SPI_SDHC has no card presence method,
# assume card is in slot. Thus error message is always shown if card is not inserted
CONFIG_SD_LOG_LEVEL_OFF=y

# Suppress LOG_INF messages from hci_core
CONFIG_BT_HCI_CORE_LOG_LEVEL_WRN=y


# Custom:
# CONFIG_WALKIE_TALKIE_DEMO=y
CONFIG_TRANSPORT_BIS=y

// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/prj_release.conf
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

# nRF5340 Audio
CONFIG_NRF5340_AUDIO=y

CONFIG_SAMPLE_RATE_CONVERTER=y
CONFIG_SAMPLE_RATE_CONVERTER_FILTER_SIMPLE=y

# General
CONFIG_DEBUG=n
CONFIG_ASSERT=n
CONFIG_STACK_USAGE=n
CONFIG_THREAD_MONITOR=n
CONFIG_SERIAL=n
CONFIG_CONSOLE=n
CONFIG_PRINTK=n
CONFIG_UART_CONSOLE=n
CONFIG_BOOT_BANNER=n

# Bluetooth
# Default value from src/bluetooth/Kconfig.defaults.
# BT_PRIVACY is default turned off to ease the development.
# Should be turned on before production.
# CONFIG_BT_PRIVACY=y

# USB
# Default values from src/modules/Kconfig.defaults.
# USB VID and PID must be changed before production.
# CONFIG_USB_DEVICE_VID=0x1915
# CONFIG_USB_DEVICE_PID=0x530A
CONFIG_TRANSPORT_BIS=y

// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/Kconfig
#
# Copyright (c) 2018 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

menuconfig NRF5340_AUDIO
	 bool "nRF5340 Audio [EXPERIMENTAL]"
	 select EXPERIMENTAL

if NRF5340_AUDIO

config AUDIO_DEV
	int "Select which device type to compile for. 1=HEADSET or 2=GATEWAY"
	range 1 2
	default 1
	help
	  Setting this variable to 1 selects that the project is compiled
	  as a HEADSET device.
	  Setting to 2 will compile as a GATEWAY.

choice NRF5340_AUDIO_TRANSPORT_MODE
	prompt "Choose BIS or CIS for ISO transport"
	default TRANSPORT_CIS if WALKIE_TALKIE_DEMO
	default TRANSPORT_CIS

config TRANSPORT_BIS
	bool "Use BIS (Broadcast Isochronous Stream)"

config TRANSPORT_CIS
	bool "Use CIS (Connected Isochronous Stream)"

endchoice

#----------------------------------------------------------------------------#
if (TRANSPORT_BIS && AUDIO_DEV = 1)
rsource "broadcast_sink/Kconfig.defaults"
endif # TRANSPORT_BIS && AUDIO_DEV = 1

if (TRANSPORT_BIS && AUDIO_DEV = 2)
rsource "broadcast_source/Kconfig.defaults"
endif # TRANSPORT_BIS && AUDIO_DEV = 2

if (TRANSPORT_CIS && AUDIO_DEV = 1)
rsource "unicast_server/Kconfig.defaults"
endif # TRANSPORT_CIS && AUDIO_DEV = 1

if (TRANSPORT_CIS && AUDIO_DEV = 2)
rsource "unicast_client/Kconfig.defaults"
endif # TRANSPORT_CIS && AUDIO_DEV = 2



rsource "Kconfig.defaults"
rsource "src/audio/Kconfig"
rsource "src/bluetooth/Kconfig"
rsource "src/drivers/Kconfig"
rsource "src/modules/Kconfig"
rsource "src/utils/Kconfig"
rsource "dfu/conf/Kconfig.dfu"

#----------------------------------------------------------------------------#
menu "Logging"

module = MAIN
module-str = main
source "subsys/logging/Kconfig.template.log_config"

module = NRF5340_AUDIO_COMMON
module-str = nrf5340_audio_common
source "subsys/logging/Kconfig.template.log_config"

config PRINT_STACK_USAGE_MS
	depends on THREAD_ANALYZER && INIT_STACKS
	int "Print stack usage every x milliseconds"
	default 5000

endmenu # Log levels

#----------------------------------------------------------------------------#
endif # NRF5340_AUDIO

source "Kconfig.zephyr"


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/sample.yaml
sample:
  name: nRF5340 Audio application
  description: LE Audio implementation example
common:
  integration_platforms:
    - nrf5340_audio_dk_nrf5340_cpuapp
tests:
  applications.nrf5340_audio.headset:
    build_only: true
    platform_allow: nrf5340_audio_dk_nrf5340_cpuapp
    platform_exclude: nrf5340_audio_dk_nrf5340_cpuapp_ns
    tags: ci_build
    extra_args: CONF_FILE="prj_release.conf" CONFIG_AUDIO_DEV=1
  applications.nrf5340_audio.gateway:
    build_only: true
    platform_allow: nrf5340_audio_dk_nrf5340_cpuapp
    platform_exclude: nrf5340_audio_dk_nrf5340_cpuapp_ns
    tags: ci_build
    extra_args: CONF_FILE="prj_release.conf" CONFIG_AUDIO_DEV=2
  applications.nrf5340_audio.headset_sd_card_playback:
    build_only: true
    platform_allow: nrf5340_audio_dk_nrf5340_cpuapp
    platform_exclude: nrf5340_audio_dk_nrf5340_cpuapp_ns
    tags: ci_build
    extra_args: CONF_FILE="prj_release.conf" CONFIG_AUDIO_DEV=1 CONFIG_SD_CARD_PLAYBACK=y


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/child_image/hci_ipc_release.conf
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

CONFIG_BT_ISO_PERIPHERAL=y
CONFIG_BT_ISO_CENTRAL=y
CONFIG_BT_ISO_BROADCASTER=y
CONFIG_BT_ISO_SYNC_RECEIVER=y
CONFIG_BT_EXT_ADV=y
CONFIG_BT_PER_ADV_SYNC_TRANSFER_RECEIVER=y
CONFIG_BT_PER_ADV_SYNC_TRANSFER_SENDER=y

CONFIG_BT_CTLR_CONN_ISO_GROUPS=1
CONFIG_BT_CTLR_CONN_ISO_STREAMS=2
CONFIG_BT_CTLR_SYNC_ISO_STREAM_COUNT=2
CONFIG_BT_CTLR_ADV_ISO_SET=1
CONFIG_BT_CTLR_ADV_ISO_STREAM_COUNT=2

# Support two links as a central, or one link as a peripheral
CONFIG_BT_MAX_CONN=3
CONFIG_BT_CTLR_SDC_PERIPHERAL_COUNT=1

# Allow using more than default advertising event length
CONFIG_BT_CTLR_ADV_DATA_LEN_MAX=251

# To present the audio at the right point in time, we need the controller and
# audio clock to be synchronized
CONFIG_MPSL_TRIGGER_IPC_TASK_ON_RTC_START=y
CONFIG_MPSL_TRIGGER_IPC_TASK_ON_RTC_START_CHANNEL=4

# General
CONFIG_DEBUG=n
CONFIG_ASSERT=n
CONFIG_STACK_USAGE=n
CONFIG_THREAD_MONITOR=n
CONFIG_SERIAL=n
CONFIG_CONSOLE=n
CONFIG_PRINTK=n
CONFIG_UART_CONSOLE=n
CONFIG_BOOT_BANNER=n


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/child_image/hci_ipc.conf
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

CONFIG_BT_ISO_PERIPHERAL=y
CONFIG_BT_ISO_CENTRAL=y
CONFIG_BT_ISO_BROADCASTER=y
CONFIG_BT_ISO_SYNC_RECEIVER=y
CONFIG_BT_EXT_ADV=y
CONFIG_BT_PER_ADV_SYNC_TRANSFER_RECEIVER=y
CONFIG_BT_PER_ADV_SYNC_TRANSFER_SENDER=y

CONFIG_BT_CTLR_CONN_ISO_GROUPS=1
CONFIG_BT_CTLR_CONN_ISO_STREAMS=2
CONFIG_BT_CTLR_SYNC_ISO_STREAM_COUNT=2
CONFIG_BT_CTLR_ADV_ISO_SET=1
CONFIG_BT_CTLR_ADV_ISO_STREAM_COUNT=2

# Support two links as a central, or one link as a peripheral
CONFIG_BT_MAX_CONN=3
CONFIG_BT_CTLR_SDC_PERIPHERAL_COUNT=1

# Allow using more than default advertising event length
CONFIG_BT_CTLR_ADV_DATA_LEN_MAX=251

# To present the audio at the right point in time, we need the controller and
# audio clock to be synchronized
CONFIG_MPSL_TRIGGER_IPC_TASK_ON_RTC_START=y
CONFIG_MPSL_TRIGGER_IPC_TASK_ON_RTC_START_CHANNEL=4

#
# If using FEM the CONFIG_BT_CTLR_TX_PWR_ANTENNA should be set here if the
# value required is not 10 dBm
#


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/unicast_client/CMakeLists.txt
#
# Copyright (c) 2023 Nordic Semiconductor
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

target_sources(app PRIVATE
	       ${CMAKE_CURRENT_SOURCE_DIR}/main.c)


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/unicast_client/Kconfig.defaults
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

config UTF8
	default y

## ACL related configs ##
config BT_MAX_CONN
	default 2

# Generic Audio Source - 0x0880
config BT_DEVICE_APPEARANCE
	default 2176

config BT_MAX_PAIRED
	default 2

config BT_GATT_DYNAMIC_DB
	default y


## ISO related configs ##
config BT_ISO_MAX_CHAN
	default 4

config BT_BAP_UNICAST_CLIENT
	default y

config BT_ISO_TX_BUF_COUNT
	default 2

config BT_BAP_UNICAST_CLIENT_GROUP_STREAM_COUNT
	default 4

config BT_BAP_UNICAST_CLIENT_ASE_SNK_COUNT
	default 2

config BT_BAP_UNICAST_CLIENT_ASE_SRC_COUNT
	default 2

config BT_VCP_VOL_CTLR
	default y

config BT_MCS
	default y

config BT_MPL
	default y

config MCTL
	default y

config MCTL_LOCAL_PLAYER_CONTROL
	default y

config MCTL_LOCAL_PLAYER_REMOTE_CONTROL
	default y


## LC3 related configs ##
config LC3_BITRATE
	default BT_AUDIO_BITRATE_UNICAST_SINK

config LC3_ENC_CHAN_MAX
	default 2

config LC3_DEC_CHAN_MAX
	default 1


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/unicast_client/main.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "streamctrl.h"

#include <zephyr/zbus/zbus.h>

#include "nrf5340_audio_common.h"
#include "nrf5340_audio_dk.h"
#include "led.h"
#include "button_assignments.h"
#include "macros_common.h"
#include "audio_system.h"
#include "button_handler.h"
#include "bt_le_audio_tx.h"
#include "bt_mgmt.h"
#include "bt_rend.h"
#include "bt_content_ctrl.h"
#include "unicast_client.h"
#include "le_audio_rx.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(main, CONFIG_MAIN_LOG_LEVEL);

static enum stream_state strm_state = STATE_PAUSED;

ZBUS_SUBSCRIBER_DEFINE(button_evt_sub, CONFIG_BUTTON_MSG_SUB_QUEUE_SIZE);
ZBUS_SUBSCRIBER_DEFINE(content_control_evt_sub, CONFIG_CONTENT_CONTROL_MSG_SUB_QUEUE_SIZE);

ZBUS_MSG_SUBSCRIBER_DEFINE(le_audio_evt_sub);

ZBUS_CHAN_DECLARE(button_chan);
ZBUS_CHAN_DECLARE(le_audio_chan);
ZBUS_CHAN_DECLARE(bt_mgmt_chan);
ZBUS_CHAN_DECLARE(cont_media_chan);
ZBUS_CHAN_DECLARE(sdu_ref_chan);

ZBUS_OBS_DECLARE(sdu_ref_msg_listen);

static struct k_thread button_msg_sub_thread_data;
static struct k_thread le_audio_msg_sub_thread_data;
static struct k_thread content_control_msg_sub_thread_data;

static k_tid_t button_msg_sub_thread_id;
static k_tid_t le_audio_msg_sub_thread_id;
static k_tid_t content_control_thread_id;

K_THREAD_STACK_DEFINE(button_msg_sub_thread_stack, CONFIG_BUTTON_MSG_SUB_STACK_SIZE);
K_THREAD_STACK_DEFINE(le_audio_msg_sub_thread_stack, CONFIG_LE_AUDIO_MSG_SUB_STACK_SIZE);
K_THREAD_STACK_DEFINE(content_control_msg_sub_thread_stack,
		      CONFIG_CONTENT_CONTROL_MSG_SUB_STACK_SIZE);

/* Function for handling all stream state changes */
static void stream_state_set(enum stream_state stream_state_new)
{
	strm_state = stream_state_new;
}

static void content_control_msg_sub_thread(void)
{
	int ret;
	const struct zbus_channel *chan;

	while (1) {
		ret = zbus_sub_wait(&content_control_evt_sub, &chan, K_FOREVER);
		ERR_CHK(ret);

		struct content_control_msg msg;

		ret = zbus_chan_read(chan, &msg, ZBUS_READ_TIMEOUT_MS);
		ERR_CHK(ret);

		switch (msg.event) {
		case MEDIA_START:
			unicast_client_start();
			break;

		case MEDIA_STOP:
			unicast_client_stop();
			break;

		default:
			LOG_WRN("Unhandled event from content ctrl: %d", msg.event);
			break;
		}

		STACK_USAGE_PRINT("content_ctrl_msg_thread", &content_control_msg_sub_thread);
	}
}

/**
 * @brief	Handle button activity.
 */
static void button_msg_sub_thread(void)
{
	int ret;
	const struct zbus_channel *chan;

	while (1) {
		ret = zbus_sub_wait(&button_evt_sub, &chan, K_FOREVER);
		ERR_CHK(ret);

		struct button_msg msg;

		ret = zbus_chan_read(chan, &msg, ZBUS_READ_TIMEOUT_MS);
		ERR_CHK(ret);

		LOG_DBG("Got btn evt from queue - id = %d, action = %d", msg.button_pin,
			msg.button_action);

		if (msg.button_action != BUTTON_PRESS) {
			LOG_WRN("Unhandled button action");
			return;
		}

		switch (msg.button_pin) {
		case BUTTON_PLAY_PAUSE:
			if (IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL)) {
				LOG_WRN("Play/pause not supported in walkie-talkie and "
					"bidirectional mode");
				break;
			}

			if (strm_state == STATE_STREAMING) {
				ret = bt_content_ctrl_stop(NULL);
				if (ret) {
					LOG_WRN("Could not stop: %d", ret);
				}

			} else if (strm_state == STATE_PAUSED) {
				ret = bt_content_ctrl_start(NULL);
				if (ret) {
					LOG_WRN("Could not start: %d", ret);
				}

			} else {
				LOG_WRN("In invalid state: %d", strm_state);
			}

			break;

		case BUTTON_VOLUME_UP:
			ret = bt_rend_volume_up();
			if (ret) {
				LOG_WRN("Failed to increase volume: %d", ret);
			}

			break;

		case BUTTON_VOLUME_DOWN:
			ret = bt_rend_volume_down();
			if (ret) {
				LOG_WRN("Failed to decrease volume: %d", ret);
			}

			break;

		case BUTTON_4:
			if (IS_ENABLED(CONFIG_AUDIO_TEST_TONE)) {
				if (IS_ENABLED(CONFIG_WALKIE_TALKIE_DEMO)) {
					LOG_DBG("Test tone is disabled in walkie-talkie mode");
					break;
				}

				if (strm_state != STATE_STREAMING) {
					LOG_WRN("Not in streaming state");
					break;
				}

				ret = audio_system_encode_test_tone_step();
				if (ret) {
					LOG_WRN("Failed to play test tone, ret: %d", ret);
				}

				break;
			}

			break;

		case BUTTON_5:
			if (IS_ENABLED(CONFIG_AUDIO_MUTE)) {
				ret = bt_rend_volume_mute(false);
				if (ret) {
					LOG_WRN("Failed to mute, ret: %d", ret);
				}

				break;
			}

			break;

		default:
			LOG_WRN("Unexpected/unhandled button id: %d", msg.button_pin);
		}

		STACK_USAGE_PRINT("button_msg_thread", &button_msg_sub_thread_data);
	}
}

/**
 * @brief	Handle Bluetooth LE audio events.
 */
static void le_audio_msg_sub_thread(void)
{
	int ret;
	uint32_t bitrate_bps;
	uint32_t sampling_rate_hz;
	const struct zbus_channel *chan;

	while (1) {
		struct le_audio_msg msg;

		ret = zbus_sub_wait_msg(&le_audio_evt_sub, &chan, &msg, K_FOREVER);
		ERR_CHK(ret);

		LOG_DBG("Received event = %d, current state = %d", msg.event, strm_state);

		switch (msg.event) {
		case LE_AUDIO_EVT_STREAMING:
			LOG_DBG("LE audio evt streaming");

			if (strm_state == STATE_STREAMING) {
				LOG_DBG("Got streaming event in streaming state");
				break;
			}

			if (msg.dir == BT_AUDIO_DIR_SINK) {
				audio_system_encoder_start();
			}

			audio_system_start();
			stream_state_set(STATE_STREAMING);

			ret = led_blink(LED_APP_1_BLUE);
			ERR_CHK(ret);
			break;

		case LE_AUDIO_EVT_NOT_STREAMING:
			LOG_DBG("LE audio evt not_streaming");

			if (strm_state == STATE_PAUSED) {
				LOG_DBG("Got not_streaming event in paused state");
				break;
			}

			if (msg.dir == BT_AUDIO_DIR_SINK) {
				audio_system_encoder_stop();
			}

			stream_state_set(STATE_PAUSED);
			audio_system_stop();

			ret = led_on(LED_APP_1_BLUE);
			ERR_CHK(ret);
			break;

		case LE_AUDIO_EVT_NO_VALID_CFG:
			LOG_WRN("No valid configurations found or CIS establishment failed, will "
				"disconnect");

			ret = bt_mgmt_conn_disconnect(msg.conn, BT_HCI_ERR_REMOTE_USER_TERM_CONN);
			if (ret) {
				LOG_ERR("Failed to disconnect: %d", ret);
			}

			break;

		case LE_AUDIO_EVT_CONFIG_RECEIVED:
			LOG_DBG("LE audio config received");

			ret = unicast_client_config_get(msg.conn, msg.dir, &bitrate_bps,
							&sampling_rate_hz);
			if (ret) {
				LOG_WRN("Failed to get config: %d", ret);
				break;
			}

			LOG_DBG("\tSampling rate: %d Hz", sampling_rate_hz);
			LOG_DBG("\tBitrate (compressed): %d bps", bitrate_bps);

			if (msg.dir == BT_AUDIO_DIR_SINK) {
				ret = audio_system_config_set(sampling_rate_hz, bitrate_bps,
							      VALUE_NOT_SET);
				ERR_CHK(ret);
			} else if (msg.dir == BT_AUDIO_DIR_SOURCE) {
				ret = audio_system_config_set(VALUE_NOT_SET, VALUE_NOT_SET,
							      sampling_rate_hz);
				ERR_CHK(ret);
			}

			break;

		default:
			LOG_WRN("Unexpected/unhandled le_audio event: %d", msg.event);
			break;
		}

		STACK_USAGE_PRINT("le_audio_msg_thread", &le_audio_msg_sub_thread_data);
	}
}

/**
 * @brief	Zbus listener to receive events from bt_mgmt.
 *
 * @param[in]	chan	Zbus channel.
 *
 * @note	Will in most cases be called from BT_RX context,
 *		so there should not be too much processing done here.
 */
static void bt_mgmt_evt_handler(const struct zbus_channel *chan)
{
	int ret;
	const struct bt_mgmt_msg *msg;

	msg = zbus_chan_const_msg(chan);

	switch (msg->event) {
	case BT_MGMT_CONNECTED:
		LOG_INF("Device connected");
		break;

	case BT_MGMT_SECURITY_CHANGED:
		LOG_INF("Security changed");

		ret = bt_rend_discover(msg->conn);
		if (ret) {
			LOG_WRN("Failed to discover rendering services");
		}

		if (IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL)) {
			ret = unicast_client_discover(msg->conn, UNICAST_SERVER_BIDIR);
		} else {
			ret = unicast_client_discover(msg->conn, UNICAST_SERVER_SINK);
		}

		if (ret) {
			LOG_ERR("Failed to handle unicast client discover: %d", ret);
		}

		break;

	case BT_MGMT_DISCONNECTED:
		LOG_INF("Device disconnected");

		unicast_client_conn_disconnected(msg->conn);
		break;

	default:
		LOG_WRN("Unexpected/unhandled bt_mgmt event: %d", msg->event);
		break;
	}
}

ZBUS_LISTENER_DEFINE(bt_mgmt_evt_listen, bt_mgmt_evt_handler);

/**
 * @brief	Create zbus subscriber threads.
 *
 * @return	0 for success, error otherwise.
 */
static int zbus_subscribers_create(void)
{
	int ret;

	button_msg_sub_thread_id = k_thread_create(
		&button_msg_sub_thread_data, button_msg_sub_thread_stack,
		CONFIG_BUTTON_MSG_SUB_STACK_SIZE, (k_thread_entry_t)button_msg_sub_thread, NULL,
		NULL, NULL, K_PRIO_PREEMPT(CONFIG_BUTTON_MSG_SUB_THREAD_PRIO), 0, K_NO_WAIT);
	ret = k_thread_name_set(button_msg_sub_thread_id, "BUTTON_MSG_SUB");
	if (ret) {
		LOG_ERR("Failed to create button_msg thread");
		return ret;
	}

	le_audio_msg_sub_thread_id = k_thread_create(
		&le_audio_msg_sub_thread_data, le_audio_msg_sub_thread_stack,
		CONFIG_LE_AUDIO_MSG_SUB_STACK_SIZE, (k_thread_entry_t)le_audio_msg_sub_thread, NULL,
		NULL, NULL, K_PRIO_PREEMPT(CONFIG_LE_AUDIO_MSG_SUB_THREAD_PRIO), 0, K_NO_WAIT);
	ret = k_thread_name_set(le_audio_msg_sub_thread_id, "LE_AUDIO_MSG_SUB");
	if (ret) {
		LOG_ERR("Failed to create le_audio_msg thread");
		return ret;
	}

	content_control_thread_id = k_thread_create(
		&content_control_msg_sub_thread_data, content_control_msg_sub_thread_stack,
		CONFIG_CONTENT_CONTROL_MSG_SUB_STACK_SIZE,
		(k_thread_entry_t)content_control_msg_sub_thread, NULL, NULL, NULL,
		K_PRIO_PREEMPT(CONFIG_CONTENT_CONTROL_MSG_SUB_THREAD_PRIO), 0, K_NO_WAIT);
	ret = k_thread_name_set(content_control_thread_id, "CONTENT_CONTROL_MSG_SUB");
	if (ret) {
		return ret;
	}

	ret = zbus_chan_add_obs(&sdu_ref_chan, &sdu_ref_msg_listen, ZBUS_ADD_OBS_TIMEOUT_MS);
	if (ret) {
		LOG_ERR("Failed to add timestamp listener");
		return ret;
	}

	return 0;
}

/**
 * @brief	Link zbus producers and observers.
 *
 * @return	0 for success, error otherwise.
 */
static int zbus_link_producers_observers(void)
{
	int ret;

	if (!IS_ENABLED(CONFIG_ZBUS)) {
		return -ENOTSUP;
	}

	ret = zbus_chan_add_obs(&button_chan, &button_evt_sub, ZBUS_ADD_OBS_TIMEOUT_MS);
	if (ret) {
		LOG_ERR("Failed to add button sub");
		return ret;
	}

	ret = zbus_chan_add_obs(&le_audio_chan, &le_audio_evt_sub, ZBUS_ADD_OBS_TIMEOUT_MS);
	if (ret) {
		LOG_ERR("Failed to add le_audio sub");
		return ret;
	}

	ret = zbus_chan_add_obs(&bt_mgmt_chan, &bt_mgmt_evt_listen, ZBUS_ADD_OBS_TIMEOUT_MS);
	if (ret) {
		LOG_ERR("Failed to add bt_mgmt listener");
		return ret;
	}

	ret = zbus_chan_add_obs(&cont_media_chan, &content_control_evt_sub,
				ZBUS_ADD_OBS_TIMEOUT_MS);

	return 0;
}

uint8_t stream_state_get(void)
{
	return strm_state;
}

void streamctrl_send(void const *const data, size_t size, uint8_t num_ch)
{
	int ret;
	static int prev_ret;

	struct le_audio_encoded_audio enc_audio = {.data = data, .size = size, .num_ch = num_ch};

	if (strm_state == STATE_STREAMING) {
		ret = unicast_client_send(enc_audio);

		if (ret != 0 && ret != prev_ret) {
			if (ret == -ECANCELED) {
				LOG_WRN("Sending operation cancelled");
			} else {
				LOG_WRN("Problem with sending LE audio data, ret: %d", ret);
			}
		}

		prev_ret = ret;
	}
}

int main(void)
{
	int ret;

	LOG_DBG("nRF5340 APP core started");

	ret = nrf5340_audio_dk_init();
	ERR_CHK(ret);

	ret = nrf5340_audio_common_init();
	ERR_CHK(ret);

	ret = zbus_subscribers_create();
	ERR_CHK_MSG(ret, "Failed to create zbus subscriber threads");

	ret = zbus_link_producers_observers();
	ERR_CHK_MSG(ret, "Failed to link zbus producers and observers");

	ret = le_audio_rx_init();
	ERR_CHK(ret);

	ret = bt_rend_init();
	ERR_CHK(ret);

	ret = bt_content_ctrl_init();
	ERR_CHK(ret);

	ret = unicast_client_enable(le_audio_rx_data_handler);
	ERR_CHK(ret);

	ret = bt_mgmt_scan_start(0, 0, BT_MGMT_SCAN_TYPE_CONN, CONFIG_BT_DEVICE_NAME,
				 BRDCAST_ID_NOT_USED);
	if (ret) {
		LOG_ERR("Failed to start scanning");
		return ret;
	}

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/unicast_client/README.rst
.. _nrf53_audio_unicast_client_app:

nRF5340 Audio: Unicast client
#############################

.. contents::
   :local:
   :depth: 2

The nRF5340 Audio unicast client application implements the :ref:`CIS gateway mode <nrf53_audio_app_overview>`.

In this mode, one Connected Isochronous Group (CIG) can be used with two Connected Isochronous Streams (CIS).
Transmitting unidirectional or transceiving bidirectional audio happens using CIG and CIS.

The following limitations apply to this application:

* One CIG with two CIS.
* Audio input: USB or I2S (Line in or using Pulse Density Modulation).
* Audio output: USB or I2S/Analog headset output.
* Configuration: 16 bit, several bit rates ranging from 32 kbps to 124 kbps.

.. _nrf53_audio_unicast_client_app_requirements:

Requirements
************

The application shares the :ref:`requirements common to all nRF5340 Audio application <nrf53_audio_app_requirements>`.

.. _nrf53_audio_unicast_client_app_ui:

User interface
**************

Most of the user interface mappings are common across all nRF5340 Audio applications.
See the :ref:`nrf53_audio_app_ui` page for detailed overview.

This application uses specific mapping for the following user interface elements:

* Long-pressed on the unicast client device during startup:

  * **BTN5** - Clears the previously stored bonding information.

* Pressed on the unicast client device during playback:

  * **PLAY/PAUSE** - Starts or pauses the playback of the stream.
  * **VOL-** - Turns the playback volume down (and unmutes).
  * **VOL+** - Turns the playback volume up (and unmutes).
  * **BTN 4** - Sends a test tone generated on the device. Use this tone to check the synchronization of headsets.
  * **BTN5** - Mutes the playback volume (and unmutes).

* **LED1** - Blinking blue - Kit is streaming audio to a headset.
* **RGB** - Solid green - The device is programmed as the gateway.

.. _nrf53_audio_unicast_client_app_configuration:

Configuration
*************

By default, if you have not made any changes to :file:`.conf` files at :file:`applications/nrf5340_audio/`, the nRF5340 build script tries to build the CIS applications in the CIS unidirectional mode.
To switch to the bidirectional mode, see :ref:`nrf53_audio_app_configuration_select_bidirectional`.

For other configuration options, see :ref:`nrf53_audio_app_configuration` and :ref:`nrf53_audio_app_fota`.

For information about how to configure applications in the |NCS|, see :ref:`configure_application`.

.. _nrf53_audio_unicast_client_app_building:

Building and running
********************

This application can be found under :file:`applications/nrf5340_audio/unicast_client` in the nRF Connect SDK folder structure, but it uses :file:`.conf` files at :file:`applications/nrf5340_audio/`.

The nRF5340 Audio DK comes preprogrammed with basic firmware that indicates if the kit is functional.
See :ref:`nrf53_audio_app_dk_testing_out_of_the_box` for more information.

To build the application, see :ref:`nrf53_audio_app_building`.

.. _nrf53_audio_unicast_client_app_testing:

Testing
*******

After building and programming the application, you can test the default CIS gateway mode using one unicast client device and at least one CIS headset device.
The recommended approach is to use another nRF5340 Audio DK programmed with the :ref:`unicast server application <nrf53_audio_unicast_server_app>`, but you can also use an external CIS headset device.

.. note::
    |nrf5340_audio_external_devices_note|

The following testing scenario assumes you are using USB as the audio source on the gateway.
This is the default setting.

Complete the following steps to test the unidirectional CIS mode for one gateway and at least one headset device:

1. Make sure that the development kits are still plugged into the USB ports and are turned on.

   .. note::
      |usb_known_issues|

   **LED3** starts blinking green on every device to indicate the ongoing CPU activity on the application core.
#. Wait for the **LED1** on the gateway to start blinking blue.
   This happens shortly after programming the development kit and indicates that the gateway device is connected to at least one headset and ready to send data.
#. Search the list of audio devices listed in the sound settings of your operating system for *nRF5340 USB Audio* (gateway) and select it as the output device.
#. Connect headphones to the **HEADPHONE** audio jack on the headset device.
#. Start audio playback on your PC from any source.
#. Wait for **LED1** to blink blue on the headset.
   When they do, the audio stream has started on the headset.

   .. note::
      The audio outputs only to the left channel of the audio jack, even if the given headset is configured as the right headset.
      This is because of the mono hardware codec chip used on the development kits.
      If you want to play stereo sound using one development kit, you must connect an external hardware codec chip that supports stereo.

#. Wait for **LED2** to light up solid green on the headsets to indicate that the audio synchronization is achieved.
#. Press the **VOL-** button on the gateway.
   The playback volume decreases for the headset.
#. Press the **PLAY/PAUSE** button on any one of the devices.
   The playback stops for the headset and the streaming state for all devices is set to paused.
#. Press the **BTN 4** button on the gateway multiple times.
   For each button press, the audio stream playback is stopped and the gateway sends a test tone to the headset.
   These tones can be used as audio cues to check the synchronization between two headsets.

For other testing options, refer to :ref:`nrf53_audio_unicast_client_app_ui`.

After the kits have paired for the first time, they are now bonded.
This means the Long-Term Key (LTK) is stored on each side, and that the kits will only connect to each other unless the bonding information is cleared.
To clear the bonding information, press and hold **BTN 5** during boot or reprogram all the development kits.

When you finish testing, power off the nRF5340 Audio development kits by switching the power switch from On to Off.

.. _nrf53_audio_unicast_client_app_testing_steps_cis_walkie_talkie:

Testing the walkie-talkie demo
==============================

Testing the walkie-talkie demo is identical to the default testing procedure, except for the following differences:

* You must enable the Kconfig option mentioned in :ref:`nrf53_audio_app_configuration_enable_walkie_talkie` before building the application.
* Instead of controlling the playback, you can speak through the PDM microphones.
  The line is open all the time, no need to press any buttons to talk, but the volume control works as in the default testing procedure.

Dependencies
************

For the list of dependencies, check the application's source files.


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/tools/uart_terminal/uart_terminal.py
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

import sys
import subprocess

sys.path.append("./scripts")

from open_putty import open_putty

if sys.platform == "linux":
    terminator = subprocess.Popen(["terminator", "--config=scripts/linux_terminator_config"], stderr=subprocess.PIPE)
elif sys.platform == "win32":
    open_putty()
else:
    print("OS not supported")


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/tools/uart_terminal/scripts/open_terminator.py
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

import sys
import subprocess
from get_serial_ports import get_serial_ports

ports = get_serial_ports()

if int(sys.argv[1]) < len(ports):
    subprocess.Popen(["minicom", "--color=on", "-b 115200", "-8", "-D " + ports[int(sys.argv[1])]])
else:
    print("Not enough boards connected")


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/tools/uart_terminal/scripts/get_serial_ports.py
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

import sys
import subprocess

def get_serial_ports():
    nrfjprog_com.wait()

    if nrfjprog_com.returncode != 0:
        sys.exit("'nrfjprog --com' failed")

    output = nrfjprog_com.communicate()
    output_decoded = output[0].decode()
    output_decoded_lines = output_decoded.splitlines()

    ports = list()

    for line in output_decoded_lines:
        if "VCOM0" in line:
            info = line.split("    ")
            ports.append(info[1])

    return ports


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/tools/uart_terminal/scripts/linux_terminator_config
[global_config]
  suppress_multiple_term_dialog = True
[keybindings]
[profiles]
  [[default]]
    cursor_color = "#aaaaaa"
    scrollback_infinite = True
[layouts]
  [[default]]
    [[[child0]]]
      type = Window
      parent = ""
      order = 0
      position = 72:35
      maximised = False
      fullscreen = False
      size = 2000, 1000
      title = nRF5340 Audio DK
      last_active_window = True
    [[[child1]]]
      type = VPaned
      parent = child0
      order = 0
      position = 540
      ratio = 0.5
    [[[child2]]]
      type = HPaned
      parent = child1
      order = 0
      position = 600
      ratio = 0.5
    [[[terminal3]]]
      type = Terminal
      parent = child2
      order = 0
      profile = default
      command = python3 scripts/open_terminator.py 0; sh
    [[[terminal4]]]
      type = Terminal
      parent = child2
      order = 1
      profile = default
      command = python3 scripts/open_terminator.py 1; sh
    [[[child5]]]
      type = HPaned
      parent = child1
      order = 1
      position = 600
      ratio = 0.5
    [[[terminal6]]]
      type = Terminal
      parent = child5
      order = 0
      profile = default
      command = python3 scripts/open_terminator.py 2; sh
    [[[terminal7]]]
      type = Terminal
      parent = child5
      order = 1
      profile = default
      command = echo Available ttyACM devices: && cd /dev/ && ls -l | grep "ttyACM"; bash
[plugins]


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/tools/uart_terminal/scripts/open_putty.py
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

import subprocess
from get_serial_ports import get_serial_ports


def open_putty():
    ports = get_serial_ports()

    for port in ports:
        subprocess.Popen("putty -serial " + port + " -sercfg 115200,8,n,1,N")


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/tools/buildprog/buildprog.py
#
# Copyright (c) 2018 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

"""
Script to build and program the nRF5340 Audio project to multiple devices
"""

import argparse
import sys
import shutil
import os
import json
import subprocess
import re
import glob
import getpass
from colorama import Fore, Style
from prettytable import PrettyTable
from nrf5340_audio_dk_devices import (
    BuildType,
    Channel,
    DeviceConf,
    BuildConf,
    AudioDevice,
    SelectFlags,
    Core,
    Controller,
)
from program import program_threads_run
from pathlib import Path


BUILDPROG_FOLDER = Path(__file__).resolve().parent
NRF5340_AUDIO_FOLDER = (BUILDPROG_FOLDER / "../..").resolve()
NRF_FOLDER = (BUILDPROG_FOLDER / "../../../..").resolve()
if os.getenv("AUDIO_KIT_SERIAL_NUMBERS_JSON") is None:
    AUDIO_KIT_SERIAL_NUMBERS_JSON = BUILDPROG_FOLDER / "nrf5340_audio_dk_devices.json"
else:
    AUDIO_KIT_SERIAL_NUMBERS_JSON = Path(
        os.getenv("AUDIO_KIT_SERIAL_NUMBERS_JSON"))
TARGET_BOARD_NRF5340_AUDIO_DK_APP_NAME = "nrf5340_audio_dk_nrf5340_cpuapp"

TARGET_CORE_APP_FOLDER = NRF5340_AUDIO_FOLDER
TARGET_DEV_HEADSET_FOLDER = NRF5340_AUDIO_FOLDER / "build/dev_headset"
TARGET_DEV_GATEWAY_FOLDER = NRF5340_AUDIO_FOLDER / "build/dev_gateway"

TARGET_RELEASE_FOLDER = "build_release"
TARGET_DEBUG_FOLDER = "build_debug"

MAX_USER_NAME_LEN = 248 - len('\0')


def __print_add_color(status):
    if status == SelectFlags.FAIL:
        return Fore.RED + status.value + Style.RESET_ALL
    elif status == SelectFlags.DONE:
        return Fore.GREEN + status.value + Style.RESET_ALL
    return status.value


def __print_dev_conf(device_list):
    """Print settings in a formatted manner"""
    table = PrettyTable()
    table.field_names = [
        "snr",
        "snr conn",
        "device",
        "only reboot",
        "core app programmed",
        "core net programmed",
    ]
    for device in device_list:
        row = []
        row.append(device.nrf5340_audio_dk_snr)
        color = Fore.GREEN if device.snr_connected else Fore.YELLOW
        row.append(color + str(device.snr_connected) + Style.RESET_ALL)
        row.append(device.nrf5340_audio_dk_dev.value)
        row.append(__print_add_color(device.only_reboot))
        row.append(__print_add_color(device.core_app_programmed))
        row.append(__print_add_color(device.core_net_programmed))

        table.add_row(row)
    print(table)


def __build_cmd_get(core: Core, device: AudioDevice, build: BuildType, pristine, controller: Controller, child_image, options):
    if core == Core.app:
        build_cmd = f"west build {TARGET_CORE_APP_FOLDER} -b {TARGET_BOARD_NRF5340_AUDIO_DK_APP_NAME}"
        if device == AudioDevice.headset:
            device_flag = "-DCONFIG_AUDIO_DEV=1"
            dest_folder = TARGET_DEV_HEADSET_FOLDER
        elif device == AudioDevice.gateway:
            device_flag = "-DCONFIG_AUDIO_DEV=2"
            dest_folder = TARGET_DEV_GATEWAY_FOLDER
        else:
            raise Exception("Invalid device!")

        if build == BuildType.debug:
            release_flag = ""
            dest_folder /= TARGET_DEBUG_FOLDER
        elif build == BuildType.release:
            release_flag = " -DCONF_FILE=prj_release.conf"
            dest_folder /= TARGET_RELEASE_FOLDER
        else:
            raise Exception("Invalid build type!")

        if options.mcuboot == 'internal':
            device_flag += " -DCONFIG_AUDIO_DFU=1"
        elif options.mcuboot == 'external':
            device_flag += " -DCONFIG_AUDIO_DFU=2"
        if options.min_b0n:
            device_flag += " -DCONFIG_B0N_MINIMAL=y"

        if options.controller == Controller.acs_nrf53:
            device_flag += " -DCONFIG_BT_LL_ACS_NRF53=y"
            device_flag += " -DCONFIG_NCS_INCLUDE_RPMSG_CHILD_IMAGE=n"

        if options.controller == Controller.sdc:
            if not child_image:
                device_flag += " -DCONFIG_NCS_INCLUDE_RPMSG_CHILD_IMAGE=n"

        if options.nrf21540:
            device_flag += " -DSHIELD=nrf21540ek_fwd"
            if options.controller == Controller.sdc:
                device_flag += " -Dhci_ipc_SHIELD=nrf21540ek"

        if options.custom_bt_name is not None and options.user_bt_name:
            raise Exception(
                "User BT name option is invalid when custom BT name is set")

        if options.custom_bt_name is not None:
            custom_bt_name = "_".join(options.custom_bt_name)[
                :MAX_USER_NAME_LEN].upper()
            device_flag += " -DCONFIG_BT_DEVICE_NAME=\\\"" + custom_bt_name + "\\\""

        if options.user_bt_name:
            user_specific_bt_name = (
                "AUDIO_DEV_" + getpass.getuser())[:MAX_USER_NAME_LEN].upper()
            device_flag += " -DCONFIG_BT_DEVICE_NAME=\\\"" + user_specific_bt_name + "\\\""

        if os.name == 'nt':
            release_flag = release_flag.replace('\\', '/')

        if pristine:
            build_cmd += " -p"

    elif core == Core.net:
        if build == BuildType.debug:
            dest_folder /= TARGET_DEBUG_FOLDER
        elif build == BuildType.release:
            dest_folder /= TARGET_RELEASE_FOLDER
        else:
            raise Exception("Invalid build type!")

        build_cmd = ""
        device_flag = ""
        release_flag = ""

    return build_cmd, dest_folder, device_flag, release_flag


def __build_module(build_config, options):
    build_cmd, dest_folder, device_flag, release_flag = __build_cmd_get(
        build_config.core,
        build_config.device,
        build_config.build,
        build_config.pristine,
        build_config.controller,
        build_config.child_image,
        options,
    )
    west_str = f"{build_cmd} -d {dest_folder} "

    if build_config.pristine and dest_folder.exists():
        shutil.rmtree(dest_folder)

    # Only add compiler flags if folder doesn't exist already
    if not dest_folder.exists():
        west_str = west_str + device_flag + release_flag

    print("Run: " + west_str)

    ret_val = os.system(west_str)

    if ret_val:
        raise Exception("cmake error: " + str(ret_val))


def __find_snr():
    """Rebooting or programming requires connected programmer/debugger"""

    # Use nrfjprog executable for WSL compatibility
        "nrfjprog --ids", shell=True).decode("utf-8")

    if not snrs:
        print("No programmer/debugger connected to PC")

    return list(map(int, snrs))


def __populate_hex_paths(dev, options, child_image):
    """Poplulate hex paths where relevant"""

    _, temp_dest_folder, _, _ = __build_cmd_get(
        Core.app, dev.nrf5340_audio_dk_dev, options.build, options.pristine, options.controller, child_image, options
    )

    dest_folder = temp_dest_folder

    if options.controller == Controller.sdc:
        dev.hex_path_app = dest_folder / "zephyr/zephyr.hex"
        dev.hex_path_net = dest_folder / "hci_ipc/zephyr/zephyr.hex"
        return

    if dev.core_app_programmed == SelectFlags.TBD:
        if options.mcuboot != '':
            dev.hex_path_app = dest_folder / "zephyr/merged.hex"
        else:
            dev.hex_path_app = dest_folder / "zephyr/zephyr.hex"

    if dev.core_net_programmed == SelectFlags.TBD:
        hex_files_found = 0
        for hex_path in glob.glob(str(NRF_FOLDER) + "/lib/bin/bt_ll_acs_nrf53/bin/" + "ble5-ctr-rpmsg_" + "[0-9]" + "*" + ".hex"):
            dev.hex_path_net = hex_path
            hex_files_found += 1

        if options.mcuboot != '':
            dev.hex_path_net = dest_folder / "zephyr/net_core_app_signed.hex"
        else:
            dest_folder = NRF_FOLDER / "lib/bin/bt_ll_acs_nrf53/bin"

            if hex_files_found != 1:
                raise Exception(
                    f"Found zero or multiple NET hex files in folder: {dest_folder}")
            else:
                print(f"Using NET hex: {dev.hex_path_net} for {dev}")


def __finish(device_list):
    """Finish script. Print report"""
    print("build_prog.py finished. Report:")
    __print_dev_conf(device_list)
    exit(0)


def __main():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=(
            "This script builds and programs the nRF5340 "
            "Audio project on Windows and Linux"
        ),
        epilog=("If there exists an environmental variable called \"AUDIO_KIT_SERIAL_NUMBERS_JSON\" which contains"
                "the location of a json file, the program will use this file as a substitute for nrf5340_audio_dk_devices.json"),
        allow_abbrev=False
    )
    parser.add_argument(
        "-r",
        "--only_reboot",
        default=False,
        action="store_true",
        help="Only reboot, no building or programming",
    )
    parser.add_argument(
        "-p",
        "--program",
        default=False,
        action="store_true",
        help="Will program and reboot nRF5340 Audio DK",
    )
    parser.add_argument(
        "-c",
        "--core",
        type=str,
        choices=[i.name for i in Core],
        help="Select which cores to include in build",
    )
    parser.add_argument(
        "--pristine", default=False, action="store_true", help="Will build cleanly"
    )
    parser.add_argument(
        "-b",
        "--build",
        required="-p" in sys.argv or "--program" in sys.argv,
        choices=[i.name for i in BuildType],
        help="Select the build type",
    )
    parser.add_argument(
        "-d",
        "--device",
        required=("-r" in sys.argv or "--only_reboot" in sys.argv)
        or (
            ("-b" in sys.argv or "--build" in sys.argv)
            and ("both" in sys.argv or "app" in sys.argv)
        ),
        choices=[i.name for i in AudioDevice],
        help=(
            "nRF5340 Audio on the application core can be "
            "built for either ordinary headset "
            "(earbuds/headphone..) use or gateway (USB dongle)"
        ),
    )
    parser.add_argument(
        "-s",
        "--sequential",
        action="store_true",
        dest="sequential_prog",
        default=False,
        help="Run nrfjprog sequentially instead of in \
                        parallel",
    )
    parser.add_argument(
        "-f",
        "--recover_on_fail",
        action="store_true",
        dest="recover_on_fail",
        default=False,
        help="Recover device if programming fails",
    )
    parser.add_argument(
        # Deprecated argument
        "--ctlr",
        type=str,
        choices=[i.value for i in Controller],
        dest="controller",
        default=Controller.sdc.value,
        help=Controller.acs_nrf53.value + \
        " is deprecated. Use the SoftDevice Controller instead (enabled by default).",
    )
    # DFU relative option
    parser.add_argument(
        "-M",
        "--min_b0n",
        dest="min_b0n",
        action='store_true',
        default=False,
        help="net core bootloader use minimal size build. Only for controller: " +
        Controller.acs_nrf53,
    )
    parser.add_argument(
        "-m",
        "--mcuboot",
        required=("-M" in sys.argv or "--min_b0n" in sys.argv),
        choices=["external", "internal"],
        default='',
        help="MCUBOOT with external, internal flash. Only for controller: " + Controller.acs_nrf53,
    )
    parser.add_argument(
        "--nrf21540",
        action="store_true",
        dest="nrf21540",
        default=False,
        help="Set when using nRF21540 for extra TX power",
    )
    parser.add_argument(
        "-cn",
        "--custom_bt_name",
        nargs='*',
        dest="custom_bt_name",
        default=None,
        help="Use custom Bluetooth device name",
    )
    parser.add_argument(
        "-u",
        "--user_bt_name",
        action="store_true",
        dest="user_bt_name",
        default=False,
        help="Set to generate a user specific Bluetooth device name. Note that this will put the computer user name on air in clear text",
    )

    options = parser.parse_args(args=sys.argv[1:])

    if options.controller == Controller.acs_nrf53:
        print(Fore.YELLOW +
              "Deprecated app - controller combination" + Style.RESET_ALL)
    if options.controller == Controller.sdc:
        if options.mcuboot != '' or options.min_b0n:
            raise Exception("DFU arguments only accepted when using controller: " +
                            Controller.acs_nrf53 + ". Please use standard tools.")

    # Post processing for Enums
    if options.core is None:
        cores = []
    elif options.core == "both":
        cores = [Core.app, Core.net]
    else:
        cores = [Core[options.core]]

    if options.device is None:
        devices = []
    elif options.device == "both":
        devices = [AudioDevice.gateway, AudioDevice.headset]
    else:
        devices = [AudioDevice[options.device]]

    options.build = BuildType[options.build] if options.build else None

    options.only_reboot = SelectFlags.TBD if options.only_reboot else SelectFlags.NOT

    boards_snr_connected = __find_snr()
    if not boards_snr_connected:
        print("No snrs connected")

    # Update device list
    # This JSON file should be altered by the developer.
    # Then run git update-index --skip-worktree FILENAME to avoid changes
    # being pushed
    with AUDIO_KIT_SERIAL_NUMBERS_JSON.open() as f:
        dev_arr = json.load(f)
    device_list = [
        DeviceConf(
            nrf5340_audio_dk_snr=dev["nrf5340_audio_dk_snr"],
            channel=Channel[dev["channel"]],
            snr_connected=(dev["nrf5340_audio_dk_snr"]
                           in boards_snr_connected),
            recover_on_fail=options.recover_on_fail,
            nrf5340_audio_dk_dev=AudioDevice[dev["nrf5340_audio_dk_dev"]],
            cores=cores,
            devices=devices,
            _only_reboot=options.only_reboot,
            controller=options.controller,
        )
        for dev in dev_arr
    ]

    __print_dev_conf(device_list)

    # Initialization step finsihed
    # Reboot step start

    if options.only_reboot == SelectFlags.TBD:
        program_threads_run(device_list, options.mcuboot,
                            sequential=options.sequential_prog)
        __finish(device_list)

    # Reboot step finished
    # Build step start
    child_image = True

    if options.build is not None:
        print("Invoking build step")
        build_configs = []
        if Core.app in cores:
            if not Core.net in cores:
                child_image = False

            if AudioDevice.headset in devices:
                build_configs.append(
                    BuildConf(
                        core=Core.app,
                        device=AudioDevice.headset,
                        pristine=options.pristine,
                        build=options.build,
                        controller=options.controller,
                        child_image=child_image,
                    )
                )
            if AudioDevice.gateway in devices:
                build_configs.append(
                    BuildConf(
                        core=Core.app,
                        device=AudioDevice.gateway,
                        pristine=options.pristine,
                        build=options.build,
                        controller=options.controller,
                        child_image=child_image,
                    )
                )

        if Core.net in cores:
            print("Net core uses precompiled hex or child image")

        for build_cfg in build_configs:
            __build_module(build_cfg, options)

    # Build step finished
    # Program step start

    if options.program:
        for dev in device_list:
            if dev.snr_connected:
                __populate_hex_paths(dev, options, child_image)
        program_threads_run(device_list, options.mcuboot,
                            sequential=options.sequential_prog)

    # Program step finished

    __finish(device_list)


if __name__ == "__main__":
    __main()


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/tools/buildprog/nrf5340_audio_dk_devices.json
[
 {
        "nrf5340_audio_dk_snr": 1000,
        "nrf5340_audio_dk_dev": "headset",
        "channel": "left"
 },
 {
        "nrf5340_audio_dk_snr": 1000,
        "nrf5340_audio_dk_dev": "gateway",
        "channel": "NA"
 },
 {
        "nrf5340_audio_dk_snr": 1000,
        "nrf5340_audio_dk_dev": "headset",
        "channel": "right"
 }
]

// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/tools/buildprog/ble5-ctr-rpmsg_sign.py
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause

"""
Sign ble5-ctr-rpmsg BT Controller with B0N
"""

import argparse
import sys
import shutil
import os
from pathlib import Path
import re

BLE5_CTR_HEX = 'new_fw_info_ble5-ctr.hex'
FINAL_BLE5_CTR_HEX = 'ble5-ctr_CPUNET.hex'
FINAL_BLE5_CTR_UPDATE_BIN = 'ble5-ctr_net_core_update.bin'
ORIG_BLE5_CTR_PATTERN = r'ble5-ctr-rpmsg_shifted_\d+\.hex'
ORIG_BLE5_CTR_MIN_PATTERN = r'ble5-ctr-rpmsg_shifted_min_\d+\.hex'
NET_CORE_APP_NAME = 'empty_net_core'

ZEPHYR_BASE = os.environ['ZEPHYR_BASE']
MANUALLY_SIGN_DIR = Path(__file__).resolve().parent
BIN_DIR = (MANUALLY_SIGN_DIR / '../../bin').resolve()


def awklike(field_str, filename):
    """ A function like unix awk to split string"""
    ret = ''
    try:
        with open(filename, encoding='utf8') as file_pointer:
            for line in file_pointer:
                if field_str in line:
                    ret = line.replace(field_str, '').replace(
                        '\n', '').replace('"', '')
                    break
    except (OSError, IOError) as exp:
        print(exp)
    return ret


def sign(orig_hex, build_dir):
    """ A function to combine and sign ble5-ctr-"""

    if os.name == 'nt':
        folder_slash = '\\'
    else:
        folder_slash = '/'

    # RETEIVE setting value from .config
    # "${ZEPHYR_BASE}/../bootloader/mcuboot/root-rsa-2048.pem"

    mcuboot_rsa_key = awklike('CONFIG_BOOT_SIGNATURE_KEY_FILE=', build_dir +
                              '/mcuboot/zephyr/.config')

    # '\\' is used for Windows, '/' is used for other Operating Systems like Linux.
    if ('/' in mcuboot_rsa_key) or ('\\' in mcuboot_rsa_key):
        print('absolute path')
        # Zephyr script convert folder separator to '/'. Should do the same here no matter Windows or not.
        if folder_slash in mcuboot_rsa_key:
            mcuboot_rsa_key.replace(folder_slash, '/')
    else:
        print('relative path')
        mcuboot_rsa_key = ZEPHYR_BASE + '/../bootloader/mcuboot/' + mcuboot_rsa_key

    # IMAGE_VERSION="0.0.0+1"
    image_version = awklike('CONFIG_MCUBOOT_IMGTOOL_SIGN_VERSION=',
                            build_dir + '/zephyr/.config')
    # VALIDATION_MAGIC_VALUE="0x281ee6de,0x86518483,79106"
    fw_info_magic_common = awklike('CONFIG_FW_INFO_MAGIC_COMMON=', build_dir +
                                   f'/{NET_CORE_APP_NAME}/zephyr/.config')
    fw_info_magic_firmware_info = awklike('CONFIG_FW_INFO_MAGIC_FIRMWARE_INFO=', build_dir +
                                          f'/{NET_CORE_APP_NAME}/zephyr/.config')
    sb_validation_info_magic = awklike('CONFIG_SB_VALIDATION_INFO_MAGIC=', build_dir +
                                       f'/{NET_CORE_APP_NAME}/zephyr/.config')
    fw_info_firmware_version = awklike('CONFIG_FW_INFO_FIRMWARE_VERSION=', build_dir +
                                       f'/{NET_CORE_APP_NAME}/zephyr/.config')
    fw_info_valid_val = awklike('CONFIG_FW_INFO_VALID_VAL=', build_dir +
                                f'/{NET_CORE_APP_NAME}/zephyr/.config')
    temp_ver = int(awklike('CONFIG_SB_VALIDATION_INFO_VERSION=', build_dir +
                           f'/{NET_CORE_APP_NAME}/zephyr/.config'))
    temp_hwid = int(awklike('CONFIG_FW_INFO_HARDWARE_ID=', build_dir +
                            f'/{NET_CORE_APP_NAME}/zephyr/.config'))
    temp_valid_crypto_id = int(awklike('CONFIG_SB_VALIDATION_INFO_CRYPTO_ID=', build_dir +
                                       f'/{NET_CORE_APP_NAME}/zephyr/.config'))
    temp_crypto_id = int(awklike('CONFIG_FW_INFO_CRYPTO_ID=', build_dir +
                                 f'/{NET_CORE_APP_NAME}/zephyr/.config'))
    temp_compat_id = int(awklike('CONFIG_FW_INFO_MAGIC_COMPATIBILITY_ID=', build_dir +
                                 f'/{NET_CORE_APP_NAME}/zephyr/.config'))
    magic_compatibility_validation_info = temp_ver + (temp_hwid << 8) + (temp_valid_crypto_id << 16)\
        + (temp_compat_id << 24)
    magic_compatibility_info = temp_ver + (temp_hwid << 8) + (temp_crypto_id << 16)\
        + (temp_compat_id << 24)

    validation_magic_value = f'{fw_info_magic_common},{sb_validation_info_magic},\
{magic_compatibility_validation_info}'

    firmware_info_magic = f'{fw_info_magic_common},{fw_info_magic_firmware_info},\
{magic_compatibility_info}'

    # 0x01008800
    pm_net_app_address = int(awklike('PM_APP_ADDRESS=', build_dir +
                                     f'/{NET_CORE_APP_NAME}/pm_CPUNET.config'), 16)
    # 0xc200/0x10200
    #PM_APP_APP_ADDRESS = int(awklike('PM_APP_ADDRESS=', build_dir + '/pm.config'), 16)
    pm_app_app_address = awklike('PM_APP_ADDRESS=', build_dir + '/pm.config')
    # CONFIG_FW_INFO_OFFSET 0x200
    fw_info_offset = int(awklike('CONFIG_FW_INFO_OFFSET=', build_dir +
                                 f'/{NET_CORE_APP_NAME}/b0n/zephyr/.config'), 16)
    # nRF5340_CPUAPP_QKAA
    soc_name = awklike('CONFIG_SOC=', build_dir + '/zephyr/.config')
    # nRF5340_CPUNET_QKAA
    net_soc_name = awklike('CONFIG_SOC=', build_dir +
                           f'/{NET_CORE_APP_NAME}/zephyr/.config')
    # CONFIG_DOMAIN_CPUNET_BOARD net_core_app_update.binboard
    net_core_app_binboard = awklike(
        'CONFIG_DOMAIN_CPUNET_BOARD=', build_dir + '/zephyr/.config')
    # CONFIG_BOARD="nrf5340_audio_nrf5340_cpuapp"
    config_board = awklike('CONFIG_BOARD=', build_dir + '/zephyr/.config')

    net_core_fw_info_address = pm_net_app_address + fw_info_offset
    net_core_fw_info_address = f'0x{net_core_fw_info_address:08X}'

    # Inject FW_INFO from .config
    os_cmd = f'{sys.executable} {MANUALLY_SIGN_DIR}/fw_info_data.py  --input {orig_hex} --output-hex {build_dir}/{BLE5_CTR_HEX}\
    --offset {net_core_fw_info_address} --magic-value {firmware_info_magic}\
    --fw-version {fw_info_firmware_version} --fw-valid-val {fw_info_valid_val}'

    ret_val = os.system(os_cmd)
    if ret_val:
        raise Exception('python error: ' + str(ret_val))

    # 240
    num_ver_counter_slots = int(awklike('CONFIG_SB_NUM_VER_COUNTER_SLOTS=', build_dir +
                                        f'/{NET_CORE_APP_NAME}/zephyr/.config'), 10)
    pm_partition_size_provision = int(awklike('CONFIG_PM_PARTITION_SIZE_PROVISION=', build_dir +
                                              f'/{NET_CORE_APP_NAME}/zephyr/.config'), 16)
    cpunet_pm_app_address = hex(int(awklike('PM_APP_ADDRESS=', build_dir +
                                            f'/{NET_CORE_APP_NAME}/pm_CPUNET.config'), 16))
    pm_provision_address = int(awklike('PM_PROVISION_ADDRESS=', build_dir +
                                       f'/{NET_CORE_APP_NAME}/pm_CPUNET.config'), 16)
    pm_mcuboot_secondary_size = int(awklike('PM_MCUBOOT_SECONDARY_SIZE=', build_dir +
                                            '/pm.config'), 16)

    os_cmd = f'{sys.executable} {ZEPHYR_BASE}/../nrf/scripts/bootloader/hash.py --in {build_dir}/{BLE5_CTR_HEX}\
    > {build_dir}/app_firmware.sha256'

    ret_val = os.system(os_cmd)
    if ret_val:
        raise Exception('python error: ' + str(ret_val))

    os_cmd = f'{sys.executable} {ZEPHYR_BASE}/../nrf/scripts/bootloader/do_sign.py --private-key\
    {build_dir}/{NET_CORE_APP_NAME}/zephyr/GENERATED_NON_SECURE_SIGN_KEY_PRIVATE.pem --in\
    {build_dir}/app_firmware.sha256 > {build_dir}/app_firmware.signature'

    ret_val = os.system(os_cmd)
    if ret_val:
        raise Exception('python error: ' + str(ret_val))

    public_keys = f' {build_dir}/{NET_CORE_APP_NAME}/zephyr/nrf/subsys/bootloader/generated/public.pem'
    os_cmd = f'{sys.executable} {ZEPHYR_BASE}/../nrf/scripts/bootloader/validation_data.py\
    --input {build_dir}/{BLE5_CTR_HEX} --output-hex {build_dir}/signed_by_b0_ble5_ctr.hex\
    --output-bin {build_dir}/signed_by_b0_ble5_ctr.bin --offset 0 --signature\
    {build_dir}/app_firmware.signature --public-key {public_keys}\
    --magic-value {validation_magic_value}'

    ret_val = os.system(os_cmd)
    if ret_val:
        raise Exception('python error: ' + str(ret_val))

    # Generate net_core_app_update.bin
    os_cmd = f'{sys.executable} {ZEPHYR_BASE}/../bootloader/mcuboot/scripts/imgtool.py sign --key\
    {mcuboot_rsa_key} --header-size {fw_info_offset} --align 4 --version {image_version}\
    --pad-header --slot-size {pm_mcuboot_secondary_size}  {build_dir}/signed_by_b0_ble5_ctr.bin\
    {build_dir}/{FINAL_BLE5_CTR_UPDATE_BIN}'

    ret_val = os.system(os_cmd)
    if ret_val:
        raise Exception('python error: ' + str(ret_val))

    # Check if debug key exists
    debug_public_key_0 = Path(f'{build_dir}/{NET_CORE_APP_NAME}/zephyr/GENERATED_NON_SECURE_PUBLIC_0.pem').resolve()
    debug_public_key_1 = Path(f'{build_dir}/{NET_CORE_APP_NAME}/zephyr/GENERATED_NON_SECURE_PUBLIC_1.pem').resolve()
    if debug_public_key_0.exists():
        public_keys += f',{str(debug_public_key_0)}'
    if debug_public_key_1.exists():
        public_keys += f',{str(debug_public_key_1)}'

    os_cmd = f'{sys.executable} {ZEPHYR_BASE}/../nrf/scripts/bootloader/provision.py\
    --s0-addr {cpunet_pm_app_address} --provision-addr {pm_provision_address}\
    --public-key-files {public_keys}\
    --output {build_dir}/provision.hex --num-counter-slots-version {num_ver_counter_slots}\
    --max-size {pm_partition_size_provision}'

    ret_val = os.system(os_cmd)
    if ret_val:
        raise Exception('python error: ' + str(ret_val))

    os_cmd = f'{sys.executable} {ZEPHYR_BASE}/scripts/build/mergehex.py -o {build_dir}/b0n_container.hex\
    {build_dir}/{BLE5_CTR_HEX} {build_dir}/provision.hex'

    ret_val = os.system(os_cmd)
    if ret_val:
        raise Exception('python error: ' + str(ret_val))

    os_cmd = f'{sys.executable} {ZEPHYR_BASE}/scripts/build/mergehex.py -o {build_dir}/{FINAL_BLE5_CTR_HEX}\
    --overlap=replace {build_dir}/{NET_CORE_APP_NAME}/b0n/zephyr/zephyr.hex  {build_dir}/b0n_container.hex\
    {build_dir}/provision.hex {build_dir}/{BLE5_CTR_HEX} {build_dir}/signed_by_b0_ble5_ctr.hex'

    ret_val = os.system(os_cmd)
    if ret_val:
        raise Exception('python error: ' + str(ret_val))

    # Replace built net_core
    src_path = f'{build_dir}/{FINAL_BLE5_CTR_UPDATE_BIN}'
    dst_path = f'{build_dir}/zephyr/net_core_app_update.bin'
    shutil.copy(src_path, dst_path)

    src_path = f'{build_dir}/{FINAL_BLE5_CTR_HEX}'
    dst_path = f'{build_dir}/zephyr/net_core_app_signed.hex'
    shutil.copy(src_path, dst_path)

    # Generate merged_domains.hex
    os_cmd = f'{sys.executable} {ZEPHYR_BASE}/scripts/build/mergehex.py -o {build_dir}/zephyr/merged_domains.hex\
    {build_dir}/{FINAL_BLE5_CTR_HEX} {build_dir}/zephyr/merged.hex'

    ret_val = os.system(os_cmd)
    # Generate dfu_application.zip
    # set(generate_script_params
    # "${app_core_binary_name}load_address=$<TARGET_PROPERTY:partition_manager,PM_APP_ADDRESS>"
    # "${app_core_binary_name}image_index=0"
    # "${app_core_binary_name}slot_index_primary=1"
    # "${app_core_binary_name}slot_index_secondary=2"
    # "${app_core_binary_name}version_MCUBOOT=${CONFIG_MCUBOOT_IMGTOOL_SIGN_VERSION}"
    # "${net_core_binary_name}image_index=1"
    # "${net_core_binary_name}slot_index_primary=3"
    # "${net_core_binary_name}slot_index_secondary=4"
    # "${net_core_binary_name}load_address=$<TARGET_PROPERTY:partition_manager,\
    # CPUNET_PM_APP_ADDRESS>"
    # "${net_core_binary_name}board=${CONFIG_DOMAIN_CPUNET_BOARD}"
    # "${net_core_binary_name}version=${net_core_version}"
    # "${net_core_binary_name}soc=${net_core_soc}"
    # )
    os.remove(f'{build_dir}/zephyr/dfu_application.zip')
    os_cmd = f'{sys.executable} {ZEPHYR_BASE}/../nrf/scripts/bootloader/generate_zip.py --bin-files\
    {build_dir}/zephyr/app_update.bin {build_dir}/zephyr/net_core_app_update.bin\
    --output {build_dir}/zephyr/dfu_application.zip --name nrf5340_audio\
    --meta-info-file {build_dir}/zephyr/zephyr.meta\
    app_update.binload_address={pm_app_app_address}\
    app_update.binimage_index=0\
    app_update.binslot_index_primary=1\
    app_update.binslot_index_secondary=2\
    app_update.binversion_MCUBOOT={image_version}\
    net_core_app_update.binimage_index=1\
    net_core_app_update.binslot_index_primary=3\
    net_core_app_update.binslot_index_secondary=4\
    net_core_app_update.binload_address={cpunet_pm_app_address}\
    net_core_app_update.binboard={net_core_app_binboard}\
    net_core_app_update.binversion={fw_info_firmware_version}\
    net_core_app_update.binsoc={net_soc_name}\
    type=application board={config_board} soc={soc_name}'

    ret_val = os.system(os_cmd)


def find_hex_name(options):

    in_path = Path(options.input_folder).resolve()

    # Add files only match pattern filename and includes digits for build number
    pattern_found = sorted([
        file for file in in_path.iterdir()\
        if re.match(ORIG_BLE5_CTR_MIN_PATTERN if options.min_b0n else ORIG_BLE5_CTR_PATTERN, file.name)\
        is not None
    ])

    # Last hex file should be latest version.
    return pattern_found[-1]


def __main():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description='This script sign and generate netcore hex and upgradable binary for the\
         nRF5340 Audio project on Windows and Linux',
        allow_abbrev=False)
    parser.add_argument('-i', '--input_file', type=str,
                        help='Input hex file name. Higher priority than -I')
    parser.add_argument('-b', '--build_dir', required=True, type=str,
                        help='Build folder.')
    parser.add_argument('-I', '--input_folder', type=str,
                        help='Input hex folder, let script choose filename automatically.\
                        Lower priority than -i')
    parser.add_argument('-m', '--min_b0n', default=False, action='store_true',
                        help='B0N use minimal. Only valid if -I is assigned')
    options = parser.parse_args(args=sys.argv[1:])

    if options.input_file is not None:
        input_file_name = options.input_file
    elif options.input_folder is not None:
        input_file_name = find_hex_name(options)
    print(f'input hex name {input_file_name}')
    sign(input_file_name, options.build_dir)


if __name__ == '__main__':
    __main()


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/tools/buildprog/program.py
#
# Copyright (c) 2018 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

""" Tools to program multiple nRF5340 Audio DKs """

from threading import Thread
from os import system, path
from typing import List
from nrf5340_audio_dk_devices import DeviceConf, SelectFlags, AudioDevice, Controller

MEM_ADDR_UICR_SNR = 0x00FF80F0
MEM_ADDR_UICR_CH = 0x00FF80F4


def __populate_UICR(dev):
    """Program UICR in device with information from JSON file"""
    if dev.nrf5340_audio_dk_dev == AudioDevice.headset:
        cmd = f"nrfjprog --memwr {MEM_ADDR_UICR_CH} --val {dev.channel.value} --snr {dev.nrf5340_audio_dk_snr}"
        # Write channel information to UICR
        print("Programming UICR")
        ret_val = system(cmd)

        if ret_val:
            return False

    cmd = f"nrfjprog --memwr {MEM_ADDR_UICR_SNR} --val {dev.nrf5340_audio_dk_snr} --snr {dev.nrf5340_audio_dk_snr}"

    # Write segger nr to UICR
    ret_val = system(cmd)
    if ret_val:
        return False
    else:
        return True


def _program_cores(dev: DeviceConf, mcuboot_type) -> int:
    if dev.core_net_programmed == SelectFlags.TBD:
        if not path.isfile(dev.hex_path_net):
            if dev.controller == Controller.sdc:
                print(
                    "Controller: SDC. NET core hex not found. Built as APP core child image.")
            if dev.controller == Controller.acs_nrf53:
                print("Controller: acs_nrf53. NET core hex not found.")
            return 1

        print(f"Programming net core on: {dev}")
        cmd = f"nrfjprog --program {dev.hex_path_net}  -f NRF53  -q --snr {dev.nrf5340_audio_dk_snr} --sectorerase --coprocessor CP_NETWORK"
        ret_val = system(cmd)
        if ret_val != 0:
            if not dev.recover_on_fail:
                dev.core_net_programmed = SelectFlags.FAIL
            return ret_val
        else:
            dev.core_net_programmed = SelectFlags.DONE

    if dev.core_app_programmed == SelectFlags.TBD:
        print(f"Programming app core on: {dev}")
        cmd = f"nrfjprog --program {dev.hex_path_app} -f NRF53  -q --snr {dev.nrf5340_audio_dk_snr} --chiperase --coprocessor CP_APPLICATION"
        ret_val = system(cmd)
        if ret_val != 0:
            if not dev.recover_on_fail:
                dev.core_app_programmed = SelectFlags.FAIL
            return ret_val
        else:
            dev.core_app_programmed = SelectFlags.DONE
        # Populate UICR data matching the JSON file
        if not __populate_UICR(dev):
            dev.core_app_programmed = SelectFlags.FAIL
            return 1

    if dev.core_net_programmed != SelectFlags.NOT or dev.core_app_programmed != SelectFlags.NOT:
        if mcuboot_type == 'external':
            print(f"Hard resetting {dev}")
            cmd = f"nrfjprog -p --snr {dev.nrf5340_audio_dk_snr}"
        else:
            print(f"Resetting {dev}")
            cmd = f"nrfjprog -r --snr {dev.nrf5340_audio_dk_snr}"
        ret_val = system(cmd)
        if ret_val != 0:
            return ret_val
    return 0


def _recover(dev: DeviceConf):
    print(f"Recovering device: {dev}")
    ret_val = system(
        f"nrfjprog --recover --coprocessor CP_NETWORK --snr {dev.nrf5340_audio_dk_snr}"
    )
    if ret_val != 0:
        dev.core_net_programmed = SelectFlags.FAIL

    ret_val = system(
        f"nrfjprog --recover --coprocessor CP_APPLICATION --snr {dev.nrf5340_audio_dk_snr}"
    )
    if ret_val != 0:
        dev.core_app_programmed = SelectFlags.FAIL


def __program_thread(dev: DeviceConf, mcuboot_type):
    if dev.only_reboot == SelectFlags.TBD:
        print(f"Resetting {dev}")
        cmd = f"nrfjprog -r --snr {dev.nrf5340_audio_dk_snr}"
        ret_val = system(cmd)
        dev.only_reboot = SelectFlags.FAIL if ret_val else SelectFlags.DONE
        return

    return_code = _program_cores(dev, mcuboot_type)
    if return_code != 0 and dev.recover_on_fail:
        _recover(dev)
        _program_cores(dev, mcuboot_type)


def program_threads_run(devices_list: List[DeviceConf], mcuboot_type, sequential: bool = False):
    """Program devices in parallel"""
    threads = []
    # First program net cores if applicable
    for dev in devices_list:
        if not dev.snr_connected:
            dev.only_reboot = SelectFlags.NOT
            dev.core_app_programmed = SelectFlags.NOT
            dev.core_net_programmed = SelectFlags.NOT
            continue
        thread = Thread(target=__program_thread, args=(dev, mcuboot_type))
        threads.append(thread)
        thread.start()
        if sequential:
            thread.join()

    for thread in threads:
        thread.join()

    threads.clear()


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/tools/buildprog/nrf5340_audio_dk_devices.py
#
# Copyright (c) 2018 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

"""
Settings for building and flashing nRF5340 Audio DK for different targets.
"""
from dataclasses import InitVar, dataclass, field
from enum import auto, Enum
from pathlib import Path
from typing import List


class SelectFlags(str, Enum):
    """Holds the available status flags"""

    NOT = "Not selected"
    TBD = "Selected"
    DONE = "Done"
    FAIL = "Failed"


class Core(str, Enum):
    app = "app"
    net = "network"
    both = "both"


class AudioDevice(str, Enum):
    headset = "headset"
    gateway = "gateway"
    both = "both"


class BuildType(str, Enum):
    release = "release"
    debug = "debug"


class Channel(Enum):
    # Value represents UICR channel
    left = 0
    right = 1
    NA = auto()


class Controller(str, Enum):
    acs_nrf53 = "ACS_nRF53"
    sdc = "SDC"


@dataclass
class DeviceConf:
    """This config is populated according to connected SEGGER serial numbers
    (snr) and command line arguments"""

    # Constructor variables
    nrf5340_audio_dk_snr: int
    channel: Channel
    snr_connected: bool
    nrf5340_audio_dk_dev: AudioDevice
    recover_on_fail: bool

    cores: InitVar[List[Core]]
    devices: InitVar[List[AudioDevice]]
    _only_reboot: InitVar[SelectFlags]
    controller: InitVar[List[Controller]]
    # Post init variables
    only_reboot: SelectFlags = field(init=False, default=SelectFlags.NOT)
    hex_path_app: Path = field(init=False, default=None)
    core_app_programmed: SelectFlags = field(
        init=False, default=SelectFlags.NOT)
    hex_path_net: Path = field(init=False, default=None)
    core_net_programmed: SelectFlags = field(
        init=False, default=SelectFlags.NOT)

    def __post_init__(
        self, cores: List[Core], devices: List[AudioDevice], _only_reboot: SelectFlags, controller: Controller,
    ):
        device_selected = self.nrf5340_audio_dk_dev in devices
        self.only_reboot = _only_reboot if device_selected else SelectFlags.NOT
        self.controller = controller
        if self.only_reboot == SelectFlags.TBD:
            return

        if (Core.app in cores) and device_selected:
            self.core_app_programmed = SelectFlags.TBD
        if (Core.net in cores) and device_selected:
            self.core_net_programmed = SelectFlags.TBD

    def __str__(self):
        str = f"{self.nrf5340_audio_dk_snr} {self.nrf5340_audio_dk_dev.name}"
        if self.nrf5340_audio_dk_dev == AudioDevice.headset:
            str += f" {self.channel.name}"
        return str


@dataclass
class BuildConf:
    """Build config"""

    core: Core
    device: AudioDevice
    build: BuildType
    pristine: bool
    controller: Controller
    child_image: bool


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/tools/buildprog/fw_info_data.py
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause

"""
Generate fw_info for B0N container from .config
"""

from intelhex import IntelHex

import argparse
import struct


def get_fw_info(input_hex, offset, magic_value, fw_version, fw_valid_val):
    # 0x0c start of fw_info_total_size
    # 0x10 start of flash_used
    # 0x14 start of fw_version
    # 0x18 the address of the start of the image
    # 0x1c the address of the boot point (vector table) of the firmware
    # 0x20 the address Value that can be modified to invalidate the firmware

    fw_info_bytes = magic_value
    for i in range(0xc, 0x14):
        fw_info_bytes += input_hex[offset + i].to_bytes(1, byteorder='little')
    fw_info_bytes += struct.pack('<I', fw_version)
    for i in range(0x18, 0x20):
        fw_info_bytes += input_hex[offset + i].to_bytes(1, byteorder='little')
    fw_info_bytes += fw_valid_val
    return fw_info_bytes


def inject_fw_info(input_file, offset, output_hex, magic_value, fw_version, fw_valid_val):
    ih = IntelHex(input_file)
    # OBJCOPY incorrectly inserts x86 specific records, remove the start_addr as it is wrong.
    ih.start_addr = None

    # Parse comma-separated string of uint32s into hex string. Each is encoded in little-endian byte order
    parsed_magic_value = b''.join(
        [struct.pack('<I', int(m, 0)) for m in magic_value.split(',')])
    # Parse string of uint32s into hex string. Each is encoded in little-endian byte order
    parsed_fw_valid_val = struct.pack('<I', fw_valid_val)
    parsed_fw_version = '0x%08X' % fw_version
    print(parsed_fw_version)
    fw_info_data = get_fw_info(input_hex=ih,
                               offset=offset,
                               magic_value=parsed_magic_value,
                               fw_version=fw_version,
                               fw_valid_val=parsed_fw_valid_val)
    fw_info_data_data_hex = IntelHex()

    fw_info_data_data_hex.frombytes(fw_info_data, offset)
    ih.merge(fw_info_data_data_hex, overlap='replace')
    ih.write_hex_file(output_hex)


def parse_args():
    parser = argparse.ArgumentParser(
        description='Inject fw info metadata at specified offset. Generate HEX file',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        allow_abbrev=False)

    parser.add_argument('-i', '--input', required=True, type=argparse.FileType('r', encoding='UTF-8'),
                        help='Input hex file.')
    parser.add_argument('--offset', required=True, type=lambda x: int(x, 0),
                        help='Offset to store validation metadata at.', default=0x01008A00)
    parser.add_argument('-m', '--magic-value', required=True,
                        help='ASCII representation of magic value.')
    parser.add_argument('-v', '--fw-version', required=True, type=int,
                        help='Fw version.')
    parser.add_argument('-l', '--fw-valid-val', required=True, type=lambda x: int(x, 0),
                        help='ASCII representation of fw valid val.')
    parser.add_argument('-o', '--output-hex', required=False, default=None, type=argparse.FileType('w'),
                        help='.hex output file name. Default is to overwrite --input.')

    args = parser.parse_args()
    if args.output_hex is None:
        args.output_hex = args.input
    return args


def main():

    args = parse_args()

    inject_fw_info(input_file=args.input,
                   offset=args.offset,
                   output_hex=args.output_hex,
                   magic_value=args.magic_value,
                   fw_version=args.fw_version,
                   fw_valid_val=args.fw_valid_val)


if __name__ == '__main__':
    main()


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/dfu/conf/overlay-empty_net_core.conf
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

# To be able to assign FW_INFO_FIRMWARE_VERSION in application,
# this file is needed
CONFIG_SECURE_BOOT=y
CONFIG_FW_INFO_FIRMWARE_VERSION=1


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/dfu/conf/pm_dfu_external_flash_2MB.yml
app:
  address: 0x10200
  region: flash_primary
  size: 0xebe00
mcuboot:
  address: 0x0
  region: flash_primary
  size: 0x10000
mcuboot_pad:
  address: 0x10000
  region: flash_primary
  size: 0x200
mcuboot_primary:
  address: 0x10000
  orig_span: &id001
  - mcuboot_pad
  - app
  region: flash_primary
  size: 0xec000
  span: *id001
mcuboot_primary_app:
  address: 0x10200
  orig_span: &id002
  - app
  region: flash_primary
  size: 0xebe00
  span: *id002
settings_storage:
  address: 0xfc000
  region: flash_primary
  size: 0x4000
mcuboot_primary_1:
  address: 0x0
  size: 0x40000
  device: flash_ctrl
  region: ram_flash
mcuboot_secondary:
  address: 0x00000
  size: 0xec000
  device: MX25R16
  region: external_flash
mcuboot_secondary_1:
  address: 0xec000
  size: 0x40000
  device: MX25R16
  region: external_flash
external_flash:
  address: 0x12c000
  size: 0xd4000
  device: MX25R16
  region: external_flash
pcd_sram:
  address: 0x20000000
  size: 0x2000
  region: sram_primary


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/dfu/conf/overlay-dfu_external_flash.overlay
/ {
	chosen {
		nordic,pm-ext-flash = &mx25r64;
	};
};

&qspi {
	status = "disabled";
};

&spi4 {
	cs-gpios = <&gpio0 11 GPIO_ACTIVE_LOW>, <&gpio0 17 GPIO_ACTIVE_LOW>, < &gpio1 10 GPIO_ACTIVE_LOW >;
	status = "okay";
	sdhc0: sdhc@0 {
		status = "okay";
	};
	cs47l63: cs47l63@1 {
		status = "okay";
	};
	mx25r64: mx25r6435f@2 {

		compatible = "jedec,spi-nor";
		reg = <2>;
		spi-max-frequency = <8000000>;

		jedec-id = [c2 28 17];
		sfdp-bfp = [
			e5 20 f1 ff  ff ff ff 03  44 eb 08 6b  08 3b 04 bb
			ee ff ff ff  ff ff 00 ff  ff ff 00 ff  0c 20 0f 52
			10 d8 00 ff  23 72 f5 00  82 ed 04 cc  44 83 68 44
			30 b0 30 b0  f7 c4 d5 5c  00 be 29 ff  f0 d0 ff ff
		];
		size = <67108864>;
		has-dpd;
		t-enter-dpd = <10000>;
		t-exit-dpd = <5000>;
		dpd-wakeup-sequence = <30000 20 45000>;
	};
};

&gpio_fwd {
	uart {
		gpios = < &gpio1 0x9 0x0 >, < &gpio1 0x8 0x0 >, < &gpio1 0xb 0x0 >;
	};
};


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/dfu/conf/Kconfig.dfu
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

config AUDIO_DFU
	int "Select which DFU type. 0=NONE, 1=Internal flash, 2=External flash"
	range 0 2
	default 0
	help
	  Setting this variable to 0 disables DFU.
	  Setting this variable to 1 selects internal flash single image DFU.
	  Setting this variable to 2 selects external flash multi images DFU.

config B0N_MINIMAL
	bool "B0N use minimal or not"
	default n
	help
	  Let CMakelist choose corresponding overlay file

if AUDIO_DFU = 1 || AUDIO_DFU = 2

# Empty net core image is needed when DFU is enabled
config NCS_SAMPLE_EMPTY_NET_CORE_CHILD_IMAGE
	bool "Dummy Net core application"
	default y if BT_LL_ACS_NRF53

config AUDIO_DFU_ENABLE
	bool
	default y
	select EXPERIMENTAL
	help
	  To show warning message of EXPERIMENTAL feature DFU

config BOOTLOADER_MCUBOOT
	bool
	default y

config SYSTEM_WORKQUEUE_STACK_SIZE
	int
	default 4096

config THREAD_NAME
	bool
	default y

config ZCBOR
	bool
	default y

# DFU
config MCUMGR
	bool
	default y

config MCUMGR_GRP_OS
	bool
	default y

config MCUMGR_GRP_OS_TASKSTAT
	bool
	default y

config MCUMGR_GRP_STAT
	bool
	default y

config MCUMGR_GRP_IMG
	bool
	default y

config MCUMGR_TRANSPORT_NETBUF_SIZE
	int
	default 1024

config IMG_MANAGER
	bool
	default y

config FLASH
	bool
	default y

config FLASH_MAP
	bool
	default y

config STREAM_FLASH
	bool
	default y

# DFU over BLE
config BT_PERIPHERAL
	default y

config MCUMGR_TRANSPORT_BT
	bool
	default y

config MCUMGR_TRANSPORT_BT_AUTHEN
	bool
	default n

config BT_L2CAP_TX_MTU
	int
	default 498

config BT_BUF_ACL_TX_SIZE
	int
	default 502

config MCUMGR_TRANSPORT_NETBUF_COUNT
	int
	default 6

config THREAD_MONITOR
	bool
	default y

config STATS
	bool
	default y

config STATS_NAMES
	bool
	default y

config BT_DEVICE_NAME_DYNAMIC
	bool
	default y

config BT_DEVICE_NAME_GATT_WRITABLE
	bool
	default n

config BT_DEVICE_NAME_MAX
	int
	default 30

endif # AUDIO_DFU = 1 and AUDIO_DFU = 2 (INTERNAL/EXTERNAL)

if AUDIO_DFU = 1

# Reduce footprint for internal flash debug build
choice COMPILER_OPTIMIZATIONS
	default SIZE_OPTIMIZATIONS
endchoice

endif # AUDIO_DFU = 1 (INTERNAL)

if AUDIO_DFU = 2

config UPDATEABLE_IMAGE_NUMBER
	int
	default 2

config IMG_ERASE_PROGRESSIVELY
	bool
	default y

config PM_EXTERNAL_FLASH_MCUBOOT_SECONDARY
	bool
	default y

#External Flash
config SPI_NOR
	bool
	default y

config SPI_NOR_CS_WAIT_DELAY
	int
	default 5

choice SPI_NOR_SFDP
	default SPI_NOR_SFDP_DEVICETREE
endchoice

# Change default flash erase size for flexible flash layout
config SPI_NOR_FLASH_LAYOUT_PAGE_SIZE
	int
	default 4096

# Enable custom SMP request to erase settings partition.
config MCUMGR_GRP_ZBASIC
	bool
	default y

config MCUMGR_GRP_ZBASIC_STORAGE_ERASE
	bool
	default y

config BOOT_IMAGE_ACCESS_HOOKS
	bool
	default y

config PM_OVERRIDE_EXTERNAL_DRIVER_CHECK
	bool
	default y

endif # AUDIO_DFU = 2 (EXTERNAL)


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/dfu/conf/pm_dfu_external_flash.yml
app:
  address: 0x10200
  region: flash_primary
  size: 0xdfe00
mcuboot:
  address: 0x0
  region: flash_primary
  size: 0x10000
mcuboot_pad:
  address: 0x10000
  region: flash_primary
  size: 0x200
mcuboot_primary:
  address: 0x10000
  orig_span: &id001
  - mcuboot_pad
  - app
  region: flash_primary
  size: 0xe0000
  span: *id001
mcuboot_primary_app:
  address: 0x10200
  orig_span: &id002
  - app
  region: flash_primary
  size: 0xdfe00
  span: *id002
settings_storage:
  address: 0xf0000
  region: flash_primary
  size: 0x10000
mcuboot_primary_1:
  address: 0x0
  size: 0x40000
  device: flash_ctrl
  region: ram_flash
mcuboot_secondary:
  address: 0x00000
  size: 0xe0000
  device: MX25R64
  region: external_flash
mcuboot_secondary_1:
  address: 0xe0000
  size: 0x40000
  device: MX25R64
  region: external_flash
external_flash:
  address: 0x120000
  size: 0x6e0000
  device: MX25R64
  region: external_flash
pcd_sram:
  address: 0x20000000
  size: 0x2000
  region: sram_primary


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/dfu/conf/overlay-mcuboot_external_flash.conf
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

CONFIG_SIZE_OPTIMIZATIONS=y
CONFIG_MAIN_STACK_SIZE=20480
CONFIG_MBEDTLS_CFG_FILE="mcuboot-mbedtls-cfg.h"
CONFIG_PCD_APP=y
CONFIG_PM_PARTITION_SIZE_MCUBOOT=0x10000
CONFIG_BOOT_MAX_IMG_SECTORS=2048

# Enable serial debug for MCUBOOT
CONFIG_CBPRINTF_NANO=y
CONFIG_CONSOLE=y
CONFIG_LOG=y
CONFIG_UART_NRFX=y

# External Flash
CONFIG_SPI=y
CONFIG_SPI_NOR=y
CONFIG_SPI_NOR_SFDP_DEVICETREE=y
CONFIG_MULTITHREADING=y
# Change default flash erase size for flexible flash layout
CONFIG_SPI_NOR_FLASH_LAYOUT_PAGE_SIZE=4096
CONFIG_BOOT_ERASE_PROGRESSIVELY=y
CONFIG_SOC_FLASH_NRF_EMULATE_ONE_BYTE_WRITE_ACCESS=y
CONFIG_FPROTECT=y

# The following configurations are required to support simultaneous multi-image update
CONFIG_UPDATEABLE_IMAGE_NUMBER=2
CONFIG_BOOT_UPGRADE_ONLY=y

# The network core cannot access external flash directly. The flash simulator must be used to
# provide a memory region that is used to forward the new firmware to the network core
CONFIG_FLASH_SIMULATOR=y
CONFIG_FLASH_SIMULATOR_DOUBLE_WRITES=y
CONFIG_FLASH_SIMULATOR_STATS=n
CONFIG_PM_EXTERNAL_FLASH_MCUBOOT_SECONDARY=y
CONFIG_PM_OVERRIDE_EXTERNAL_DRIVER_CHECK=y


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/dfu/conf/overlay-mcuboot.conf
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

CONFIG_SIZE_OPTIMIZATIONS=y
CONFIG_MAIN_STACK_SIZE=20480
CONFIG_MBEDTLS_CFG_FILE="mcuboot-mbedtls-cfg.h"
CONFIG_PCD_APP=y

# Enable serial debug for MCUBOOT
CONFIG_CBPRINTF_NANO=y
CONFIG_LOG=y
CONFIG_UART_NRFX=y


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/include/nrf5340_audio_common.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _NRF5340_AUDIO_COMMON_H_
#define _NRF5340_AUDIO_COMMON_H_

#include <zephyr/bluetooth/audio/audio.h>

#define ZBUS_READ_TIMEOUT_MS	K_MSEC(100)
#define ZBUS_ADD_OBS_TIMEOUT_MS K_MSEC(200)

/***** Messages for zbus ******/

enum button_action {
	BUTTON_PRESS = 1,
};

struct button_msg {
	uint32_t button_pin;
	enum button_action button_action;
};

enum le_audio_evt_type {
	LE_AUDIO_EVT_CONFIG_RECEIVED = 1,
	LE_AUDIO_EVT_PRES_DELAY_SET,
	LE_AUDIO_EVT_STREAMING,
	LE_AUDIO_EVT_NOT_STREAMING,
	LE_AUDIO_EVT_SYNC_LOST,
	LE_AUDIO_EVT_NO_VALID_CFG,
};

struct le_audio_msg {
	enum le_audio_evt_type event;
	struct bt_conn *conn;
	struct bt_le_per_adv_sync *pa_sync;
	enum bt_audio_dir dir;
};

/**
 * tx_sync_ts_us	The timestamp from get_tx_sync.
 * curr_ts_us		The current time. This must be in the controller frame of reference.
 */
struct sdu_ref_msg {
	uint32_t tx_sync_ts_us;
	uint32_t curr_ts_us;
	bool adjust;
};

enum bt_mgmt_evt_type {
	BT_MGMT_EXT_ADV_WITH_PA_READY = 1,
	BT_MGMT_CONNECTED,
	BT_MGMT_SECURITY_CHANGED,
	BT_MGMT_PA_SYNCED,
	BT_MGMT_PA_SYNC_LOST,
	BT_MGMT_DISCONNECTED,
};

struct bt_mgmt_msg {
	enum bt_mgmt_evt_type event;
	struct bt_conn *conn;
	struct bt_le_ext_adv *ext_adv;
	struct bt_le_per_adv_sync *pa_sync;
	uint32_t broadcast_id;
	uint8_t pa_sync_term_reason;
};

enum volume_evt_type {
	VOLUME_UP = 1,
	VOLUME_DOWN,
	VOLUME_SET,
	VOLUME_MUTE,
	VOLUME_UNMUTE,
};

struct volume_msg {
	enum volume_evt_type event;
	uint8_t volume;
};

enum content_control_evt_type {
	MEDIA_START = 1,
	MEDIA_STOP,
};

struct content_control_msg {
	enum content_control_evt_type event;
};

/**
 * @brief	Initialize the software modules that are common for all the audio samples.
 *
 * @return	0 if successful, error otherwise.
 */
int nrf5340_audio_common_init(void);

#endif /* _NRF5340_AUDIO_COMMON_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/broadcast_sink/CMakeLists.txt
#
# Copyright (c) 2023 Nordic Semiconductor
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

target_sources(app PRIVATE
	       ${CMAKE_CURRENT_SOURCE_DIR}/main.c)


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/broadcast_sink/Kconfig.defaults
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

## ACL related configs ##
config BT_OBSERVER
	default y

config BT_PERIPHERAL
	default y

# Generic Audio Sink - 0x0840
config BT_DEVICE_APPEARANCE
	default 2112

config BT_PER_ADV_SYNC_MAX
	default 2

config BT_SMP
	default y


## ISO related configs ##
config BT_ISO_SYNC_RECEIVER
	default y

config BT_BAP_BROADCAST_SINK
	default y

config BT_BAP_SCAN_DELEGATOR
	default y

config BT_BAP_BROADCAST_SNK_STREAM_COUNT
	default 2

config BT_BAP_BROADCAST_SNK_COUNT
	default 2

config BT_ISO_MAX_CHAN
	default 2

config BT_ISO_MAX_BIG
	default 2

config BT_PAC_SNK
	default y

config BT_AUDIO_RX
	default y


## Audio related configs ##
config AUDIO_MUTE
	default n

config AUDIO_TEST_TONE
	default n


## LC3 related configs ##
config LC3_DEC_CHAN_MAX
	default 1


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/broadcast_sink/main.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "streamctrl.h"

#include <zephyr/kernel.h>
#include <zephyr/zbus/zbus.h>

#include "nrf5340_audio_common.h"
#include "nrf5340_audio_dk.h"
#include "broadcast_sink.h"
#include "led.h"
#include "button_assignments.h"
#include "macros_common.h"
#include "audio_system.h"
#include "bt_mgmt.h"
#include "bt_rend.h"
#include "audio_datapath.h"
#include "le_audio_rx.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(main, CONFIG_MAIN_LOG_LEVEL);

struct ble_iso_data {
	uint8_t data[CONFIG_BT_ISO_RX_MTU];
	size_t data_size;
	bool bad_frame;
	uint32_t sdu_ref;
	uint32_t recv_frame_ts;
} __packed;

ZBUS_SUBSCRIBER_DEFINE(button_evt_sub, CONFIG_BUTTON_MSG_SUB_QUEUE_SIZE);

ZBUS_MSG_SUBSCRIBER_DEFINE(le_audio_evt_sub);

ZBUS_CHAN_DECLARE(button_chan);
ZBUS_CHAN_DECLARE(le_audio_chan);
ZBUS_CHAN_DECLARE(bt_mgmt_chan);
ZBUS_CHAN_DECLARE(volume_chan);

ZBUS_OBS_DECLARE(volume_evt_sub);

static struct k_thread button_msg_sub_thread_data;
static struct k_thread le_audio_msg_sub_thread_data;

static k_tid_t button_msg_sub_thread_id;
static k_tid_t le_audio_msg_sub_thread_id;

K_THREAD_STACK_DEFINE(button_msg_sub_thread_stack, CONFIG_BUTTON_MSG_SUB_STACK_SIZE);
K_THREAD_STACK_DEFINE(le_audio_msg_sub_thread_stack, CONFIG_LE_AUDIO_MSG_SUB_STACK_SIZE);

static enum stream_state strm_state = STATE_PAUSED;

/* Function for handling all stream state changes */
static void stream_state_set(enum stream_state stream_state_new)
{
	strm_state = stream_state_new;
}

/**
 * @brief	Handle button activity.
 */
static void button_msg_sub_thread(void)
{
	int ret;
	const struct zbus_channel *chan;
	bool broadcast_alt = true;

	while (1) {
		ret = zbus_sub_wait(&button_evt_sub, &chan, K_FOREVER);
		ERR_CHK(ret);

		struct button_msg msg;

		ret = zbus_chan_read(chan, &msg, ZBUS_READ_TIMEOUT_MS);
		ERR_CHK(ret);

		LOG_DBG("Got btn evt from queue - id = %d, action = %d", msg.button_pin,
			msg.button_action);

		if (msg.button_action != BUTTON_PRESS) {
			LOG_WRN("Unhandled button action");
			continue;
		}

		switch (msg.button_pin) {
		case BUTTON_PLAY_PAUSE:
			if (strm_state == STATE_STREAMING) {
				ret = broadcast_sink_stop();
				if (ret) {
					LOG_WRN("Failed to stop broadcast sink: %d", ret);
				}
			} else if (strm_state == STATE_PAUSED) {
				ret = broadcast_sink_start();
				if (ret) {
					LOG_WRN("Failed to start broadcast sink: %d", ret);
				}
			} else {
				LOG_WRN("In invalid state: %d", strm_state);
			}

			break;

		case BUTTON_VOLUME_UP:
			ret = bt_rend_volume_up();
			if (ret) {
				LOG_WRN("Failed to increase volume: %d", ret);
			}

			break;

		case BUTTON_VOLUME_DOWN:
			ret = bt_rend_volume_down();
			if (ret) {
				LOG_WRN("Failed to decrease volume: %d", ret);
			}

			break;

		case BUTTON_4:
			ret = broadcast_sink_change_active_audio_stream();
			if (ret) {
				LOG_WRN("Failed to change active audio stream: %d", ret);
			}

			break;

		case BUTTON_5:
			if (IS_ENABLED(CONFIG_AUDIO_MUTE)) {
				ret = bt_rend_volume_mute(false);
				if (ret) {
					LOG_WRN("Failed to mute, ret: %d", ret);
				}

				break;
			}

			ret = broadcast_sink_disable();
			if (ret) {
				LOG_ERR("Failed to disable the broadcast sink: %d", ret);
				break;
			}

			if (broadcast_alt) {
				ret = bt_mgmt_scan_start(0, 0, BT_MGMT_SCAN_TYPE_BROADCAST,
							 CONFIG_BT_AUDIO_BROADCAST_NAME_ALT,
							 BRDCAST_ID_NOT_USED);
				broadcast_alt = false;
			} else {
				ret = bt_mgmt_scan_start(0, 0, BT_MGMT_SCAN_TYPE_BROADCAST,
							 CONFIG_BT_AUDIO_BROADCAST_NAME,
							 BRDCAST_ID_NOT_USED);
				broadcast_alt = true;
			}

			if (ret) {
				LOG_WRN("Failed to start scanning for broadcaster: %d", ret);
			}

			break;

		default:
			LOG_WRN("Unexpected/unhandled button id: %d", msg.button_pin);
		}

		STACK_USAGE_PRINT("button_msg_thread", &button_msg_sub_thread_data);
	}
}

/**
 * @brief	Handle Bluetooth LE audio events.
 */
static void le_audio_msg_sub_thread(void)
{
	int ret;
	uint32_t pres_delay_us;
	uint32_t bitrate_bps;
	uint32_t sampling_rate_hz;

	const struct zbus_channel *chan;

	while (1) {
		struct le_audio_msg msg;

		ret = zbus_sub_wait_msg(&le_audio_evt_sub, &chan, &msg, K_FOREVER);
		ERR_CHK(ret);

		LOG_DBG("Received event = %d, current state = %d", msg.event, strm_state);

		switch (msg.event) {
		case LE_AUDIO_EVT_STREAMING:
			LOG_DBG("LE audio evt streaming");

			if (strm_state == STATE_STREAMING) {
				LOG_DBG("Got streaming event in streaming state");
				break;
			}

			audio_system_start();
			stream_state_set(STATE_STREAMING);
			ret = led_blink(LED_APP_1_BLUE);
			ERR_CHK(ret);

			break;

		case LE_AUDIO_EVT_NOT_STREAMING:
			LOG_DBG("LE audio evt not_streaming");

			if (strm_state == STATE_PAUSED) {
				LOG_DBG("Got not_streaming event in paused state");
				break;
			}

			stream_state_set(STATE_PAUSED);
			audio_system_stop();
			ret = led_on(LED_APP_1_BLUE);
			ERR_CHK(ret);

			break;

		case LE_AUDIO_EVT_CONFIG_RECEIVED:
			LOG_DBG("LE audio config received");

			ret = broadcast_sink_config_get(&bitrate_bps, &sampling_rate_hz,
							&pres_delay_us);
			if (ret) {
				LOG_WRN("Failed to get config: %d", ret);
				break;
			}

			LOG_DBG("\tSampling rate: %d Hz", sampling_rate_hz);
			LOG_DBG("\tBitrate (compressed): %d bps", bitrate_bps);

			ret = audio_system_config_set(VALUE_NOT_SET, VALUE_NOT_SET,
						      sampling_rate_hz);
			ERR_CHK(ret);

			ret = audio_datapath_pres_delay_us_set(pres_delay_us);
			if (ret) {
				LOG_ERR("Failed to set presentation delay to %d", pres_delay_us);
				break;
			}

			LOG_INF("Presentation delay %d us is set", pres_delay_us);

			break;

		case LE_AUDIO_EVT_SYNC_LOST:
			LOG_INF("Sync lost");

			ret = bt_mgmt_pa_sync_delete(msg.pa_sync);
			if (ret) {
				LOG_WRN("Failed to delete PA sync");
			}

			if (strm_state == STATE_STREAMING) {
				stream_state_set(STATE_PAUSED);
				audio_system_stop();
				ret = led_on(LED_APP_1_BLUE);
				ERR_CHK(ret);
			}

			if (IS_ENABLED(CONFIG_BT_OBSERVER)) {
				ret = bt_mgmt_scan_start(0, 0, BT_MGMT_SCAN_TYPE_BROADCAST, NULL,
							 BRDCAST_ID_NOT_USED);
				if (ret) {
					if (ret == -EALREADY) {
						break;
					}

					LOG_ERR("Failed to restart scanning: %d", ret);
					break;
				}

				/* NOTE: The string below is used by the Nordic CI system */
				LOG_INF("Restarted scanning for broadcaster");
			}

			break;

		case LE_AUDIO_EVT_NO_VALID_CFG:
			LOG_WRN("No valid configurations found, disabling the broadcast sink");

			ret = broadcast_sink_disable();
			if (ret) {
				LOG_ERR("Failed to disable the broadcast sink: %d", ret);
				break;
			}

			break;

		default:
			LOG_WRN("Unexpected/unhandled le_audio event: %d", msg.event);

			break;
		}

		STACK_USAGE_PRINT("le_audio_msg_thread", &le_audio_msg_sub_thread_data);
	}
}

/**
 * @brief	Create zbus subscriber threads.
 *
 * @return	0 for success, error otherwise.
 */
static int zbus_subscribers_create(void)
{
	int ret;

	button_msg_sub_thread_id = k_thread_create(
		&button_msg_sub_thread_data, button_msg_sub_thread_stack,
		CONFIG_BUTTON_MSG_SUB_STACK_SIZE, (k_thread_entry_t)button_msg_sub_thread, NULL,
		NULL, NULL, K_PRIO_PREEMPT(CONFIG_BUTTON_MSG_SUB_THREAD_PRIO), 0, K_NO_WAIT);
	ret = k_thread_name_set(button_msg_sub_thread_id, "BUTTON_MSG_SUB");
	if (ret) {
		LOG_ERR("Failed to create button_msg thread");
		return ret;
	}

	le_audio_msg_sub_thread_id = k_thread_create(
		&le_audio_msg_sub_thread_data, le_audio_msg_sub_thread_stack,
		CONFIG_LE_AUDIO_MSG_SUB_STACK_SIZE, (k_thread_entry_t)le_audio_msg_sub_thread, NULL,
		NULL, NULL, K_PRIO_PREEMPT(CONFIG_LE_AUDIO_MSG_SUB_THREAD_PRIO), 0, K_NO_WAIT);
	ret = k_thread_name_set(le_audio_msg_sub_thread_id, "LE_AUDIO_MSG_SUB");
	if (ret) {
		LOG_ERR("Failed to create le_audio_msg thread");
		return ret;
	}

	return 0;
}

/**
 * @brief	Zbus listener to receive events from bt_mgmt.
 *
 * @param[in]	chan	Zbus channel.
 *
 * @note	Will in most cases be called from BT_RX context,
 *		so there should not be too much processing done here.
 */
static void bt_mgmt_evt_handler(const struct zbus_channel *chan)
{
	int ret;
	const struct bt_mgmt_msg *msg;

	msg = zbus_chan_const_msg(chan);

	switch (msg->event) {
	case BT_MGMT_PA_SYNCED:
		LOG_INF("PA synced");

		ret = broadcast_sink_pa_sync_set(msg->pa_sync, msg->broadcast_id);
		if (ret) {
			LOG_WRN("Failed to set PA sync");
		}

		break;

	case BT_MGMT_PA_SYNC_LOST:
		LOG_INF("PA sync lost, reason: %d", msg->pa_sync_term_reason);

		if (IS_ENABLED(CONFIG_BT_OBSERVER) &&
		    msg->pa_sync_term_reason != BT_HCI_ERR_LOCALHOST_TERM_CONN) {
			ret = bt_mgmt_scan_start(0, 0, BT_MGMT_SCAN_TYPE_BROADCAST, NULL,
						 BRDCAST_ID_NOT_USED);
			if (ret) {
				if (ret == -EALREADY) {
					return;
				}

				LOG_ERR("Failed to restart scanning: %d", ret);
				break;
			}

			/* NOTE: The string below is used by the Nordic CI system */
			LOG_INF("Restarted scanning for broadcaster");
		}

		break;

	default:
		LOG_WRN("Unexpected/unhandled bt_mgmt event: %d", msg->event);

		break;
	}
}

ZBUS_LISTENER_DEFINE(bt_mgmt_evt_listen, bt_mgmt_evt_handler);

/**
 * @brief	Link zbus producers and observers.
 *
 * @return	0 for success, error otherwise.
 */
static int zbus_link_producers_observers(void)
{
	int ret;

	if (!IS_ENABLED(CONFIG_ZBUS)) {
		return -ENOTSUP;
	}

	ret = zbus_chan_add_obs(&button_chan, &button_evt_sub, ZBUS_ADD_OBS_TIMEOUT_MS);
	if (ret) {
		LOG_ERR("Failed to add button sub");
		return ret;
	}

	ret = zbus_chan_add_obs(&le_audio_chan, &le_audio_evt_sub, ZBUS_ADD_OBS_TIMEOUT_MS);
	if (ret) {
		LOG_ERR("Failed to add le_audio sub");
		return ret;
	}

	ret = zbus_chan_add_obs(&volume_chan, &volume_evt_sub, ZBUS_ADD_OBS_TIMEOUT_MS);
	if (ret) {
		LOG_ERR("Failed to add add volume sub");
		return ret;
	}

	ret = zbus_chan_add_obs(&bt_mgmt_chan, &bt_mgmt_evt_listen, ZBUS_ADD_OBS_TIMEOUT_MS);
	if (ret) {
		LOG_ERR("Failed to add bt_mgmt listener");
		return ret;
	}

	return 0;
}

uint8_t stream_state_get(void)
{
	return strm_state;
}

void streamctrl_send(void const *const data, size_t size, uint8_t num_ch)
{
	ARG_UNUSED(data);
	ARG_UNUSED(size);
	ARG_UNUSED(num_ch);

	LOG_WRN("Sending is not possible for broadcast sink");
}

int main(void)
{
	int ret;

	LOG_DBG("nRF5340 APP core started");

	ret = nrf5340_audio_dk_init();
	ERR_CHK(ret);

	ret = nrf5340_audio_common_init();
	ERR_CHK(ret);

	ret = zbus_subscribers_create();
	ERR_CHK_MSG(ret, "Failed to create zbus subscriber threads");

	ret = zbus_link_producers_observers();
	ERR_CHK_MSG(ret, "Failed to link zbus producers and observers");

	ret = le_audio_rx_init();
	ERR_CHK_MSG(ret, "Failed to initialize rx path");

	ret = broadcast_sink_enable(le_audio_rx_data_handler);
	ERR_CHK_MSG(ret, "Failed to enable broadcast sink");

	ret = bt_mgmt_scan_start(0, 0, BT_MGMT_SCAN_TYPE_BROADCAST, CONFIG_BT_AUDIO_BROADCAST_NAME,
				 BRDCAST_ID_NOT_USED);
	ERR_CHK_MSG(ret, "Failed to start scanning");

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/broadcast_sink/README.rst
.. _nrf53_audio_broadcast_sink_app:

nRF5340 Audio: Broadcast sink
#############################

.. contents::
   :local:
   :depth: 2

The nRF5340 Audio broadcast sink application implements the :ref:`BIS headset mode <nrf53_audio_app_overview>`.
In this mode, receiving broadcast audio happens using Broadcast Isochronous Stream (BIS) and Broadcast Isochronous Group (BIG).

The following limitations apply to this application:

* One BIG, one of the two BIS streams (selectable).
* Audio output: I2S/Analog headset output.
* Configuration: 16 bit, several bit rates ranging from 32 kbps to 124 kbps.

.. _nrf53_audio_broadcast_sink_app_requirements:

Requirements
************

The application shares the :ref:`requirements common to all nRF5340 Audio application <nrf53_audio_app_requirements>`.

.. _nrf53_audio_broadcast_sink_app_ui:

User interface
**************

Most of the user interface mappings are common across all nRF5340 Audio applications.
See the :ref:`nrf53_audio_app_ui` page for detailed overview.

This application uses specific mapping for the following user interface elements:

* Long-pressed on the broadcast sink device during startup:

  * **VOL-** - Changes the headset to the left channel one.
  * **VOL+** - Changes the headset to the right channel one.

* Pressed on the broadcast sink device during playback:

  * **PLAY/PAUSE** - Starts or pauses listening to the stream.
  * **VOL-** - Turns the playback volume down.
  * **VOL+** - Turns the playback volume up.
  * **BTN 4** - Changes audio stream (different BIS), if more than one is available.
  * **BTN 5** - Changes the gateway, if more than one is available.

* **LED1**:

  * Solid blue - Devices have synchronized with a broadcasted stream.
  * Blinking blue - Devices have started streaming audio (BIS mode).

* **LED2** - Solid green - Sync achieved (both drift and presentation compensation are in the ``LOCKED`` state).
* **RGB**:

  * Solid blue - The device is programmed as the left headset.
  * Solid magenta - The device is programmed as the right headset.

.. _nrf53_audio_broadcast_sink_app_configuration:

Configuration
*************

The application requires the ``CONFIG_TRANSPORT_BIS`` Kconfig option to be set to ``y`` in the :file:`applications/nrf5340_audio/prj.conf` file for `Building and running`_ to succeed.

For other configuration options, see :ref:`nrf53_audio_app_configuration` and :ref:`nrf53_audio_app_fota`.

For information about how to configure applications in the |NCS|, see :ref:`configure_application`.

.. _nrf53_audio_broadcast_sink_app_building:

Building and running
********************

This application can be found under :file:`applications/nrf5340_audio/broadcast_sink` in the nRF Connect SDK folder structure, but it uses :file:`.conf` files at :file:`applications/nrf5340_audio/`.

The nRF5340 Audio DK comes preprogrammed with basic firmware that indicates if the kit is functional.
See :ref:`nrf53_audio_app_dk_testing_out_of_the_box` for more information.

To build the application, complete the following steps:

1. Select the BIS mode by setting the ``CONFIG_TRANSPORT_BIS`` Kconfig option to ``y`` in the :file:`applications/nrf5340_audio/prj.conf` file for the debug version and in the :file:`applications/nrf5340_audio/prj_release.conf` file for the release version.
#. Complete the steps for building and programming common to all audio applications using one of the following methods:

   * :ref:`nrf53_audio_app_building_script`
   * :ref:`nrf53_audio_app_building_standard`

.. _nrf53_audio_broadcast_sink_app_testing:

Testing
*******

.. note::
    |nrf5340_audio_external_devices_note|

To test the broadcast sink application, complete the following steps:

1. Make sure you have another nRF5340 Audio DK for testing purposes.
#. Program the other DK with the :ref:`broadcast source <nrf53_audio_broadcast_source_app>` application.
   The broadcast sink device automatically synchronizes with the broadcast source after programming.
#. Proceed to testing the devices using the :ref:`nrf53_audio_broadcast_sink_app_ui` buttons and LEDs.

Dependencies
************

For the list of dependencies, check the application's source files under :file:`applications/nrf5340_audio/broadcast_sink`.


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/unicast_server/CMakeLists.txt
#
# Copyright (c) 2023 Nordic Semiconductor
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

target_sources(app PRIVATE
	       ${CMAKE_CURRENT_SOURCE_DIR}/main.c)


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/unicast_server/Kconfig.defaults
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

## ACL related configs ##
config BT_MAX_CONN
	default 4

config BT_MAX_PAIRED
	default 4

config BT_PERIPHERAL
	default y

config BT_GATT_AUTO_RESUBSCRIBE
	default n

config BT_GATT_AUTO_SEC_REQ
	default n


## ISO related configs ##
config BT_BAP_UNICAST_SERVER
	default y

config BT_ISO_MAX_CHAN
	default 2

# Earbud - 0x0941
config BT_DEVICE_APPEARANCE
	default 2369

config BT_GAP_PERIPHERAL_PREF_PARAMS
	default n

config BT_ASCS_ASE_SNK_COUNT
	default 1

config BT_ASCS_ASE_SRC_COUNT
	default 1

config BT_VCP_VOL_REND
	default y

config BT_MCC
	default y

# For fixing compatibility issue with Android 14
config BT_PAC_SNK_NOTIFIABLE
	default y

config BT_CSIP_SET_MEMBER
	default y

config BT_CAP_ACCEPTOR
	default y

config BT_CAP_ACCEPTOR_SET_MEMBER
	default y

config BT_AUDIO_CODEC_CFG_MAX_METADATA_SIZE
	default 25


## LC3 related configs ##
config LC3_BITRATE
	default BT_AUDIO_BITRATE_UNICAST_SRC

config LC3_ENC_CHAN_MAX
	default 1

config LC3_DEC_CHAN_MAX
	default 1


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/unicast_server/main.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "streamctrl.h"

#include <zephyr/zbus/zbus.h>

#include "nrf5340_audio_common.h"
#include "nrf5340_audio_dk.h"
#include "led.h"
#include "button_assignments.h"
#include "macros_common.h"
#include "audio_system.h"
#include "button_handler.h"
#include "bt_le_audio_tx.h"
#include "bt_mgmt.h"
#include "bt_rend.h"
#include "audio_datapath.h"
#include "bt_content_ctrl.h"
#include "unicast_server.h"
#include "le_audio.h"
#include "le_audio_rx.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(main, CONFIG_MAIN_LOG_LEVEL);

ZBUS_SUBSCRIBER_DEFINE(button_evt_sub, CONFIG_BUTTON_MSG_SUB_QUEUE_SIZE);

ZBUS_MSG_SUBSCRIBER_DEFINE(le_audio_evt_sub);

ZBUS_CHAN_DECLARE(button_chan);
ZBUS_CHAN_DECLARE(le_audio_chan);
ZBUS_CHAN_DECLARE(bt_mgmt_chan);
ZBUS_CHAN_DECLARE(volume_chan);

ZBUS_OBS_DECLARE(volume_evt_sub);

static struct k_thread button_msg_sub_thread_data;
static struct k_thread le_audio_msg_sub_thread_data;

static k_tid_t button_msg_sub_thread_id;
static k_tid_t le_audio_msg_sub_thread_id;

K_THREAD_STACK_DEFINE(button_msg_sub_thread_stack, CONFIG_BUTTON_MSG_SUB_STACK_SIZE);
K_THREAD_STACK_DEFINE(le_audio_msg_sub_thread_stack, CONFIG_LE_AUDIO_MSG_SUB_STACK_SIZE);

static enum stream_state strm_state = STATE_PAUSED;

/* Function for handling all stream state changes */
static void stream_state_set(enum stream_state stream_state_new)
{
	strm_state = stream_state_new;
}

/**
 * @brief	Handle button activity.
 */
static void button_msg_sub_thread(void)
{
	int ret;
	const struct zbus_channel *chan;

	while (1) {
		ret = zbus_sub_wait(&button_evt_sub, &chan, K_FOREVER);
		ERR_CHK(ret);

		struct button_msg msg;

		ret = zbus_chan_read(chan, &msg, ZBUS_READ_TIMEOUT_MS);
		ERR_CHK(ret);

		LOG_DBG("Got btn evt from queue - id = %d, action = %d", msg.button_pin,
			msg.button_action);

		if (msg.button_action != BUTTON_PRESS) {
			LOG_WRN("Unhandled button action");
			return;
		}

		switch (msg.button_pin) {
		case BUTTON_PLAY_PAUSE:
			if (IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL)) {
				LOG_WRN("Play/pause not supported in walkie-talkie and "
					"bidirectional mode");
				break;
			}

			if (strm_state == STATE_STREAMING) {
				ret = bt_content_ctrl_stop(NULL);
				if (ret) {
					LOG_WRN("Could not stop: %d", ret);
				}

			} else if (strm_state == STATE_PAUSED) {
				ret = bt_content_ctrl_start(NULL);
				if (ret) {
					LOG_WRN("Could not start: %d", ret);
				}

			} else {
				LOG_WRN("In invalid state: %d", strm_state);
			}

			break;

		case BUTTON_VOLUME_UP:
			ret = bt_rend_volume_up();
			if (ret) {
				LOG_WRN("Failed to increase volume: %d", ret);
			}

			break;

		case BUTTON_VOLUME_DOWN:
			ret = bt_rend_volume_down();
			if (ret) {
				LOG_WRN("Failed to decrease volume: %d", ret);
			}

			break;

		case BUTTON_4:
			if (IS_ENABLED(CONFIG_AUDIO_TEST_TONE)) {
				if (IS_ENABLED(CONFIG_WALKIE_TALKIE_DEMO)) {
					LOG_DBG("Test tone is disabled in walkie-talkie mode");
					break;
				}

				if (strm_state != STATE_STREAMING) {
					LOG_WRN("Not in streaming state");
					break;
				}

				ret = audio_system_encode_test_tone_step();
				if (ret) {
					LOG_WRN("Failed to play test tone, ret: %d", ret);
				}

				break;
			}

			break;

		case BUTTON_5:
			if (IS_ENABLED(CONFIG_AUDIO_MUTE)) {
				ret = bt_rend_volume_mute(false);
				if (ret) {
					LOG_WRN("Failed to mute, ret: %d", ret);
				}

				break;
			}

			break;

		default:
			LOG_WRN("Unexpected/unhandled button id: %d", msg.button_pin);
		}

		STACK_USAGE_PRINT("button_msg_thread", &button_msg_sub_thread_data);
	}
}

/**
 * @brief	Handle Bluetooth LE audio events.
 */
static void le_audio_msg_sub_thread(void)
{
	int ret;
	uint32_t pres_delay_us;
	uint32_t bitrate_bps;
	uint32_t sampling_rate_hz;
	const struct zbus_channel *chan;

	while (1) {
		struct le_audio_msg msg;

		ret = zbus_sub_wait_msg(&le_audio_evt_sub, &chan, &msg, K_FOREVER);
		ERR_CHK(ret);

		LOG_DBG("Received event = %d, current state = %d", msg.event, strm_state);

		switch (msg.event) {
		case LE_AUDIO_EVT_STREAMING:
			LOG_DBG("LE audio evt streaming");

			if (msg.dir == BT_AUDIO_DIR_SOURCE) {
				audio_system_encoder_start();
			}

			if (strm_state == STATE_STREAMING) {
				LOG_DBG("Got streaming event in streaming state");
				break;
			}

			audio_system_start();
			stream_state_set(STATE_STREAMING);
			ret = led_blink(LED_APP_1_BLUE);
			ERR_CHK(ret);

			break;

		case LE_AUDIO_EVT_NOT_STREAMING:
			LOG_DBG("LE audio evt not streaming");

			if (strm_state == STATE_PAUSED) {
				LOG_DBG("Got not_streaming event in paused state");
				break;
			}

			if (msg.dir == BT_AUDIO_DIR_SOURCE) {
				audio_system_encoder_stop();
			}

			stream_state_set(STATE_PAUSED);
			audio_system_stop();
			ret = led_on(LED_APP_1_BLUE);
			ERR_CHK(ret);

			break;

		case LE_AUDIO_EVT_CONFIG_RECEIVED:
			LOG_DBG("LE audio config received");

			ret = unicast_server_config_get(msg.conn, msg.dir, &bitrate_bps,
							&sampling_rate_hz, NULL);
			if (ret) {
				LOG_WRN("Failed to get config: %d", ret);
				break;
			}

			LOG_DBG("\tSampling rate: %d Hz", sampling_rate_hz);
			LOG_DBG("\tBitrate (compressed): %d bps", bitrate_bps);

			if (msg.dir == BT_AUDIO_DIR_SINK) {
				ret = audio_system_config_set(VALUE_NOT_SET, VALUE_NOT_SET,
							      sampling_rate_hz);
				ERR_CHK(ret);
			} else if (msg.dir == BT_AUDIO_DIR_SOURCE) {
				ret = audio_system_config_set(sampling_rate_hz, bitrate_bps,
							      VALUE_NOT_SET);
				ERR_CHK(ret);
			}

			break;

		case LE_AUDIO_EVT_PRES_DELAY_SET:
			LOG_DBG("Set presentation delay");

			ret = unicast_server_config_get(msg.conn, BT_AUDIO_DIR_SINK, NULL, NULL,
							&pres_delay_us);
			if (ret) {
				LOG_ERR("Failed to get config: %d", ret);
				break;
			}

			ret = audio_datapath_pres_delay_us_set(pres_delay_us);
			if (ret) {
				LOG_ERR("Failed to set presentation delay to %d", pres_delay_us);
				break;
			}

			LOG_INF("Presentation delay %d us is set by initiator", pres_delay_us);

			break;

		case LE_AUDIO_EVT_NO_VALID_CFG:
			LOG_WRN("No valid configurations found, will disconnect");

			ret = bt_mgmt_conn_disconnect(msg.conn, BT_HCI_ERR_REMOTE_USER_TERM_CONN);
			if (ret) {
				LOG_ERR("Failed to disconnect: %d", ret);
			}

			break;

		default:
			LOG_WRN("Unexpected/unhandled le_audio event: %d", msg.event);

			break;
		}

		STACK_USAGE_PRINT("le_audio_msg_thread", &le_audio_msg_sub_thread_data);
	}
}

/**
 * @brief	Create zbus subscriber threads.
 *
 * @return	0 for success, error otherwise.
 */
static int zbus_subscribers_create(void)
{
	int ret;

	button_msg_sub_thread_id = k_thread_create(
		&button_msg_sub_thread_data, button_msg_sub_thread_stack,
		CONFIG_BUTTON_MSG_SUB_STACK_SIZE, (k_thread_entry_t)button_msg_sub_thread, NULL,
		NULL, NULL, K_PRIO_PREEMPT(CONFIG_BUTTON_MSG_SUB_THREAD_PRIO), 0, K_NO_WAIT);
	ret = k_thread_name_set(button_msg_sub_thread_id, "BUTTON_MSG_SUB");
	if (ret) {
		LOG_ERR("Failed to create button_msg thread");
		return ret;
	}

	le_audio_msg_sub_thread_id = k_thread_create(
		&le_audio_msg_sub_thread_data, le_audio_msg_sub_thread_stack,
		CONFIG_LE_AUDIO_MSG_SUB_STACK_SIZE, (k_thread_entry_t)le_audio_msg_sub_thread, NULL,
		NULL, NULL, K_PRIO_PREEMPT(CONFIG_LE_AUDIO_MSG_SUB_THREAD_PRIO), 0, K_NO_WAIT);
	ret = k_thread_name_set(le_audio_msg_sub_thread_id, "LE_AUDIO_MSG_SUB");
	if (ret) {
		LOG_ERR("Failed to create le_audio_msg thread");
		return ret;
	}

	return 0;
}

/**
 * @brief	Zbus listener to receive events from bt_mgmt.
 *
 * @param[in]	chan	Zbus channel.
 *
 * @note	Will in most cases be called from BT_RX context,
 *		so there should not be too much processing done here.
 */
static void bt_mgmt_evt_handler(const struct zbus_channel *chan)
{
	int ret;
	const struct bt_mgmt_msg *msg;

	msg = zbus_chan_const_msg(chan);

	switch (msg->event) {
	case BT_MGMT_CONNECTED:
		LOG_INF("Connected");

		break;

	case BT_MGMT_DISCONNECTED:
		LOG_INF("Disconnected");

		ret = bt_content_ctrl_conn_disconnected(msg->conn);
		if (ret) {
			LOG_ERR("Failed to handle disconnection in content control: %d", ret);
		}

		break;

	case BT_MGMT_SECURITY_CHANGED:
		LOG_INF("Security changed");

		ret = bt_rend_discover(msg->conn);
		if (ret) {
			LOG_WRN("Failed to discover rendering services");
		}

		ret = bt_content_ctrl_discover(msg->conn);
		if (ret == -EALREADY) {
			LOG_DBG("Discovery in progress or already done");
		} else if (ret) {
			LOG_ERR("Failed to start discovery of content control: %d", ret);
		}

		break;

	default:
		LOG_WRN("Unexpected/unhandled bt_mgmt event: %d", msg->event);

		break;
	}
}

ZBUS_LISTENER_DEFINE(bt_mgmt_evt_listen, bt_mgmt_evt_handler);

/**
 * @brief	Link zbus producers and observers.
 *
 * @return	0 for success, error otherwise.
 */
static int zbus_link_producers_observers(void)
{
	int ret;

	if (!IS_ENABLED(CONFIG_ZBUS)) {
		return -ENOTSUP;
	}

	ret = zbus_chan_add_obs(&button_chan, &button_evt_sub, ZBUS_ADD_OBS_TIMEOUT_MS);
	if (ret) {
		LOG_ERR("Failed to add button sub");
		return ret;
	}

	ret = zbus_chan_add_obs(&le_audio_chan, &le_audio_evt_sub, ZBUS_ADD_OBS_TIMEOUT_MS);
	if (ret) {
		LOG_ERR("Failed to add le_audio sub");
		return ret;
	}

	ret = zbus_chan_add_obs(&bt_mgmt_chan, &bt_mgmt_evt_listen, ZBUS_ADD_OBS_TIMEOUT_MS);
	if (ret) {
		LOG_ERR("Failed to add bt_mgmt sub");
		return ret;
	}

	ret = zbus_chan_add_obs(&volume_chan, &volume_evt_sub, ZBUS_ADD_OBS_TIMEOUT_MS);
	if (ret) {
		LOG_ERR("Failed to add volume sub");
		return ret;
	}

	return 0;
}

static int ext_adv_populate(struct bt_data *ext_adv_buf, size_t ext_adv_buf_size,
			    size_t *ext_adv_count)
{
	int ret;
	size_t ext_adv_buf_cnt = 0;

	NET_BUF_SIMPLE_DEFINE_STATIC(uuid_buf, CONFIG_EXT_ADV_UUID_BUF_MAX);

	ext_adv_buf[ext_adv_buf_cnt].type = BT_DATA_UUID16_SOME;
	ext_adv_buf[ext_adv_buf_cnt].data_len = 0;
	ext_adv_buf[ext_adv_buf_cnt].data = uuid_buf.data;
	ext_adv_buf_cnt++;

	ret = bt_rend_uuid_populate(&uuid_buf);

	if (ret) {
		LOG_ERR("Failed to add adv data from renderer: %d", ret);
		return ret;
	}

	ret = bt_content_ctrl_uuid_populate(&uuid_buf);

	if (ret) {
		LOG_ERR("Failed to add adv data from content ctrl: %d", ret);
		return ret;
	}

	ret = unicast_server_adv_populate(&ext_adv_buf[ext_adv_buf_cnt],
					  ext_adv_buf_size - ext_adv_buf_cnt);

	if (ret < 0) {
		LOG_ERR("Failed to add adv data from unicast server: %d", ret);
		return ret;
	}

	ext_adv_buf_cnt += ret;

	/* Add the number of UUIDs */
	ext_adv_buf[0].data_len = uuid_buf.len;

	LOG_DBG("Size of adv data: %d, num_elements: %d", sizeof(struct bt_data) * ext_adv_buf_cnt,
		ext_adv_buf_cnt);

	*ext_adv_count = ext_adv_buf_cnt;

	return 0;
}

uint8_t stream_state_get(void)
{
	return strm_state;
}

void streamctrl_send(void const *const data, size_t size, uint8_t num_ch)
{
	int ret;
	static int prev_ret;

	struct le_audio_encoded_audio enc_audio = {.data = data, .size = size, .num_ch = num_ch};

	if (strm_state == STATE_STREAMING) {
		ret = unicast_server_send(enc_audio);

		if (ret != 0 && ret != prev_ret) {
			if (ret == -ECANCELED) {
				LOG_WRN("Sending operation cancelled");
			} else {
				LOG_WRN("Problem with sending LE audio data, ret: %d", ret);
			}
		}

		prev_ret = ret;
	}
}

int main(void)
{
	int ret;
	static struct bt_data ext_adv_buf[CONFIG_EXT_ADV_BUF_MAX];

	LOG_DBG("nRF5340 APP core started");

	size_t ext_adv_buf_cnt = 0;

	ret = nrf5340_audio_dk_init();
	ERR_CHK(ret);

	ret = nrf5340_audio_common_init();
	ERR_CHK(ret);

	ret = zbus_subscribers_create();
	ERR_CHK_MSG(ret, "Failed to create zbus subscriber threads");

	ret = zbus_link_producers_observers();
	ERR_CHK_MSG(ret, "Failed to link zbus producers and observers");

	ret = le_audio_rx_init();
	ERR_CHK_MSG(ret, "Failed to initialize rx path");

	ret = unicast_server_enable(le_audio_rx_data_handler);
	ERR_CHK_MSG(ret, "Failed to enable LE Audio");

	ret = bt_rend_init();
	ERR_CHK(ret);

	ret = bt_content_ctrl_init();
	ERR_CHK(ret);

	ret = ext_adv_populate(ext_adv_buf, ARRAY_SIZE(ext_adv_buf), &ext_adv_buf_cnt);
	ERR_CHK(ret);

	ret = bt_mgmt_adv_start(ext_adv_buf, ext_adv_buf_cnt, NULL, 0, true);
	ERR_CHK(ret);

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/unicast_server/README.rst
.. _nrf53_audio_unicast_server_app:

nRF5340 Audio: Unicast server
#############################

.. contents::
   :local:
   :depth: 2

The nRF5340 Audio unicast server application implements the :ref:`CIS headset mode <nrf53_audio_app_overview>`.

In this mode, one Connected Isochronous Group (CIG) can be used with two Connected Isochronous Streams (CIS).
Receiving unidirectional or transceiving bidirectional audio happens using CIG and CIS.
In addition, Coordinated Set Identification Service (CSIS) is implemented on the server side.

The following limitations apply to this application:

* One CIG, one of the two CIS streams (selectable).
* Audio output: I2S/Analog headset output.
* Audio input: PDM microphone over I2S.
* Configuration: 16 bit, several bit rates ranging from 32 kbps to 124 kbps.

.. _nrf53_audio_unicast_server_app_requirements:

Requirements
************

The application shares the :ref:`requirements common to all nRF5340 Audio application <nrf53_audio_app_requirements>`.

.. _nrf53_audio_unicast_server_app_ui:

User interface
**************

Most of the user interface mappings are common across all nRF5340 Audio applications.
See the :ref:`nrf53_audio_app_ui` page for detailed overview.

This application uses specific mapping for the following user interface elements:

* Long-pressed on the unicast server device during startup:

  * **VOL-** - Changes the headset to the left channel one.
  * **VOL+** - Changes the headset to the right channel one.
  * **BTN5** - Clears the previously stored bonding information.

* Pressed on the unicast server device during playback:

  * **PLAY/PAUSE** - Starts or pauses the playback of the stream.
  * **VOL-** - Turns the playback volume down.
  * **VOL+** - Turns the playback volume up.
  * **BTN5** - Mutes the playback volume (and unmutes).

* **LED1** - Blinking blue - Kits have started streaming audio.
* **LED2** - Solid green - Sync achieved (both drift and presentation compensation are in the ``LOCKED`` state).
* **RGB**:

  * Solid blue - The device is programmed as the left headset.
  * Solid magenta - The device is programmed as the right headset.

.. _nrf53_audio_unicast_server_app_configuration:

Configuration
*************

By default, if you have not made any changes to :file:`.conf` files at :file:`applications/nrf5340_audio/`, the nRF5340 build script tries to build the CIS applications in the CIS unidirectional mode.
To switch to the bidirectional mode, see :ref:`nrf53_audio_app_configuration_select_bidirectional`.

For other configuration options, see :ref:`nrf53_audio_app_configuration` and :ref:`nrf53_audio_app_fota`.

For information about how to configure applications in the |NCS|, see :ref:`configure_application`.

.. _nrf53_audio_unicast_server_app_building:

Building and running
********************

This application can be found under :file:`applications/nrf5340_audio/unicast_server` in the nRF Connect SDK folder structure, but it uses :file:`.conf` files at :file:`applications/nrf5340_audio/`.

The nRF5340 Audio DK comes preprogrammed with basic firmware that indicates if the kit is functional.
See :ref:`nrf53_audio_app_dk_testing_out_of_the_box` for more information.

To build the application, see :ref:`nrf53_audio_app_building`.

.. _nrf53_audio_unicast_server_app_testing:

Testing
*******

After building and programming the application, you can test the default CIS headset mode using one :ref:`unicast client application <nrf53_audio_unicast_client_app>` and one or two unicast server devices (this application).
The recommended approach is to use two other nRF5340 Audio DKs programmed with the :ref:`unicast client application <nrf53_audio_unicast_client_app>` for the CIS gateway and the unicast server application (this application) for the CIS headset, respectively, but you can also use an external device that supports the role of unicast server.

.. note::
    |nrf5340_audio_external_devices_note|

The following testing scenario assumes you are using USB as the audio source on the gateway.
This is the default setting.

Complete the following steps to test the unidirectional CIS mode for one gateway and two headset devices:

1. Make sure that the development kits are still plugged into the USB ports and are turned on.

   .. note::
      |usb_known_issues|

   **LED3** starts blinking green on every device to indicate the ongoing CPU activity on the application core.
#. Wait for the **LED1** on the gateway to start blinking blue.
   This happens shortly after programming the development kit and indicates that the gateway device is connected to at least one headset and ready to send data.
#. Search the list of audio devices listed in the sound settings of your operating system for *nRF5340 USB Audio* (gateway) and select it as the output device.
#. Connect headphones to the **HEADPHONE** audio jack on both headset devices.
#. Start audio playback on your PC from any source.
#. Wait for **LED1** to blink blue on the headset.
   When they do, the audio stream has started on the headset.

   .. note::
      The audio outputs only to the left channel of the audio jack, even if the given headset is configured as the right headset.
      This is because of the mono hardware codec chip used on the development kits.
      If you want to play stereo sound using one development kit, you must connect an external hardware codec chip that supports stereo.

#. Wait for **LED2** to light up solid green on the headsets to indicate that the audio synchronization is achieved.
#. Press the **VOL+** button on one of the headsets.
   The playback volume increases for the headset.
#. If you use more than one headset, hold down the **VOL+** button and press the **RESET** button on a headset.
   After startup, this headset will be configured as the right channel headset.
#. If you use more than one headset, hold down the **VOL-** button and press the **RESET** button on a headset.
   After startup, this headset will be configured as the left channel headset.
   You can also just press the **RESET** button to restore the original programmed settings.

For other testing options, refer to :ref:`nrf53_audio_unicast_server_app_ui`.

After the kits have paired for the first time, they are now bonded.
This means the Long-Term Key (LTK) is stored on each side, and that the kits will only connect to each other unless the bonding information is cleared.
To clear the bonding information, press and hold **BTN 5** during boot or reprogram all the development kits.

When you finish testing, power off the nRF5340 Audio development kits by switching the power switch from On to Off.

.. _nrf53_audio_unicast_server_app_testing_steps_cis_walkie_talkie:

Testing the walkie-talkie demo
==============================

Testing the walkie-talkie demo is identical to the default testing procedure, except for the following differences:

* You must enable the Kconfig option mentioned in :ref:`nrf53_audio_app_configuration_enable_walkie_talkie` before building the application.
* Instead of controlling the playback, you can speak through the PDM microphones.
  The line is open all the time, no need to press any buttons to talk, but the volume control works as in the default testing procedure.

Dependencies
************

For the list of dependencies, check the application's source files.


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/broadcast_source/CMakeLists.txt
#
# Copyright (c) 2023 Nordic Semiconductor
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

target_sources(app PRIVATE
	       ${CMAKE_CURRENT_SOURCE_DIR}/main.c)


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/broadcast_source/Kconfig.defaults
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

## ISO related configs ##
config BT_CAP_INITIATOR
	default y

# Broadcasting Device - 0x0885
config BT_DEVICE_APPEARANCE
	default 2181

config BT_ISO_BROADCASTER
	default y

config BT_BAP_BROADCAST_SOURCE
	default y

config BT_ISO_TX_BUF_COUNT
	default 2

config BT_BAP_BROADCAST_SRC_STREAM_COUNT
	default 2

config BT_ISO_MAX_CHAN
	default 2

config BT_AUDIO_TX
	default y


## LC3 related configs ##
config LC3_BITRATE
	default BT_AUDIO_BITRATE_BROADCAST_SRC

config LC3_ENC_CHAN_MAX
	default 2


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/broadcast_source/main.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "streamctrl.h"

#include <zephyr/bluetooth/audio/audio.h>
#include <zephyr/kernel.h>
#include <zephyr/zbus/zbus.h>

#include "nrf5340_audio_common.h"
#include "nrf5340_audio_dk.h"
#include "broadcast_source.h"
#include "led.h"
#include "button_assignments.h"
#include "macros_common.h"
#include "audio_system.h"
#include "bt_mgmt.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(main, CONFIG_MAIN_LOG_LEVEL);

ZBUS_SUBSCRIBER_DEFINE(button_evt_sub, CONFIG_BUTTON_MSG_SUB_QUEUE_SIZE);

ZBUS_MSG_SUBSCRIBER_DEFINE(le_audio_evt_sub);

ZBUS_CHAN_DECLARE(button_chan);
ZBUS_CHAN_DECLARE(le_audio_chan);
ZBUS_CHAN_DECLARE(bt_mgmt_chan);
ZBUS_CHAN_DECLARE(sdu_ref_chan);

ZBUS_OBS_DECLARE(sdu_ref_msg_listen);

static struct k_thread button_msg_sub_thread_data;
static struct k_thread le_audio_msg_sub_thread_data;

static k_tid_t button_msg_sub_thread_id;
static k_tid_t le_audio_msg_sub_thread_id;

K_THREAD_STACK_DEFINE(button_msg_sub_thread_stack, CONFIG_BUTTON_MSG_SUB_STACK_SIZE);
K_THREAD_STACK_DEFINE(le_audio_msg_sub_thread_stack, CONFIG_LE_AUDIO_MSG_SUB_STACK_SIZE);

static enum stream_state strm_state = STATE_PAUSED;

/* Function for handling all stream state changes */
static void stream_state_set(enum stream_state stream_state_new)
{
	strm_state = stream_state_new;
}

/**
 * @brief	Handle button activity.
 */
static void button_msg_sub_thread(void)
{
	int ret;
	const struct zbus_channel *chan;

	while (1) {
		ret = zbus_sub_wait(&button_evt_sub, &chan, K_FOREVER);
		ERR_CHK(ret);

		struct button_msg msg;

		ret = zbus_chan_read(chan, &msg, ZBUS_READ_TIMEOUT_MS);
		ERR_CHK(ret);

		LOG_DBG("Got btn evt from queue - id = %d, action = %d", msg.button_pin,
			msg.button_action);

		if (msg.button_action != BUTTON_PRESS) {
			LOG_WRN("Unhandled button action");
			return;
		}

		switch (msg.button_pin) {
		case BUTTON_PLAY_PAUSE:
			if (strm_state == STATE_STREAMING) {
				ret = broadcast_source_stop();
				if (ret) {
					LOG_WRN("Failed to stop broadcaster: %d", ret);
				}
			} else if (strm_state == STATE_PAUSED) {
				ret = broadcast_source_start(NULL);
				if (ret) {
					LOG_WRN("Failed to start broadcaster: %d", ret);
				}
			} else {
				LOG_WRN("In invalid state: %d", strm_state);
			}

			break;

		case BUTTON_4:
			if (IS_ENABLED(CONFIG_AUDIO_TEST_TONE)) {
				if (strm_state != STATE_STREAMING) {
					LOG_WRN("Not in streaming state");
					break;
				}

				ret = audio_system_encode_test_tone_step();
				if (ret) {
					LOG_WRN("Failed to play test tone, ret: %d", ret);
				}

				break;
			}

			break;

		default:
			LOG_WRN("Unexpected/unhandled button id: %d", msg.button_pin);
		}

		STACK_USAGE_PRINT("button_msg_thread", &button_msg_sub_thread_data);
	}
}

/**
 * @brief	Handle Bluetooth LE audio events.
 */
static void le_audio_msg_sub_thread(void)
{
	int ret;
	const struct zbus_channel *chan;

	while (1) {
		struct le_audio_msg msg;

		ret = zbus_sub_wait_msg(&le_audio_evt_sub, &chan, &msg, K_FOREVER);
		ERR_CHK(ret);

		LOG_DBG("Received event = %d, current state = %d", msg.event, strm_state);

		switch (msg.event) {
		case LE_AUDIO_EVT_STREAMING:
			LOG_DBG("LE audio evt streaming");

			audio_system_encoder_start();

			if (strm_state == STATE_STREAMING) {
				LOG_DBG("Got streaming event in streaming state");
				break;
			}

			audio_system_start();
			stream_state_set(STATE_STREAMING);
			ret = led_blink(LED_APP_1_BLUE);
			ERR_CHK(ret);

			break;

		case LE_AUDIO_EVT_NOT_STREAMING:
			LOG_DBG("LE audio evt not_streaming");

			audio_system_encoder_stop();

			if (strm_state == STATE_PAUSED) {
				LOG_DBG("Got not_streaming event in paused state");
				break;
			}

			stream_state_set(STATE_PAUSED);
			audio_system_stop();
			ret = led_on(LED_APP_1_BLUE);
			ERR_CHK(ret);

			break;

		default:
			LOG_WRN("Unexpected/unhandled le_audio event: %d", msg.event);

			break;
		}

		STACK_USAGE_PRINT("le_audio_msg_thread", &le_audio_msg_sub_thread_data);
	}
}

/**
 * @brief	Create zbus subscriber threads.
 *
 * @return	0 for success, error otherwise.
 */
static int zbus_subscribers_create(void)
{
	int ret;

	button_msg_sub_thread_id = k_thread_create(
		&button_msg_sub_thread_data, button_msg_sub_thread_stack,
		CONFIG_BUTTON_MSG_SUB_STACK_SIZE, (k_thread_entry_t)button_msg_sub_thread, NULL,
		NULL, NULL, K_PRIO_PREEMPT(CONFIG_BUTTON_MSG_SUB_THREAD_PRIO), 0, K_NO_WAIT);
	ret = k_thread_name_set(button_msg_sub_thread_id, "BUTTON_MSG_SUB");
	if (ret) {
		LOG_ERR("Failed to create button_msg thread");
		return ret;
	}

	le_audio_msg_sub_thread_id = k_thread_create(
		&le_audio_msg_sub_thread_data, le_audio_msg_sub_thread_stack,
		CONFIG_LE_AUDIO_MSG_SUB_STACK_SIZE, (k_thread_entry_t)le_audio_msg_sub_thread, NULL,
		NULL, NULL, K_PRIO_PREEMPT(CONFIG_LE_AUDIO_MSG_SUB_THREAD_PRIO), 0, K_NO_WAIT);
	ret = k_thread_name_set(le_audio_msg_sub_thread_id, "LE_AUDIO_MSG_SUB");
	if (ret) {
		LOG_ERR("Failed to create le_audio_msg thread");
		return ret;
	}

	ret = zbus_chan_add_obs(&sdu_ref_chan, &sdu_ref_msg_listen, ZBUS_ADD_OBS_TIMEOUT_MS);
	if (ret) {
		LOG_ERR("Failed to add timestamp listener");
		return ret;
	}

	return 0;
}

/**
 * @brief	Zbus listener to receive events from bt_mgmt.
 *
 * @param[in]	chan	Zbus channel.
 *
 * @note	Will in most cases be called from BT_RX context,
 *		so there should not be too much processing done here.
 */
static void bt_mgmt_evt_handler(const struct zbus_channel *chan)
{
	int ret;
	const struct bt_mgmt_msg *msg;

	msg = zbus_chan_const_msg(chan);

	switch (msg->event) {
	case BT_MGMT_EXT_ADV_WITH_PA_READY:
		LOG_INF("Ext adv ready");

		ret = broadcast_source_start(msg->ext_adv);
		if (ret) {
			LOG_ERR("Failed to start broadcaster: %d", ret);
		}

		break;

	default:
		LOG_WRN("Unexpected/unhandled bt_mgmt event: %d", msg->event);
		break;
	}
}

ZBUS_LISTENER_DEFINE(bt_mgmt_evt_listen, bt_mgmt_evt_handler);

/**
 * @brief	Link zbus producers and observers.
 *
 * @return	0 for success, error otherwise.
 */
static int zbus_link_producers_observers(void)
{
	int ret;

	if (!IS_ENABLED(CONFIG_ZBUS)) {
		return -ENOTSUP;
	}

	ret = zbus_chan_add_obs(&button_chan, &button_evt_sub, ZBUS_ADD_OBS_TIMEOUT_MS);
	if (ret) {
		LOG_ERR("Failed to add button sub");
		return ret;
	}

	ret = zbus_chan_add_obs(&le_audio_chan, &le_audio_evt_sub, ZBUS_ADD_OBS_TIMEOUT_MS);
	if (ret) {
		LOG_ERR("Failed to add le_audio sub");
		return ret;
	}

	ret = zbus_chan_add_obs(&bt_mgmt_chan, &bt_mgmt_evt_listen, ZBUS_ADD_OBS_TIMEOUT_MS);
	if (ret) {
		LOG_ERR("Failed to add bt_mgmt listener");
		return ret;
	}

	return 0;
}

uint8_t stream_state_get(void)
{
	return strm_state;
}

void streamctrl_send(void const *const data, size_t size, uint8_t num_ch)
{
	int ret;
	static int prev_ret;

	struct le_audio_encoded_audio enc_audio = {.data = data, .size = size, .num_ch = num_ch};

	if (strm_state == STATE_STREAMING) {
		ret = broadcast_source_send(enc_audio);

		if (ret != 0 && ret != prev_ret) {
			if (ret == -ECANCELED) {
				LOG_WRN("Sending operation cancelled");
			} else {
				LOG_WRN("Problem with sending LE audio data, ret: %d", ret);
			}
		}

		prev_ret = ret;
	}
}

int main(void)
{
	int ret;
	static const struct bt_data *ext_adv;
	static const struct bt_data *per_adv;

	LOG_DBG("nRF5340 APP core started");

	ret = nrf5340_audio_dk_init();
	ERR_CHK(ret);

	ret = nrf5340_audio_common_init();
	ERR_CHK(ret);

	size_t ext_adv_size = 0;
	size_t per_adv_size = 0;

	ret = zbus_subscribers_create();
	ERR_CHK_MSG(ret, "Failed to create zbus subscriber threads");

	ret = zbus_link_producers_observers();
	ERR_CHK_MSG(ret, "Failed to link zbus producers and observers");

	ret = broadcast_source_enable();
	ERR_CHK_MSG(ret, "Failed to enable broadcaster");

	ret = audio_system_config_set(
		bt_audio_codec_cfg_freq_to_freq_hz(CONFIG_BT_AUDIO_PREF_SAMPLE_RATE_VALUE),
		CONFIG_BT_AUDIO_BITRATE_BROADCAST_SRC, VALUE_NOT_SET);
	ERR_CHK_MSG(ret, "Failed to set sample- and bitrate");

	broadcast_source_adv_get(&ext_adv, &ext_adv_size, &per_adv, &per_adv_size);

	ret = bt_mgmt_adv_start(ext_adv, ext_adv_size, per_adv, per_adv_size, false);
	ERR_CHK_MSG(ret, "Failed to start advertiser");

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/broadcast_source/README.rst
.. _nrf53_audio_broadcast_source_app:

nRF5340 Audio: Broadcast source
###############################

.. contents::
   :local:
   :depth: 2

The nRF5340 Audio broadcast source application implements the :ref:`BIS gateway mode <nrf53_audio_app_overview>`.

In this mode, transmitting broadcast audio happens using Broadcast Isochronous Stream (BIS) and Broadcast Isochronous Group (BIG).
Play and pause are emulated by enabling and disabling stream, respectively.

The following limitations apply to this application:

* One BIG with two BIS streams.
* Audio input: USB or I2S (Line in or using Pulse Density Modulation).
* Configuration: 16 bit, several bit rates ranging from 32 kbps to 124 kbps.

.. _nrf53_audio_broadcast_source_app_requirements:

Requirements
************

The application shares the :ref:`requirements common to all nRF5340 Audio application <nrf53_audio_app_requirements>`.

.. _nrf53_audio_broadcast_source_app_ui:

User interface
**************

Most of the user interface mappings are common across all nRF5340 Audio applications.
See the :ref:`nrf53_audio_app_ui` page for detailed overview.

This application uses specific mapping for the following user interface elements:

* Pressed on the broadcast source device during playback:

  * **PLAY/PAUSE** - Starts or pauses the playback of the stream.
  * **BTN 4** -  Toggles between the normal audio stream and different test tones generated on the device.
    Use this tone to check the synchronization of headsets.

* **LED1** - Blinking blue - Device has started broadcasting audio.
* **RGB** - Solid green - The device is programmed as the gateway.

.. _nrf53_audio_broadcast_source_app_configuration:

Configuration
*************

The application requires the ``CONFIG_TRANSPORT_BIS`` Kconfig option to be set to ``y`` in the :file:`applications/nrf5340_audio/prj.conf` file for `Building and running`_ to succeed.

For other configuration options, see :ref:`nrf53_audio_app_configuration` and :ref:`nrf53_audio_app_fota`.

For information about how to configure applications in the |NCS|, see :ref:`configure_application`.

.. _nrf53_audio_broadcast_source_app_building:

Building and running
********************

This application can be found under :file:`applications/nrf5340_audio/broadcast_source` in the nRF Connect SDK folder structure, but it uses :file:`.conf` files at :file:`applications/nrf5340_audio/`.

The nRF5340 Audio DK comes preprogrammed with basic firmware that indicates if the kit is functional.
See :ref:`nrf53_audio_app_dk_testing_out_of_the_box` for more information.

To build the application, complete the following steps:

1. Select the BIS mode by setting the ``CONFIG_TRANSPORT_BIS`` Kconfig option to ``y`` in the :file:`applications/nrf5340_audio/prj.conf` file for the debug version and in the :file:`applications/nrf5340_audio/prj_release.conf` file for the release version.
#. Complete the steps for building and programming common to all audio applications using one of the following methods:

   * :ref:`nrf53_audio_app_building_script`
   * :ref:`nrf53_audio_app_building_standard`

After programming, the broadcast source automatically starts broadcasting the default 48-kHz audio stream.

.. _nrf53_audio_broadcast_source_app_testing:

Testing
*******

.. note::
    |nrf5340_audio_external_devices_note|

To test the broadcast source application, complete the following steps:

1. Make sure you have another nRF5340 Audio DK for testing purposes.
#. Program the other DK with the :ref:`broadcast sink <nrf53_audio_broadcast_sink_app>` application.
   The broadcast sink device automatically synchronizes with the broadcast source after programming.
#. Proceed to testing the broadcast source using the :ref:`nrf53_audio_broadcast_source_app_ui` buttons and LEDs.

Dependencies
************

For the list of dependencies, check the application's source files.


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/doc/user_interface.rst
.. _nrf53_audio_app_ui:

User interface
##############

.. contents::
   :local:
   :depth: 2

All nRF5340 Audio applications implement the same, simple user interface based on the available PCB elements of the nRF5340 Audio development kit.
You can control the application using predefined switches and buttons while the LEDs display information.

Some user interface options are only valid for some nRF5340 Audio applications.

.. _nrf53_audio_app_ui_switches:

Switches
********

The application uses the following switches on the supported development kit:

+-------------------+-------------------------------------------------------------------------------------+---------------------------------------+
| Switch            | Function                                                                            | Applications                          |
+===================+=====================================================================================+=======================================+
| **POWER**         | Turns the development kit on or off.                                                | All                                   |
+-------------------+-------------------------------------------------------------------------------------+---------------------------------------+
| **DEBUG ENABLE**  | Turns on or off power for debug features.                                           | All                                   |
|                   | This switch is used for accurate power and current measurements.                    |                                       |
+-------------------+-------------------------------------------------------------------------------------+---------------------------------------+

.. _nrf53_audio_app_ui_buttons:

Buttons
*******

The application uses the following buttons on the supported development kit:

+---------------+-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
| Button        | Function                                                                                                  | Applications                                |
+===============+===========================================================================================================+=============================================+
| **VOL-**      | Long-pressed during startup: Changes the headset to the left channel one.                                 | * :ref:`nrf53_audio_broadcast_sink_app`     |
|               |                                                                                                           | * :ref:`nrf53_audio_unicast_server_app`     |
|               +-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
|               | Pressed on the headset or the CIS gateway during playback: Turns the playback volume down.                | * :ref:`nrf53_audio_broadcast_sink_app`     |
|               |                                                                                                           | * :ref:`nrf53_audio_unicast_server_app`     |
|               |                                                                                                           | * :ref:`nrf53_audio_unicast_client_app`     |
+---------------+-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
| **VOL+**      | Long-pressed during startup: Changes the headset to the right channel one.                                | * :ref:`nrf53_audio_broadcast_sink_app`     |
|               |                                                                                                           | * :ref:`nrf53_audio_unicast_server_app`     |
|               +-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
|               | Pressed on the headset or the CIS gateway during playback: Turns the playback volume up.                  | * :ref:`nrf53_audio_broadcast_sink_app`     |
|               |                                                                                                           | * :ref:`nrf53_audio_unicast_server_app`     |
|               |                                                                                                           | * :ref:`nrf53_audio_unicast_client_app`     |
+---------------+-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
| **PLAY/PAUSE**| Starts or pauses the playback of the stream or listening to the stream.                                   | All                                         |
+---------------+-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
| **BTN 4**     | Long-pressed during startup: Turns on the DFU mode, if                                                    | All                                         |
|               | the device is :ref:`configured for it<nrf53_audio_app_configuration_configure_fota>`.                     |                                             |
|               +-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
|               | Pressed on the gateway during playback: Toggles between the normal audio stream and different test        | * :ref:`nrf53_audio_broadcast_source_app`   |
|               | tones generated on the device. Use this tone to check the synchronization of headsets.                    | * :ref:`nrf53_audio_unicast_client_app`     |
|               +-----------------------------------------------------------------------------------------------------------+                                             |
|               | Pressed on the gateway during playback multiple times: Changes the test tone frequency.                   |                                             |
|               | The available values are 1000 Hz, 2000 Hz, and 4000 Hz.                                                   |                                             |
|               +-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
|               | Pressed on a BIS headset during playback: Change stream (different BIS), if more than one is available.   | :ref:`nrf53_audio_broadcast_sink_app`       |
+---------------+-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
| **BTN 5**     | Long-pressed during startup: Clears the previously stored bonding information.                            | * :ref:`nrf53_audio_unicast_server_app`     |
|               |                                                                                                           | * :ref:`nrf53_audio_unicast_client_app`     |
|               +-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
|               | Pressed during playback: Mutes the playback volume.                                                       | * :ref:`nrf53_audio_unicast_server_app`     |
|               |                                                                                                           | * :ref:`nrf53_audio_unicast_client_app`     |
|               +-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
|               | Pressed on a BIS headset during playback: Change the gateway, if more than one is available.              | :ref:`nrf53_audio_broadcast_sink_app`       |
+---------------+-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
| **RESET**     | Resets the device to the originally programmed settings.                                                  | All                                         |
|               | This reverts any changes made during testing, for example the channel switches with **VOL** buttons.      |                                             |
+---------------+-----------------------------------------------------------------------------------------------------------+---------------------------------------------+

.. _nrf53_audio_app_ui_leds:

LEDs
****

To indicate the tasks performed, the application uses the LED behavior described in the following table:

+--------------------------+-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
| LED                      |Indication                                                                                                 | Applications                                |
+==========================+===========================================================================================================+=============================================+
| **LED1**                 | Off - No Bluetooth connection.                                                                            | All                                         |
|                          +-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
|                          | Solid blue on the CIS gateway and headset: Kits have connected.                                           | * :ref:`nrf53_audio_unicast_server_app`     |
|                          |                                                                                                           | * :ref:`nrf53_audio_unicast_client_app`     |
|                          +-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
|                          | Solid blue on the BIS headset: Kits have found a broadcasting stream.                                     | :ref:`nrf53_audio_broadcast_sink_app`       |
|                          +-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
|                          | Blinking blue on headset: Kits have started streaming audio (BIS and CIS modes).                          | * :ref:`nrf53_audio_broadcast_sink_app`     |
|                          |                                                                                                           | * :ref:`nrf53_audio_unicast_server_app`     |
|                          +-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
|                          | Blinking blue on the CIS gateway: Kit is streaming to a headset.                                          | :ref:`nrf53_audio_unicast_client_app`       |
|                          +-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
|                          | Blinking blue on the BIS gateway: Kit has started broadcasting audio.                                     | :ref:`nrf53_audio_broadcast_source_app`     |
+--------------------------+-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
| **LED2**                 | Off - Sync not achieved.                                                                                  | All                                         |
|                          +-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
|                          | Solid green - Sync achieved (both drift and presentation compensation are in the ``LOCKED`` state).       | * :ref:`nrf53_audio_broadcast_sink_app`     |
|                          |                                                                                                           | * :ref:`nrf53_audio_unicast_server_app`     |
+--------------------------+-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
| **LED3**                 | Blinking green - The nRF5340 Audio DK application core is running.                                        | All                                         |
+--------------------------+-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
| **CODEC**                | Off - No configuration loaded to the onboard hardware codec.                                              | All                                         |
|                          +-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
|                          | Solid green - Hardware codec configuration loaded.                                                        | All                                         |
+--------------------------+-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
| **RGB**                  | Solid green - The device is programmed as the gateway.                                                    | * :ref:`nrf53_audio_broadcast_source_app`   |
|                          |                                                                                                           | * :ref:`nrf53_audio_unicast_client_app`     |
| (bottom side LEDs around +-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
| the center opening)      | Solid blue - The device is programmed as the left headset.                                                | * :ref:`nrf53_audio_broadcast_sink_app`     |
|                          |                                                                                                           | * :ref:`nrf53_audio_unicast_server_app`     |
|                          +-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
|                          | Solid magenta - The device is programmed as the right headset.                                            | * :ref:`nrf53_audio_broadcast_sink_app`     |
|                          |                                                                                                           | * :ref:`nrf53_audio_unicast_server_app`     |
|                          +-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
|                          | Solid yellow - The device is programmed with factory firmware.                                            | All                                         |
|                          | It must be re-programmed as gateway or headset.                                                           |                                             |
|                          +-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
|                          | Solid red (debug mode) - Fault in the application core has occurred.                                      | All                                         |
|                          | See UART log for details and use the **RESET** button to reset the device.                                |                                             |
|                          | In the release mode, the device resets automatically with no indication on LED or UART.                   |                                             |
+--------------------------+-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
| **ERR**                  | PMIC error or a charging error (or both).                                                                 | All                                         |
|                          | Also turns on when charging the battery exceeds seven hours, since the PMIC has a protection timeout,     |                                             |
|                          | which stops the charging.                                                                                 |                                             |
+--------------------------+-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
| **CHG**                  | Off - Charge completed or no battery connected.                                                           | All                                         |
|                          +-----------------------------------------------------------------------------------------------------------+                                             |
|                          | Solid yellow - Charging in progress.                                                                      |                                             |
+--------------------------+-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
| **OB/EXT**               | Off - No 3.3 V power available.                                                                           | All                                         |
|                          +-----------------------------------------------------------------------------------------------------------+                                             |
|                          | Solid green - On-board hardware codec selected.                                                           |                                             |
|                          +-----------------------------------------------------------------------------------------------------------+                                             |
|                          | Solid yellow - External hardware codec selected.                                                          |                                             |
|                          | This LED turns solid yellow also when the devices are reset, for the time then pins are floating.         |                                             |
+--------------------------+-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
| **FTDI SPI**             | Off - No data is written to the hardware codec using SPI.                                                 | All                                         |
|                          +-----------------------------------------------------------------------------------------------------------+                                             |
|                          | Yellow - The same SPI is used for both the hardware codec and the SD card.                                |                                             |
|                          | When this LED is yellow, the shared SPI is used by the FTDI to write data to the hardware codec.          |                                             |
+--------------------------+-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
| **IFMCU**                | Off - No PC connection available.                                                                         | All                                         |
| (bottom side)            +-----------------------------------------------------------------------------------------------------------+                                             |
|                          | Solid green - Connected to PC.                                                                            |                                             |
|                          +-----------------------------------------------------------------------------------------------------------+                                             |
|                          | Rapid green flash - USB enumeration failed.                                                               |                                             |
+--------------------------+-----------------------------------------------------------------------------------------------------------+---------------------------------------------+
| **HUB**                  | Off - No PC connection available.                                                                         | All                                         |
| (bottom side)            +-----------------------------------------------------------------------------------------------------------+                                             |
|                          | Green - Standard USB hub operation.                                                                       |                                             |
+--------------------------+-----------------------------------------------------------------------------------------------------------+---------------------------------------------+


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/doc/configuration.rst
.. _nrf53_audio_app_configuration:

Configuring the nRF5340 Audio applications
##########################################

.. contents::
   :local:
   :depth: 2

|config|

.. _nrf53_audio_app_configuration_select_bidirectional:

Selecting the CIS bidirectional communication
*********************************************

By default, if you have not made any changes to :file:`.conf` files at :file:`applications/nrf5340_audio/`, the nRF5340 build script tries to build the CIS applications in the CIS unidirectional mode.
To switch to the bidirectional mode, set the ``CONFIG_STREAM_BIDIRECTIONAL`` Kconfig option to ``y``  in the :file:`applications/nrf5340_audio/prj.conf` file (for the debug version) or in the :file:`applications/nrf5340_audio/prj_release.conf` file (for the release version).

.. _nrf53_audio_app_configuration_enable_walkie_talkie:

Enabling the walkie-talkie demo
===============================

The walkie-talkie demo uses one or two bidirectional streams from the gateway to one or two headsets.
The PDM microphone is used as input on both the gateway and headset device.
To switch to using the walkie-talkie, set the ``CONFIG_WALKIE_TALKIE_DEMO`` Kconfig option to ``y``  in the :file:`applications/nrf5340_audio/prj.conf` file (for the debug version) or in the :file:`applications/nrf5340_audio/prj_release.conf` file (for the release version).

.. _nrf53_audio_app_configuration_select_bis_two_gateways:

Enabling the BIS mode with two gateways
***************************************

In addition to the standard BIS mode with one gateway, you can also add a second gateway device.
The BIS headsets can then switch between the two gateways and receive audio stream from one of the two gateways.

To configure the second gateway, add both the ``CONFIG_TRANSPORT_BIS`` and the ``CONFIG_BT_AUDIO_USE_BROADCAST_NAME_ALT`` Kconfig options set to ``y`` to the :file:`applications/nrf5340_audio/prj.conf` file for the debug version and to the :file:`applications/nrf5340_audio/prj_release.conf` file for the release version.
You can provide an alternative name to the second gateway using the ``CONFIG_BT_AUDIO_BROADCAST_NAME_ALT`` or use the default alternative name.

You build each BIS gateway separately using the normal procedures from :ref:`nrf53_audio_app_building`.
After building the first gateway, configure the required Kconfig options for the second gateway and build the second gateway firmware.
Remember to program the two firmware versions to two separate gateway devices.

.. _nrf53_audio_app_configuration_select_i2s:

Selecting the analog jack input using I2S
*****************************************

In the default configuration, the gateway application uses USB as the audio source.
The :ref:`nrf53_audio_app_building` and the testing steps also refer to using the USB serial connection.

To switch to using the 3.5 mm jack analog input, set the ``CONFIG_AUDIO_SOURCE_I2S`` Kconfig option to ``y`` in the :file:`applications/nrf5340_audio/prj.conf` file for the debug version and in the :file:`applications/nrf5340_audio/prj_release.conf` file for the release version.

When testing the application, an additional audio jack cable is required to use I2S.
Use this cable to connect the audio source (PC) to the analog **LINE IN** on the development kit.

.. _nrf53_audio_app_adding_FEM_support:

Adding FEM support
******************

You can add support for the nRF21540 front-end module (FEM) to the following nRF5340 Audio applications:

* :ref:`Broadcast source <nrf53_audio_broadcast_source_app>`
* :ref:`Unicast client <nrf53_audio_unicast_client_app>`
* :ref:`Unicast server <nrf53_audio_unicast_server_app>`

The :ref:`broadcast sink application <nrf53_audio_broadcast_sink_app>` does not need FEM support as it only receives data.

Adding FEM support happens when :ref:`nrf53_audio_app_building`.
You can use one of the following options, depending on how you decide to build the application:

* If you opt for :ref:`nrf53_audio_app_building_script`, add the ``--nrf21540`` to the script's building command.
* If you opt for :ref:`nrf53_audio_app_building_standard`, add the ``-DSHIELD=nrf21540ek_fwd`` to the ``west build`` command.
  For example:

  .. code-block:: console

     west build -b nrf5340_audio_dk_nrf5340_cpuapp --pristine -- -DCONFIG_AUDIO_DEV=1 -DSHIELD=nrf21540ek_fwd -DCONF_FILE=prj_release.conf

To set the TX power output, use the ``CONFIG_NRF_21540_MAIN_TX_POWER`` and ``CONFIG_NRF_21540_PRI_ADV_TX_POWER`` Kconfig options.

.. note::
   When you build the nRF5340 Audio application with the nRF21540 FEM support, the :ref:`lib_bt_ll_acs_nrf53_readme` does not support the +20 dBm setting.
   This is because of a power class restriction in the controller's QDID.

See :ref:`ug_radio_fem` for more information about FEM in the |NCS|.


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/doc/fota.rst
.. _nrf53_audio_app_fota:

Configuring and testing FOTA upgrades for nRF5340 Audio applications
####################################################################

.. contents::
   :local:
   :depth: 2

All nRF5340 Audio applications share the same configuration and testing procedures for FOTA upgrades.

Requirements for FOTA
*********************

To test Firmware Over-The-Air (FOTA), you need an Android or iOS device with the `nRF Connect Device Manager`_ app installed.

To enable the external flash DFU and do FOTA upgrades for the application core and the network core at the same time, you need an external flash shield.
See `Requirements for external flash memory DFU`_ in the nRF5340 Audio DK Hardware documentation for more information.

.. _nrf53_audio_app_configuration_configure_fota:

Configuring FOTA upgrades
*************************

.. caution::
	Firmware based on the |NCS| versions earlier than v2.1.0 does not support DFU.
	FOTA is not available for those versions.

	You can test performing separate application and network core upgrades, but for production, both cores must be updated at the same time.
	When updates take place in the inter-core communication module (HCI IPC), communication between the cores will break if they are not updated together.

You can configure Firmware Over-The-Air (FOTA) upgrades to replace the applications on both the application core and the network core.
The nRF5340 Audio applications support the following types of DFU flash memory layouts:

* Internal flash memory layout - which supports only single-image DFU.
* External flash memory layout - which supports :ref:`multi-image DFU <ug_nrf5340_multi_image_dfu>`.

The LE Audio Controller Subsystem for nRF53 supports both the normal and minimal sizes of the bootloader.
The minimal size is specified using the :kconfig:option:`CONFIG_NETBOOT_MIN_PARTITION_SIZE`.

Enabling FOTA upgrades
**********************

The FOTA upgrades are only available when :ref:`nrf53_audio_app_building_script`.
With the appropriate parameters provided, the :file:`buildprog.py` Python script will add overlay files for the given DFU type.
To enable the desired FOTA functions:

* To define flash memory layout, include the ``-m internal`` parameter for the internal layout (when using the ``release`` application version) or the ``-m external`` parameter for the external layout (when using either ``release`` or ``debug``).
* To use the minimal size network core bootloader, add the ``-M`` parameter.

For the full list of parameters and examples, see the :ref:`nrf53_audio_app_building_script_running` section.

FOTA build files
================

The generated FOTA build files use the following naming patterns:

* For multi-image DFU, the file is called ``dfu_application.zip``.
  This file updates two cores with one single file.
* For single-image DFU, the bin file for the application core is called ``app_update.bin``.
  The bin file for the network core is called ``net_core_app_update.bin``.
  In this scenario, the cores are updated one by one with two separate files in two actions.

See :ref:`app_build_output_files` for more information about the image files.

Entering the DFU mode
=====================

The |NCS| uses :ref:`SMP server and mcumgr <zephyr:device_mgmt>` as the DFU backend.
Unlike the CIS and BIS modes for gateway and headsets, the DFU mode is advertising using the SMP server service.
For this reason, to enter the DFU mode, you must long press **BTN 4** during each device startup to have the nRF5340 Audio DK enter the DFU mode.

To identify the devices before the DFU takes place, the DFU mode advertising names mention the device type directly.
The names follow the pattern in which the device *ROLE* is inserted before the ``_DFU`` suffix.
For example:

* Gateway: ``NRF5340_AUDIO_GW_DFU``
* Left Headset: ``NRF5340_AUDIO_HL_DFU``
* Right Headset: ``NRF5340_AUDIO_HR_DFU``

The first part of these names is based on :kconfig:option:`CONFIG_BT_DEVICE_NAME`.

.. note::
   When performing DFU for the nRF5340 Audio applications, there will be one or more error prints related to opening flash area ID 1.
   This is due to restrictions in the DFU system, and the error print is expected.
   The DFU process should still complete successfully.

.. _nrf53_audio_unicast_client_app_testing_steps_fota:

Testing FOTA upgrades
*********************

`nRF Connect Device Manager`_ can be used for testing FOTA upgrades.
The procedure for upgrading the firmware is identical for all applications.

Testing FOTA upgrades on a headset device
=========================================

You can test upgrading the firmware on both cores at the same time on a headset device by completing the following steps:

1. Make sure you have :ref:`configured the application for FOTA <nrf53_audio_app_configuration_configure_fota>`.
#. Install `nRF Connect Device Manager`_ on your Android or iOS device.
#. Connect an external flash shield to the headset.
#. Make sure the headset runs a firmware that supports DFU using external flash memory.
   One way of doing this is to connect the headset to the USB port, turn it on, and then run this command:

   .. code-block:: console

      python buildprog.py -c both -b debug -d headset --pristine -m external -p

   .. note::
      When using the FOTA related functionality in the :file:`buildprog.py` script on Linux, the ``python`` command must execute Python 3.

#. Use the :file:`buildprog.py` script to create a zip file that contains new firmware for both cores:

   .. code-block:: console

      python buildprog.py -c both -b debug -d headset --pristine -m external

#. Transfer the generated file to your Android or iOS device, depending on the DFU scenario.
   See the `FOTA build files`_ section for information about FOTA file name patterns.
   For transfer, you can use cloud services like Google Drive for Android or iCloud for iOS.
#. Enter the DFU mode by pressing and holding down **RESET** and **BTN 4** at the same time, and then releasing **RESET** while continuing to hold down **BTN 4** for a couple more seconds.
#. Open `nRF Connect Device Manager`_ and look for ``NRF5340_AUDIO_HL_DFU`` in the scanned devices window.
   The headset is left by default.
#. Tap on :guilabel:`NRF5340_AUDIO_HL_DFU` and then on the downward arrow icon at the bottom of the screen.
#. In the :guilabel:`Firmware Upgrade` section, tap :guilabel:`SELECT FILE`.
#. Select the file you transferred to the device.
#. Tap :guilabel:`START` and check :guilabel:`Confirm only` in the notification.
#. Tap :guilabel:`START` again to start the DFU process.
#. When the DFU has finished, verify that the new application core and network core firmware works properly.


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/doc/requirements.rst
.. _nrf53_audio_app_requirements:

nRF5340 Audio application requirements
######################################

.. contents::
   :local:
   :depth: 2

The nRF5340 Audio applications are designed to be used only with the following hardware:

.. table-from-rows:: /includes/sample_board_rows.txt
   :header: heading
   :rows: nrf5340_audio_dk_nrf5340

.. note::
   The applications supports PCA10121 revisions 1.0.0 or above.
   The applications are also compatible with the following pre-launch revisions:

   * Revisions 0.8.0 and above.

You need at least two nRF5340 Audio development kits (one with the gateway firmware and one with headset firmware) to test each of the applications.
For CIS with TWS in mind, three kits are required.

If you want to test with other hardware (for example, a mobile phone or PC), it is highly recommended to test with Audio DKs on both the gateway and headset side first to verify basic functionality before moving on to testing with other vendors.

.. _nrf53_audio_app_requirements_codec:

Software codec requirements
***************************

The nRF5340 Audio applications only support the :ref:`LC3 software codec <nrfxlib:lc3>`, developed specifically for use with LE Audio.

The applications can be configured for other alternative codecs, but this integration is beyond the scope of this documentation.

.. _nrf53_audio_app_dk:
.. _nrf53_audio_app_dk_features:

nRF5340 Audio development kit
*****************************

The nRF5340 Audio development kit is a hardware development platform that demonstrates the nRF5340 Audio applications.
Read the `nRF5340 Audio DK Hardware`_ documentation on Nordic Semiconductor Infocenter for more information about this development kit.

You can :ref:`test the DK out of the box <nrf53_audio_app_dk_testing_out_of_the_box>` before you program it.

.. _nrf53_audio_app_configuration_files:

nRF5340 Audio configuration files
*********************************

All applications use the :file:`Kconfig.defaults` located in the :file:`nrf5340_audio` directory.
Additionally, each nRF5340 Audio application uses its own, application-specific :file:`Kconfig.defaults` file from the application directory, which includes configuration specific to the given application.
These files change the configuration defaults automatically, based on the different application versions and device types.

For each application, only one of the following :file:`.conf` files is included when building:

* :file:`prj.conf` is the default configuration file and it implements the debug application version.
* :file:`prj_release.conf` is the optional configuration file and it implements the release application version.
  No debug features are enabled in the release application version.
  When building using the command line, you must explicitly specify if :file:`prj_release.conf` is going to be included instead of :file:`prj.conf`.
  See :ref:`nrf53_audio_app_building` for details.

In addition, the application features the :file:`child_image` directory with :file:`hci_ipc.conf`.
This file contains the necessary configurations for nRF5340 Audio applications to run the :ref:`bluetooth-hci-ipc-sample` sample with :ref:`SoftDevice Controller for LE Isochronous Channels <nrfxlib:softdevice_controller_iso>` support.


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/doc/feature_support.rst
.. _nrf53_audio_app_dk_legal:
.. _nrf53_audio_feature_support:

nRF5340 Audio feature support and QDIDs
#######################################

.. contents::
   :local:
   :depth: 2

The following table lists features of the nRF5340 Audio application and their respective limitations and maturity level.
For an explanation of the maturity levels, see :ref:`Software maturity levels <software_maturity>`.

.. note::
   Features not listed are not supported.

.. include:: /releases_and_maturity/software_maturity.rst
   :start-after: software_maturity_application_nrf5340audio_table:
   :end-before: software_maturity_protocol

nRF5340 Audio QDIDs
*******************

The following QDIDs are related to the nRF5340 Audio application:

.. ncs-include:: lc3/README.rst
   :docset: nrfxlib
   :start-after: lc3_qdid_start
   :end-before: lc3_qdid_end

.. include:: /libraries/bin/bt_ll_acs_nrf53/index.rst
   :start-after: le_audio_controller_qdid_start
   :end-before: le_audio_controller_qdid_end


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/doc/firmware_architecture.rst
.. _nrf53_audio_app_overview:

nRF5340 Audio overview and firmware architecture
################################################

.. contents::
   :local:
   :depth: 2

Each nRF5340 Audio application corresponds to one specific LE Audio role: unicast client (gateway), unicast server (headset), broadcast source (gateway), or broadcast sink (headset).
The gateway receives the audio data from external sources (USB or line input/I2S) and forwards it to one or more headsets.
The headset is a receiver device that plays back the audio it gets from the gateway, and will act as earbuds, headphones, a speaker, hearing aids, or similar.

Each nRF5340 Audio application is configured for one specific LE Audio mode: the *connected isochronous stream* (CIS, unicast) mode or in the *broadcast isochronous stream* (BIS) mode.
See :ref:`nrf53_audio_app_overview_modes` for more information.

The applications use the same code base, but use different :file:`main.c` files and include different modules and libraries depending on the configuration.

You might need to configure and program two applications for testing the interoperability, depending on your use case.
See the testing steps for each of the application for more information.

.. _nrf53_audio_app_overview_modes:

Application modes
*****************

Each application works either in the *connected isochronous stream* (CIS) mode or in the *broadcast isochronous stream* (BIS) mode.

.. figure:: /images/nrf5340_audio_application_topologies.png
   :alt: CIS and BIS mode overview

   CIS and BIS mode overview

Connected Isochronous Stream (CIS)
  CIS is a bidirectional communication protocol that allows for sending separate connected audio streams from a source device to one or more receivers.
  The gateway can send the audio data using both the left and the right ISO channels at the same time, allowing for stereophonic sound reproduction with synchronized playback.

  This is the mode available for the unicast applications (:ref:`unicast client<nrf53_audio_unicast_client_app>` and :ref:`unicast server<nrf53_audio_unicast_server_app>`).
  In this mode, you can use the nRF5340 Audio development kit in the role of the gateway, the left headset, or the right headset.

  In the current version of the nRF5340 Audio unicast client, the application offers both unidirectional and bidirectional communication.
  In the bidirectional communication, the headset device will send audio from the on-board PDM microphone.
  See :ref:`nrf53_audio_app_configuration_select_bidirectional` in the application description for more information.

  You can also enable a walkie-talkie demonstration.
  In this demonstration, the gateway device will send audio from the on-board PDM microphone instead of using USB or the line-in.
  See :ref:`nrf53_audio_app_configuration_enable_walkie_talkie` in the application description for more information.

Broadcast Isochronous Stream (BIS)
  BIS is a unidirectional communication protocol that allows for broadcasting one or more audio streams from a source device to an unlimited number of receivers that are not connected to the source.

  This is the mode available for the broadcast applications (:ref:`broadcast source<nrf53_audio_broadcast_source_app>` for headset and :ref:`broadcast sink<nrf53_audio_broadcast_sink_app>` for gateway).
  In this mode, you can use the nRF5340 Audio development kit in the role of the gateway or as one of the headsets.
  Use multiple nRF5340 Audio development kits to test BIS having multiple receiving headsets.

  .. note::
     In the BIS mode, you can use any number of nRF5340 Audio development kits as receivers.

The audio quality for both modes does not change, although the processing time for stereo can be longer.

.. _nrf53_audio_app_overview_architecture:

Firmware architecture
*********************

The following figure illustrates the software layout for the nRF5340 Audio application:

.. figure:: /images/nrf5340_audio_structure_generic.svg
   :alt: nRF5340 Audio high-level design (overview)

   nRF5340 Audio high-level design (overview)

The network core of the nRF5340 SoC runs the SoftDevice Controller, which is responsible for receiving the audio stream data from hardware layers and forwarding the data to the Bluetooth LE host on the application core.
The controller implements the lower layers of the Bluetooth Low Energy software stack.
See :ref:`ug_ble_controller_softdevice` for more information about the controller, and :ref:`SoftDevice Controller for LE Isochronous Channels <nrfxlib:softdevice_controller_iso>` for information on how it implements ISO channels used by the nRF5340 Audio applications.

The application core runs both the Bluetooth LE Host from Zephyr and the application layer.
The application layer is composed of a series of modules from different sources.
These modules include the following major ones:

* Peripheral modules from the |NCS|:

  * I2S
  * USB
  * SPI
  * TWI/I2C
  * UART (debug)
  * Timer
  * LC3 encoder/decoder

* Application-specific Bluetooth modules for handling the Bluetooth connection:

  * Management - This module handles scanning and advertising, in addition to general initialization, controller configuration, and transfer of DFU images.
  * Stream - This module handles the setup and transfer of audio in the Bluetooth LE Audio context.
    It includes submodules for CIS (unicast) and BIS (broadcast).
  * Renderer - This module handles rendering, such as volume up and down.
  * Content Control - This module handles content control, such as play and pause.

* Application-specific custom modules, including the synchronization module (part of `I2S-based firmware for gateway and headsets`_) - See `Synchronization module overview`_ for more information.

Since the application architecture is the same for all applications and the code before compilation is shared to a significant degree, the set of modules in use depends on the chosen audio inputs and outputs (USB or analog jack).

.. note::
   In the current versions of the applications, the bootloader is disabled by default.
   Device Firmware Update (DFU) can only be enabled when :ref:`nrf53_audio_app_building_script`.
   See :ref:`nrf53_audio_app_configuration_configure_fota` for details.

Communication between modules
=============================

Communication between modules is primarily done through Zephyr's :ref:`zephyr:zbus` to make sure that there are as few dependencies as possible. Each of the buses used by the applications has their message structures described in :file:`nrf5340_audio_common.h`.

.. _nrf53_audio_app_overview_architecture_usb:

USB-based firmware for gateway
==============================

The following figures show an overview of the modules currently included in the firmware of applications that use USB.

In this firmware design, no synchronization module is used after decoding the incoming frames or before encoding the outgoing ones.
The Bluetooth LE RX FIFO is mainly used to make decoding run in a separate thread.

Broadcast source USB-based firmware
-----------------------------------

.. figure:: /images/nrf5340_audio_broadcast_source_USB_structure.svg
   :alt: nRF5340 Audio modules for the broadcast source using USB

   nRF5340 Audio modules for the broadcast source using USB

Unicast client USB-based firmware
---------------------------------

.. figure:: /images/nrf5340_audio_unicast_client_USB_structure.svg
   :alt: nRF5340 Audio modules for the unicast client using USB

   nRF5340 Audio modules for the unicast client using USB

.. _nrf53_audio_app_overview_architecture_i2s:

I2S-based firmware for gateway and headsets
===========================================

The following figure shows an overview of the modules currently included in the firmware of applications that use I2S.

The Bluetooth LE RX FIFO is mainly used to make :file:`audio_datapath.c` (synchronization module) run in a separate thread.

Broadcast source I2S-based firmware
-----------------------------------

.. figure:: /images/nrf5340_audio_broadcast_source_I2S_structure.svg
   :alt: nRF5340 Audio modules for the broadcast source using I2S

   nRF5340 Audio modules for the broadcast source using I2S

Broadcast sink I2S-based firmware
---------------------------------

.. figure:: /images/nrf5340_audio_broadcast_sink_I2S_structure.svg
   :alt: nRF5340 Audio modules for the broadcast sink using I2S

   nRF5340 Audio modules for the broadcast sink using I2S

Unicast client I2S-based firmware
---------------------------------

.. figure:: /images/nrf5340_audio_unicast_client_I2S_structure.svg
   :alt: nRF5340 Audio modules for the unicast client using I2S

   nRF5340 Audio modules for the unicast client using I2S

Unicast server I2S-based firmware
---------------------------------

.. figure:: /images/nrf5340_audio_unicast_server_I2S_structure.svg
   :alt: nRF5340 Audio modules for the unicast server using I2S

   nRF5340 Audio modules for the unicast server using I2S

.. _nrf53_audio_app_overview_architecture_sync_module:

Synchronization module overview
===============================

The synchronization module (:file:`audio_datapath.c`) handles audio synchronization.
To synchronize the audio, it executes the following types of adjustments:

* Presentation compensation
* Drift compensation

The presentation compensation makes all the headsets play audio at the same time, even if the packets containing the audio frames are not received at the same time on the different headsets.
In practice, it moves the audio data blocks in the FIFO forward or backward a few blocks, adding blocks of *silence* when needed.

The drift compensation adjusts the frequency of the audio clock to adjust the speed at which the audio is played.
This is required in the CIS mode, where the gateway and headsets must keep the audio playback synchronized to provide True Wireless Stereo (TWS) audio playback.
As such, it provides both larger adjustments at the start and then continuous small adjustments to the audio synchronization.
This compensation method counters any drift caused by the differences in the frequencies of the quartz crystal oscillators used in the development kits.
Development kits use quartz crystal oscillators to generate a stable clock frequency.
However, the frequency of these crystals always slightly differs.
The drift compensation makes the inter-IC sound (I2S) interface on the headsets run as fast as the Bluetooth packets reception.
This prevents I2S overruns or underruns, both in the CIS mode and the BIS mode.

See the following figure for an overview of the synchronization module.

.. figure:: /images/nrf5340_audio_structure_sync_module.svg
   :alt: nRF5340 Audio synchronization module overview

   nRF5340 Audio synchronization module overview

Both synchronization methods use the SDU reference timestamps (:c:type:`sdu_ref`) as the reference variable.
If the device is a gateway that is :ref:`using I2S as audio source <nrf53_audio_app_overview_architecture_i2s>` and the stream is unidirectional (gateway to headsets), :c:type:`sdu_ref` is continuously being extracted from the LE Audio Controller Subsystem for nRF53 on the gateway.
The extraction happens inside the :file:`unicast_client.c` and :file:`broadcast_source.c` files' send function.
The :c:type:`sdu_ref` values are then sent to the gateway's synchronization module, and used to do drift compensation.

.. note::
   Inside the synchronization module (:file:`audio_datapath.c`), all time-related variables end with ``_us`` (for microseconds).
   This means that :c:type:`sdu_ref` becomes :c:type:`sdu_ref_us` inside the module.

As the nRF5340 is a dual-core SoC, and both cores need the same concept of time, each core runs a free-running timer in an infinite loop.
These two timers are reset at the same time, and they run from the same clock source.
This means that they should always show the same values for the same points in time.
The network core of the nRF5340 running the LE controller for nRF53 uses its timer to generate the :c:type:`sdu_ref` timestamp for every audio packet received.
The application core running the nRF5340 Audio application uses its timer to generate :c:type:`cur_time` and :c:type:`frame_start_ts`.

After the decoding takes place, the audio data is divided into smaller blocks and added to a FIFO.
These blocks are then continuously being fed to I2S, block by block.

See the following figure for the details of the compensation methods of the synchronization module.

.. figure:: /images/nrf5340_audio_sync_module_states.svg
   :alt: nRF5340 Audio's state machine for compensation mechanisms

   nRF5340 Audio's state machine for compensation mechanisms

The following external factors can affect the presentation compensation:

* The drift compensation must be synchronized to the locked state (:c:enumerator:`DRIFT_STATE_LOCKED`) before the presentation compensation can start.
  This drift compensation adjusts the frequency of the audio clock, indicating that the audio is being played at the right speed.
  When the drift compensation is not in the locked state, the presentation compensation does not leave the init state (:c:enumerator:`PRES_STATE_INIT`).
  Also, if the drift compensation loses synchronization, moving out of :c:enumerator:`DRIFT_STATE_LOCKED`, the presentation compensation moves back to :c:enumerator:`PRES_STATE_INIT`.
* When audio is being played, it is expected that a new audio frame is received in each ISO connection interval.
  If this does not occur, the headset might have lost its connection with the gateway.
  When the connection is restored, the application receives a :c:type:`sdu_ref` not consecutive with the previously received :c:type:`sdu_ref`.
  Then the presentation compensation is put into :c:enumerator:`PRES_STATE_WAIT` to ensure that the audio is still in sync.

.. note::
   When both the drift and presentation compensation are in state *locked* (:c:enumerator:`DRIFT_STATE_LOCKED` and :c:enumerator:`PRES_STATE_LOCKED`), **LED2** lights up.

Synchronization module flow
---------------------------

The received audio data in the I2S-based firmware devices follows the following path:

1. The SoftDevice Controller running on the network core receives the compressed audio data.
#. The controller, running in the :ref:`zephyr:bluetooth-hci-ipc-sample` sample on the nRF5340 SoC network core, sends the audio data to the Zephyr Bluetooth LE host running on the nRF5340 SoC application core.
#. The host sends the data to the stream control module.
#. The data is sent to a FIFO buffer.
#. The data is sent from the FIFO buffer to the :file:`audio_datapath.c` synchronization module.
   The :file:`audio_datapath.c` module performs the audio synchronization based on the SDU reference timestamps.
   Each package sent from the gateway gets a unique SDU reference timestamp.
   These timestamps are generated on the headset controllers (in the network core).
   This enables the creation of True Wireless Stereo (TWS) earbuds where the audio is synchronized in the CIS mode.
   It does also keep the speed of the inter-IC sound (I2S) interface synchronized with the sending and receiving speed of Bluetooth packets.
#. The :file:`audio_datapath.c` module sends the compressed audio data to the LC3 audio decoder for decoding.

#. The audio decoder decodes the data and sends the uncompressed audio data (PCM) back to the :file:`audio_datapath.c` module.
#. The :file:`audio_datapath.c` module continuously feeds the uncompressed audio data to the hardware codec.
#. The hardware codec receives the uncompressed audio data over the inter-IC sound (I2S) interface and performs the digital-to-analog (DAC) conversion to an analog audio signal.


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/doc/building.rst
.. _nrf53_audio_app_building:

Building and running nRF5340 Audio applications
###############################################

.. contents::
   :local:
   :depth: 2

This nRF5340 Audio application source files can be found in their respective folders under :file:`applications/nrf5340_audio` in the nRF Connect SDK folder structure.

You can build and program the applications in one of the following ways:

* :ref:`nrf53_audio_app_building_script`.
  This is the suggested method.
  Using this method allows you to build and program multiple development kits at the same time.
* :ref:`nrf53_audio_app_building_standard`.
  Using this method requires building and programming each development kit separately.

.. important::
   Building and programming using the |nRFVSC| is currently not supported.

.. note::
   You might want to check the :ref:`nRF5340 Audio application known issues <known_issues_nrf5340audio>` before building and programming the applications.

.. _nrf53_audio_app_dk_testing_out_of_the_box:

Testing out of the box
**********************

Each development kit comes preprogrammed with basic firmware that indicates if the kit is functional.
Before building the application, you can verify if the kit is working by completing the following steps:

1. Plug the device into the USB port.
#. Turn on the development kit using the On/Off switch.
#. Observe **RGB** (bottom side LEDs around the center opening that illuminate the Nordic Semiconductor logo) turn solid yellow, **OB/EXT** turn solid green, and **LED3** start blinking green.

You can now program the development kit.

.. _nrf53_audio_app_building_script:

Building and programming using script
*************************************

The suggested method for building each of the applications and programming it to the development kit is running the :file:`buildprog.py` Python script, which is located in the :file:`applications/nrf5340_audio/tools/buildprog` directory.
The script automates the process of selecting :ref:`configuration files <nrf53_audio_app_configuration_files>` and building different applications.
This eases the process of building and programming images for multiple development kits.

Preparing the JSON file
=======================

The script depends on the settings defined in the :file:`nrf5340_audio_dk_devices.json` file.
Before using the script, make sure to update this file with the following information for each development kit you want to use:

* ``nrf5340_audio_dk_snr`` -- This field lists the SEGGER serial number.
  You can check this number on the sticker on the nRF5340 Audio development kit.
  Alternatively, connect the development kit to your PC and run ``nrfjprog -i`` in a command window to print the SEGGER serial number of the kit.
* ``nrf5340_audio_dk_dev`` -- This field assigns the specific nRF5340 Audio development kit to be ``headset`` or ``gateway``.
* ``channel`` -- This field is valid only for headsets.
  It sets the channels on which the headset is meant to work.
  When no channel is set, the headset is programmed as a left channel one.

.. _nrf53_audio_app_building_script_running:

Running the script
==================

After editing the :file:`nrf5340_audio_dk_devices.json` file, run :file:`buildprog.py` to build the firmware for the development kits.
The building command for running the script requires providing the following parameters:

* Core type (``-c`` parameter): ``app``, ``net``, or ``both``
* Application version (``-b`` parameter): either ``release`` or ``debug``
* Device type (``-d`` parameter): ``headset``, ``gateway``, or ``both``
* DFU type (``-m`` parameter): ``internal``, ``external``
* Network core bootloader minimal size (``-M``)

See the following examples of the parameter usage with the command run from the :file:`buildprog` directory:

* Example 1: The following command builds headset and gateway applications using the script for the application core with the ``debug`` application version:

  .. code-block:: console

     python buildprog.py -c app -b debug -d both

* Example 2: The following command builds headset and gateway applications using the script for both the application and the network core (``both``).
  It builds with the ``release`` application version, with the DFU external flash memory layout enabled, and using the minimal size of the network core bootloader:

  .. code-block:: console

     python buildprog.py -c both -b release -d both -m external -M

The command can be run from any location, as long as the correct path to :file:`buildprog.py` is given.

The build files are saved in the :file:`applications/nrf5340_audio/build` directory.
The script creates a directory for each application version and device type combination.
For example, when running the command above, the script creates the :file:`dev_gateway/build_debug` and :file:`dev_headset/build_debug` directories.

Programming with the script
   The development kits are programmed according to the serial numbers set in the JSON file.
   Make sure to connect the development kits to your PC using USB and turn them on using the **POWER** switch before you run the command.

   The following parameters are available for programming:

   * Programming (``-p`` parameter) -- If you run the building script with this parameter, you can program one or both of the cores after building the files.
   * Sequential programming (``-s`` parameter) -- If you encounter problems while programming, include this parameter alongside other parameters to program sequentially.

   The command for programming can look as follows:

   .. code-block:: console

      python buildprog.py -c both -b debug -d both -p

   This command builds the headset and the gateway applications with ``debug`` version of both the application core binary and the network core binary - and programs each to its respective core.

   .. note::
      If the programming command fails because of :ref:`readback_protection_error`, run :file:`buildprog.py` with the ``--recover_on_fail`` or ``-f`` parameter to recover and re-program automatically when programming fails.
      For example, using the programming command example above:

      .. code-block:: console

         python buildprog.py -c both -b debug -d both -p --recover_on_fail

   If you want to program firmware that has DFU enabled, you must include the DFU parameters in the command.
   The command for programming with DFU enabled can look as follows:

   .. code-block:: console

     python buildprog.py -c both -b release -d both -m external -M -p

Getting help
   Run ``python buildprog.py -h`` for information about all available script parameters.

Configuration table overview
   When running the script command, a table similar to the following one is displayed to provide an overview of the selected options and parameter values:

   .. code-block:: console

      +------------+----------+---------+--------------+---------------------+---------------------+
      | snr        | snr conn | device  | only reboot  | core app programmed | core net programmed |
      +------------+----------+---------+--------------+---------------------+---------------------+
      | 1010101010 | True     | headset | Not selected | Selected TBD        | Not selected        |
      | 2020202020 | True     | gateway | Not selected | Selected TBD        | Not selected        |
      | 3030303030 | True     | headset | Not selected | Selected TBD        | Not selected        |
      +------------+----------+---------+--------------+---------------------+---------------------+

   See the following table for the meaning of each column and the list of possible values:

   +-----------------------+-----------------------------------------------------------------------------------------------------+-------------------------------------------------+
   | Column                | Indication                                                                                          | Possible values                                 |
   +=======================+=====================================================================================================+=================================================+
   | ``snr``               | Serial number of the device, as provided in the :file:`nrf5340_audio_dk_devices.json` file.         | Serial number.                                  |
   +-----------------------+-----------------------------------------------------------------------------------------------------+-------------------------------------------------+
   | ``snr conn``          | Whether the device with the provided serial number is connected to the PC with a serial connection. | ``True`` - Connected.                           |
   |                       |                                                                                                     +-------------------------------------------------+
   |                       |                                                                                                     | ``False`` - Not connected.                      |
   +-----------------------+-----------------------------------------------------------------------------------------------------+-------------------------------------------------+
   | ``device``            | Device type, as provided in the :file:`nrf5340_audio_dk_devices.json` file.                         | ``headset`` - Headset.                          |
   |                       |                                                                                                     +-------------------------------------------------+
   |                       |                                                                                                     | ``gateway`` - Gateway.                          |
   +-----------------------+-----------------------------------------------------------------------------------------------------+-------------------------------------------------+
   | ``only reboot``       | Whether the device is to be only reset and not programmed.                                          | ``Not selected`` - No reset.                    |
   |                       | This depends on the ``-r`` parameter in the command, which overrides other parameters.              +-------------------------------------------------+
   |                       |                                                                                                     | ``Selected TBD`` - Only reset requested.        |
   |                       |                                                                                                     +-------------------------------------------------+
   |                       |                                                                                                     | ``Done`` - Reset done.                          |
   |                       |                                                                                                     +-------------------------------------------------+
   |                       |                                                                                                     | ``Failed`` - Reset failed.                      |
   +-----------------------+-----------------------------------------------------------------------------------------------------+-------------------------------------------------+
   |``core app programmed``| Whether the application core is to be programmed.                                                   | ``Not selected`` - Core will not be programmed. |
   |                       | This depends on the value provided to the ``-c`` parameter (see above).                             +-------------------------------------------------+
   |                       |                                                                                                     | ``Selected TBD`` - Programming requested.       |
   |                       |                                                                                                     +-------------------------------------------------+
   |                       |                                                                                                     | ``Done`` - Programming done.                    |
   |                       |                                                                                                     +-------------------------------------------------+
   |                       |                                                                                                     | ``Failed`` - Programming failed.                |
   +-----------------------+-----------------------------------------------------------------------------------------------------+-------------------------------------------------+
   |``core net programmed``| Whether the network core is to be programmed.                                                       | ``Not selected`` - Core will not be programmed. |
   |                       | This depends on the value provided to the ``-c`` parameter (see above).                             +-------------------------------------------------+
   |                       |                                                                                                     | ``Selected TBD`` - Programming requested.       |
   |                       |                                                                                                     +-------------------------------------------------+
   |                       |                                                                                                     | ``Done`` - Programming done.                    |
   |                       |                                                                                                     +-------------------------------------------------+
   |                       |                                                                                                     | ``Failed`` - Programming failed.                |
   +-----------------------+-----------------------------------------------------------------------------------------------------+-------------------------------------------------+

.. _nrf53_audio_app_building_standard:

Building and programming using command line
*******************************************

You can also build the nRF5340 Audio applications using the standard |NCS| :ref:`build steps <programming_cmd>` for the command line.

.. note::
   Using this method requires you to build and program each development kit one at a time before moving to the next configuration, which can be time-consuming.
   :ref:`nrf53_audio_app_building_script` is recommended.

Building the application
========================

Complete the following steps to build the application:

1. Choose the combination of build flags:

   a. Choose the device type by using one of the following options:

      * For headset device: ``-DCONFIG_AUDIO_DEV=1``
      * For gateway device: ``-DCONFIG_AUDIO_DEV=2``

   #. Choose the application version by using one of the following options:

      * For the debug version: No build flag needed.
      * For the release version: ``-DCONF_FILE="prj_release.conf"``

#. Build the application using the standard :ref:`build steps <building>` for the command line.
   For example, if you want to build the firmware for the application core as a headset using the ``release`` application version, you can run the following command from the :file:`applications/nrf5340_audio/` directory:

   .. code-block:: console

      west build -b nrf5340_audio_dk_nrf5340_cpuapp --pristine -- -DCONFIG_AUDIO_DEV=1 -DCONF_FILE="prj_release.conf"

   Unlike when :ref:`nrf53_audio_app_building_script`, this command creates the build files directly in the :file:`build` directory.
   This means that you first need to program the headset development kits before you build and program gateway development kits.
   Alternatively, you can add the ``-d`` parameter to the ``west`` command to specify a custom build folder. This lets you build firmware for both
   headset and gateway before programming any development kits.

Programming the application
===========================

After building the files for the development kit you want to program, follow the :ref:`standard procedure for programming applications <building>` in the |NCS|.

When using the default CIS configuration, if you want to use two headset devices, you must also populate the UICR with the desired channel for each headset.
Use the following commands, depending on which headset you want to populate:

* Left headset:

   .. code-block:: console

      nrfjprog --memwr 0x00FF80F4 --val 0

* Right headset:

   .. code-block:: console

      nrfjprog --memwr 0x00FF80F4 --val 1

Select the correct board when prompted with the popup or add the ``--snr`` parameter followed by the SEGGER serial number of the correct board at the end of the ``nrfjprog`` command.

.. note::
   |usb_known_issues|


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/doc/adapting_application.rst
.. _nrf53_audio_app_adapting:

Adapting nRF5340 Audio applications for end products
####################################################

.. contents::
   :local:
   :depth: 2

This page describes the relevant configuration sources and lists the steps required for adapting the :ref:`nrf53_audio_app` to end products.

Board configuration sources
***************************

The nRF5340 Audio applications use the following files as board configuration sources:

* Devicetree Specification (DTS) files - These reflect the hardware configuration.
  See :ref:`zephyr:dt-guide` for more information about the DTS data structure.
* Kconfig files - These reflect the hardware-related software configuration.
  See :ref:`kconfig_tips_and_tricks` for information about how to configure them.
* Memory layout configuration files - These define the memory layout of the application.

You can see the :file:`zephyr/boards/arm/nrf5340_audio_dk_nrf5340` directory as an example of how these files are structured.

For information about differences between DTS and Kconfig, see :ref:`zephyr:dt_vs_kconfig`.
For detailed instructions for adding Zephyr support to a custom board, see Zephyr's :ref:`zephyr:board_porting_guide`.

.. _nrf53_audio_app_porting_guide_app_configuration:

Application configuration sources
*********************************

The application configuration source file defines a set of options used by the given nRF5340 Audio application.
This is a :file:`.conf` file that modifies the default Kconfig values defined in the Kconfig files.

Only one :file:`.conf` file is included at a time.
The :file:`prj.conf` file is the default configuration file and it implements the debug application version.
For the release application version, you need to include the :file:`prj_release.conf` configuration file.
In the release application version no debug features should be enabled.

Each nRF5340 Audio application also uses its own :file:`Kconfig.default` file to change configuration defaults automatically.

You need to edit :file:`prj.conf` and :file:`prj_release.conf` if you want to add new functionalities to your application, but editing these files when adding a new board is not required.

.. _nrf53_audio_app_porting_guide_adding_board:

Adding a new board
******************

.. note::
    The first three steps of the configuration procedure are identical to the steps described in Zephyr's :ref:`zephyr:board_porting_guide`.

To use the nRF5340 Audio application with your custom board:

1. Define the board files for your custom board:

   a. Create a new directory in the :file:`nrf/boards/arm/` directory with the name of the new board.
   #. Copy the nRF5340 Audio board files from the :file:`nrf5340_audio_dk_nrf5340` directory located in the :file:`zephyr/boards/arm/` folder to the newly created directory.

#. Edit the DTS files to make sure they match the hardware configuration.
   Pay attention to the following elements:

   * Pins that are used.
   * Interrupt priority that might be different.

#. Edit the board's Kconfig files to make sure they match the required system configuration.
   For example, disable the drivers that will not be used by your device.
#. Build the application by selecting the name of the new board (for example, ``new_audio_board_name``) in your build system.
   For example, when building from the command line, add ``-b new_audio_board_name`` to your build command.

FOTA for end products
*********************

Do not use the default MCUboot key for end products.
See :ref:`ug_fw_update` and :ref:`west-sign` for more information.

To create your own app that supports DFU, you can use the `nRF Connect Device Manager`_ libraries for Android and iOS.

Changing default values
***********************

Given the requirements for the Coordinated Set Identification Service (CSIS), make sure to change the Set Identity Resolving Key (SIRK) value when adapting the application.


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/.DS_Store
// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/nrf5340_audio_common.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "bt_mgmt.h"
#include "fw_info_app.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(nrf5340_audio_common, CONFIG_NRF5340_AUDIO_COMMON_LOG_LEVEL);

int nrf5340_audio_common_init(void)
{
	int ret;

	ret = fw_info_app_print();
	if (ret) {
		LOG_ERR("Failed to print application FW info");
		return ret;
	}

	ret = bt_mgmt_init();
	if (ret) {
		LOG_ERR("Failed to initialize bt_mgmt");
		return ret;
	}

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/drivers/cs47l63_reg_conf.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _CS47L63_REG_CONF_H_
#define _CS47L63_REG_CONF_H_

#include "cs47l63_spec.h"

/* Magic value to signal a sleep instead of register address.
 * This can be used e.g. after resets where time is needed before
 * a device is ready.
 * Note that this is a busy wait, and should only be used sparingly where fast
 * execution is not critical.
 *
 * 0001 is used as the reg addr. In case of a fault, this reg is read only.
 */
#define SPI_BUSY_WAIT 0x0001
#define SPI_BUSY_WAIT_US_1000 1000
#define SPI_BUSY_WAIT_US_3000 3000

#define MAX_VOLUME_REG_VAL 0x80
#define MAX_VOLUME_DB 64
#define OUT_VOLUME_DEFAULT 0x62
#define VOLUME_UPDATE_BIT (1 << 9)

#define CS47L63_SOFT_RESET_VAL 0x5A000000

/* clang-format off */
/* Set up clocks */
const uint32_t clock_configuration[][2] = {
	{ CS47L63_SAMPLE_RATE3, 0x0012 },
	{ CS47L63_SAMPLE_RATE2, 0x0002 },
	{ CS47L63_SAMPLE_RATE1, 0x0003 },
	{ CS47L63_SYSTEM_CLOCK1, 0x034C },
	{ CS47L63_ASYNC_CLOCK1, 0x034C },
	{ CS47L63_FLL1_CONTROL2, 0x88200008 },
	{ CS47L63_FLL1_CONTROL3, 0x10000 },
	{ CS47L63_FLL1_GPIO_CLOCK, 0x0005 },
	{ CS47L63_FLL1_CONTROL1, 0x0001 },
};
/* clang-format on */

/* Set up GPIOs */
const uint32_t GPIO_configuration[][2] = {
	{ CS47L63_GPIO6_CTRL1, 0x61000001 },
	{ CS47L63_GPIO7_CTRL1, 0x61000001 },
	{ CS47L63_GPIO8_CTRL1, 0x61000001 },

	/* Enable CODEC LED */
	{ CS47L63_GPIO10_CTRL1, 0x41008001 },
};

const uint32_t pdm_mic_enable_configure[][2] = {
	/* Set MICBIASes */
	{ CS47L63_LDO2_CTRL1, 0x0005 },
	{ CS47L63_MICBIAS_CTRL1, 0x00EC },
	{ CS47L63_MICBIAS_CTRL5, 0x0272 },

	/* Enable IN1L */
	{ CS47L63_INPUT_CONTROL, 0x000F },

	/* Enable PDM mic as digital input */
	{ CS47L63_INPUT1_CONTROL1, 0x50021 },

	/* Un-mute and set gain to 0dB */
	{ CS47L63_IN1L_CONTROL2, 0x800080 },
	{ CS47L63_IN1R_CONTROL2, 0x800080 },

	/* Volume Update */
	{ CS47L63_INPUT_CONTROL3, 0x20000000 },

	/* Send PDM MIC to I2S Tx */
	{ CS47L63_ASP1TX1_INPUT1, 0x800010 },
	{ CS47L63_ASP1TX2_INPUT1, 0x800011 },
};

/* Set up input */
const uint32_t line_in_enable[][2] = {
	/* Select LINE-IN as analog input */
	{ CS47L63_INPUT2_CONTROL1, 0x50020 },

	/* Set IN2L and IN2R to single-ended */
	{ CS47L63_IN2L_CONTROL1, 0x10000000 },
	{ CS47L63_IN2R_CONTROL1, 0x10000000 },

	/* Un-mute and set gain to 0dB */
	{ CS47L63_IN2L_CONTROL2, 0x800080 },
	{ CS47L63_IN2R_CONTROL2, 0x800080 },

	/* Enable IN2L and IN2R */
	{ CS47L63_INPUT_CONTROL, 0x000F },

	/* Volume Update */
	{ CS47L63_INPUT_CONTROL3, 0x20000000 },

	/* Route IN2L and IN2R to I2S */
	{ CS47L63_ASP1TX1_INPUT1, 0x800012 },
	{ CS47L63_ASP1TX2_INPUT1, 0x800013 },
};

/* Set up output */
const uint32_t output_enable[][2] = {
	{ CS47L63_OUTPUT_ENABLE_1, 0x0002 },
	{ CS47L63_OUT1L_INPUT1, 0x800020 },
	{ CS47L63_OUT1L_INPUT2, 0x800021 },
};

const uint32_t output_disable[][2] = {
	{ CS47L63_OUTPUT_ENABLE_1, 0x00 },
};

/* Set up ASP1 (I2S) */
const uint32_t asp1_enable[][2] = {
	/* Enable ASP1 GPIOs */
	{ CS47L63_GPIO1_CTRL1, 0x61000000 },
	{ CS47L63_GPIO2_CTRL1, 0xE1000000 },
	{ CS47L63_GPIO3_CTRL1, 0xE1000000 },
	{ CS47L63_GPIO4_CTRL1, 0xE1000000 },
	{ CS47L63_GPIO5_CTRL1, 0x61000001 },

/* Set correct sample rate */
#if CONFIG_AUDIO_SAMPLE_RATE_16000_HZ
	{ CS47L63_SAMPLE_RATE1, 0x000000012 },
#elif CONFIG_AUDIO_SAMPLE_RATE_24000_HZ
	{ CS47L63_SAMPLE_RATE1, 0x000000002 },
#elif CONFIG_AUDIO_SAMPLE_RATE_48000_HZ
	{ CS47L63_SAMPLE_RATE1, 0x000000003 },
#endif
	/* Disable unused sample rates */
	{ CS47L63_SAMPLE_RATE2, 0 },
	{ CS47L63_SAMPLE_RATE3, 0 },
	{ CS47L63_SAMPLE_RATE4, 0 },

	/* Set ASP1 in slave mode and 16 bit per channel */
	{ CS47L63_ASP1_CONTROL2, 0x10100200 },
	{ CS47L63_ASP1_CONTROL3, 0x0000 },
	{ CS47L63_ASP1_DATA_CONTROL1, 0x0020 },
	{ CS47L63_ASP1_DATA_CONTROL5, 0x0020 },
	{ CS47L63_ASP1_ENABLES1, 0x30003 },
};

const uint32_t FLL_toggle[][2] = {
	{ CS47L63_FLL1_CONTROL1, 0x0000 },
	{ SPI_BUSY_WAIT, SPI_BUSY_WAIT_US_1000 },
	{ CS47L63_FLL1_CONTROL1, 0x0001 },
};

const uint32_t soft_reset[][2] = {
	{ CS47L63_SFT_RESET, CS47L63_SOFT_RESET_VAL },
	{ SPI_BUSY_WAIT, SPI_BUSY_WAIT_US_3000 },
};

#endif /* _CS47L63_REG_CONF_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/drivers/cs47l63_comm.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _CS47L63_COMM_H_
#define _CS47L63_COMM_H_

#include <stdint.h>
#include "cs47l63.h"

/**@brief Initialize the CS47L63
 *
 * @param driver   Pointer to CS47L63 driver
 *
 * @return 0 on success.
 */
int cs47l63_comm_init(cs47l63_t *driver);

#endif /* _CS47L63_COMM_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/drivers/CMakeLists.txt
#
# Copyright (c) 2022 Nordic Semiconductor
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

target_sources(app PRIVATE
	       ${CMAKE_CURRENT_SOURCE_DIR}/cs47l63_comm.c
)


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/drivers/Kconfig
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

menu "Drivers"

#----------------------------------------------------------------------------#
menu "Thread priorities"

config CS47L63_THREAD_PRIO
	int "Priority for CS47L63 thread"
	default 5
	help
	  This is a preemptible thread

endmenu # Thread priorities

#----------------------------------------------------------------------------#
menu "Stack sizes"

config CS47L63_STACK_SIZE
	int "Stack size for CS47L63"
	default 700

endmenu # Stack sizes

#----------------------------------------------------------------------------#
menu "Log levels"

module = CS47L63
module-str = cs47l63
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log levels
endmenu # Drivers


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/drivers/cs47l63_comm.c
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#define DT_DRV_COMPAT cirrus_cs47l63

#include "cs47l63_comm.h"

#include <zephyr/kernel.h>
#include <zephyr/drivers/spi.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <zephyr/kernel.h>
#include <zephyr/drivers/gpio.h>

#include "bsp_driver_if.h"
#include "cs47l63.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(CS47L63, CONFIG_CS47L63_LOG_LEVEL);

#define CS47L63_DEVID_VAL 0x47A63
#define PAD_LEN 4 /* Four bytes padding after address */
/* Delay the processing thread to allow interrupts to settle after boot */
#define CS47L63_PROCESS_THREAD_DELAY_MS 10

static const struct gpio_dt_spec hw_codec_gpio = GPIO_DT_SPEC_INST_GET(0, gpio9_gpios);
static const struct gpio_dt_spec hw_codec_irq = GPIO_DT_SPEC_INST_GET(0, irq_gpios);
static const struct gpio_dt_spec hw_codec_reset = GPIO_DT_SPEC_INST_GET(0, reset_gpios);

const static struct device *gpio_dev = DEVICE_DT_GET(DT_NODELABEL(gpio0));

static const struct spi_dt_spec spi = SPI_DT_SPEC_INST_GET(
	0, SPI_OP_MODE_MASTER | SPI_TRANSFER_MSB | SPI_WORD_SET(8) | SPI_LINES_SINGLE, 0);
static bsp_callback_t bsp_callback;
static void *bsp_callback_arg;

static struct gpio_callback gpio_cb;

static struct k_thread cs47l63_data;
static K_THREAD_STACK_DEFINE(cs47l63_stack, CONFIG_CS47L63_STACK_SIZE);

static K_SEM_DEFINE(sem_cs47l63, 0, 1);

static struct k_mutex cirrus_reg_oper_mutex;

static void notification_callback(uint32_t event_flags, void *arg)
{
	LOG_DBG("Notification from CS47L63, flags: %d", event_flags);
}

/* Locks the mutex and holds the CS pin
 * for consecutive transactions
 */
static int spi_mutex_lock(void)
{
	int ret;

	ret = k_mutex_lock(&cirrus_reg_oper_mutex, K_FOREVER);
	if (ret) {
		LOG_ERR("Failed to lock mutex: %d", ret);
		return ret;
	}

	/* If operation mode set to HOLD or the SPI_LOCK_ON is set when
	 * taking the mutex something is wrong
	 */
	if ((spi.config.operation & SPI_HOLD_ON_CS) || (spi.config.operation & SPI_LOCK_ON)) {
		LOG_ERR("SPI_HOLD_ON_CS and SPI_LOCK_ON must be freed before releasing mutex");
		return -EPERM;
	}

	return 0;
}

/* Unlocks mutex and CS pin */
static int spi_mutex_unlock(void)
{
	int ret;
	/* If operation mode still set to HOLD or
	 * the SPI_LOCK_ON is still set when releasing the mutex
	 * something is wrong
	 */
	if ((spi.config.operation & SPI_HOLD_ON_CS) || (spi.config.operation & SPI_LOCK_ON)) {
		LOG_ERR("SPI_HOLD_ON_CS and SPI_LOCK_ON must be freed before releasing mutex");
		return -EPERM;
	}

	ret = k_mutex_unlock(&cirrus_reg_oper_mutex);
	if (ret) {
		LOG_ERR("Failed to unlock mutex: %d", ret);
		return ret;
	}

	return 0;
}

/* Pin interrupt handler for CS47L63 */
static void cs47l63_comm_pin_int_handler(const struct device *gpio_port, struct gpio_callback *cb,
					 uint32_t pins)
{
	__ASSERT(bsp_callback != NULL, "No callback registered");

	if (pins == BIT(hw_codec_irq.pin)) {
		bsp_callback(BSP_STATUS_OK, bsp_callback_arg);
		k_sem_give(&sem_cs47l63);
	}
}

static uint32_t cs47l63_comm_reg_read(uint32_t bsp_dev_id, uint8_t *addr_buffer,
				      uint32_t addr_length, uint8_t *data_buffer,
				      uint32_t data_length, uint32_t pad_len)
{
	if (pad_len != PAD_LEN) {
		LOG_ERR("Trying to pad more than 4 bytes: %d", pad_len);
		return BSP_STATUS_FAIL;
	}

	int ret;

	uint8_t pad_buffer[PAD_LEN] = { 0 };

	struct spi_buf_set rx;
	struct spi_buf rx_buf[] = { { .buf = addr_buffer, .len = addr_length },
				    { .buf = pad_buffer, .len = pad_len },
				    { .buf = data_buffer, .len = data_length } };

	rx.buffers = rx_buf;
	rx.count = ARRAY_SIZE(rx_buf);

	ret = spi_mutex_lock();
	if (ret) {
		return BSP_STATUS_FAIL;
	}

	ret = spi_transceive_dt(&spi, &rx, &rx);
	if (ret) {
		LOG_ERR("Failed transceive operation: %d", ret);
		return BSP_STATUS_FAIL;
	}

	ret = spi_mutex_unlock();
	if (ret) {
		return BSP_STATUS_FAIL;
	}

	return BSP_STATUS_OK;
}

static uint32_t cs47l63_comm_reg_write(uint32_t bsp_dev_id, uint8_t *addr_buffer,
				       uint32_t addr_length, uint8_t *data_buffer,
				       uint32_t data_length, uint32_t pad_len)
{
	if (pad_len != PAD_LEN) {
		LOG_ERR("Trying to pad more than 4 bytes: %d", pad_len);
		return BSP_STATUS_FAIL;
	}

	int ret;

	uint8_t pad_buffer[PAD_LEN] = { 0 };

	struct spi_buf_set tx;
	struct spi_buf tx_buf[] = { { .buf = addr_buffer, .len = addr_length },
				    { .buf = pad_buffer, .len = pad_len },
				    { .buf = data_buffer, .len = data_length } };

	tx.buffers = tx_buf;
	tx.count = ARRAY_SIZE(tx_buf);

	ret = spi_mutex_lock();
	if (ret) {
		return BSP_STATUS_FAIL;
	}

	ret = spi_write_dt(&spi, &tx);
	if (ret) {
		LOG_ERR("SPI failed to write: %d", ret);
		return BSP_STATUS_FAIL;
	}

	ret = spi_mutex_unlock();
	if (ret) {
		return BSP_STATUS_FAIL;
	}

	return BSP_STATUS_OK;
}

static uint32_t cs47l63_comm_gpio_set(uint32_t gpio_id, uint8_t gpio_state)
{
	int ret;

	ret = gpio_pin_set_raw(gpio_dev, gpio_id, gpio_state);

	if (ret) {
		LOG_ERR("Failed to set gpio state, ret: %d", ret);
		return BSP_STATUS_FAIL;
	}

	return BSP_STATUS_OK;
}

/* Register callback for pin interrupt from CS47L63 */
static uint32_t cs47l63_comm_gpio_cb_register(uint32_t gpio_id, bsp_callback_t cb, void *cb_arg)
{
	int ret;

	bsp_callback = cb;
	bsp_callback_arg = cb_arg;

	gpio_init_callback(&gpio_cb, cs47l63_comm_pin_int_handler, BIT(gpio_id));

	ret = gpio_add_callback(gpio_dev, &gpio_cb);
	if (ret) {
		return BSP_STATUS_FAIL;
	}

	ret = gpio_pin_interrupt_configure(gpio_dev, gpio_id, GPIO_INT_EDGE_TO_INACTIVE);
	if (ret) {
		return BSP_STATUS_FAIL;
	}

	return BSP_STATUS_OK;
}

static uint32_t cs47l63_comm_timer_set(uint32_t duration_ms, bsp_callback_t cb, void *cb_arg)
{
	if (cb != NULL || cb_arg != NULL) {
		LOG_ERR("Timer with callback not supported");
		return BSP_STATUS_FAIL;
	}

	k_msleep(duration_ms);

	return BSP_STATUS_OK;
}

static uint32_t cs47l63_comm_set_supply(uint32_t supply_id, uint8_t supply_state)
{
	LOG_DBG("Tried to set supply, not supported");
	/* OK is returned in order to make reset function work */
	return BSP_STATUS_OK;
}

static uint32_t cs47l63_comm_i2c_reset(uint32_t bsp_dev_id, bool *was_i2c_busy)
{
	LOG_ERR("Tried to reset I2C, not supported");
	return BSP_STATUS_FAIL;
}

static uint32_t cs47l63_comm_i2c_read_repeated_start(uint32_t bsp_dev_id, uint8_t *write_buffer,
						     uint32_t write_length, uint8_t *read_buffer,
						     uint32_t read_length, bsp_callback_t cb,
						     void *cb_arg)
{
	LOG_ERR("Tried to read repeated start I2C, not supported");
	return BSP_STATUS_FAIL;
}

static uint32_t cs47l63_comm_i2c_write(uint32_t bsp_dev_id, uint8_t *write_buffer,
				       uint32_t write_length, bsp_callback_t cb, void *cb_arg)
{
	LOG_ERR("Tried writing to I2C, not supported");
	return BSP_STATUS_FAIL;
}

static uint32_t cs47l63_comm_i2c_db_write(uint32_t bsp_dev_id, uint8_t *write_buffer_0,
					  uint32_t write_length_0, uint8_t *write_buffer_1,
					  uint32_t write_length_1, bsp_callback_t cb, void *cb_arg)
{
	LOG_ERR("Tried to write double buffered I2C, not supported");
	return BSP_STATUS_FAIL;
}

static uint32_t cs47l63_comm_enable_irq(void)
{
	LOG_ERR("Tried to enable irq, not supported");
	return BSP_STATUS_FAIL;
}

static uint32_t cs47l63_comm_disable_irq(void)
{
	LOG_ERR("Tried to disable irq, not supported");
	return BSP_STATUS_FAIL;
}

static uint32_t cs47l63_comm_spi_throttle_speed(uint32_t speed_hz)
{
	LOG_ERR("Tried to throttle SPI speed, not supported");
	return BSP_STATUS_FAIL;
}

static uint32_t cs47l63_comm_spi_restore_speed(void)
{
	LOG_ERR("Tried to restore SPI speed, not supported");
	return BSP_STATUS_FAIL;
}

/* Thread to process events from CS47L63 */
static void cs47l63_comm_thread(void *cs47l63_driver, void *dummy2, void *dummy3)
{
	int ret;

	while (1) {
		k_sem_take(&sem_cs47l63, K_FOREVER);
		ret = cs47l63_process((cs47l63_t *)cs47l63_driver);
		if (ret) {
			LOG_ERR("CS47L63 failed to process event");
		}
	}
}

static cs47l63_bsp_config_t bsp_config = { .bsp_reset_gpio_id = hw_codec_reset.pin,
					   .bsp_int_gpio_id = hw_codec_irq.pin,
					   .cp_config.bus_type = CS47L63_BUS_TYPE_SPI,
					   .cp_config.spi_pad_len = 4,
					   .notification_cb = &notification_callback,
					   .notification_cb_arg = NULL };

int cs47l63_comm_init(cs47l63_t *cs47l63_driver)
{
	int ret;

	cs47l63_config_t cs47l63_config;

	memset(&cs47l63_config, 0, sizeof(cs47l63_config_t));

	k_mutex_init(&cirrus_reg_oper_mutex);

	if (!spi_is_ready_dt(&spi)) {
		LOG_ERR("CS47L63 is not ready!");
		return -ENXIO;
	}

	if (!gpio_is_ready_dt(&hw_codec_gpio)) {
		LOG_ERR("GPIO is not ready!");
		return -ENXIO;
	}

	ret = gpio_pin_configure_dt(&hw_codec_gpio, GPIO_INPUT);
	if (ret) {
		return ret;
	}

	if (!gpio_is_ready_dt(&hw_codec_irq)) {
		LOG_ERR("GPIO is not ready!");
		return -ENXIO;
	}

	ret = gpio_pin_configure_dt(&hw_codec_irq, GPIO_INPUT);
	if (ret) {
		return ret;
	}

	if (!gpio_is_ready_dt(&hw_codec_reset)) {
		LOG_ERR("GPIO is not ready!");
		return -ENXIO;
	}

	ret = gpio_pin_configure_dt(&hw_codec_reset, GPIO_OUTPUT);
	if (ret) {
		return ret;
	}

	/* Start thread to handle events from CS47L63 */
	(void)k_thread_create(&cs47l63_data, cs47l63_stack, CONFIG_CS47L63_STACK_SIZE,
			      (k_thread_entry_t)cs47l63_comm_thread, (void *)cs47l63_driver, NULL,
			      NULL, K_PRIO_PREEMPT(CONFIG_CS47L63_THREAD_PRIO), 0,
			      K_MSEC(CS47L63_PROCESS_THREAD_DELAY_MS));

	ret = k_thread_name_set(&cs47l63_data, "CS47L63");
	if (ret) {
		return ret;
	}

	/* Initialize CS47L63 drivers */
	ret = cs47l63_initialize(cs47l63_driver);
	if (ret != CS47L63_STATUS_OK) {
		LOG_ERR("Failed to initialize CS47L63");
		return -ENXIO;
	}

	cs47l63_config.bsp_config = bsp_config;

	cs47l63_config.syscfg_regs = cs47l63_syscfg_regs;
	cs47l63_config.syscfg_regs_total = CS47L63_SYSCFG_REGS_TOTAL;

	ret = cs47l63_configure(cs47l63_driver, &cs47l63_config);
	if (ret != CS47L63_STATUS_OK) {
		LOG_ERR("Failed to configure CS47L63");
		return -ENXIO;
	}

	/* Will pin reset the device and wait until boot done */
	ret = cs47l63_reset(cs47l63_driver);
	if (ret != CS47L63_STATUS_OK) {
		LOG_ERR("Failed to reset CS47L63");
		return -ENXIO;
	}

	if (cs47l63_driver->devid != CS47L63_DEVID_VAL) {
		LOG_ERR("Wrong device id: 0x%02x, should be 0x%02x", cs47l63_driver->devid,
			CS47L63_DEVID_VAL);
		return -EIO;
	}

	return 0;
}

static bsp_driver_if_t bsp_driver_if_s = { .set_gpio = &cs47l63_comm_gpio_set,
					   .register_gpio_cb = &cs47l63_comm_gpio_cb_register,
					   .set_timer = &cs47l63_comm_timer_set,
					   .spi_read = &cs47l63_comm_reg_read,
					   .spi_write = &cs47l63_comm_reg_write,

					   /* Functions not supported */
					   .set_supply = &cs47l63_comm_set_supply,
					   .i2c_read_repeated_start =
						   &cs47l63_comm_i2c_read_repeated_start,
					   .i2c_write = &cs47l63_comm_i2c_write,
					   .i2c_db_write = &cs47l63_comm_i2c_db_write,
					   .i2c_reset = &cs47l63_comm_i2c_reset,
					   .enable_irq = &cs47l63_comm_enable_irq,
					   .disable_irq = &cs47l63_comm_disable_irq,
					   .spi_throttle_speed = &cs47l63_comm_spi_throttle_speed,
					   .spi_restore_speed = &cs47l63_comm_spi_restore_speed };

bsp_driver_if_t *bsp_driver_if_g = &bsp_driver_if_s;


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/utils/uicr.c
/*
 * Copyright (c) 2021 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "uicr.h"
#include <stdint.h>
#include <errno.h>
#include <nrfx_nvmc.h>

/* Memory address to store segger number of the board */
#define MEM_ADDR_UICR_SNR UICR_APP_BASE_ADDR
/* Memory address to store the channel intended used for this board */
#define MEM_ADDR_UICR_CH (MEM_ADDR_UICR_SNR + sizeof(uint32_t))

uint8_t uicr_channel_get(void)
{
	return *(uint8_t *)MEM_ADDR_UICR_CH;
}

int uicr_channel_set(uint8_t channel)
{
	if (channel == *(uint8_t *)MEM_ADDR_UICR_CH) {
		return 0;
	} else if (*(uint32_t *)MEM_ADDR_UICR_CH != 0xFFFFFFFF) {
		return -EROFS;
	}

	nrfx_nvmc_byte_write(MEM_ADDR_UICR_CH, channel);

	if (channel == *(uint8_t *)MEM_ADDR_UICR_CH) {
		return 0;
	} else {
		return -EIO;
	}
}

uint64_t uicr_snr_get(void)
{
	return *(uint64_t *)MEM_ADDR_UICR_SNR;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/utils/CMakeLists.txt
#
# Copyright (c) 2022 Nordic Semiconductor
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

target_sources(app PRIVATE
	       ${CMAKE_CURRENT_SOURCE_DIR}/board_version.c
	       ${CMAKE_CURRENT_SOURCE_DIR}/channel_assignment.c
	       ${CMAKE_CURRENT_SOURCE_DIR}/error_handler.c
	       ${CMAKE_CURRENT_SOURCE_DIR}/uicr.c
	       ${CMAKE_CURRENT_SOURCE_DIR}/nrf5340_audio_dk.c
)


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/utils/Kconfig.defaults
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

# Channel assignment writes to UICR
config NRFX_NVMC
	default y


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/utils/channel_assignment.c
/*
 * Copyright (c) 2022 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "channel_assignment.h"

#include <errno.h>

#include "uicr.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(channel_assignment, CONFIG_CHAN_ASSIGNMENT_LOG_LEVEL);

static uint8_t channel_value;

void channel_assignment_get(enum audio_channel *channel)
{
	*channel = (enum audio_channel)channel_value;
}

#if CONFIG_AUDIO_HEADSET_CHANNEL_RUNTIME
void channel_assignment_set(enum audio_channel channel)
{
	int ret;

	channel_value = channel;

	/* Try to write the channel value to UICR */
	ret = uicr_channel_set(channel);
	if (ret) {
		LOG_DBG("Unable to write channel value to UICR");
	}
}
#endif /* CONFIG_AUDIO_HEADSET_CHANNEL_RUNTIME */

void channel_assignment_init(void)
{
#if CONFIG_AUDIO_HEADSET_CHANNEL_RUNTIME
	channel_value = uicr_channel_get();

	if (channel_value >= AUDIO_CH_NUM) {
		/* Invalid value in UICR if UICR is not written */
		channel_value = AUDIO_CHANNEL_DEFAULT;
	}
#else
	channel_value = CONFIG_AUDIO_HEADSET_CHANNEL;
#endif /* CONFIG_AUDIO_HEADSET_CHANNEL_RUNTIME */
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/utils/nrf5340_audio_dk.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "led.h"
#include "button_handler.h"
#include "button_assignments.h"
#include "nrfx_clock.h"
#include "sd_card.h"
#include "board_version.h"
#include "channel_assignment.h"
#include "audio_system.h"

#include "sd_card_playback.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(nrf5340_audio_dk, CONFIG_MODULE_NRF5340_AUDIO_DK_LOG_LEVEL);

static struct board_version board_rev;

static int hfclock_config_and_start(void)
{
	int ret;

	/* Use this to turn on 128 MHz clock for cpu_app */
	ret = nrfx_clock_divider_set(NRF_CLOCK_DOMAIN_HFCLK, NRF_CLOCK_HFCLK_DIV_1);

	ret -= NRFX_ERROR_BASE_NUM;
	if (ret) {
		return ret;
	}

	nrfx_clock_hfclk_start();
	while (!nrfx_clock_hfclk_is_running()) {
	}

	return 0;
}

static int leds_set(void)
{
	int ret;

	/* Blink LED 3 to indicate that APP core is running */
	ret = led_blink(LED_APP_3_GREEN);
	if (ret) {
		return ret;
	}

#if (CONFIG_AUDIO_DEV == HEADSET)
	enum audio_channel channel;

	channel_assignment_get(&channel);

	if (channel == AUDIO_CH_L) {
		ret = led_on(LED_APP_RGB, LED_COLOR_BLUE);
	} else {
		ret = led_on(LED_APP_RGB, LED_COLOR_MAGENTA);
	}

	if (ret) {
		return ret;
	}
#elif (CONFIG_AUDIO_DEV == GATEWAY)
	ret = led_on(LED_APP_RGB, LED_COLOR_GREEN);
	if (ret) {
		return ret;
	}
#endif /* (CONFIG_AUDIO_DEV == HEADSET) */

	return 0;
}

static int channel_assign_check(void)
{
#if (CONFIG_AUDIO_DEV == HEADSET) && CONFIG_AUDIO_HEADSET_CHANNEL_RUNTIME
	int ret;
	bool pressed;

	ret = button_pressed(BUTTON_VOLUME_DOWN, &pressed);
	if (ret) {
		return ret;
	}

	if (pressed) {
		channel_assignment_set(AUDIO_CH_L);
		return 0;
	}

	ret = button_pressed(BUTTON_VOLUME_UP, &pressed);
	if (ret) {
		return ret;
	}

	if (pressed) {
		channel_assignment_set(AUDIO_CH_R);
		return 0;
	}
#endif

	return 0;
}

int nrf5340_audio_dk_init(void)
{
	int ret;

	ret = hfclock_config_and_start();
	if (ret) {
		return ret;
	}

	ret = led_init();
	if (ret) {
		LOG_ERR("Failed to initialize LED module");
		return ret;
	}

	ret = button_handler_init();
	if (ret) {
		LOG_ERR("Failed to initialize button handler");
		return ret;
	}

	channel_assignment_init();

	ret = channel_assign_check();
	if (ret) {
		LOG_ERR("Failed get channel assignment");
		return ret;
	}

	ret = board_version_valid_check();
	if (ret) {
		return ret;
	}

	ret = board_version_get(&board_rev);
	if (ret) {
		return ret;
	}

	if (board_rev.mask & BOARD_VERSION_VALID_MSK_SD_CARD) {
		ret = sd_card_init();
		if (ret != -ENODEV && ret != 0) {
			LOG_ERR("Failed to initialize SD card");
			return ret;
		}
	}

	ret = leds_set();
	if (ret) {
		LOG_ERR("Failed to set LEDs");
		return ret;
	}

	if (IS_ENABLED(CONFIG_SD_CARD_PLAYBACK)) {
		ret = sd_card_playback_init();
		if (ret) {
			LOG_ERR("Failed to initialize SD card playback");
			return ret;
		}
	}

	ret = audio_system_init();
	if (ret) {
		LOG_ERR("Failed to initialize the audio system");
		return ret;
	}

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/utils/error_handler.c
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include <zephyr/kernel.h>
#include <zephyr/sys/reboot.h>
#include <zephyr/fatal.h>
#include <zephyr/logging/log_ctrl.h>
#include <zephyr/drivers/gpio.h>

/* Print everything from the error handler */
#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(error_handler, CONFIG_ERROR_HANDLER_LOG_LEVEL);

#if (defined(CONFIG_BOARD_NRF5340_AUDIO_DK_NRF5340_CPUAPP) && (CONFIG_DEBUG))
/* nRF5340 Audio DK center RGB LED */
static const struct gpio_dt_spec center_led_r = GPIO_DT_SPEC_GET(DT_NODELABEL(rgb1_red), gpios);
static const struct gpio_dt_spec center_led_g = GPIO_DT_SPEC_GET(DT_NODELABEL(rgb1_green), gpios);
static const struct gpio_dt_spec center_led_b = GPIO_DT_SPEC_GET(DT_NODELABEL(rgb1_blue), gpios);
#endif /* (defined(CONFIG_BOARD_NRF5340_AUDIO_DK_NRF5340_CPUAPP) && (CONFIG_DEBUG)) */

void error_handler(unsigned int reason, const z_arch_esf_t *esf)
{
#if (CONFIG_DEBUG)
	LOG_ERR("Caught system error -- reason %d. Entering infinite loop", reason);
	LOG_PANIC();
#if defined(CONFIG_BOARD_NRF5340_AUDIO_DK_NRF5340_CPUAPP)
	(void)gpio_pin_configure_dt(&center_led_r, GPIO_OUTPUT_ACTIVE);
	(void)gpio_pin_configure_dt(&center_led_g, GPIO_OUTPUT_INACTIVE);
	(void)gpio_pin_configure_dt(&center_led_b, GPIO_OUTPUT_INACTIVE);
#endif /* defined(CONFIG_BOARD_NRF5340_AUDIO_DK_NRF5340_CPUAPP) */
	irq_lock();
	while (1) {
		__asm__ volatile("nop");
	}
#else
	LOG_ERR("Caught system error -- reason %d. Cold rebooting.", reason);
#if (CONFIG_LOG)
	LOG_PANIC();
#endif /* (CONFIG_LOG) */
	sys_reboot(SYS_REBOOT_COLD);
#endif /* (CONFIG_DEBUG) */
	CODE_UNREACHABLE;
}

void bt_ctlr_assert_handle(char *c, int code)
{
	LOG_ERR("BT controller assert: %s, code: 0x%x", c, code);
	error_handler(code, NULL);
}

void k_sys_fatal_error_handler(unsigned int reason, const z_arch_esf_t *esf)
{
	error_handler(reason, esf);
}

void assert_post_action(const char *file, unsigned int line)
{
	LOG_ERR("Assert post action: file: %s, line %d", file, line);
	error_handler(0, NULL);
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/utils/Kconfig
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

rsource "Kconfig.defaults"

menu "Utils"

menu "FIFO"

config FIFO_FRAME_SPLIT_NUM
	int "Number of blocks to make up one frame of audio data"
	default 10
	help
	  Easy DMA in I2S requires two buffers to be filled before I2S
	  transmission will begin. In order to reduce latency, an audio
	  frame can be split into multiple blocks with this parameter. USB
	  sends data in 1 ms blocks, so we need the split to match that.
	  Since we set frame size to 10 ms for USB, 10 is selected as
	  FRAME_SPLIT_NUM

config FIFO_TX_FRAME_COUNT
	int "Max number of audio frames in TX slab"
	default 3
	help
	  FIFO_TX is the buffer that holds decoded audio data before it
	  is sent to either I2S or USB

config FIFO_RX_FRAME_COUNT
	int "Max number of audio frames in RX slab"
	default 1
	help
	  FIFO_RX is the buffer that holds uncompressed audio data coming
	  from either I2S or USB

endmenu # FIFO

#----------------------------------------------------------------------------#
menu "Log levels"

module = BOARD_VERSION
module-str = board-version
source "subsys/logging/Kconfig.template.log_config"

module = CHAN_ASSIGNMENT
module-str = chan-assignment
source "subsys/logging/Kconfig.template.log_config"

module = ERROR_HANDLER
module-str = error-handler
source "subsys/logging/Kconfig.template.log_config"

module = FW_INFO
module-str = fw-info
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log levels
endmenu # Utils


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/utils/fw_info_app.c.in
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "fw_info_app.h"

#include <zephyr/kernel.h>
#include <stdio.h>
#include <zephyr/logging/log_ctrl.h>
#include "channel_assignment.h"
#include "ncs_version.h"

#include "macros_common.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(fw_info, CONFIG_FW_INFO_LOG_LEVEL);

static const char COMPILE_DATE[] = "@NRF5340_AUDIO_CORE_APP_COMP_DATE@";
/* NOTE: The string below is used by the Nordic CI system */
static const char NRF5340_CORE[] = "nRF5340 Audio nRF5340 Audio DK cpuapp";

int fw_info_app_print(void)
{
	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF(COLOR_GREEN "\r\n\t %s \
			    \r\n\t NCS base version: %s \
			    \r\n\t Cmake run : %s" COLOR_RESET,
		NRF5340_CORE, NCS_VERSION_STRING, COMPILE_DATE);

#if (CONFIG_DEBUG)
	int ret;

	LOG_INF("------- DEBUG BUILD -------");

#if (CONFIG_AUDIO_DEV == HEADSET)
	enum audio_channel channel;

	channel_assignment_get(&channel);
	if (channel == AUDIO_CH_L) {
		ret = log_set_tag(CH_L_TAG);
		if (ret) {
			return ret;
		}
		/* NOTE: The string below is used by the Nordic CI system */
		LOG_INF(COLOR_CYAN "HEADSET left device" COLOR_RESET);
	} else if (channel == AUDIO_CH_R) {
		ret = log_set_tag(CH_R_TAG);
		if (ret) {
			return ret;
		}
		/* NOTE: The string below is used by the Nordic CI system */
		LOG_INF(COLOR_CYAN "HEADSET right device" COLOR_RESET);
	} else {
		__ASSERT(false, "Unknown channel");
	}

#elif CONFIG_AUDIO_DEV == GATEWAY
	ret = log_set_tag(GW_TAG);
	if (ret) {
		return ret;
	}
	LOG_INF(COLOR_CYAN "Compiled for GATEWAY device" COLOR_RESET);
#endif /* (CONFIG_AUDIO_DEV == HEADSET) */
#endif /* (CONFIG_DEBUG) */

	return 0;
}

// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/utils/board_version.c
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "board_version.h"

#include <zephyr/kernel.h>
#include <zephyr/drivers/adc.h>
#include <zephyr/drivers/gpio.h>
#include <stdlib.h>

#include "board.h"
#include "macros_common.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(board_version, CONFIG_BOARD_VERSION_LOG_LEVEL);

#define BOARD_ID DT_NODELABEL(board_id)

static const struct adc_dt_spec adc = ADC_DT_SPEC_GET(BOARD_ID);
static const struct gpio_dt_spec power_gpios = GPIO_DT_SPEC_GET(BOARD_ID, power_gpios);

/* We allow the ADC register value to deviate by N points in either direction */
#define BOARD_VERSION_TOLERANCE	  70
#define VOLTAGE_STABILIZE_TIME_US 5

static int16_t sample_buffer;

static struct adc_sequence sequence = {
	.buffer = &sample_buffer,
	.buffer_size = sizeof(sample_buffer),
};

/* @brief Enable board version voltage divider and trigger ADC read */
static int divider_value_get(void)
{
	int ret;

	ret = gpio_pin_set_dt(&power_gpios, 1);
	if (ret) {
		return ret;
	}

	/* Wait for voltage to stabilize */
	k_busy_wait(VOLTAGE_STABILIZE_TIME_US);

	ret = adc_read(adc.dev, &sequence);
	if (ret) {
		return ret;
	}

	ret = gpio_pin_set_dt(&power_gpios, 0);
	if (ret) {
		return ret;
	}

	return 0;
}

/**@brief Traverse all defined versions and get the one with the
 * most similar value. Check tolerances.
 */
static int version_search(int reg_value, uint32_t tolerance, struct board_version *board_rev)
{
	uint32_t diff;
	uint32_t smallest_diff = UINT_MAX;
	uint8_t smallest_diff_idx = UCHAR_MAX;

	for (uint8_t i = 0; i < (uint8_t)ARRAY_SIZE(BOARD_VERSION_ARR); i++) {
		diff = abs(BOARD_VERSION_ARR[i].adc_reg_val - reg_value);

		if (diff < smallest_diff) {
			smallest_diff = diff;
			smallest_diff_idx = i;
		}
	}

	if (smallest_diff >= tolerance) {
		LOG_ERR("Board ver search failed. ADC reg read: %d", reg_value);
		return -ESPIPE; /* No valid board_rev found */
	}

	*board_rev = BOARD_VERSION_ARR[smallest_diff_idx];
	LOG_DBG("Board ver search OK!. ADC reg val: %d", reg_value);
	return 0;
}

/* @brief Internal init routine */
static int board_version_init(void)
{
	int ret;
	static bool initialized;

	if (initialized) {
		return 0;
	}

	if (!gpio_is_ready_dt(&power_gpios)) {
		return -ENXIO;
	}

	ret = gpio_pin_configure_dt(&power_gpios, GPIO_OUTPUT_INACTIVE);
	if (ret) {
		return ret;
	}

	if (!device_is_ready(adc.dev)) {
		LOG_ERR("ADC not ready");
		return -ENODEV;
	}

	ret = adc_channel_setup_dt(&adc);
	if (ret) {
		return ret;
	}

	(void)adc_sequence_init_dt(&adc, &sequence);

	initialized = true;
	return 0;
}

int board_version_get(struct board_version *board_rev)
{
	int ret;

	ret = board_version_init();
	if (ret) {
		return ret;
	}

	ret = divider_value_get();
	if (ret) {
		return ret;
	}

	ret = version_search(sample_buffer, BOARD_VERSION_TOLERANCE, board_rev);
	if (ret) {
		return ret;
	}

	return 0;
}

int board_version_valid_check(void)
{
	int ret;
	struct board_version board_rev;

	ret = board_version_get(&board_rev);
	if (ret) {
		LOG_ERR("Unable to get any board version");
		return ret;
	}

	if (BOARD_VERSION_VALID_MSK & (board_rev.mask)) {
		LOG_INF(COLOR_GREEN "Compatible board/HW version found: %s" COLOR_RESET,
			board_rev.name);
	} else {
		LOG_ERR("Invalid board found, rev: %s Valid mask: 0x%x valid mask: 0x%lx",
			board_rev.name, board_rev.mask, BOARD_VERSION_VALID_MSK);
		return -EPERM;
	}

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/utils/uicr.h
/*
 * Copyright (c) 2021 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _UICR_H_
#define _UICR_H_

#include <stdint.h>

// TODO: Discuss better alternative for UICR storage. This memory range is not documented
#define UICR_APP_BASE_ADDR (NRF_UICR_S_BASE + 0xF0)

/**
 * @brief Get raw channel value from UICR
 */
uint8_t uicr_channel_get(void);

/**
 * @brief Write raw channel value to UICR
 *
 * @param channel Channel value
 *
 * @return 0 if successful
 * @return -EROFS if different channel is already written
 * @return -EIO if channel failed to be written
 */
int uicr_channel_set(uint8_t channel);

/**
 * @brief Get Segger serial number value from UICR
 */
uint64_t uicr_snr_get(void);

#endif /* _UICR_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/utils/fw_info_app.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _FW_INFO_APP_H_
#define _FW_INFO_APP_H_

/**
 * @brief Prints firmware info, such as Git details, compiled timestamp etc.
 *
 * @return      0 on success.
 *              Otherwise, error from underlying drivers
 */
int fw_info_app_print(void);

#endif /* _FW_INFO_APP_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/utils/nrf5340_audio_dk.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

/**
 * @brief	Initialize the hardware related modules on the nRF5340 Audio DK/PCA10121
 *
 * @return	0 if successful, error otherwise.
 */
int nrf5340_audio_dk_init(void);


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/utils/channel_assignment.h
/*
 * Copyright (c) 2022 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _CHANNEL_ASSIGNMENT_H_
#define _CHANNEL_ASSIGNMENT_H_

/** @file
 *  @brief Audio channel assignment
 *
 * Audio channel can be assigned at runtime or compile-time, depending on configuration.
 *
 */

#include <audio_defines.h>

#ifndef AUDIO_CHANNEL_DEFAULT
#define AUDIO_CHANNEL_DEFAULT AUDIO_CH_L
#endif /* AUDIO_CHANNEL_DEFAULT */

static const char CH_L_TAG[] = "HL";
static const char CH_R_TAG[] = "HR";
static const char GW_TAG[] = "GW";

/**
 * @brief Get assigned audio channel.
 *
 * @param[out] channel Channel value
 */
void channel_assignment_get(enum audio_channel *channel);

#if CONFIG_AUDIO_HEADSET_CHANNEL_RUNTIME
/**
 * @brief Assign audio channel.
 *
 * @param[out] channel Channel value
 */
void channel_assignment_set(enum audio_channel channel);
#endif /* AUDIO_HEADSET_CHANNEL_RUNTIME */

/**
 * @brief Initialize the channel assignment
 */
void channel_assignment_init(void);

#endif /* _CHANNEL_ASSIGNMENT_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/utils/board_version.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BOARD_VERSION_H_
#define _BOARD_VERSION_H_

#include "board.h"

/**@brief Get the board/HW version
 *
 * @note  This function will init the ADC, perform a reading, and
 *	  return the HW version.
 *
 * @param board_rev	Pointer to container for board version
 *
 * @return 0 on success.
 * Error code on fault or -ESPIPE if no valid version found
 */
int board_version_get(struct board_version *board_rev);

/**@brief Check that the FW is compatible with the HW version
 *
 * @note  This function will init the ADC, perform a reading, and
 * check for valid version match.
 *
 * @note The board file must define a BOARD_VERSION_ARR array of
 * possible valid ADC register values (voltages) for the divider.
 * A BOARD_VERSION_VALID_MSK with valid version bits must also be defined.
 *
 * @return 0 on success. Error code on fault or -EPERM if incompatible board version.
 */
int board_version_valid_check(void);

#endif /* _BOARD_VERSION_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/utils/macros/macros_common.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _MACROS_H_
#define _MACROS_H_

#include <errno.h>

/* Error check. If != 0, print err code and call _SysFatalErrorHandler in main.
 * For debug mode all LEDs are turned on in case of an error.
 */

#define PRINT_AND_OOPS(code)                                                                       \
	do {                                                                                       \
		LOG_ERR("ERR_CHK Err_code: [%d] @ line: %d\t", code, __LINE__);                    \
		k_oops();                                                                          \
	} while (0)

#define ERR_CHK(err_code)                                                                          \
	do {                                                                                       \
		if (err_code) {                                                                    \
			PRINT_AND_OOPS(err_code);                                                  \
		}                                                                                  \
	} while (0)

#define ERR_CHK_MSG(err_code, msg)                                                                 \
	do {                                                                                       \
		if (err_code) {                                                                    \
			LOG_ERR("%s", msg);                                                        \
			PRINT_AND_OOPS(err_code);                                                  \
		}                                                                                  \
	} while (0)

#if (defined(CONFIG_INIT_STACKS) && defined(CONFIG_THREAD_ANALYZER))

#define STACK_USAGE_PRINT(thread_name, p_thread)                                                   \
	do {                                                                                       \
		static uint64_t thread_ts;                                                         \
		size_t unused_space_in_thread_bytes;                                               \
		if (k_uptime_get() - thread_ts > CONFIG_PRINT_STACK_USAGE_MS) {                    \
			k_thread_stack_space_get(p_thread, &unused_space_in_thread_bytes);         \
			thread_ts = k_uptime_get();                                                \
			LOG_DBG("Unused space in %s thread: %d bytes", thread_name,                \
				unused_space_in_thread_bytes);                                     \
		}                                                                                  \
	} while (0)
#else
#define STACK_USAGE_PRINT(thread_name, p_stack)
#endif /* (defined(CONFIG_INIT_STACKS) && defined(CONFIG_THREAD_ANALYZER)) */

#ifndef MIN
#define MIN(a, b) (((a) < (b)) ? (a) : (b))
#endif /* MIN */

#define COLOR_BLACK "\x1B[0;30m"
#define COLOR_RED "\x1B[0;31m"
#define COLOR_GREEN "\x1B[0;32m"
#define COLOR_YELLOW "\x1B[0;33m"
#define COLOR_BLUE "\x1B[0;34m"
#define COLOR_MAGENTA "\x1B[0;35m"
#define COLOR_CYAN "\x1B[0;36m"
#define COLOR_WHITE "\x1B[0;37m"

#define COLOR_RESET "\x1b[0m"

#define BIT_SET(REG, BIT) ((REG) |= (BIT))
#define BIT_CLEAR(REG, BIT) ((REG) &= ~(BIT))

#endif /* _MACROS_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/audio/CMakeLists.txt
#
# Copyright (c) 2022 Nordic Semiconductor
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

target_sources(app PRIVATE
	       ${CMAKE_CURRENT_SOURCE_DIR}/audio_system.c
	       ${CMAKE_CURRENT_SOURCE_DIR}/audio_datapath.c
	       ${CMAKE_CURRENT_SOURCE_DIR}/sw_codec_select.c
	       ${CMAKE_CURRENT_SOURCE_DIR}/le_audio_rx.c
)


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/audio/Kconfig.defaults
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

# Audio sync timer
config NRFX_TIMER1
	default y

# Audio sync timer
config NRFX_DPPI
	default y


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/audio/le_audio_rx.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include <zephyr/kernel.h>
#include <nrfx_clock.h>

#include "streamctrl.h"
#include "audio_datapath.h"
#include "macros_common.h"
#include "audio_system.h"
#include "audio_sync_timer.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(le_audio_rx, CONFIG_LE_AUDIO_RX_LOG_LEVEL);

struct ble_iso_data {
	uint8_t data[CONFIG_BT_ISO_RX_MTU];
	size_t data_size;
	bool bad_frame;
	uint32_t sdu_ref;
	uint32_t recv_frame_ts;
} __packed;

struct rx_stats {
	uint32_t recv_cnt;
	uint32_t bad_frame_cnt;
	uint32_t data_size_mismatch_cnt;
};

static bool initialized;
static struct k_thread audio_datapath_thread_data;
static k_tid_t audio_datapath_thread_id;
K_THREAD_STACK_DEFINE(audio_datapath_thread_stack, CONFIG_AUDIO_DATAPATH_STACK_SIZE);

DATA_FIFO_DEFINE(ble_fifo_rx, CONFIG_BUF_BLE_RX_PACKET_NUM, WB_UP(sizeof(struct ble_iso_data)));

/* Callback for handling ISO RX */
void le_audio_rx_data_handler(uint8_t const *const p_data, size_t data_size, bool bad_frame,
			      uint32_t sdu_ref, enum audio_channel channel_index,
			      size_t desired_data_size)
{
	int ret;
	uint32_t blocks_alloced_num, blocks_locked_num;
	struct ble_iso_data *iso_received = NULL;
	static struct rx_stats rx_stats[AUDIO_CH_NUM];
	static uint32_t num_overruns;

	if (!initialized) {
		ERR_CHK_MSG(-EPERM, "Data received but le_audio_rx is not initialized");
	}

	/* Capture timestamp of when audio frame is received */
	uint32_t recv_frame_ts = audio_sync_timer_capture();

	rx_stats[channel_index].recv_cnt++;

	if (data_size != desired_data_size) {
		/* A valid frame should always be equal to desired_data_size, set bad_frame
		 * if that is not the case
		 */
		bad_frame = true;
		rx_stats[channel_index].data_size_mismatch_cnt++;
	}

	if (bad_frame) {
		rx_stats[channel_index].bad_frame_cnt++;
	}

	if ((rx_stats[channel_index].recv_cnt % 100) == 0 && rx_stats[channel_index].recv_cnt) {
		/* NOTE: The string below is used by the Nordic CI system */
		LOG_DBG("ISO RX SDUs: Ch: %d Total: %d Bad: %d Size mismatch %d", channel_index,
			rx_stats[channel_index].recv_cnt, rx_stats[channel_index].bad_frame_cnt,
			rx_stats[channel_index].data_size_mismatch_cnt);
	}

	if (stream_state_get() != STATE_STREAMING) {
		/* Throw away data */
		LOG_WRN("Not in streaming state, throwing data: %d", stream_state_get());
		return;
	}

	if (channel_index != AUDIO_CH_L && (CONFIG_AUDIO_DEV == GATEWAY)) {
		/* Only left channel RX data in use on gateway */
		return;
	}

	ret = data_fifo_num_used_get(&ble_fifo_rx, &blocks_alloced_num, &blocks_locked_num);
	ERR_CHK(ret);

	if (blocks_alloced_num >= CONFIG_BUF_BLE_RX_PACKET_NUM) {
		/* FIFO buffer is full, swap out oldest frame for a new one */

		void *stale_data;
		size_t stale_size;
		num_overruns++;

		if ((num_overruns % 100) == 1) {
			LOG_WRN("BLE ISO RX overrun: Num: %d", num_overruns);
		}

		ret = data_fifo_pointer_last_filled_get(&ble_fifo_rx, &stale_data, &stale_size,
							K_NO_WAIT);
		ERR_CHK(ret);

		data_fifo_block_free(&ble_fifo_rx, stale_data);
	}

	ret = data_fifo_pointer_first_vacant_get(&ble_fifo_rx, (void *)&iso_received, K_NO_WAIT);
	ERR_CHK_MSG(ret, "Unable to get FIFO pointer");

	if (data_size > ARRAY_SIZE(iso_received->data)) {
		ERR_CHK_MSG(-ENOMEM, "Data size too large for buffer");
		return;
	}

	memcpy(iso_received->data, p_data, data_size);

	iso_received->bad_frame = bad_frame;
	iso_received->data_size = data_size;
	iso_received->sdu_ref = sdu_ref;
	iso_received->recv_frame_ts = recv_frame_ts;

	ret = data_fifo_block_lock(&ble_fifo_rx, (void *)&iso_received,
				   sizeof(struct ble_iso_data));
	ERR_CHK_MSG(ret, "Failed to lock block");
}

/**
 * @brief	Receive data from BLE through a k_fifo and send to USB or audio datapath.
 */
static void audio_datapath_thread(void *dummy1, void *dummy2, void *dummy3)
{
	int ret;
	struct ble_iso_data *iso_received = NULL;
	size_t iso_received_size;

	while (1) {
		ret = data_fifo_pointer_last_filled_get(&ble_fifo_rx, (void *)&iso_received,
							&iso_received_size, K_FOREVER);
		ERR_CHK(ret);

		if (IS_ENABLED(CONFIG_AUDIO_SOURCE_USB) && (CONFIG_AUDIO_DEV == GATEWAY)) {
			ret = audio_system_decode(iso_received->data, iso_received->data_size,
						  iso_received->bad_frame);
			ERR_CHK(ret);
		} else {
			audio_datapath_stream_out(iso_received->data, iso_received->data_size,
						  iso_received->sdu_ref, iso_received->bad_frame,
						  iso_received->recv_frame_ts);
		}
		data_fifo_block_free(&ble_fifo_rx, (void *)iso_received);

		STACK_USAGE_PRINT("audio_datapath_thread", &audio_datapath_thread_data);
	}
}

static int audio_datapath_thread_create(void)
{
	int ret;

	audio_datapath_thread_id = k_thread_create(
		&audio_datapath_thread_data, audio_datapath_thread_stack,
		CONFIG_AUDIO_DATAPATH_STACK_SIZE, (k_thread_entry_t)audio_datapath_thread, NULL,
		NULL, NULL, K_PRIO_PREEMPT(CONFIG_AUDIO_DATAPATH_THREAD_PRIO), 0, K_NO_WAIT);
	ret = k_thread_name_set(audio_datapath_thread_id, "AUDIO_DATAPATH");
	if (ret) {
		LOG_ERR("Failed to create audio_datapath thread");
		return ret;
	}

	return 0;
}

int le_audio_rx_init(void)
{
	int ret;

	if (initialized) {
		return -EALREADY;
	}

	ret = data_fifo_init(&ble_fifo_rx);
	if (ret) {
		LOG_ERR("Failed to set up ble_rx FIFO");
		return ret;
	}

	ret = audio_datapath_thread_create();
	if (ret) {
		return ret;
	}

	initialized = true;

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/audio/audio_system.c
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "audio_system.h"

#include <zephyr/kernel.h>
#include <zephyr/shell/shell.h>

#include "macros_common.h"
#include "sw_codec_select.h"
#include "audio_datapath.h"
#include "audio_i2s.h"
#include "data_fifo.h"
#include "hw_codec.h"
#include "tone.h"
#include "contin_array.h"
#include "pcm_stream_channel_modifier.h"
#include "audio_usb.h"
#include "streamctrl.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(audio_system, CONFIG_AUDIO_SYSTEM_LOG_LEVEL);

#define FIFO_TX_BLOCK_COUNT (CONFIG_FIFO_FRAME_SPLIT_NUM * CONFIG_FIFO_TX_FRAME_COUNT)
#define FIFO_RX_BLOCK_COUNT (CONFIG_FIFO_FRAME_SPLIT_NUM * CONFIG_FIFO_RX_FRAME_COUNT)

#define DEBUG_INTERVAL_NUM     1000
#define TEST_TONE_BASE_FREQ_HZ 1000

K_THREAD_STACK_DEFINE(encoder_thread_stack, CONFIG_ENCODER_STACK_SIZE);

DATA_FIFO_DEFINE(fifo_tx, FIFO_TX_BLOCK_COUNT, WB_UP(BLOCK_SIZE_BYTES));
DATA_FIFO_DEFINE(fifo_rx, FIFO_RX_BLOCK_COUNT, WB_UP(BLOCK_SIZE_BYTES));

static K_SEM_DEFINE(sem_encoder_start, 0, 1);

static struct k_thread encoder_thread_data;
static k_tid_t encoder_thread_id;

static struct k_poll_signal encoder_sig;

static struct k_poll_event encoder_evt =
	K_POLL_EVENT_INITIALIZER(K_POLL_TYPE_SIGNAL, K_POLL_MODE_NOTIFY_ONLY, &encoder_sig);

static struct sw_codec_config sw_codec_cfg;
/* Buffer which can hold max 1 period test tone at 1000 Hz */
static int16_t test_tone_buf[CONFIG_AUDIO_SAMPLE_RATE_HZ / 1000];
static size_t test_tone_size;

static bool sample_rate_valid(uint32_t sample_rate_hz)
{
	if (sample_rate_hz == 16000 || sample_rate_hz == 24000 || sample_rate_hz == 48000) {
		return true;
	}

	return false;
}

static void audio_gateway_configure(void)
{
	if (IS_ENABLED(CONFIG_SW_CODEC_LC3)) {
		sw_codec_cfg.sw_codec = SW_CODEC_LC3;
	} else {
		ERR_CHK_MSG(-EINVAL, "No codec selected");
	}

#if (CONFIG_STREAM_BIDIRECTIONAL)
	sw_codec_cfg.decoder.enabled = true;
	sw_codec_cfg.decoder.num_ch = 1;
	sw_codec_cfg.decoder.channel_mode = SW_CODEC_MONO;
#endif /* (CONFIG_STREAM_BIDIRECTIONAL) */

	if (IS_ENABLED(CONFIG_MONO_TO_ALL_RECEIVERS)) {
		sw_codec_cfg.encoder.num_ch = 1;
	} else {
		sw_codec_cfg.encoder.num_ch = 2;
	}

	sw_codec_cfg.encoder.channel_mode =
		(sw_codec_cfg.encoder.num_ch == 1) ? SW_CODEC_MONO : SW_CODEC_STEREO;
	sw_codec_cfg.encoder.enabled = true;
}

static void audio_headset_configure(void)
{
	if (IS_ENABLED(CONFIG_SW_CODEC_LC3)) {
		sw_codec_cfg.sw_codec = SW_CODEC_LC3;
	} else {
		ERR_CHK_MSG(-EINVAL, "No codec selected");
	}

#if (CONFIG_STREAM_BIDIRECTIONAL)
	sw_codec_cfg.encoder.enabled = true;
	sw_codec_cfg.encoder.num_ch = 1;
	sw_codec_cfg.encoder.channel_mode = SW_CODEC_MONO;
#endif /* (CONFIG_STREAM_BIDIRECTIONAL) */

	sw_codec_cfg.decoder.num_ch = 1;
	sw_codec_cfg.decoder.channel_mode = SW_CODEC_MONO;

	if (IS_ENABLED(CONFIG_SD_CARD_PLAYBACK)) {
		/* Need an extra decoder channel to decode data from SD card */
		sw_codec_cfg.decoder.num_ch++;
	}

	sw_codec_cfg.decoder.enabled = true;
}

static void encoder_thread(void *arg1, void *arg2, void *arg3)
{
	int ret;
	uint32_t blocks_alloced_num;
	uint32_t blocks_locked_num;

	int debug_trans_count = 0;
	size_t encoded_data_size = 0;

	void *tmp_pcm_raw_data[CONFIG_FIFO_FRAME_SPLIT_NUM];
	char pcm_raw_data[FRAME_SIZE_BYTES];

	static uint8_t *encoded_data;
	static size_t pcm_block_size;
	static uint32_t test_tone_finite_pos;

	while (1) {
		/* Don't start encoding until the stream needing it has started */
		ret = k_poll(&encoder_evt, 1, K_FOREVER);

		/* Get PCM data from I2S */
		/* Since one audio frame is divided into a number of
		 * blocks, we need to fetch the pointers to all of these
		 * blocks before copying it to a continuous area of memory
		 * before sending it to the encoder
		 */
		for (int i = 0; i < CONFIG_FIFO_FRAME_SPLIT_NUM; i++) {
			ret = data_fifo_pointer_last_filled_get(&fifo_rx, &tmp_pcm_raw_data[i],
								&pcm_block_size, K_FOREVER);
			ERR_CHK(ret);
			memcpy(pcm_raw_data + (i * BLOCK_SIZE_BYTES), tmp_pcm_raw_data[i],
			       pcm_block_size);

			data_fifo_block_free(&fifo_rx, tmp_pcm_raw_data[i]);
		}

		if (sw_codec_cfg.encoder.enabled) {
			if (test_tone_size) {
				/* Test tone takes over audio stream */
				uint32_t num_bytes;
				char tmp[FRAME_SIZE_BYTES / 2];

				ret = contin_array_create(tmp, FRAME_SIZE_BYTES / 2, test_tone_buf,
							  test_tone_size, &test_tone_finite_pos);
				ERR_CHK(ret);

				ret = pscm_copy_pad(tmp, FRAME_SIZE_BYTES / 2,
						    CONFIG_AUDIO_BIT_DEPTH_BITS, pcm_raw_data,
						    &num_bytes);
				ERR_CHK(ret);
			}

			ret = sw_codec_encode(pcm_raw_data, FRAME_SIZE_BYTES, &encoded_data,
					      &encoded_data_size);

			ERR_CHK_MSG(ret, "Encode failed");
		}

		/* Print block usage */
		if (debug_trans_count == DEBUG_INTERVAL_NUM) {
			ret = data_fifo_num_used_get(&fifo_rx, &blocks_alloced_num,
						     &blocks_locked_num);
			ERR_CHK(ret);
			LOG_DBG(COLOR_CYAN "RX alloced: %d, locked: %d" COLOR_RESET,
				blocks_alloced_num, blocks_locked_num);
			debug_trans_count = 0;
		} else {
			debug_trans_count++;
		}

		if (sw_codec_cfg.encoder.enabled) {
			streamctrl_send(encoded_data, encoded_data_size,
					sw_codec_cfg.encoder.num_ch);
		}
		STACK_USAGE_PRINT("encoder_thread", &encoder_thread_data);
	}
}

void audio_system_encoder_start(void)
{
	LOG_DBG("Encoder started");
	k_poll_signal_raise(&encoder_sig, 0);
}

void audio_system_encoder_stop(void)
{
	k_poll_signal_reset(&encoder_sig);
}

int audio_system_encode_test_tone_set(uint32_t freq)
{
	int ret;

	if (freq == 0) {
		test_tone_size = 0;
		return 0;
	}

	if (IS_ENABLED(CONFIG_AUDIO_TEST_TONE)) {
		ret = tone_gen(test_tone_buf, &test_tone_size, freq, CONFIG_AUDIO_SAMPLE_RATE_HZ,
			       1);
		ERR_CHK(ret);
	} else {
		LOG_ERR("Test tone is not enabled");
		return -ENXIO;
	}

	if (test_tone_size > sizeof(test_tone_buf)) {
		return -ENOMEM;
	}

	return 0;
}

int audio_system_encode_test_tone_step(void)
{
	int ret;
	static uint32_t test_tone_hz;

	if (CONFIG_AUDIO_BIT_DEPTH_BITS != 16) {
		LOG_WRN("Tone gen only supports 16 bits");
		return -ECANCELED;
	}

	if (test_tone_hz == 0) {
		test_tone_hz = TEST_TONE_BASE_FREQ_HZ;
	} else if (test_tone_hz >= TEST_TONE_BASE_FREQ_HZ * 4) {
		test_tone_hz = 0;
	} else {
		test_tone_hz = test_tone_hz * 2;
	}

	if (test_tone_hz != 0) {
		LOG_INF("Test tone set at %d Hz", test_tone_hz);
	} else {
		LOG_INF("Test tone off");
	}

	ret = audio_system_encode_test_tone_set(test_tone_hz);
	if (ret) {
		LOG_ERR("Failed to generate test tone");
		return ret;
	}

	return 0;
}

int audio_system_config_set(uint32_t encoder_sample_rate_hz, uint32_t encoder_bitrate,
			    uint32_t decoder_sample_rate_hz)
{
	if (sample_rate_valid(encoder_sample_rate_hz)) {
		sw_codec_cfg.encoder.sample_rate_hz = encoder_sample_rate_hz;
	} else if (encoder_sample_rate_hz) {
		LOG_ERR("%d is not a valid sample rate", encoder_sample_rate_hz);
		return -EINVAL;
	}

	if (sample_rate_valid(decoder_sample_rate_hz)) {
		sw_codec_cfg.decoder.sample_rate_hz = decoder_sample_rate_hz;
	} else if (decoder_sample_rate_hz) {
		LOG_ERR("%d is not a valid sample rate", decoder_sample_rate_hz);
		return -EINVAL;
	}

	if (encoder_bitrate) {
		sw_codec_cfg.encoder.bitrate = encoder_bitrate;
	}

	return 0;
}

/* This function is only used on gateway using USB as audio source and bidirectional stream */
int audio_system_decode(void const *const encoded_data, size_t encoded_data_size, bool bad_frame)
{
	int ret;
	uint32_t blocks_alloced_num;
	uint32_t blocks_locked_num;
	static int debug_trans_count;
	static void *tmp_pcm_raw_data[CONFIG_FIFO_FRAME_SPLIT_NUM];
	static void *pcm_raw_data;
	size_t pcm_block_size;

	if (!sw_codec_cfg.initialized) {
		/* Throw away data */
		/* This can happen when using play/pause since there might be
		 * some packages left in the buffers
		 */
		LOG_DBG("Trying to decode while codec is not initialized");
		return -EPERM;
	}

	ret = data_fifo_num_used_get(&fifo_tx, &blocks_alloced_num, &blocks_locked_num);
	if (ret) {
		return ret;
	}

	uint8_t free_blocks_num = FIFO_TX_BLOCK_COUNT - blocks_locked_num;

	/* If not enough space for a full frame, remove oldest samples to make room */
	if (free_blocks_num < CONFIG_FIFO_FRAME_SPLIT_NUM) {
		void *old_data;
		size_t size;

		for (int i = 0; i < (CONFIG_FIFO_FRAME_SPLIT_NUM - free_blocks_num); i++) {
			ret = data_fifo_pointer_last_filled_get(&fifo_tx, &old_data, &size,
								K_NO_WAIT);
			if (ret == -ENOMSG) {
				/* If there are no more blocks in FIFO, break */
				break;
			}

			data_fifo_block_free(&fifo_tx, old_data);
		}
	}

	for (int i = 0; i < CONFIG_FIFO_FRAME_SPLIT_NUM; i++) {
		ret = data_fifo_pointer_first_vacant_get(&fifo_tx, &tmp_pcm_raw_data[i], K_FOREVER);
		if (ret) {
			return ret;
		}
	}

	ret = sw_codec_decode(encoded_data, encoded_data_size, bad_frame, &pcm_raw_data,
			      &pcm_block_size);
	if (ret) {
		LOG_ERR("Failed to decode");
		return ret;
	}

	/* Split decoded frame into CONFIG_FIFO_FRAME_SPLIT_NUM blocks */
	for (int i = 0; i < CONFIG_FIFO_FRAME_SPLIT_NUM; i++) {
		memcpy(tmp_pcm_raw_data[i], (char *)pcm_raw_data + (i * (BLOCK_SIZE_BYTES)),
		       BLOCK_SIZE_BYTES);

		ret = data_fifo_block_lock(&fifo_tx, &tmp_pcm_raw_data[i], BLOCK_SIZE_BYTES);
		if (ret) {
			LOG_ERR("Failed to lock block");
			return ret;
		}
	}
	if (debug_trans_count == DEBUG_INTERVAL_NUM) {
		ret = data_fifo_num_used_get(&fifo_tx, &blocks_alloced_num, &blocks_locked_num);
		if (ret) {
			return ret;
		}
		LOG_DBG(COLOR_MAGENTA "TX alloced: %d, locked: %d" COLOR_RESET, blocks_alloced_num,
			blocks_locked_num);
		debug_trans_count = 0;
	} else {
		debug_trans_count++;
	}

	return 0;
}

/**@brief Initializes the FIFOs, the codec, and starts the I2S
 */
void audio_system_start(void)
{
	int ret;

	if (CONFIG_AUDIO_DEV == HEADSET) {
		audio_headset_configure();
	} else if (CONFIG_AUDIO_DEV == GATEWAY) {
		audio_gateway_configure();
	} else {
		LOG_ERR("Invalid CONFIG_AUDIO_DEV: %d", CONFIG_AUDIO_DEV);
		ERR_CHK(-EINVAL);
	}

	if (!fifo_tx.initialized) {
		ret = data_fifo_init(&fifo_tx);
		ERR_CHK_MSG(ret, "Failed to set up tx FIFO");
	}

	if (!fifo_rx.initialized) {
		ret = data_fifo_init(&fifo_rx);
		ERR_CHK_MSG(ret, "Failed to set up rx FIFO");
	}

	ret = sw_codec_init(sw_codec_cfg);
	ERR_CHK_MSG(ret, "Failed to set up codec");

	sw_codec_cfg.initialized = true;

	if (sw_codec_cfg.encoder.enabled && encoder_thread_id == NULL) {
		encoder_thread_id = k_thread_create(
			&encoder_thread_data, encoder_thread_stack, CONFIG_ENCODER_STACK_SIZE,
			(k_thread_entry_t)encoder_thread, NULL, NULL, NULL,
			K_PRIO_PREEMPT(CONFIG_ENCODER_THREAD_PRIO), 0, K_NO_WAIT);
		ret = k_thread_name_set(encoder_thread_id, "ENCODER");
		ERR_CHK(ret);
	}

#if ((CONFIG_AUDIO_SOURCE_USB) && (CONFIG_AUDIO_DEV == GATEWAY))
	ret = audio_usb_start(&fifo_tx, &fifo_rx);
	ERR_CHK(ret);
#else
	ret = hw_codec_default_conf_enable();
	ERR_CHK(ret);

	ret = audio_datapath_start(&fifo_rx);
	ERR_CHK(ret);
#endif /* ((CONFIG_AUDIO_SOURCE_USB) && (CONFIG_AUDIO_DEV == GATEWAY))) */
}

void audio_system_stop(void)
{
	int ret;

	if (!sw_codec_cfg.initialized) {
		LOG_WRN("Codec already unitialized");
		return;
	}

	LOG_DBG("Stopping codec");

#if ((CONFIG_AUDIO_DEV == GATEWAY) && CONFIG_AUDIO_SOURCE_USB)
	audio_usb_stop();
#else
	ret = hw_codec_soft_reset();
	ERR_CHK(ret);

	ret = audio_datapath_stop();
	ERR_CHK(ret);
#endif /* ((CONFIG_AUDIO_DEV == GATEWAY) && CONFIG_AUDIO_SOURCE_USB) */

	ret = sw_codec_uninit(sw_codec_cfg);
	ERR_CHK_MSG(ret, "Failed to uninit codec");
	sw_codec_cfg.initialized = false;

	data_fifo_empty(&fifo_rx);
	data_fifo_empty(&fifo_tx);
}

int audio_system_fifo_rx_block_drop(void)
{
	int ret;
	void *temp;
	size_t temp_size;

	ret = data_fifo_pointer_last_filled_get(&fifo_rx, &temp, &temp_size, K_NO_WAIT);
	if (ret) {
		LOG_WRN("Failed to get last filled block");
		return -ECANCELED;
	}

	data_fifo_block_free(&fifo_rx, temp);

	LOG_DBG("Block dropped");
	return 0;
}

int audio_system_decoder_num_ch_get(void)
{
	return sw_codec_cfg.decoder.num_ch;
}

int audio_system_init(void)
{
	int ret;

#if ((CONFIG_AUDIO_DEV == GATEWAY) && (CONFIG_AUDIO_SOURCE_USB))
	ret = audio_usb_init();
	if (ret) {
		LOG_ERR("Failed to initialize USB: %d", ret);
		return ret;
	}
#else
	ret = audio_datapath_init();
	if (ret) {
		LOG_ERR("Failed to initialize audio datapath: %d", ret);
		return ret;
	}

	ret = hw_codec_init();
	if (ret) {
		LOG_ERR("Failed to initialize HW codec: %d", ret);
		return ret;
	}
#endif
	k_poll_signal_init(&encoder_sig);

	return 0;
}

static int cmd_audio_system_start(const struct shell *shell, size_t argc, const char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	audio_system_start();

	shell_print(shell, "Audio system started");

	return 0;
}

static int cmd_audio_system_stop(const struct shell *shell, size_t argc, const char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	audio_system_stop();

	shell_print(shell, "Audio system stopped");

	return 0;
}

SHELL_STATIC_SUBCMD_SET_CREATE(audio_system_cmd,
			       SHELL_COND_CMD(CONFIG_SHELL, start, NULL, "Start the audio system",
					      cmd_audio_system_start),
			       SHELL_COND_CMD(CONFIG_SHELL, stop, NULL, "Stop the audio system",
					      cmd_audio_system_stop),
			       SHELL_SUBCMD_SET_END);

SHELL_CMD_REGISTER(audio_system, &audio_system_cmd, "Audio system commands", NULL);


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/audio/sw_codec_select.c
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "sw_codec_select.h"

#include <zephyr/kernel.h>
#include <errno.h>

#include "channel_assignment.h"
#include "pcm_stream_channel_modifier.h"
#include "sample_rate_converter.h"
#if (CONFIG_SW_CODEC_LC3)
#include "sw_codec_lc3.h"
#endif /* (CONFIG_SW_CODEC_LC3) */

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(sw_codec_select, CONFIG_SW_CODEC_SELECT_LOG_LEVEL);

static struct sw_codec_config m_config;

static struct sample_rate_converter_ctx encoder_converters[AUDIO_CH_NUM];
static struct sample_rate_converter_ctx decoder_converters[AUDIO_CH_NUM];

/**
 * @brief	Converts the sample rate of the uncompressed audio stream if needed.
 *
 * @details	Two buffers must be made available for the function: the input_data buffer that
 *		contains the samples for the audio stream, and the conversion buffer that will be
 *		used to store the converted audio stream. data_ptr will point to conversion_buffer
 *		if a conversion took place; otherwise, it will point to input_data.
 *
 * @param[in]	ctx			Sample rate converter context.
 * @param[in]	input_sample_rate	Input sample rate.
 * @param[in]	output_sample_rate	Output sample rate.
 * @param[in]	input_data		Data coming in. Buffer is assumed to be of size
 *					PCM_NUM_BYTES_MONO.
 * @param[in]	input_data_size		Size of input data.
 * @param[in]	conversion_buffer	Buffer to perform sample rate conversion. Must be of size
 *					PCM_NUM_BYTES_MONO.
 * @param[out]	data_ptr		Pointer to the data to be used from this point on.
 *					Will point to either @p input_data or @p conversion_buffer.
 * @param[out]	output_size		Number of bytes out.
 *
 * @retval	-ENOTSUP	Sample rates are not equal, and the sample rate conversion has not
 *been enabled in the application.
 * @retval	0		Success.
 */
static int sw_codec_sample_rate_convert(struct sample_rate_converter_ctx *ctx,
					uint32_t input_sample_rate, uint32_t output_sample_rate,
					char *input_data, size_t input_data_size,
					char *conversion_buffer, char **data_ptr,
					size_t *output_size)
{
	int ret;

	if (input_sample_rate == output_sample_rate) {
		*data_ptr = input_data;
		*output_size = input_data_size;
	} else if (IS_ENABLED(CONFIG_SAMPLE_RATE_CONVERTER)) {
		ret = sample_rate_converter_process(ctx, SAMPLE_RATE_FILTER_SIMPLE, input_data,
						    input_data_size, input_sample_rate,
						    conversion_buffer, PCM_NUM_BYTES_MONO,
						    output_size, output_sample_rate);
		if (ret) {
			LOG_ERR("Failed to convert sample rate: %d", ret);
			return ret;
		}

		*data_ptr = conversion_buffer;
	} else {
		LOG_ERR("Sample rates are not equal, and sample rate conversion has not been "
			"enabled in the application.");
		return -ENOTSUP;
	}

	return 0;
}

bool sw_codec_is_initialized(void)
{
	return m_config.initialized;
}

int sw_codec_encode(void *pcm_data, size_t pcm_size, uint8_t **encoded_data, size_t *encoded_size)
{
	int ret;

	/* Temp storage for split stereo PCM signal */
	char pcm_data_mono_system_sample_rate[AUDIO_CH_NUM][PCM_NUM_BYTES_MONO] = {0};
	/* Make sure we have enough space for two frames (stereo) */
	static uint8_t m_encoded_data[ENC_MAX_FRAME_SIZE * AUDIO_CH_NUM];

	char pcm_data_mono_converted_buf[AUDIO_CH_NUM][PCM_NUM_BYTES_MONO] = {0};

	size_t pcm_block_size_mono_system_sample_rate;
	size_t pcm_block_size_mono;

	if (!m_config.encoder.enabled) {
		LOG_ERR("Encoder has not been initialized");
		return -ENXIO;
	}

	switch (m_config.sw_codec) {
	case SW_CODEC_LC3: {
#if (CONFIG_SW_CODEC_LC3)
		uint16_t encoded_bytes_written;
		char *pcm_data_mono_ptrs[m_config.encoder.channel_mode];

		/* Since LC3 is a single channel codec, we must split the
		 * stereo PCM stream
		 */
		ret = pscm_two_channel_split(pcm_data, pcm_size, CONFIG_AUDIO_BIT_DEPTH_BITS,
					     pcm_data_mono_system_sample_rate[AUDIO_CH_L],
					     pcm_data_mono_system_sample_rate[AUDIO_CH_R],
					     &pcm_block_size_mono_system_sample_rate);
		if (ret) {
			return ret;
		}

		for (int i = 0; i < m_config.encoder.channel_mode; ++i) {
			ret = sw_codec_sample_rate_convert(
				&encoder_converters[i], CONFIG_AUDIO_SAMPLE_RATE_HZ,
				m_config.encoder.sample_rate_hz,
				pcm_data_mono_system_sample_rate[i],
				pcm_block_size_mono_system_sample_rate,
				pcm_data_mono_converted_buf[i], &pcm_data_mono_ptrs[i],
				&pcm_block_size_mono);
			if (ret) {
				LOG_ERR("Sample rate conversion failed for channel %d: %d", i, ret);
				return ret;
			}
		}

		switch (m_config.encoder.channel_mode) {
		case SW_CODEC_MONO: {
			ret = sw_codec_lc3_enc_run(pcm_data_mono_ptrs[AUDIO_CH_L],
						   pcm_block_size_mono, LC3_USE_BITRATE_FROM_INIT,
						   0, sizeof(m_encoded_data), m_encoded_data,
						   &encoded_bytes_written);
			if (ret) {
				return ret;
			}
			break;
		}
		case SW_CODEC_STEREO: {
			ret = sw_codec_lc3_enc_run(pcm_data_mono_ptrs[AUDIO_CH_L],
						   pcm_block_size_mono, LC3_USE_BITRATE_FROM_INIT,
						   AUDIO_CH_L, sizeof(m_encoded_data),
						   m_encoded_data, &encoded_bytes_written);
			if (ret) {
				return ret;
			}

			ret = sw_codec_lc3_enc_run(
				pcm_data_mono_ptrs[AUDIO_CH_R], pcm_block_size_mono,
				LC3_USE_BITRATE_FROM_INIT, AUDIO_CH_R,
				sizeof(m_encoded_data) - encoded_bytes_written,
				m_encoded_data + encoded_bytes_written, &encoded_bytes_written);
			if (ret) {
				return ret;
			}
			encoded_bytes_written += encoded_bytes_written;
			break;
		}
		default:
			LOG_ERR("Unsupported channel mode for encoder: %d",
				m_config.encoder.channel_mode);
			return -ENODEV;
		}

		*encoded_data = m_encoded_data;
		*encoded_size = encoded_bytes_written;

#endif /* (CONFIG_SW_CODEC_LC3) */
		break;
	}
	default:
		LOG_ERR("Unsupported codec: %d", m_config.sw_codec);
		return -ENODEV;
	}

	return 0;
}

int sw_codec_decode(uint8_t const *const encoded_data, size_t encoded_size, bool bad_frame,
		    void **decoded_data, size_t *decoded_size)
{
	if (!m_config.decoder.enabled) {
		LOG_ERR("Decoder has not been initialized");
		return -ENXIO;
	}

	int ret;

	static char pcm_data_stereo[PCM_NUM_BYTES_STEREO];

	char decoded_data_mono[AUDIO_CH_NUM][PCM_NUM_BYTES_MONO] = {0};
	char decoded_data_mono_system_sample_rate[AUDIO_CH_NUM][PCM_NUM_BYTES_MONO] = {0};

	size_t pcm_size_stereo = 0;
	size_t pcm_size_mono = 0;
	size_t decoded_data_size = 0;

	switch (m_config.sw_codec) {
	case SW_CODEC_LC3: {
#if (CONFIG_SW_CODEC_LC3)
		char *pcm_in_data_ptrs[m_config.decoder.channel_mode];

		switch (m_config.decoder.channel_mode) {
		case SW_CODEC_MONO: {
			if (bad_frame && IS_ENABLED(CONFIG_SW_CODEC_OVERRIDE_PLC)) {
				memset(decoded_data_mono[AUDIO_CH_L], 0, PCM_NUM_BYTES_MONO);
				decoded_data_size = PCM_NUM_BYTES_MONO;
			} else {
				ret = sw_codec_lc3_dec_run(
					encoded_data, encoded_size, LC3_PCM_NUM_BYTES_MONO, 0,
					decoded_data_mono[AUDIO_CH_L],
					(uint16_t *)&decoded_data_size, bad_frame);
				if (ret) {
					return ret;
				}

				ret = sw_codec_sample_rate_convert(
					&decoder_converters[AUDIO_CH_L],
					m_config.decoder.sample_rate_hz,
					CONFIG_AUDIO_SAMPLE_RATE_HZ, decoded_data_mono[AUDIO_CH_L],
					decoded_data_size,
					decoded_data_mono_system_sample_rate[AUDIO_CH_L],
					&pcm_in_data_ptrs[AUDIO_CH_L], &pcm_size_mono);
				if (ret) {
					LOG_ERR("Sample rate conversion failed for mono: %d", ret);
					return ret;
				}
			}

			/* For now, i2s is only stereo, so in order to send
			 * just one channel, we need to insert 0 for the
			 * other channel
			 */
			ret = pscm_zero_pad(pcm_in_data_ptrs[AUDIO_CH_L], pcm_size_mono,
					    m_config.decoder.audio_ch, CONFIG_AUDIO_BIT_DEPTH_BITS,
					    pcm_data_stereo, &pcm_size_stereo);
			if (ret) {
				return ret;
			}
			break;
		}
		case SW_CODEC_STEREO: {
			if (bad_frame && IS_ENABLED(CONFIG_SW_CODEC_OVERRIDE_PLC)) {
				memset(decoded_data_mono[AUDIO_CH_L], 0, PCM_NUM_BYTES_MONO);
				memset(decoded_data_mono[AUDIO_CH_R], 0, PCM_NUM_BYTES_MONO);
				decoded_data_size = PCM_NUM_BYTES_MONO;
			} else {
				/* Decode left channel */
				ret = sw_codec_lc3_dec_run(
					encoded_data, encoded_size / 2, LC3_PCM_NUM_BYTES_MONO,
					AUDIO_CH_L, decoded_data_mono[AUDIO_CH_L],
					(uint16_t *)&decoded_data_size, bad_frame);
				if (ret) {
					return ret;
				}

				/* Decode right channel */
				ret = sw_codec_lc3_dec_run(
					(encoded_data + (encoded_size / 2)), encoded_size / 2,
					LC3_PCM_NUM_BYTES_MONO, AUDIO_CH_R,
					decoded_data_mono[AUDIO_CH_R],
					(uint16_t *)&decoded_data_size, bad_frame);
				if (ret) {
					return ret;
				}

				for (int i = 0; i < m_config.decoder.channel_mode; ++i) {
					ret = sw_codec_sample_rate_convert(
						&decoder_converters[i],
						m_config.decoder.sample_rate_hz,
						CONFIG_AUDIO_SAMPLE_RATE_HZ, decoded_data_mono[i],
						decoded_data_size,
						decoded_data_mono_system_sample_rate[i],
						&pcm_in_data_ptrs[i], &pcm_size_mono);
					if (ret) {
						LOG_ERR("Sample rate conversion failed for channel "
							"%d : %d",
							i, ret);
						return ret;
					}
				}
			}

			ret = pscm_combine(pcm_in_data_ptrs[AUDIO_CH_L],
					   pcm_in_data_ptrs[AUDIO_CH_R], pcm_size_mono,
					   CONFIG_AUDIO_BIT_DEPTH_BITS, pcm_data_stereo,
					   &pcm_size_stereo);
			if (ret) {
				return ret;
			}
			break;
		}
		default:
			LOG_ERR("Unsupported channel mode for decoder: %d",
				m_config.decoder.channel_mode);
			return -ENODEV;
		}

		*decoded_size = pcm_size_stereo;
		*decoded_data = pcm_data_stereo;
#endif /* (CONFIG_SW_CODEC_LC3) */
		break;
	}
	default:
		LOG_ERR("Unsupported codec: %d", m_config.sw_codec);
		return -ENODEV;
	}
	return 0;
}

int sw_codec_uninit(struct sw_codec_config sw_codec_cfg)
{
	int ret;

	if (m_config.sw_codec != sw_codec_cfg.sw_codec) {
		LOG_ERR("Trying to uninit a codec that is not first initialized");
		return -ENODEV;
	}
	switch (m_config.sw_codec) {
	case SW_CODEC_LC3:
#if (CONFIG_SW_CODEC_LC3)
		if (sw_codec_cfg.encoder.enabled) {
			if (!m_config.encoder.enabled) {
				LOG_ERR("Trying to uninit encoder, it has not been "
					"initialized");
				return -EALREADY;
			}
			ret = sw_codec_lc3_enc_uninit_all();
			if (ret) {
				return ret;
			}
			m_config.encoder.enabled = false;
		}

		if (sw_codec_cfg.decoder.enabled) {
			if (!m_config.decoder.enabled) {
				LOG_WRN("Trying to uninit decoder, it has not been "
					"initialized");
				return -EALREADY;
			}

			ret = sw_codec_lc3_dec_uninit_all();
			if (ret) {
				return ret;
			}
			m_config.decoder.enabled = false;
		}
#endif /* (CONFIG_SW_CODEC_LC3) */
		break;
	default:
		LOG_ERR("Unsupported codec: %d", m_config.sw_codec);
		return false;
	}

	m_config.initialized = false;

	return 0;
}

int sw_codec_init(struct sw_codec_config sw_codec_cfg)
{
	int ret;

	switch (sw_codec_cfg.sw_codec) {
	case SW_CODEC_LC3: {
#if (CONFIG_SW_CODEC_LC3)
		if (m_config.sw_codec != SW_CODEC_LC3) {
			/* Check if LC3 is already initialized */
			ret = sw_codec_lc3_init(NULL, NULL, CONFIG_AUDIO_FRAME_DURATION_US);
			if (ret) {
				return ret;
			}
		}

		if (sw_codec_cfg.encoder.enabled) {
			if (m_config.encoder.enabled) {
				LOG_WRN("The LC3 encoder is already initialized");
				return -EALREADY;
			}
			uint16_t pcm_bytes_req_enc;

			LOG_DBG("Encode: %dHz %dbits %dus %dbps %d channel(s)",
				sw_codec_cfg.encoder.sample_rate_hz, CONFIG_AUDIO_BIT_DEPTH_BITS,
				CONFIG_AUDIO_FRAME_DURATION_US, sw_codec_cfg.encoder.bitrate,
				sw_codec_cfg.encoder.num_ch);

			ret = sw_codec_lc3_enc_init(
				sw_codec_cfg.encoder.sample_rate_hz, CONFIG_AUDIO_BIT_DEPTH_BITS,
				CONFIG_AUDIO_FRAME_DURATION_US, sw_codec_cfg.encoder.bitrate,
				sw_codec_cfg.encoder.num_ch, &pcm_bytes_req_enc);

			if (ret) {
				return ret;
			}
		}

		if (sw_codec_cfg.decoder.enabled) {
			if (m_config.decoder.enabled) {
				LOG_WRN("The LC3 decoder is already initialized");
				return -EALREADY;
			}

			LOG_DBG("Decode: %dHz %dbits %dus %d channel(s)",
				sw_codec_cfg.decoder.sample_rate_hz, CONFIG_AUDIO_BIT_DEPTH_BITS,
				CONFIG_AUDIO_FRAME_DURATION_US, sw_codec_cfg.decoder.num_ch);

			ret = sw_codec_lc3_dec_init(
				sw_codec_cfg.decoder.sample_rate_hz, CONFIG_AUDIO_BIT_DEPTH_BITS,
				CONFIG_AUDIO_FRAME_DURATION_US, sw_codec_cfg.decoder.num_ch);

			if (ret) {
				return ret;
			}
		}
		break;
#else
		LOG_ERR("LC3 is not compiled in, please open menuconfig and select "
			"LC3");
		return -ENODEV;
#endif /* (CONFIG_SW_CODEC_LC3) */
	}

	default:
		LOG_ERR("Unsupported codec: %d", sw_codec_cfg.sw_codec);
		return false;
	}

	if (sw_codec_cfg.encoder.enabled && IS_ENABLED(SAMPLE_RATE_CONVERTER)) {
		for (int i = 0; i < sw_codec_cfg.encoder.channel_mode; i++) {
			ret = sample_rate_converter_open(&encoder_converters[i]);
			if (ret) {
				LOG_ERR("Failed to initialize the sample rate converter for "
					"encoding channel %d: %d",
					i, ret);
				return ret;
			}
		}
	}

	if (sw_codec_cfg.decoder.enabled && IS_ENABLED(SAMPLE_RATE_CONVERTER)) {
		for (int i = 0; i < sw_codec_cfg.decoder.channel_mode; i++) {
			ret = sample_rate_converter_open(&decoder_converters[i]);
			if (ret) {
				LOG_ERR("Failed to initialize the sample rate converter for "
					"decoding channel %d: %d",
					i, ret);
				return ret;
			}
		}
	}

	m_config = sw_codec_cfg;
	m_config.initialized = true;

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/audio/Kconfig
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

rsource "Kconfig.defaults"

menu "Audio"

choice AUDIO_FRAME_DURATION
	prompt "Select frame duration - 7.5 ms frame duration is not tested"
	default AUDIO_FRAME_DURATION_10_MS
	help
	  LC3 supports frame duration of 7.5 and 10 ms.
	  If USB is selected as audio source, we should
	  have a frame duration of 10 ms since USB sends 1ms at a time.

config AUDIO_FRAME_DURATION_7_5_MS
	bool "7.5 ms"

config AUDIO_FRAME_DURATION_10_MS
	bool "10 ms"
endchoice

config AUDIO_FRAME_DURATION_US
	int
	default 7500 if AUDIO_FRAME_DURATION_7_5_MS
	default 10000 if AUDIO_FRAME_DURATION_10_MS
	help
	  Audio frame duration in s.

config AUDIO_MIN_PRES_DLY_US
	int "The minimum presentation delay"
	default 4000
	help
	  The minimum presentation delay in micro seconds determined by
	  the audio system processing and the minimum buffering.

config AUDIO_MAX_PRES_DLY_US
	int "The maximum presentation delay"
	default 60000
	help
	  The maximum presentation delay in micro seconds.

choice AUDIO_SYSTEM_SAMPLE_RATE
	prompt "System audio sample rate"
	default AUDIO_SAMPLE_RATE_48000_HZ
	help
	  This configuration reflects the system sample rate, but the audio data may be resampled to
	  another sample rate before encoding, and after decoding.

config AUDIO_SAMPLE_RATE_16000_HZ
	bool "16 kHz"
	help
	  Sample rate of 16kHz is currently only valid for I2S/line-in.

config AUDIO_SAMPLE_RATE_24000_HZ
	bool "24 kHz"
	help
	  Sample rate of 24kHz is currently only valid for I2S/line-in.

config AUDIO_SAMPLE_RATE_48000_HZ
	bool "48 kHz"
	help
	  Sample rate of 48kHz is valid for both I2S/line-in and USB.
endchoice

config AUDIO_SAMPLE_RATE_HZ
	int
	default 16000 if AUDIO_SAMPLE_RATE_16000_HZ
	default 24000 if AUDIO_SAMPLE_RATE_24000_HZ
	default 48000 if AUDIO_SAMPLE_RATE_48000_HZ
	help
	  I2S supports 16, 24, and 48 kHz sample rates for both input and output.
	  USB supports only 48 kHz for input.

choice AUDIO_BIT_DEPTH
	prompt "Audio bit depth"
	default AUDIO_BIT_DEPTH_16
	help
	  Select the bit depth for audio.

config AUDIO_BIT_DEPTH_16
	bool "16 bit audio"

config AUDIO_BIT_DEPTH_32
	bool "32 bit audio"
endchoice

config AUDIO_BIT_DEPTH_BITS
	int
	default 16 if AUDIO_BIT_DEPTH_16
	default 32 if AUDIO_BIT_DEPTH_32
	help
	  Bit depth of one sample in storage.

config AUDIO_BIT_DEPTH_OCTETS
	int
	default 2 if AUDIO_BIT_DEPTH_16
	default 4 if AUDIO_BIT_DEPTH_32
	help
	  Bit depth of one sample in storage given in octets.

config AUDIO_MIN_PRES_DLY_US
	int "The minimum presentation delay"
	default 4000
	help
	  The minimum allowable presentation delay in microseconds.
	  This needs to allow time for decoding and internal routing.
	  For 48kHz sampling rate and 96kbps bitrate this is about 4000 us.

config AUDIO_MAX_PRES_DLY_US
	int "The maximum presentation delay"
	default 60000
	help
	  The maximum allowable presentation delay in microseconds.
	  Increasing this will also increase the FIFO buffers to allow buffering.

choice AUDIO_SOURCE_GATEWAY
	prompt "Audio source for gateway"
	default AUDIO_SOURCE_I2S if WALKIE_TALKIE_DEMO
	default AUDIO_SOURCE_USB
	help
	  Select audio source for the gateway.

config AUDIO_SOURCE_USB
	bool "Use USB as audio source"
	help
	  Set USB as audio source. Note that this forces the
	  stream to be unidirectional because of CPU load.

config AUDIO_SOURCE_I2S
	bool "Use I2S as audio source"
endchoice

choice AUDIO_HEADSET_CHANNEL
	prompt "Headset audio channel assignment"
	default AUDIO_HEADSET_CHANNEL_RUNTIME
	help
	  Set whether audio channel assignment for the headset
	  should happen at runtime or compile-time.

config AUDIO_HEADSET_CHANNEL_RUNTIME
	bool "Select at runtime"
	help
	  Make channel selection at runtime. Selected value is stored in persistent memory.
	  Left channel: Hold volume-down button on headset while resetting headset.
	  Right channel: Hold volume-up button on headset while resetting headset.

config AUDIO_HEADSET_CHANNEL_COMPILE_TIME
	bool "Set at compile-time"
	help
	  Set channel selection at compile-time.
endchoice

config AUDIO_TEST_TONE
	bool "Test tone instead of doing user defined action"
	select TONE
	default y
	help
	  Use button 4 to set a test tone
	  instead of doing a user defined action.
	  The test tone is generated on the device itself.

config AUDIO_MUTE
	bool "Mute instead of doing user defined action"
	default y
	help
	  Use button 5 to mute audio instead of
	  doing a user defined action.

if AUDIO_HEADSET_CHANNEL_COMPILE_TIME

config AUDIO_HEADSET_CHANNEL
	int "Audio channel used by headset"
	range 0 1
	default 0
	help
	  Audio channel compile-time selection.
	  Left = 0.
	  Right = 1.

endif # AUDIO_HEADSET_CHANNEL_COMPILE_TIME

#----------------------------------------------------------------------------#
menu "SW Codec"

choice SW_CODEC_DEFAULT
	prompt "Starting SW codec"
	default SW_CODEC_LC3
	help
	  Select the default codec to use on start up.

config SW_CODEC_LC3
	bool "LC3"
	select SW_CODEC_LC3_T2_SOFTWARE
	help
	  LC3 is the mandatory codec for LE Audio.

# Leave room for other codecs
endchoice

config SW_CODEC_PLC_DISABLED
	bool "Skip PLC on a bad frame and fill the output buffer(s) with zeros instead"
	default n
	select LC3_PLC_DISABLED

#----------------------------------------------------------------------------#
menu "LC3"
visible if SW_CODEC_LC3

config LC3_BITRATE_MAX
	int "Max bitrate for LC3"
	default 96000

config LC3_BITRATE_MIN
	int "Min bitrate for LC3"
	default 32000

config LC3_BITRATE
	int
	range LC3_BITRATE_MIN LC3_BITRATE_MAX
	default 96000

osource "../nrfxlib/lc3/Kconfig"

endmenu # LC3
endmenu # SW Codec

#----------------------------------------------------------------------------#
menu "Stream"

config BUF_BLE_RX_PACKET_NUM
	int
	default 5
	range 2 5
	help
	  Value can be adjusted to affect the overall latency.
	  This adjusts the number packets in the BLE FIFO RX buffer,
	  which is where the main latency resides. A low value will decrease
	  latency and reduce stability, and vice-versa.
	  Two is recommended minimum to reduce the likelyhood of audio
	  gaps due to BLE retransmits.

config STREAM_BIDIRECTIONAL
	depends on TRANSPORT_CIS
	bool "Bidirectional stream"
	default n
	help
	  Bidirectional stream enables encoder and decoder on both sides,
	  and one device can both send and receive audio.

config WALKIE_TALKIE_DEMO
	select STREAM_BIDIRECTIONAL
	bool "Walkie talkie demo"
	default n
	help
	  The walkie talkie demo will set up a bidirectional stream using PDM
	  microphones on each side.

config MONO_TO_ALL_RECEIVERS
	bool "Send mono (first/left channel) to all receivers"
	default y if BT_BAP_UNICAST_CLIENT_ASE_SNK_COUNT = 1
	default y if BT_BAP_BROADCAST_SRC_STREAM_COUNT = 1
	default n
	help
	  With this flag set, the gateway will encode and send the same (first/left)
	  channel on all ISO channels.

endmenu # Stream

#----------------------------------------------------------------------------#
menu "Log levels"

module = AUDIO_SYSTEM
module-str = audio-system
source "subsys/logging/Kconfig.template.log_config"

module = SW_CODEC_SELECT
module-str = sw-codec-select
source "subsys/logging/Kconfig.template.log_config"

module = STREAMCTRL
module-str = streamctrl
source "subsys/logging/Kconfig.template.log_config"

module = AUDIO_DATAPATH
module-str = audio-datapath
source "subsys/logging/Kconfig.template.log_config"

module = AUDIO_SYNC_TIMER
module-str = audio-sync-timer
source "subsys/logging/Kconfig.template.log_config"

module = LE_AUDIO_RX
module-str = le-audio-rx
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log levels

#----------------------------------------------------------------------------#
menu "Thread priorities"

config ENCODER_THREAD_PRIO
	int "Priority for encoder thread"
	default 3
	help
	  This is a preemptible thread.

config AUDIO_DATAPATH_THREAD_PRIO
	int "Priority for audio datapath thread"
	default 4
	help
	  This is a preemptible thread.

config BUTTON_MSG_SUB_THREAD_PRIO
	int "Thread priority for button subscriber"
	default 5
	help
	  This is a preemptible thread.
	  This thread will subscribe to button events from zbus.

config LE_AUDIO_MSG_SUB_THREAD_PRIO
	int "Thread priority for LE Audio subscriber"
	default 5
	help
	  This is a preemptible thread.
	  This thread will subscribe to LE Audio events from zbus.

config CONTENT_CONTROL_MSG_SUB_THREAD_PRIO
	int "Thread priority for content control subscriber"
	default 5
	help
	  This is a preemptible thread.
	  This thread will subscribe to content control events from zbus.

endmenu # Thread priorities

#----------------------------------------------------------------------------#
menu "Stack sizes"

config ENCODER_STACK_SIZE
	int "Stack size for encoder thread"
	default 11000 if AUDIO_BIT_DEPTH_16
	default 21400 if AUDIO_BIT_DEPTH_32

config AUDIO_DATAPATH_STACK_SIZE
	int "Stack size for audio datapath thread"
	default 7600 if AUDIO_BIT_DEPTH_16
	default 14700 if AUDIO_BIT_DEPTH_32

config BUTTON_MSG_SUB_STACK_SIZE
	int "Stack size for button subscriber"
	default 2048

config LE_AUDIO_MSG_SUB_STACK_SIZE
	int "Stack size for LE Audio subscriber"
	default 2048

config CONTENT_CONTROL_MSG_SUB_STACK_SIZE
	int "Stack size for content control subscriber"
	default 1024

endmenu # Stack sizes

#----------------------------------------------------------------------------#
menu "Zbus"

config BUTTON_MSG_SUB_QUEUE_SIZE
	int "Queue size for button subscriber"
	default 4

config CONTENT_CONTROL_MSG_SUB_QUEUE_SIZE
	int "Queue size for content control subscriber"
	default 4

endmenu # Zbus
endmenu # Audio


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/audio/audio_datapath.c
/*
 *  Copyright (c) 2021, PACKETCRAFT, INC.
 *
 *  SPDX-License-Identifier: LicenseRef-PCFT
 */

#include "audio_datapath.h"

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <zephyr/zbus/zbus.h>
#include <zephyr/kernel.h>
#include <zephyr/shell/shell.h>
#include <nrfx_clock.h>

#include "nrf5340_audio_common.h"
#include "macros_common.h"
#include "led.h"
#include "audio_i2s.h"
#include "sw_codec_select.h"
#include "audio_system.h"
#include "tone.h"
#include "contin_array.h"
#include "pcm_mix.h"
#include "streamctrl.h"
#include "audio_sync_timer.h"
#include "sd_card_playback.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(audio_datapath, CONFIG_AUDIO_DATAPATH_LOG_LEVEL);

/*
 * Terminology
 *   - sample: signed integer of audio waveform amplitude
 *   - sample FIFO: circular array of raw audio samples
 *   - block: set of raw audio samples exchanged with I2S
 *   - frame: encoded audio packet exchanged with connectivity
 */

#define SDU_REF_DELTA_MAX_ERR_US (int)(CONFIG_AUDIO_FRAME_DURATION_US * 0.001)

#define BLK_PERIOD_US 1000

/* Total sample FIFO period in microseconds */
#define FIFO_SMPL_PERIOD_US (CONFIG_AUDIO_MAX_PRES_DLY_US * 2)
#define FIFO_NUM_BLKS	    NUM_BLKS(FIFO_SMPL_PERIOD_US)
#define MAX_FIFO_SIZE	    (FIFO_NUM_BLKS * BLK_SIZE_SAMPLES(CONFIG_AUDIO_SAMPLE_RATE_HZ) * 2)

/* Number of audio blocks given a duration */
#define NUM_BLKS(d) ((d) / BLK_PERIOD_US)
/* Single audio block size in number of samples (stereo) */
/* clang-format off */
#define BLK_SIZE_SAMPLES(r) (((r)*BLK_PERIOD_US) / 1000000)
/* clang-format on */
/* Increment sample FIFO index by one block */
#define NEXT_IDX(i) (((i) < (FIFO_NUM_BLKS - 1)) ? ((i) + 1) : 0)
/* Decrement sample FIFO index by one block */
#define PREV_IDX(i) (((i) > 0) ? ((i)-1) : (FIFO_NUM_BLKS - 1))

#define NUM_BLKS_IN_FRAME      NUM_BLKS(CONFIG_AUDIO_FRAME_DURATION_US)
#define BLK_MONO_NUM_SAMPS     BLK_SIZE_SAMPLES(CONFIG_AUDIO_SAMPLE_RATE_HZ)
#define BLK_STEREO_NUM_SAMPS   (BLK_MONO_NUM_SAMPS * 2)
/* Number of octets in a single audio block */
#define BLK_MONO_SIZE_OCTETS   (BLK_MONO_NUM_SAMPS * CONFIG_AUDIO_BIT_DEPTH_OCTETS)
#define BLK_STEREO_SIZE_OCTETS (BLK_MONO_SIZE_OCTETS * 2)
/* How many function calls before moving on with drift compensation */
#define DRIFT_COMP_WAITING_CNT (DRIFT_MEAS_PERIOD_US / BLK_PERIOD_US)
/* How much data to be collected before moving on with presentation compensation */
#define PRES_COMP_NUM_DATA_PTS (DRIFT_MEAS_PERIOD_US / CONFIG_AUDIO_FRAME_DURATION_US)

/* Audio clock - nRF5340 Analog Phase-Locked Loop (APLL) */
#define APLL_FREQ_CENTER 39854
#define APLL_FREQ_MIN	 36834
#define APLL_FREQ_MAX	 42874
/* Use nanoseconds to reduce rounding errors */
/* clang-format off */
#define APLL_FREQ_ADJ(t) (-((t)*1000) / 331)
/* clang-format on */

#define DRIFT_MEAS_PERIOD_US	   100000
#define DRIFT_ERR_THRESH_LOCK	   16
#define DRIFT_ERR_THRESH_UNLOCK	   32
/* To get smaller corrections */
#define DRIFT_REGULATOR_DIV_FACTOR 2

/* To allow BLE transmission and (host -> HCI -> controller) */
#if defined(CONFIG_BT_LL_ACS_NRF53)
#define JUST_IN_TIME_TARGET_DLY_US (CONFIG_AUDIO_FRAME_DURATION_US - 3000)
#else /* !CONFIG_BT_LL_ACS_NRF53 */
#define JUST_IN_TIME_TARGET_DLY_US 3000
#endif /* !CONFIG_BT_LL_ACS_NRF53 */
#define JUST_IN_TIME_BOUND_US 2500

/* How often to print under-run warning */
#define UNDERRUN_LOG_INTERVAL_BLKS 5000

enum drift_comp_state {
	DRIFT_STATE_INIT,   /* Waiting for data to be received */
	DRIFT_STATE_CALIB,  /* Calibrate and zero out local delay */
	DRIFT_STATE_OFFSET, /* Adjust I2S offset relative to SDU Reference */
	DRIFT_STATE_LOCKED  /* Drift compensation locked - Minor corrections */
};

static const char *const drift_comp_state_names[] = {
	"INIT",
	"CALIB",
	"OFFSET",
	"LOCKED",
};

enum pres_comp_state {
	PRES_STATE_INIT,  /* Initialize presentation compensation */
	PRES_STATE_MEAS,  /* Measure presentation delay */
	PRES_STATE_WAIT,  /* Wait for some time */
	PRES_STATE_LOCKED /* Presentation compensation locked */
};

static const char *const pres_comp_state_names[] = {
	"INIT",
	"MEAS",
	"WAIT",
	"LOCKED",
};

static struct {
	bool datapath_initialized;
	bool stream_started;
	void *decoded_data;

	struct {
		struct data_fifo *fifo;
	} in;

	struct {
#if CONFIG_AUDIO_BIT_DEPTH_16
		int16_t __aligned(sizeof(uint32_t)) fifo[MAX_FIFO_SIZE];
#elif CONFIG_AUDIO_BIT_DEPTH_32
		int32_t __aligned(sizeof(uint32_t)) fifo[MAX_FIFO_SIZE];
#endif
		uint16_t prod_blk_idx; /* Output producer audio block index */
		uint16_t cons_blk_idx; /* Output consumer audio block index */
		uint32_t prod_blk_ts[FIFO_NUM_BLKS];
		/* Statistics */
		uint32_t total_blk_underruns;
	} out;

	uint32_t prev_drift_sdu_ref_us;
	uint32_t prev_pres_sdu_ref_us;
	uint32_t current_pres_dly_us;

	struct {
		enum drift_comp_state state: 8;
		uint16_t ctr; /* Count func calls. Used for waiting */
		uint32_t meas_start_time_us;
		uint32_t center_freq;
		bool enabled;
	} drift_comp;

	struct {
		enum pres_comp_state state: 8;
		uint16_t ctr; /* Count func calls. Used for collecting data points and waiting */
		int32_t sum_err_dly_us;
		uint32_t pres_delay_us;
		bool enabled;
	} pres_comp;
} ctrl_blk;

static bool tone_active;
/* Buffer which can hold max 1 period test tone at 100 Hz */
static uint16_t test_tone_buf[CONFIG_AUDIO_SAMPLE_RATE_HZ / 100];
static size_t test_tone_size;

/**
 * @brief	Calculate error between sdu_ref and frame_start_ts_us.
 *
 * @note	Used to adjust audio clock to account for drift.
 *
 * @param	sdu_ref_us	Timestamp for SDU.
 * @param	frame_start_ts_us	Timestamp for I2S.
 *
 * @return	Error in microseconds (err_us).
 */
static int32_t err_us_calculate(uint32_t sdu_ref_us, uint32_t frame_start_ts_us)
{
	bool err_neg = false;

	if (IS_ENABLED(CONFIG_BT_LL_ACS_NRF53) && IS_ENABLED(CONFIG_TRANSPORT_BIS)) {
		/* To make the drift compensation work as expected
		 * when using the LE Audio Controller Subsystem Link Layer
		 * and BIS we must add CONFIG_AUDIO_FRAME_DURATION_US to
		 * sdu_ref_us.
		 * This is a temporary workaround.
		 */
		sdu_ref_us += CONFIG_AUDIO_FRAME_DURATION_US;
	}

	int64_t total_err = ((int64_t)sdu_ref_us - (int64_t)frame_start_ts_us);

	/* Store sign for later use, since remainder operation is undefined for negatives */
	if (total_err < 0) {
		err_neg = true;
		total_err *= -1;
	}

	/* Check diff below 1000 us, diff above 1000 us is fixed later on */
	int32_t err_us = total_err % BLK_PERIOD_US;

	if (err_us > (BLK_PERIOD_US / 2)) {
		err_us = err_us - BLK_PERIOD_US;
	}

	/* Restore the sign */
	if (err_neg) {
		err_us *= -1;
	}

	return err_us;
}

static void hfclkaudio_set(uint16_t freq_value)
{
	uint16_t freq_val = freq_value;

	freq_val = MIN(freq_val, APLL_FREQ_MAX);
	freq_val = MAX(freq_val, APLL_FREQ_MIN);

	nrfx_clock_hfclkaudio_config_set(freq_val);
}

static void drift_comp_state_set(enum drift_comp_state new_state)
{
	if (new_state == ctrl_blk.drift_comp.state) {
		LOG_WRN("Trying to change to the same drift compensation state");
		return;
	}

	ctrl_blk.drift_comp.state = new_state;
	LOG_INF("Drft comp state: %s", drift_comp_state_names[new_state]);
}

/**
 * @brief	Adjust frequency of HFCLKAUDIO to get audio in sync.
 *
 * @note	The audio sync is based on sdu_ref_us.
 *
 * @param	frame_start_ts_us	I2S frame start timestamp.
 */
static void audio_datapath_drift_compensation(uint32_t frame_start_ts_us)
{
	if (CONFIG_AUDIO_DEV == HEADSET) {
		/** For headsets we do not use the timestamp gotten from hci_tx_sync_get to adjust
		 * for drift
		 */
		ctrl_blk.prev_drift_sdu_ref_us = ctrl_blk.prev_pres_sdu_ref_us;
	}
	switch (ctrl_blk.drift_comp.state) {
	case DRIFT_STATE_INIT: {
		/* Check if audio data has been received */
		if (ctrl_blk.prev_drift_sdu_ref_us) {
			ctrl_blk.drift_comp.meas_start_time_us = ctrl_blk.prev_drift_sdu_ref_us;

			drift_comp_state_set(DRIFT_STATE_CALIB);
		}

		break;
	}
	case DRIFT_STATE_CALIB: {
		if (++ctrl_blk.drift_comp.ctr < DRIFT_COMP_WAITING_CNT) {
			/* Waiting */
			return;
		}

		ctrl_blk.drift_comp.ctr = 0;

		int32_t err_us = DRIFT_MEAS_PERIOD_US - (ctrl_blk.prev_drift_sdu_ref_us -
							 ctrl_blk.drift_comp.meas_start_time_us);

		int32_t freq_adj = APLL_FREQ_ADJ(err_us);

		ctrl_blk.drift_comp.center_freq = APLL_FREQ_CENTER + freq_adj;

		if ((ctrl_blk.drift_comp.center_freq > (APLL_FREQ_MAX)) ||
		    (ctrl_blk.drift_comp.center_freq < (APLL_FREQ_MIN))) {
			LOG_DBG("Invalid center frequency, re-calculating");
			drift_comp_state_set(DRIFT_STATE_INIT);
			return;
		}

		hfclkaudio_set(ctrl_blk.drift_comp.center_freq);

		drift_comp_state_set(DRIFT_STATE_OFFSET);

		break;
	}
	case DRIFT_STATE_OFFSET: {
		if (++ctrl_blk.drift_comp.ctr < DRIFT_COMP_WAITING_CNT) {
			/* Waiting */
			return;
		}

		ctrl_blk.drift_comp.ctr = 0;

		int32_t err_us =
			err_us_calculate(ctrl_blk.prev_drift_sdu_ref_us, frame_start_ts_us);

		err_us /= DRIFT_REGULATOR_DIV_FACTOR;
		int32_t freq_adj = APLL_FREQ_ADJ(err_us);

		hfclkaudio_set(ctrl_blk.drift_comp.center_freq + freq_adj);

		if ((err_us < DRIFT_ERR_THRESH_LOCK) && (err_us > -DRIFT_ERR_THRESH_LOCK)) {
			drift_comp_state_set(DRIFT_STATE_LOCKED);
		}

		break;
	}
	case DRIFT_STATE_LOCKED: {
		if (++ctrl_blk.drift_comp.ctr < DRIFT_COMP_WAITING_CNT) {
			/* Waiting */
			return;
		}

		ctrl_blk.drift_comp.ctr = 0;

		int32_t err_us =
			err_us_calculate(ctrl_blk.prev_drift_sdu_ref_us, frame_start_ts_us);

		err_us /= DRIFT_REGULATOR_DIV_FACTOR;
		int32_t freq_adj = APLL_FREQ_ADJ(err_us);

		hfclkaudio_set(ctrl_blk.drift_comp.center_freq + freq_adj);

		if ((err_us > DRIFT_ERR_THRESH_UNLOCK) || (err_us < -DRIFT_ERR_THRESH_UNLOCK)) {
			drift_comp_state_set(DRIFT_STATE_INIT);
		}

		break;
	}
	default: {
		break;
	}
	}
}

static void pres_comp_state_set(enum pres_comp_state new_state)
{
	int ret;

	if (new_state == ctrl_blk.pres_comp.state) {
		return;
	}

	ctrl_blk.pres_comp.state = new_state;
	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Pres comp state: %s", pres_comp_state_names[new_state]);
	if (new_state == PRES_STATE_LOCKED) {
		ret = led_on(LED_APP_2_GREEN);
	} else {
		ret = led_off(LED_APP_2_GREEN);
	}
	ERR_CHK(ret);
}

/**
 * @brief	Move audio blocks back and forth in FIFO to get audio in sync.
 *
 * @note	The audio sync is based on sdu_ref_us.
 *
 * @param	recv_frame_ts_us	Timestamp of when frame was received.
 * @param	sdu_ref_us		ISO timestamp reference from Bluetooth LE controller.
 * @param	sdu_ref_not_consecutive	True if sdu_ref_us and the previous sdu_ref_us
 *					originate from non-consecutive frames.
 */
static void audio_datapath_presentation_compensation(uint32_t recv_frame_ts_us, uint32_t sdu_ref_us,
						     bool sdu_ref_not_consecutive)
{
	if (ctrl_blk.drift_comp.state != DRIFT_STATE_LOCKED) {
		/* Unconditionally reset state machine if drift compensation looses lock */
		pres_comp_state_set(PRES_STATE_INIT);
		return;
	}

	/* Move presentation compensation into PRES_STATE_WAIT if sdu_ref_us and
	 * the previous sdu_ref_us originate from non-consecutive frames.
	 */
	if (sdu_ref_not_consecutive) {
		ctrl_blk.pres_comp.ctr = 0;
		pres_comp_state_set(PRES_STATE_WAIT);
	}

	int32_t wanted_pres_dly_us =
		ctrl_blk.pres_comp.pres_delay_us - (recv_frame_ts_us - sdu_ref_us);
	int32_t pres_adj_us = 0;

	switch (ctrl_blk.pres_comp.state) {
	case PRES_STATE_INIT: {
		ctrl_blk.pres_comp.ctr = 0;
		ctrl_blk.pres_comp.sum_err_dly_us = 0;
		pres_comp_state_set(PRES_STATE_MEAS);

		break;
	}
	case PRES_STATE_MEAS: {
		if (ctrl_blk.pres_comp.ctr++ < PRES_COMP_NUM_DATA_PTS) {
			ctrl_blk.pres_comp.sum_err_dly_us +=
				wanted_pres_dly_us - ctrl_blk.current_pres_dly_us;

			/* Same state - Collect more data */
			break;
		}

		ctrl_blk.pres_comp.ctr = 0;

		pres_adj_us = ctrl_blk.pres_comp.sum_err_dly_us / PRES_COMP_NUM_DATA_PTS;
		if ((pres_adj_us >= (BLK_PERIOD_US / 2)) || (pres_adj_us <= -(BLK_PERIOD_US / 2))) {
			pres_comp_state_set(PRES_STATE_WAIT);
		} else {
			/* Drift compensation will always be in DRIFT_STATE_LOCKED here */
			pres_comp_state_set(PRES_STATE_LOCKED);
		}

		break;
	}
	case PRES_STATE_WAIT: {
		if (ctrl_blk.pres_comp.ctr++ >
		    (FIFO_SMPL_PERIOD_US / CONFIG_AUDIO_FRAME_DURATION_US)) {
			pres_comp_state_set(PRES_STATE_INIT);
		}

		break;
	}
	case PRES_STATE_LOCKED: {
		/*
		 * Presentation delay compensation moves into PRES_STATE_WAIT if sdu_ref_us
		 * and the previous sdu_ref_us originate from non-consecutive frames, or into
		 * PRES_STATE_INIT if drift compensation unlocks.
		 */

		break;
	}
	default: {
		break;
	}
	}

	if (pres_adj_us == 0) {
		return;
	}

	if (pres_adj_us >= 0) {
		pres_adj_us += (BLK_PERIOD_US / 2);
	} else {
		pres_adj_us += -(BLK_PERIOD_US / 2);
	}

	/* Number of adjustment blocks is 0 as long as |pres_adj_us| < BLK_PERIOD_US */
	int32_t pres_adj_blks = pres_adj_us / BLK_PERIOD_US;

	if (pres_adj_blks > (FIFO_NUM_BLKS / 2)) {
		/* Limit adjustment */
		pres_adj_blks = FIFO_NUM_BLKS / 2;

		LOG_WRN("Requested presentation delay out of range: pres_adj_us=%d", pres_adj_us);
	} else if (pres_adj_blks < -(FIFO_NUM_BLKS / 2)) {
		/* Limit adjustment */
		pres_adj_blks = -(FIFO_NUM_BLKS / 2);

		LOG_WRN("Requested presentation delay out of range: pres_adj_us=%d", pres_adj_us);
	}

	if (pres_adj_blks > 0) {
		LOG_DBG("Presentation delay inserted: pres_adj_blks=%d", pres_adj_blks);

		/* Increase presentation delay */
		for (int i = 0; i < pres_adj_blks; i++) {
			/* Mute audio block */
			memset(&ctrl_blk.out.fifo[ctrl_blk.out.prod_blk_idx * BLK_STEREO_NUM_SAMPS],
			       0, BLK_STEREO_SIZE_OCTETS);

			/* Record producer block start reference */
			ctrl_blk.out.prod_blk_ts[ctrl_blk.out.prod_blk_idx] =
				recv_frame_ts_us - ((pres_adj_blks - i) * BLK_PERIOD_US);

			ctrl_blk.out.prod_blk_idx = NEXT_IDX(ctrl_blk.out.prod_blk_idx);
		}
	} else if (pres_adj_blks < 0) {
		LOG_DBG("Presentation delay removed: pres_adj_blks=%d", pres_adj_blks);

		/* Reduce presentation delay */
		for (int i = 0; i > pres_adj_blks; i--) {
			ctrl_blk.out.prod_blk_idx = PREV_IDX(ctrl_blk.out.prod_blk_idx);
		}
	}
}

static void tone_stop_worker(struct k_work *work)
{
	tone_active = false;
	memset(test_tone_buf, 0, sizeof(test_tone_buf));
	LOG_DBG("Tone stopped");
}

K_WORK_DEFINE(tone_stop_work, tone_stop_worker);

static void tone_stop_timer_handler(struct k_timer *dummy)
{
	k_work_submit(&tone_stop_work);
};

K_TIMER_DEFINE(tone_stop_timer, tone_stop_timer_handler, NULL);

int audio_datapath_tone_play(uint16_t freq, uint16_t dur_ms, float amplitude)
{
	int ret;

	if (tone_active) {
		return -EBUSY;
	}

	if (IS_ENABLED(CONFIG_AUDIO_TEST_TONE)) {
		ret = tone_gen(test_tone_buf, &test_tone_size, freq, CONFIG_AUDIO_SAMPLE_RATE_HZ,
			       amplitude);
		if (ret) {
			return ret;
		}
	} else {
		LOG_ERR("Test tone is not enabled");
		return -ENXIO;
	}

	/* If duration is 0, play forever */
	if (dur_ms != 0) {
		k_timer_start(&tone_stop_timer, K_MSEC(dur_ms), K_NO_WAIT);
	}

	tone_active = true;
	LOG_DBG("Tone started");
	return 0;
}

void audio_datapath_tone_stop(void)
{
	k_timer_stop(&tone_stop_timer);
	k_work_submit(&tone_stop_work);
}

static void tone_mix(uint8_t *tx_buf)
{
	int ret;
	int8_t tone_buf_continuous[BLK_MONO_SIZE_OCTETS];
	static uint32_t finite_pos;

	ret = contin_array_create(tone_buf_continuous, BLK_MONO_SIZE_OCTETS, test_tone_buf,
				  test_tone_size, &finite_pos);
	ERR_CHK(ret);

	ret = pcm_mix(tx_buf, BLK_STEREO_SIZE_OCTETS, tone_buf_continuous, BLK_MONO_SIZE_OCTETS,
		      B_MONO_INTO_A_STEREO_L);
	ERR_CHK(ret);
}

/* Alternate-buffers used when there is no active audio stream.
 * Used interchangeably by I2S.
 */
static struct {
	uint8_t __aligned(WB_UP(1)) buf_0[BLK_STEREO_SIZE_OCTETS];
	uint8_t __aligned(WB_UP(1)) buf_1[BLK_STEREO_SIZE_OCTETS];
	bool buf_0_in_use;
	bool buf_1_in_use;
} alt;

/**
 * @brief	Get first available alternative-buffer.
 *
 * @param	p_buffer	Double pointer to populate with buffer.
 *
 * @retval	0 if success.
 * @retval	-ENOMEM No available buffers.
 */
static int alt_buffer_get(void **p_buffer)
{
	if (!alt.buf_0_in_use) {
		alt.buf_0_in_use = true;
		*p_buffer = alt.buf_0;
	} else if (!alt.buf_1_in_use) {
		alt.buf_1_in_use = true;
		*p_buffer = alt.buf_1;
	} else {
		return -ENOMEM;
	}

	return 0;
}

/**
 * @brief	Checks if pointer matches that of a buffer
 *		and frees it in one operation.
 *
 * @param	p_buffer	Buffer to free.
 */
static void alt_buffer_free(void const *const p_buffer)
{
	if (p_buffer == alt.buf_0) {
		alt.buf_0_in_use = false;
	} else if (p_buffer == alt.buf_1) {
		alt.buf_1_in_use = false;
	}
}

/**
 * @brief	Frees both alternative buffers.
 */
static void alt_buffer_free_both(void)
{
	alt.buf_0_in_use = false;
	alt.buf_1_in_use = false;
}

/*
 * This handler function is called every time I2S needs new buffers for
 * TX and RX data.
 *
 * The new TX data buffer is the next consumer block in out.fifo.
 *
 * The new RX data buffer is the first empty slot of in.fifo.
 * New I2S RX data is located in rx_buf_released, and is locked into
 * the in.fifo message queue.
 */
static void audio_datapath_i2s_blk_complete(uint32_t frame_start_ts_us, uint32_t *rx_buf_released,
					    uint32_t const *tx_buf_released)
{
	int ret;
	static bool underrun_condition;

	alt_buffer_free(tx_buf_released);

	/*** Presentation delay measurement ***/
	ctrl_blk.current_pres_dly_us =
		frame_start_ts_us - ctrl_blk.out.prod_blk_ts[ctrl_blk.out.cons_blk_idx];

	/********** I2S TX **********/
	static uint8_t *tx_buf;

	if (IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL) || (CONFIG_AUDIO_DEV == HEADSET)) {
		if (tx_buf_released != NULL) {
			/* Double buffered index */
			uint32_t next_out_blk_idx = NEXT_IDX(ctrl_blk.out.cons_blk_idx);

			if (next_out_blk_idx != ctrl_blk.out.prod_blk_idx) {
				/* Only increment if not in under-run condition */
				ctrl_blk.out.cons_blk_idx = next_out_blk_idx;
				if (underrun_condition) {
					underrun_condition = false;
					LOG_WRN("Data received, total under-runs: %d",
						ctrl_blk.out.total_blk_underruns);
				}

				tx_buf = (uint8_t *)&ctrl_blk.out
						 .fifo[next_out_blk_idx * BLK_STEREO_NUM_SAMPS];

			} else {
				if (stream_state_get() == STATE_STREAMING) {
					underrun_condition = true;
					ctrl_blk.out.total_blk_underruns++;

					if ((ctrl_blk.out.total_blk_underruns %
					     UNDERRUN_LOG_INTERVAL_BLKS) == 0) {
						LOG_WRN("In I2S TX under-run condition, total: %d",
							ctrl_blk.out.total_blk_underruns);
					}
				}

				/*
				 * No data available in out.fifo
				 * use alternative buffers
				 */
				ret = alt_buffer_get((void **)&tx_buf);
				ERR_CHK(ret);

				memset(tx_buf, 0, BLK_STEREO_SIZE_OCTETS);
			}

			if (tone_active) {
				tone_mix(tx_buf);
			}
		}
	}

	/********** I2S RX **********/
	static uint32_t *rx_buf;
	static int prev_ret;

	if (IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL) || (CONFIG_AUDIO_DEV == GATEWAY)) {
		/* Lock last filled buffer into message queue */
		if (rx_buf_released != NULL) {
			ret = data_fifo_block_lock(ctrl_blk.in.fifo, (void **)&rx_buf_released,
						   BLOCK_SIZE_BYTES);

			ERR_CHK_MSG(ret, "Unable to lock block RX");
		}

		/* Get new empty buffer to send to I2S HW */
		ret = data_fifo_pointer_first_vacant_get(ctrl_blk.in.fifo, (void **)&rx_buf,
							 K_NO_WAIT);
		if (ret == 0 && prev_ret == -ENOMEM) {
			LOG_WRN("I2S RX continuing stream");
			prev_ret = ret;
		}

		/* If RX FIFO is filled up */
		if (ret == -ENOMEM) {
			void *data;
			size_t size;

			if (ret != prev_ret) {
				LOG_WRN("I2S RX overrun. Single msg");
				prev_ret = ret;
			}

			ret = data_fifo_pointer_last_filled_get(ctrl_blk.in.fifo, &data, &size,
								K_NO_WAIT);
			ERR_CHK(ret);

			data_fifo_block_free(ctrl_blk.in.fifo, data);

			ret = data_fifo_pointer_first_vacant_get(ctrl_blk.in.fifo, (void **)&rx_buf,
								 K_NO_WAIT);
		}

		ERR_CHK_MSG(ret, "RX failed to get block");
	}

	/*** Data exchange ***/
	audio_i2s_set_next_buf(tx_buf, rx_buf);

	/*** Drift compensation ***/
	if (ctrl_blk.drift_comp.enabled) {
		audio_datapath_drift_compensation(frame_start_ts_us);
	}
}

static void audio_datapath_i2s_start(void)
{
	int ret;

	/* Double buffer I2S */
	uint8_t *tx_buf_one = NULL;
	uint8_t *tx_buf_two = NULL;
	uint32_t *rx_buf_one = NULL;
	uint32_t *rx_buf_two = NULL;

	/* TX */
	if (IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL) || (CONFIG_AUDIO_DEV == HEADSET)) {
		ctrl_blk.out.cons_blk_idx = PREV_IDX(ctrl_blk.out.cons_blk_idx);
		tx_buf_one = (uint8_t *)&ctrl_blk.out
				     .fifo[ctrl_blk.out.cons_blk_idx * BLK_STEREO_NUM_SAMPS];

		ctrl_blk.out.cons_blk_idx = PREV_IDX(ctrl_blk.out.cons_blk_idx);
		tx_buf_two = (uint8_t *)&ctrl_blk.out
				     .fifo[ctrl_blk.out.cons_blk_idx * BLK_STEREO_NUM_SAMPS];
	}

	/* RX */
	if (IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL) || (CONFIG_AUDIO_DEV == GATEWAY)) {
		uint32_t alloced_cnt;
		uint32_t locked_cnt;

		ret = data_fifo_num_used_get(ctrl_blk.in.fifo, &alloced_cnt, &locked_cnt);
		if (alloced_cnt || locked_cnt || ret) {
			ERR_CHK_MSG(-ENOMEM, "FIFO is not empty!");
		}

		ret = data_fifo_pointer_first_vacant_get(ctrl_blk.in.fifo, (void **)&rx_buf_one,
							 K_NO_WAIT);
		ERR_CHK_MSG(ret, "RX failed to get block");
		ret = data_fifo_pointer_first_vacant_get(ctrl_blk.in.fifo, (void **)&rx_buf_two,
							 K_NO_WAIT);
		ERR_CHK_MSG(ret, "RX failed to get block");
	}

	/* Start I2S */
	audio_i2s_start(tx_buf_one, rx_buf_one);
	audio_i2s_set_next_buf(tx_buf_two, rx_buf_two);
}

static void audio_datapath_i2s_stop(void)
{
	audio_i2s_stop();
	alt_buffer_free_both();
}

/**
 * @brief	Adjust timing to make sure audio data is sent just in time for Bluetooth LE event.
 *
 * @note	The time from last anchor point is checked and then blocks of 1 ms can be dropped
 *		to allow the sending of encoded data to be sent just before the connection interval
 *		opens up. This is done to reduce overall latency.
 *
 * @param[in]	tx_sync_ts_us	The timestamp from get_tx_sync.
 * @param[in]	curr_ts_us	The current time. This must be in the controller frame of reference.
 */
static void audio_datapath_just_in_time_check_and_adjust(uint32_t tx_sync_ts_us,
							 uint32_t curr_ts_us)
{
	int ret;
	static int32_t print_count;
	int64_t diff;

	if (IS_ENABLED(CONFIG_BT_LL_ACS_NRF53)) {
		/* CONFIG_BT_LL_ACS_NRF53 custom implementation. */
		diff = (int64_t)curr_ts_us - tx_sync_ts_us;
	} else {
		diff = (int64_t)tx_sync_ts_us - curr_ts_us;
	}

	/*
	 * The diff should always be positive. If diff is a large negative number, it is likely
	 * that wrapping has occurred. A small negative value however, may point to the application
	 * sending data too late, and we need to drop data to get back in sync with the controller.
	 */
	if (diff < -((int64_t)UINT32_MAX / 2)) {
		LOG_DBG("Timestamp wrap. diff: %lld", diff);
		diff += UINT32_MAX;

	} else if (diff < 0) {
		LOG_DBG("tx_sync_ts_us: %u is earlier than curr_ts_us %u", tx_sync_ts_us,
			curr_ts_us);
	}

	if (print_count % 100 == 0) {
		if (IS_ENABLED(CONFIG_BT_LL_ACS_NRF53)) {
			LOG_DBG("JIT diff: %lld us. Target: %u +/- %u",
				CONFIG_AUDIO_FRAME_DURATION_US - diff,
				CONFIG_AUDIO_FRAME_DURATION_US - JUST_IN_TIME_TARGET_DLY_US,
				JUST_IN_TIME_BOUND_US);
		} else {
			LOG_DBG("JIT diff: %lld us. Target: %u +/- %u", diff,
				JUST_IN_TIME_TARGET_DLY_US, JUST_IN_TIME_BOUND_US);
		}
	}
	print_count++;

	if ((diff < (JUST_IN_TIME_TARGET_DLY_US - JUST_IN_TIME_BOUND_US)) ||
	    (diff > (JUST_IN_TIME_TARGET_DLY_US + JUST_IN_TIME_BOUND_US))) {
		ret = audio_system_fifo_rx_block_drop();
		if (ret) {
			LOG_WRN("Not able to drop FIFO RX block");
			return;
		}
		LOG_DBG("Dropped block to align with connection interval");
		print_count = 0;
	}
}

/**
 * @brief	Update sdu_ref_us so that drift compensation can work correctly.
 *
 * @note	This function is only valid for gateway using I2S as audio source
 *		and unidirectional audio stream (gateway to one or more headsets).
 *
 * @param	sdu_ref_us    ISO timestamp reference from Bluetooth LE controller.
 * @param	adjust        Indicate if the sdu_ref should be used to adjust timing.
 */
static void audio_datapath_sdu_ref_update(const struct zbus_channel *chan)
{
	if (IS_ENABLED(CONFIG_AUDIO_SOURCE_I2S)) {
		uint32_t tx_sync_ts_us;
		uint32_t curr_ts_us;
		bool adjust;
		const struct sdu_ref_msg *msg;

		msg = zbus_chan_const_msg(chan);
		tx_sync_ts_us = msg->tx_sync_ts_us;
		curr_ts_us = msg->curr_ts_us;
		adjust = msg->adjust;

		if (ctrl_blk.stream_started) {
			ctrl_blk.prev_drift_sdu_ref_us = tx_sync_ts_us;

			if (adjust && tx_sync_ts_us != 0) {
				audio_datapath_just_in_time_check_and_adjust(tx_sync_ts_us,
									     curr_ts_us);
			}
		} else {
			LOG_WRN("Stream not started - Can not update tx_sync_ts_us");
		}
	}
}

ZBUS_LISTENER_DEFINE(sdu_ref_msg_listen, audio_datapath_sdu_ref_update);

int audio_datapath_pres_delay_us_set(uint32_t delay_us)
{
	if (!IN_RANGE(delay_us, CONFIG_AUDIO_MIN_PRES_DLY_US, CONFIG_AUDIO_MAX_PRES_DLY_US)) {
		LOG_WRN("Presentation delay not supported: %d", delay_us);
		return -EINVAL;
	}

	ctrl_blk.pres_comp.pres_delay_us = delay_us;

	LOG_DBG("Presentation delay set to %d us", delay_us);

	return 0;
}

void audio_datapath_pres_delay_us_get(uint32_t *delay_us)
{
	*delay_us = ctrl_blk.pres_comp.pres_delay_us;
}

void audio_datapath_stream_out(const uint8_t *buf, size_t size, uint32_t sdu_ref_us, bool bad_frame,
			       uint32_t recv_frame_ts_us)
{
	if (!ctrl_blk.stream_started) {
		LOG_WRN("Stream not started");
		return;
	}

	/*** Check incoming data ***/

	if (!buf) {
		LOG_ERR("Buffer pointer is NULL");
	}

	if (sdu_ref_us == ctrl_blk.prev_pres_sdu_ref_us && sdu_ref_us != 0) {
		LOG_WRN("Duplicate sdu_ref_us (%d) - Dropping audio frame", sdu_ref_us);
		return;
	}

	bool sdu_ref_not_consecutive = false;

	if (ctrl_blk.prev_pres_sdu_ref_us) {
		uint32_t sdu_ref_delta_us = sdu_ref_us - ctrl_blk.prev_pres_sdu_ref_us;

		/* Check if the delta is from two consecutive frames */
		if (sdu_ref_delta_us <
		    (CONFIG_AUDIO_FRAME_DURATION_US + (CONFIG_AUDIO_FRAME_DURATION_US / 2))) {
			/* Check for invalid delta */
			if ((sdu_ref_delta_us >
			     (CONFIG_AUDIO_FRAME_DURATION_US + SDU_REF_DELTA_MAX_ERR_US)) ||
			    (sdu_ref_delta_us <
			     (CONFIG_AUDIO_FRAME_DURATION_US - SDU_REF_DELTA_MAX_ERR_US))) {
				LOG_DBG("Invalid sdu_ref_us delta (%d) - Estimating sdu_ref_us",
					sdu_ref_delta_us);

				/* Estimate sdu_ref_us */
				sdu_ref_us = ctrl_blk.prev_pres_sdu_ref_us +
					     CONFIG_AUDIO_FRAME_DURATION_US;
			}
		} else {
			LOG_INF("sdu_ref_us not from consecutive frames (diff: %d us)",
				sdu_ref_delta_us);
			sdu_ref_not_consecutive = true;
		}
	}

	ctrl_blk.prev_pres_sdu_ref_us = sdu_ref_us;

	/*** Presentation compensation ***/
	if (ctrl_blk.pres_comp.enabled) {
		audio_datapath_presentation_compensation(recv_frame_ts_us, sdu_ref_us,
							 sdu_ref_not_consecutive);
	}

	/*** Decode ***/

	int ret;
	size_t pcm_size;

	ret = sw_codec_decode(buf, size, bad_frame, &ctrl_blk.decoded_data, &pcm_size);
	if (ret) {
		LOG_WRN("SW codec decode error: %d", ret);
	}

	if (IS_ENABLED(CONFIG_SD_CARD_PLAYBACK)) {
		if (sd_card_playback_is_active()) {
			sd_card_playback_mix_with_stream(ctrl_blk.decoded_data, pcm_size);
		}
	}

	if (pcm_size != (BLK_STEREO_SIZE_OCTETS * NUM_BLKS_IN_FRAME)) {
		LOG_WRN("Decoded audio has wrong size: %d. Expected: %d", pcm_size,
			(BLK_STEREO_SIZE_OCTETS * NUM_BLKS_IN_FRAME));
		/* Discard frame */
		return;
	}

	/*** Add audio data to FIFO buffer ***/

	int32_t num_blks_in_fifo = ctrl_blk.out.prod_blk_idx - ctrl_blk.out.cons_blk_idx;

	if ((num_blks_in_fifo + NUM_BLKS_IN_FRAME) > FIFO_NUM_BLKS) {
		LOG_WRN("Output audio stream overrun - Discarding audio frame");

		/* Discard frame to allow consumer to catch up */
		return;
	}

	uint32_t out_blk_idx = ctrl_blk.out.prod_blk_idx;

	for (uint32_t i = 0; i < NUM_BLKS_IN_FRAME; i++) {
		if (IS_ENABLED(CONFIG_AUDIO_BIT_DEPTH_16)) {
			memcpy(&ctrl_blk.out.fifo[out_blk_idx * BLK_STEREO_NUM_SAMPS],
			       &((int16_t *)ctrl_blk.decoded_data)[i * BLK_STEREO_NUM_SAMPS],
			       BLK_STEREO_SIZE_OCTETS);
		} else if (IS_ENABLED(CONFIG_AUDIO_BIT_DEPTH_32)) {
			memcpy(&ctrl_blk.out.fifo[out_blk_idx * BLK_STEREO_NUM_SAMPS],
			       &((int32_t *)ctrl_blk.decoded_data)[i * BLK_STEREO_NUM_SAMPS],
			       BLK_STEREO_SIZE_OCTETS);
		}

		/* Record producer block start reference */
		ctrl_blk.out.prod_blk_ts[out_blk_idx] = recv_frame_ts_us + (i * BLK_PERIOD_US);

		out_blk_idx = NEXT_IDX(out_blk_idx);
	}

	ctrl_blk.out.prod_blk_idx = out_blk_idx;
}

int audio_datapath_start(struct data_fifo *fifo_rx)
{
	__ASSERT_NO_MSG(fifo_rx != NULL);

	if (!ctrl_blk.datapath_initialized) {
		LOG_WRN("Audio datapath not initialized");
		return -ECANCELED;
	}

	if (!ctrl_blk.stream_started) {
		ctrl_blk.in.fifo = fifo_rx;

		/* Clear counters and mute initial audio */
		memset(&ctrl_blk.out, 0, sizeof(ctrl_blk.out));

		audio_datapath_i2s_start();
		ctrl_blk.stream_started = true;

		return 0;
	} else {
		return -EALREADY;
	}
}

int audio_datapath_stop(void)
{
	if (ctrl_blk.stream_started) {
		ctrl_blk.stream_started = false;
		audio_datapath_i2s_stop();
		ctrl_blk.prev_pres_sdu_ref_us = 0;
		ctrl_blk.prev_drift_sdu_ref_us = 0;

		pres_comp_state_set(PRES_STATE_INIT);

		return 0;
	} else {
		return -EALREADY;
	}
}

int audio_datapath_init(void)
{
	memset(&ctrl_blk, 0, sizeof(ctrl_blk));
	audio_i2s_blk_comp_cb_register(audio_datapath_i2s_blk_complete);
	audio_i2s_init();
	ctrl_blk.datapath_initialized = true;
	ctrl_blk.drift_comp.enabled = true;
	if (IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL) && (CONFIG_AUDIO_DEV == GATEWAY) &&
	    IS_ENABLED(CONFIG_BT_LL_ACS_NRF53)) {
		/* Disable presentation compensation feature for microphone return on gateway when
		 * using Audio Controller Subsystem. Also, since there's only one stream output from
		 * gateway for now, so no need to have presentation compensation.
		 */
		ctrl_blk.pres_comp.enabled = false;
	} else {
		ctrl_blk.pres_comp.enabled = true;
	}

	ctrl_blk.pres_comp.pres_delay_us = CONFIG_BT_AUDIO_PRESENTATION_DELAY_US;

	return 0;
}

static int cmd_i2s_tone_play(const struct shell *shell, size_t argc, const char **argv)
{
	int ret;
	uint16_t freq;
	uint16_t dur_ms;
	float amplitude;

	if (argc != 4) {
		shell_error(
			shell,
			"3 arguments (freq [Hz], dur [ms], and amplitude [0-1.0] must be provided");
		return -EINVAL;
	}

	if (!isdigit((int)argv[1][0])) {
		shell_error(shell, "Argument 1 is not numeric");
		return -EINVAL;
	}

	if (!isdigit((int)argv[2][0])) {
		shell_error(shell, "Argument 2 is not numeric");
		return -EINVAL;
	}

	freq = strtoul(argv[1], NULL, 10);
	dur_ms = strtoul(argv[2], NULL, 10);
	amplitude = strtof(argv[3], NULL);

	if (amplitude <= 0 || amplitude > 1) {
		shell_error(shell, "Make sure amplitude is 0 < [float] >= 1");
		return -EINVAL;
	}

	shell_print(shell, "Setting tone %d Hz for %d ms", freq, dur_ms);
	ret = audio_datapath_tone_play(freq, dur_ms, amplitude);

	if (ret == -EBUSY) {
		/* Abort continuous running tone with new tone */
		audio_datapath_tone_stop();
		ret = audio_datapath_tone_play(freq, dur_ms, amplitude);
	}

	if (ret) {
		shell_print(shell, "Tone failed with code %d", ret);
	}

	shell_print(shell, "Tone play: %d Hz for %d ms with amplitude %.02f", freq, dur_ms,
		    amplitude);

	return ret;
}

static int cmd_i2s_tone_stop(const struct shell *shell, size_t argc, const char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	audio_datapath_tone_stop();

	shell_print(shell, "Tone stop");

	return 0;
}

static int cmd_hfclkaudio_drift_comp_enable(const struct shell *shell, size_t argc,
					    const char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	ctrl_blk.drift_comp.enabled = true;

	shell_print(shell, "Audio PLL drift compensation enabled");

	return 0;
}

static int cmd_hfclkaudio_drift_comp_disable(const struct shell *shell, size_t argc,
					     const char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	if (ctrl_blk.pres_comp.enabled) {
		shell_print(shell, "Pres comp must be disabled to disable drift comp");
	} else {
		ctrl_blk.drift_comp.enabled = false;
		ctrl_blk.drift_comp.ctr = 0;
		drift_comp_state_set(DRIFT_STATE_INIT);

		shell_print(shell, "Audio PLL drift compensation disabled");
	}

	return 0;
}

static int cmd_audio_pres_comp_enable(const struct shell *shell, size_t argc, const char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	if (ctrl_blk.drift_comp.enabled) {
		ctrl_blk.pres_comp.enabled = true;

		shell_print(shell, "Presentation compensation enabled");
	} else {
		shell_print(shell, "Drift comp must be enabled to enable pres comp");
	}

	return 0;
}

static int cmd_audio_pres_comp_disable(const struct shell *shell, size_t argc, const char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	ctrl_blk.pres_comp.enabled = false;
	pres_comp_state_set(PRES_STATE_INIT);

	shell_print(shell, "Presentation compensation disabled");

	return 0;
}

SHELL_STATIC_SUBCMD_SET_CREATE(test_cmd,
			       SHELL_COND_CMD(CONFIG_SHELL, nrf_tone_start, NULL,
					      "Start local tone from nRF5340", cmd_i2s_tone_play),
			       SHELL_COND_CMD(CONFIG_SHELL, nrf_tone_stop, NULL,
					      "Stop local tone from nRF5340", cmd_i2s_tone_stop),
			       SHELL_COND_CMD(CONFIG_SHELL, pll_drift_comp_enable, NULL,
					      "Enable audio PLL auto drift compensation (default)",
					      cmd_hfclkaudio_drift_comp_enable),
			       SHELL_COND_CMD(CONFIG_SHELL, pll_drift_comp_disable, NULL,
					      "Disable audio PLL auto drift compensation",
					      cmd_hfclkaudio_drift_comp_disable),
			       SHELL_COND_CMD(CONFIG_SHELL, pll_pres_comp_enable, NULL,
					      "Enable audio presentation compensation (default)",
					      cmd_audio_pres_comp_enable),
			       SHELL_COND_CMD(CONFIG_SHELL, pll_pres_comp_disable, NULL,
					      "Disable audio presentation compensation",
					      cmd_audio_pres_comp_disable),
			       SHELL_SUBCMD_SET_END);

SHELL_CMD_REGISTER(test, &test_cmd, "Test mode commands", NULL);


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/audio/le_audio_rx.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _LE_AUDIO_RX_H_
#define _LE_AUDIO_RX_H_

/**
 * @brief Data handler when ISO data has been received.
 *
 * @param[in] p_data		Pointer to the received data.
 * @param[in] data_size		Size of the received data.
 * @param[in] bad_frame		Bad frame flag. (I.e. set for missed ISO data).
 * @param[in] sdu_ref		SDU reference timestamp.
 * @param[in] channel_index	Which channel is received.
 * @param[in] desired_data_size	The expected data size.
 *
 * @return 0 if successful, error otherwise.
 */
void le_audio_rx_data_handler(uint8_t const *const p_data, size_t data_size, bool bad_frame,
			      uint32_t sdu_ref, enum audio_channel channel_index,
			      size_t desired_data_size);

/**
 * @brief Initialize the receive audio path.
 *
 * @return 0 if successful, error otherwise.
 */
int le_audio_rx_init(void);

#endif /* _LE_AUDIO_RX_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/audio/sw_codec_select.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _SW_CODEC_SELECT_H_
#define _SW_CODEC_SELECT_H_

#include <zephyr/kernel.h>
#include "channel_assignment.h"

#if (CONFIG_SW_CODEC_LC3)
#define LC3_MAX_FRAME_SIZE_MS	10
#define LC3_ENC_MONO_FRAME_SIZE (CONFIG_LC3_BITRATE_MAX * LC3_MAX_FRAME_SIZE_MS / (8 * 1000))

#define LC3_PCM_NUM_BYTES_MONO                                                                     \
	(CONFIG_AUDIO_SAMPLE_RATE_HZ * CONFIG_AUDIO_BIT_DEPTH_OCTETS * LC3_MAX_FRAME_SIZE_MS / 1000)
#define LC3_ENC_TIME_US 3000
#define LC3_DEC_TIME_US 1500
#else
#define LC3_ENC_MONO_FRAME_SIZE 0
#define LC3_PCM_NUM_BYTES_MONO	0
#define LC3_ENC_TIME_US		0
#define LC3_DEC_TIME_US		0
#endif /* CONFIG_SW_CODEC_LC3 */

/* Max will be used when multiple codecs are supported */
#define ENC_MAX_FRAME_SIZE   MAX(LC3_ENC_MONO_FRAME_SIZE, 0)
#define ENC_TIME_US	     MAX(LC3_ENC_TIME_US, 0)
#define DEC_TIME_US	     MAX(LC3_DEC_TIME_US, 0)
#define PCM_NUM_BYTES_MONO   MAX(LC3_PCM_NUM_BYTES_MONO, 0)
#define PCM_NUM_BYTES_STEREO (PCM_NUM_BYTES_MONO * 2)

enum sw_codec_select {
	SW_CODEC_NONE,
	SW_CODEC_LC3, /* Low Complexity Communication Codec */
};

enum sw_codec_channel_mode {
	SW_CODEC_MONO = 1,
	SW_CODEC_STEREO,
};

struct sw_codec_encoder {
	bool enabled;
	int bitrate;
	enum sw_codec_channel_mode channel_mode;
	uint8_t num_ch;
	enum audio_channel audio_ch;
	uint32_t sample_rate_hz;
};

struct sw_codec_decoder {
	bool enabled;
	bool started;
	enum sw_codec_channel_mode channel_mode; /* Mono or stereo. */
	uint8_t num_ch;				 /* Number of decoder channels. */
	enum audio_channel audio_ch;		 /* Used to choose which channel to use. */
	uint32_t sample_rate_hz;
};

/**
 * @brief  Sw_codec configuration structure.
 */
struct sw_codec_config {
	enum sw_codec_select sw_codec;	 /* sw_codec to be used, e.g. LC3, etc. */
	struct sw_codec_decoder decoder; /* Struct containing settings for decoder. */
	struct sw_codec_encoder encoder; /* Struct containing settings for encoder. */
	bool initialized;		 /* Status of codec. */
};

/**
 * @brief	Check if the software codec is initialized.
 *
 * @retval	true	SW codec is initialized.
 * @retval	false	SW codec is not initialized.
 */
bool sw_codec_is_initialized(void);

/**
 * @brief	Encode PCM data and output encoded data.
 *
 * @note	Takes in stereo PCM stream, will encode either one or two
 *		channels, based on channel_mode set during init.
 *
 * @param[in]	pcm_data	Pointer to PCM data.
 * @param[in]	pcm_size	Size of PCM data.
 * @param[out]	encoded_data	Pointer to buffer to store encoded data.
 * @param[out]	encoded_size	Size of encoded data.
 *
 * @return	0 if success, error codes depends on sw_codec selected.
 */
int sw_codec_encode(void *pcm_data, size_t pcm_size, uint8_t **encoded_data, size_t *encoded_size);

/**
 * @brief	Decode encoded data and output PCM data.
 *
 * @param[in]	encoded_data	Pointer to encoded data.
 * @param[in]	encoded_size	Size of encoded data.
 * @param[in]	bad_frame	Flag to indicate a missing/bad frame (only LC3).
 * @param[out]	pcm_data	Pointer to buffer to store decoded PCM data.
 * @param[out]	pcm_size	Size of decoded data.
 *
 * @return	0 if success, error codes depends on sw_codec selected.
 */
int sw_codec_decode(uint8_t const *const encoded_data, size_t encoded_size, bool bad_frame,
		    void **pcm_data, size_t *pcm_size);

/**
 * @brief	Uninitialize the software codec and free the allocated space.
 *
 * @note	Must be called before calling init for another sw_codec.
 *
 * @param[in]	sw_codec_cfg	Struct to tear down sw_codec.
 *
 * @return	0 if success, error codes depends on sw_codec selected.
 */
int sw_codec_uninit(struct sw_codec_config sw_codec_cfg);

/**
 * @brief	Initialize the software codec and statically or dynamically
 *		allocate memory to be used, depending on the selected codec
 *		and its configuration.
 *
 * @param[in]	sw_codec_cfg	Struct to set up sw_codec.
 *
 * @return	0 if success, error codes depends on sw_codec selected.
 */
int sw_codec_init(struct sw_codec_config sw_codec_cfg);

#endif /* _SW_CODEC_SELECT_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/audio/audio_system.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _AUDIO_SYSTEM_H_
#define _AUDIO_SYSTEM_H_

#include <stddef.h>
#include <stdbool.h>
#include <stdint.h>

#define VALUE_NOT_SET 0

/**
 * @brief	Start the execution of the encoder thread.
 */
void audio_system_encoder_start(void);

/**
 * @brief	Stop the encoder thread from executing.
 *
 * @note	Using this allows the encode thread to always be enabled,
 *		but disables the execution when not needed, saving power.
 */
void audio_system_encoder_stop(void);

/**
 * @brief	Toggle a test tone on and off.
 *
 * @note	A stream must already be running to use this feature.
 *
 * @param[in]	freq	Desired frequency of tone. Off if set to 0.
 *
 * @retval	-ENOMEM	The frequency is too low (buffer overflow).
 * @retval	0	Success.
 */
int audio_system_encode_test_tone_set(uint32_t freq);

/**
 * @brief	Step through different test tones.
 *
 * @note	A stream must already be running to use this feature.
 *		Will step through test tones: 1 kHz, 2 kHz, 4 kHz and off.
 *
 * @return	0 on success, error otherwise.
 */
int audio_system_encode_test_tone_step(void);

/**
 * @brief	Set the sample rates for the encoder and the decoder, and the bit rate for encoder.
 *
 * @note	If any of the values are 0, the corresponding configuration will not be set.
 *
 * @param[in]	encoder_sample_rate_hz	Sample rate to be used by the encoder; can be 0.
 * @param[in]	encoder_bitrate		Bit rate to be used by the encoder (bps); can be 0.
 * @param[in]	decoder_sample_rate_hz	Sample rate to be used by the decoder; can be 0.
 *
 * @retval	-EINVAL	Invalid sample rate given.
 * @retval	0	On success.
 */
int audio_system_config_set(uint32_t encoder_sample_rate_hz, uint32_t encoder_bitrate,
			    uint32_t decoder_sample_rate_hz);

/**
 * @brief	Decode data and then add it to TX FIFO buffer.
 *
 * @param[in]	encoded_data		Pointer to encoded data.
 * @param[in]	encoded_data_size	Size of encoded data.
 * @param[in]	bad_frame		Indication on missed or incomplete frame.
 *
 * @return	0 on success, error otherwise.
 */
int audio_system_decode(void const *const encoded_data, size_t encoded_data_size, bool bad_frame);

/**
 * @brief	Initialize and start both HW and SW audio codec.
 */
void audio_system_start(void);

/**
 * @brief	Stop all activities related to audio.
 */
void audio_system_stop(void);

/**
 * @brief	Drop oldest block from the fifo_rx buffer.
 *
 * @note	This can be used to reduce latency by adjusting the timing of the completed frame
 *		that was sampled in relation to the connection interval in Bluetooth LE.
 *
 * @return	0 on success, -ECANCELED otherwise.
 */
int audio_system_fifo_rx_block_drop(void);

/**
 * @brief	Get number of decoder channels.
 *
 * @return	Number of decoder channels.
 */
int audio_system_decoder_num_ch_get(void);

/**
 * @brief	Initialize the audio_system.
 *
 * @return	0 on success, error otherwise.
 */
int audio_system_init(void);

#endif /* _AUDIO_SYSTEM_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/audio/audio_datapath.h
/*
 *  Copyright (c) 2021, PACKETCRAFT, INC.
 *
 *  SPDX-License-Identifier: LicenseRef-PCFT
 */

#ifndef _AUDIO_DATAPATH_H_
#define _AUDIO_DATAPATH_H_

#include <zephyr/kernel.h>
#include <stdint.h>
#include <stdbool.h>

#include "data_fifo.h"
#include "sw_codec_select.h"

/**
 * @brief Mixes a tone into the I2S TX stream
 *
 * @param freq Tone frequency [Hz]
 * @param dur_ms Tone duration [ms]. 0 = forever
 * @param amplitude Tone amplitude [0, 1]
 *
 * @return 0 if successful, error otherwise
 */
int audio_datapath_tone_play(uint16_t freq, uint16_t dur_ms, float amplitude);

/**
 * @brief Stops tone playback
 */
void audio_datapath_tone_stop(void);

/**
 * @brief Set the presentation delay
 *
 * @param delay_us The presentation delay in s
 *
 * @return 0 if successful, error otherwise
 */
int audio_datapath_pres_delay_us_set(uint32_t delay_us);

/**
 * @brief Get the current presentation delay
 *
 * @param delay_us  The presentation delay in s
 */
void audio_datapath_pres_delay_us_get(uint32_t *delay_us);

/**
 * @brief Input an audio data frame which is processed and outputted over I2S
 *
 * @note A frame of raw encoded audio data is inputted, and this data then is decoded
 *       and processed before being outputted over I2S. The audio is synchronized
 *       using sdu_ref_us
 *
 * @param buf Pointer to audio data frame
 * @param size Size of audio data frame in bytes
 * @param sdu_ref_us ISO timestamp reference from BLE controller
 * @param bad_frame Indicating if the audio frame is bad or not
 * @param recv_frame_ts_us Timestamp of when audio frame was received
 */
void audio_datapath_stream_out(const uint8_t *buf, size_t size, uint32_t sdu_ref_us, bool bad_frame,
			       uint32_t recv_frame_ts_us);

/**
 * @brief Start the audio datapath module
 *
 * @note The continuously running I2S is started
 *
 * @param fifo_rx Pointer to FIFO structure where I2S RX data is put
 *
 * @return 0 if successful, error otherwise
 */
int audio_datapath_start(struct data_fifo *fifo_rx);

/**
 * @brief Stop the audio datapath module
 *
 * @return 0 if successful, error otherwise
 */
int audio_datapath_stop(void);

/**
 * @brief Initialize the audio datapath module
 *
 * @return 0 if successful, error otherwise
 */
int audio_datapath_init(void);

#endif /* _AUDIO_DATAPATH_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/audio/streamctrl.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _STREAMCTRL_H_
#define _STREAMCTRL_H_

#include <stddef.h>
#include <zephyr/kernel.h>

/* State machine states for peer or stream. */
enum stream_state {
	STATE_STREAMING,
	STATE_PAUSED,
};

/**
 * @brief Get the current streaming state.
 *
 * @return      strm_state enum value.
 */
uint8_t stream_state_get(void);

/**
 * @brief Send audio data over the stream.
 *
 * @param data		Data to send.
 * @param size		Size of data.
 * @param num_ch	Number of audio channels.
 */
void streamctrl_send(void const *const data, size_t size, uint8_t num_ch);

#endif /* _STREAMCTRL_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/CMakeLists.txt
#
# Copyright (c) 2022 Nordic Semiconductor
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

add_subdirectory(bt_management)
add_subdirectory(bt_renderer)
add_subdirectory(bt_content_control)
add_subdirectory(bt_stream)

zephyr_library_include_directories(
    bt_management
    bt_renderer
    bt_content_control
    bt_stream
)


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/.DS_Store
// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/Kconfig.defaults
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

config BT_AUDIO
	default y

config BT_DEVICE_NAME
	default BT_AUDIO_BROADCAST_NAME if TRANSPORT_BIS
	default "NRF5340_AUDIO"

config BT_ECC
	default y if BT

config BT_EXT_ADV
	default y

# Mandatory to support at least 1 for ASCS
config BT_ATT_PREPARE_COUNT
	default 1


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/Kconfig
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

rsource "Kconfig.defaults"

menu "Bluetooth"

rsource "bt_management/Kconfig"

#----------------------------------------------------------------------------#
menu "Bluetooth audio"

if TRANSPORT_BIS
rsource "bt_stream/broadcast/Kconfig"
endif # TRANSPORT_BIS

if TRANSPORT_CIS
rsource "bt_stream/unicast/Kconfig"
endif # TRANSPORT_CIS

config BT_AUDIO_PACKING_INTERLEAVED
	bool "Interleaved packing"
	default n
	help
	  ISO channels can either be interleaved or sequentially packed; sequential is the default one.

config BT_AUDIO_PREF_SAMPLE_RATE_VALUE
	hex
	default 0x03 if BT_AUDIO_PREF_SAMPLE_RATE_16KHZ
	default 0x05 if BT_AUDIO_PREF_SAMPLE_RATE_24KHZ
	default 0x08 if BT_AUDIO_PREF_SAMPLE_RATE_48KHZ

choice BT_AUDIO_PREF_SAMPLE_RATE
	prompt "Preferred audio sample rate"
	default BT_AUDIO_PREF_SAMPLE_RATE_24KHZ if STREAM_BIDIRECTIONAL
	default BT_AUDIO_PREF_SAMPLE_RATE_48KHZ
	help
	  Select the preferred sample rate if there are more than one to choose from.

config  BT_AUDIO_PREF_SAMPLE_RATE_48KHZ
	bool "48 kHz"
	help
	  Select 48000 Hz as the preferred sample rate.

config  BT_AUDIO_PREF_SAMPLE_RATE_24KHZ
	bool "24 kHz"
	help
	  Select 24000 Hz as the preferred sample rate.

config  BT_AUDIO_PREF_SAMPLE_RATE_16KHZ
	bool "16 kHz"
	help
	  Select 16000 Hz as the preferred sample rate.
endchoice

#----------------------------------------------------------------------------#
menu "QoS"

config BT_AUDIO_PRESENTATION_DELAY_US
	int "Presentation delay"
	range AUDIO_MIN_PRES_DLY_US AUDIO_MAX_PRES_DLY_US
	default 10000
	help
	  The audio source/client defined presentation delay if within
	  AUDIO_MIN_PRES_DLY_US and AUDIO_MAX_PRES_DLY_US range. This will
	  override the audio receivers presentation delay as long as it
	  is in range of the max and min supported by the audio receivers.
	  If it is outside this range, then it will revert to the closest
	  supported value.

config BT_AUDIO_MAX_TRANSPORT_LATENCY_MS
	int "Max transport latency"
	range 5 4000
	default 20
	help
	  Max transport latency for the ISO link.

config BT_AUDIO_RETRANSMITS
	int "Number of re-transmits"
	range 0 30
	default 2
	help
	  Number of re-transmits for the ISO link. 2 re-transmits means a total
	  of 3 packets sent per stream.

endmenu # QoS
endmenu # Bluetooth audio

rsource "bt_renderer/Kconfig"
rsource "bt_content_control/Kconfig"

#----------------------------------------------------------------------------#
menu "Log levels"

module = BLE
module-str = ble
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log levels

#----------------------------------------------------------------------------#
menu "Testing"

config TESTING_BLE_ADDRESS_RANDOM
	bool "Random address and bonding clear on every restart [EXPERIMENTAL]"
	default n
	select EXPERIMENTAL
	help
	  If enabled the system will generate a new address on every
	  restart (i.e. reset, re-flash). Any bonding information will
	  be cleared. This is only for testing purposes.

endmenu # Testing
endmenu # Bluetooth


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_content_control/CMakeLists.txt
#
# Copyright (c) 2023 Nordic Semiconductor
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

zephyr_library_include_directories(
    media
)

target_sources(app PRIVATE
		${CMAKE_CURRENT_SOURCE_DIR}/bt_content_ctrl.c)

if (CONFIG_BT_MCC OR CONFIG_BT_MCS)
target_sources(app PRIVATE
		${CMAKE_CURRENT_SOURCE_DIR}/media/bt_content_ctrl_media.c)
endif()


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_content_control/Kconfig
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

menu "Content control"

rsource "media/Kconfig"

#----------------------------------------------------------------------------#
menu "Log level"

module = BT_CONTENT_CTRL
module-str = bt_content_ctrl
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log level
endmenu # Content control


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_content_control/bt_content_ctrl.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BT_CONTENT_CTRL_H_
#define _BT_CONTENT_CTRL_H_

#include <zephyr/bluetooth/conn.h>

/**
 * @brief	Send the start request for content transmission.
 *
 * @param[in]	conn	Pointer to the connection to control; can be NULL.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_start(struct bt_conn *conn);

/**
 * @brief	Send the stop request for content transmission.
 *
 * @param[in]	conn	Pointer to the connection to control; can be NULL.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_stop(struct bt_conn *conn);

/**
 * @brief	Handle disconnected connection for the content control services.
 *
 * @param[in]	conn	Pointer to the disconnected connection.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_conn_disconnected(struct bt_conn *conn);

/**
 * @brief	Discover the content control services for the given connection pointer.
 *
 * @param[in]	conn	Pointer to the connection on which to discover the services.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_discover(struct bt_conn *conn);

/**
 * @brief	Put the UUIDs from this module into the buffer.
 *
 * @note	This partial data is used to build a complete extended advertising packet.
 *
 * @param[out]	uuid_buf	Buffer being populated with UUIDs.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_uuid_populate(struct net_buf_simple *uuid_buf);

/**
 * @brief	Initialize the content control module.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_init(void);

#endif /* _BT_CONTENT_CTRL_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_content_control/bt_content_ctrl.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "bt_content_ctrl.h"

#include <zephyr/zbus/zbus.h>
#include <zephyr/bluetooth/uuid.h>

#include "bt_content_ctrl_media_internal.h"
#include "nrf5340_audio_common.h"
#include "macros_common.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(bt_content_ctrl, CONFIG_BT_CONTENT_CTRL_LOG_LEVEL);

ZBUS_CHAN_DEFINE(cont_media_chan, struct content_control_msg, NULL, NULL, ZBUS_OBSERVERS_EMPTY,
		 ZBUS_MSG_INIT(0));

static void media_control_cb(bool play)
{
	int ret;
	struct content_control_msg msg;

	if (play) {
		msg.event = MEDIA_START;
	} else {
		msg.event = MEDIA_STOP;
	}

	ret = zbus_chan_pub(&cont_media_chan, &msg, K_NO_WAIT);
	ERR_CHK_MSG(ret, "zbus publication failed");
}

int bt_content_ctrl_start(struct bt_conn *conn)
{
	int ret;
	struct content_control_msg msg;

	if (IS_ENABLED(CONFIG_BT_MCC) || IS_ENABLED(CONFIG_BT_MCS)) {
		ret = bt_content_ctrl_media_play(conn);
		if (ret) {
			LOG_WRN("Failed to change the streaming state");
			return ret;
		}

		return 0;
	}

	msg.event = MEDIA_START;

	ret = zbus_chan_pub(&cont_media_chan, &msg, K_NO_WAIT);
	ERR_CHK_MSG(ret, "zbus publication failed");

	return 0;
}

int bt_content_ctrl_stop(struct bt_conn *conn)
{
	int ret;
	struct content_control_msg msg;

	if (IS_ENABLED(CONFIG_BT_MCC) || IS_ENABLED(CONFIG_BT_MCS)) {
		ret = bt_content_ctrl_media_pause(conn);
		if (ret) {
			LOG_WRN("Failed to change the streaming state");
			return ret;
		}

		return 0;
	}

	msg.event = MEDIA_STOP;

	ret = zbus_chan_pub(&cont_media_chan, &msg, K_NO_WAIT);
	ERR_CHK_MSG(ret, "zbus publication failed");

	return 0;
}

int bt_content_ctrl_conn_disconnected(struct bt_conn *conn)
{
	int ret;

	if (IS_ENABLED(CONFIG_BT_MCC)) {
		ret = bt_content_ctrl_media_conn_disconnected(conn);
		if (ret) {
			LOG_ERR("bt_content_ctrl_media_conn_disconnected failed with %d", ret);
		}
	}

	return 0;
}

int bt_content_ctrl_discover(struct bt_conn *conn)
{
	int ret;

	if (IS_ENABLED(CONFIG_BT_MCC)) {
		ret = bt_content_ctrl_media_discover(conn);
		if (ret) {
			LOG_ERR("Failed to discover the media control client");
			return ret;
		}
	}

	return 0;
}

int bt_content_ctrl_uuid_populate(struct net_buf_simple *uuid_buf)
{
	if (IS_ENABLED(CONFIG_BT_MCC)) {
		if (net_buf_simple_tailroom(uuid_buf) >= BT_UUID_SIZE_16) {
			net_buf_simple_add_le16(uuid_buf, BT_UUID_MCS_VAL);
		} else {
			return -ENOMEM;
		}
	}

	return 0;
}

int bt_content_ctrl_init(void)
{
	int ret;

	if (IS_ENABLED(CONFIG_BT_MCS)) {
		ret = bt_content_ctrl_media_server_init(media_control_cb);
		if (ret) {
			LOG_ERR("MCS server init failed");
			return ret;
		}
	}

	if (IS_ENABLED(CONFIG_BT_MCC)) {
		ret = bt_content_ctrl_media_client_init();
		if (ret) {
			LOG_ERR("MCS client init failed");
			return ret;
		}
	}

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_content_control/media/bt_content_ctrl_media.c
/*
 * Copyright (c) 2021 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "bt_content_ctrl_media_internal.h"

#include <zephyr/kernel.h>
#include <zephyr/types.h>
#include <zephyr/bluetooth/att.h>
#include <zephyr/bluetooth/conn.h>
#include <zephyr/bluetooth/audio/media_proxy.h>
#include <zephyr/bluetooth/audio/mcs.h>
#include <zephyr/bluetooth/audio/mcc.h>

#include "macros_common.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(bt_content_ctrl_media, CONFIG_BT_CONTENT_CTRL_MEDIA_LOG_LEVEL);

static uint8_t media_player_state = BT_MCS_MEDIA_STATE_PLAYING;

static struct media_player *local_player;
static bt_content_ctrl_media_play_pause_cb play_pause_cb;

enum mcs_disc_status {
	IDLE,
	IN_PROGRESS,
	FINISHED,
};

struct media_ctlr {
	enum mcs_disc_status mcp_mcs_disc_status;
	struct bt_conn *conn;
};

static struct media_ctlr mcc_peer[CONFIG_BT_MAX_CONN];

/**
 * @brief	Get the index of the first available mcc_peer
 *
 * @return	Index if success, -ENOMEM if no available indexes
 */
static int mcc_peer_index_free_get(void)
{
	for (int i = 0; i < ARRAY_SIZE(mcc_peer); i++) {
		if (mcc_peer[i].conn == NULL) {
			return i;
		}
	}

	LOG_WRN("No more indexes for MCC peer");

	return -ENOMEM;
}

/**
 * @brief	Get index of a given conn pointer
 *
 * @param	conn	Pointer to check against
 *
 * @return	index if found, -ESRCH if not found, -EINVAL if invalid conn pointer
 */
static int mcc_peer_index_get(struct bt_conn *conn)
{
	if (conn == NULL) {
		LOG_WRN("Invalid conn pointer");
		return -EINVAL;
	}

	for (uint8_t i = 0; i < ARRAY_SIZE(mcc_peer); i++) {
		if (mcc_peer[i].conn == conn) {
			return i;
		}
	}

	LOG_DBG("No matching conn pointer for this mcc_peer");
	return -ESRCH;
}

/**
 * @brief	Callback handler for MCS discover finished.
 *
 * @note	This callback handler will be triggered when MCS
 *		discovery is finished. Used by the client.
 */
static void mcc_discover_mcs_cb(struct bt_conn *conn, int err)
{
	int ret;
	int idx = mcc_peer_index_get(conn);

	if (idx < 0) {
		LOG_WRN("Unable to look up conn pointer: %d", idx);
		return;
	}

	if (err) {
		if (err == BT_ATT_ERR_UNLIKELY) {
			/* BT_ATT_ERR_UNLIKELY may occur in normal operating conditions if there is
			 * a disconnect while discovering, hence it will be treated as a warning.
			 */
			LOG_WRN("Discovery of MCS failed (%d)", err);
		} else {
			LOG_ERR("Discovery of MCS failed (%d)", err);
		}

		mcc_peer[idx].mcp_mcs_disc_status = IDLE;
		return;
	}

	if (mcc_peer[idx].mcp_mcs_disc_status != IN_PROGRESS) {
		/* Due to the design of MCC, there will be several
		 * invocations of this callback. We are only interested
		 * in what we have explicitly requested.
		 */
		LOG_DBG("Filtered out callback");
		return;
	}

	mcc_peer[idx].mcp_mcs_disc_status = FINISHED;
	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Discovery of MCS finished");

	ret = bt_content_ctrl_media_state_update(conn);
	if (ret < 0 && ret != -EBUSY) {
		LOG_WRN("Failed to update media state: %d", ret);
	}
}

/**
 * @brief	Callback handler for sent MCS commands.
 *
 * @note	This callback will be triggered when MCS commands have been sent.
 *		Used by the client.
 */
static void mcc_send_command_cb(struct bt_conn *conn, int err, const struct mpl_cmd *cmd)
{
	LOG_DBG("mcc_send_command_cb");

	if (err) {
		LOG_ERR("MCC: cmd send failed (%d) - opcode: %u, param: %d", err, cmd->opcode,
			cmd->param);
	}
}

/**
 * @brief  Callback handler for received notifications.
 *
 * @note	This callback will be triggered when a notification has been received.
 *		Used by the client.
 */
static void mcc_cmd_notification_cb(struct bt_conn *conn, int err, const struct mpl_cmd_ntf *ntf)
{
	LOG_DBG("mcc_cmd_ntf_cb");

	if (err) {
		LOG_ERR("MCC: cmd ntf error (%d) - opcode: %u, result: %u", err,
			ntf->requested_opcode, ntf->result_code);
	}
}

/**
 * @brief  Callback handler for reading media state.
 *
 * @note	This callback will be triggered when the client has asked to read
 *		the current state of the media player.
 */
static void mcc_read_media_state_cb(struct bt_conn *conn, int err, uint8_t state)
{
	LOG_DBG("mcc_read_media_cb, state: %d", state);

	if (err) {
		LOG_ERR("MCC: Media State read failed (%d)", err);
		return;
	}

	media_player_state = state;
}

/**
 * @brief  Callback handler for received MCS commands.
 *
 * @note	This callback will be triggered when the server has received a
 *		command from the client or the commander.
 */
static void mcs_command_recv_cb(struct media_player *plr, int err,
				const struct mpl_cmd_ntf *cmd_ntf)
{
	if (err) {
		LOG_ERR("Command failed (%d)", err);
		return;
	}

	LOG_DBG("Received opcode: %d", cmd_ntf->requested_opcode);

	if (cmd_ntf->requested_opcode == BT_MCS_OPC_PLAY) {
		play_pause_cb(true);
	} else if (cmd_ntf->requested_opcode == BT_MCS_OPC_PAUSE) {
		play_pause_cb(false);
	} else {
		LOG_WRN("Unsupported opcode: %d", cmd_ntf->requested_opcode);
	}
}

/**
 * @brief  Callback handler for getting the current state of the media player.
 *
 * @note	This callback will be triggered when the server has asked for the
 *		current state of its local media player.
 */
static void mcs_media_state_cb(struct media_player *plr, int err, uint8_t state)
{
	if (err) {
		LOG_ERR("Media state failed (%d)", err);
		return;
	}

	media_player_state = state;
}

/**
 * @brief  Callback handler for getting a pointer to the local media player.
 *
 * @note	This callback will be triggered during initialization when the
 *		local media player is ready.
 */
static void mcs_local_player_instance_cb(struct media_player *player, int err)
{
	int ret;
	struct mpl_cmd cmd;

	if (err) {
		LOG_ERR("Local player instance failed (%d)", err);
		return;
	}

	LOG_DBG("Received local player");

	local_player = player;

	cmd.opcode = BT_MCS_OPC_PLAY;

	/* Since the media player is default paused when initialized, we
	 * send a play command when the first stream is enabled
	 */
	ret = media_proxy_ctrl_send_command(local_player, &cmd);
	if (ret) {
		LOG_WRN("Failed to set media proxy state to play: %d", ret);
	}
}

/**
 * @brief	Send command to either local media player or peer
 *
 * @param	conn	Pointer to the conn to send the command to
 * @param	cmd	Command to send
 *
 * @return	0 for success, error otherwise.
 */
static int mpl_cmd_send(struct bt_conn *conn, struct mpl_cmd *cmd)
{
	int ret;
	int any_failures = 0;

	if (IS_ENABLED(CONFIG_BT_MCS)) {
		ret = media_proxy_ctrl_send_command(local_player, cmd);
		if (ret) {
			LOG_WRN("Failed to send command: %d", ret);
			return ret;
		}
	}

	if (IS_ENABLED(CONFIG_BT_MCC)) {
		if (conn != NULL) {
			int idx = mcc_peer_index_get(conn);

			if (idx < 0) {
				LOG_ERR("Unable to find mcc_peer");
				return idx;
			}

			if (mcc_peer[idx].mcp_mcs_disc_status == FINISHED) {
				ret = bt_mcc_send_cmd(mcc_peer[idx].conn, cmd);
				if (ret) {
					LOG_WRN("Failed to send command: %d", ret);
					return ret;
				}
			} else {
				LOG_WRN("MCS discovery has not finished: %d",
					mcc_peer[idx].mcp_mcs_disc_status);
				return -EBUSY;
			}

			return 0;
		}

		/* Send cmd to all peers connected and has finished discovery */
		for (uint8_t i = 0; i < ARRAY_SIZE(mcc_peer); i++) {
			if (mcc_peer[i].conn != NULL) {
				if (mcc_peer[i].mcp_mcs_disc_status == FINISHED) {
					ret = bt_mcc_send_cmd(mcc_peer[i].conn, cmd);
					if (ret) {
						LOG_WRN("Failed to send command: %d", ret);
						any_failures = ret;
					}
				} else {
					LOG_WRN("MCS discovery has not finished: %d",
						mcc_peer[i].mcp_mcs_disc_status);
					any_failures = -EBUSY;
				}
			}
		}
	}

	if (any_failures) {
		return any_failures;
	}

	return 0;
}

int bt_content_ctrl_media_discover(struct bt_conn *conn)
{
	int ret;

	if (!IS_ENABLED(CONFIG_BT_MCC)) {
		LOG_ERR("MCC not enabled");
		return -ECANCELED;
	}

	if (conn == NULL) {
		LOG_ERR("Invalid conn pointer");
		return -EINVAL;
	}

	int idx = mcc_peer_index_get(conn);

	if (idx == -ESRCH) {
		idx = mcc_peer_index_free_get();
		if (idx < 0) {
			LOG_WRN("Error getting free index: %d", idx);
			return idx;
		}

		mcc_peer[idx].conn = conn;
	}

	if (mcc_peer[idx].mcp_mcs_disc_status == FINISHED ||
	    mcc_peer[idx].mcp_mcs_disc_status == IN_PROGRESS) {
		return -EALREADY;
	}

	mcc_peer[idx].mcp_mcs_disc_status = IN_PROGRESS;

	ret = bt_mcc_discover_mcs(conn, true);
	if (ret) {
		mcc_peer[idx].mcp_mcs_disc_status = IDLE;
		return ret;
	}

	return 0;
}

int bt_content_ctrl_media_state_update(struct bt_conn *conn)
{
	if (!IS_ENABLED(CONFIG_BT_MCC)) {
		LOG_ERR("MCC not enabled");
		return -ECANCELED;
	}

	int idx = mcc_peer_index_get(conn);

	if (idx < 0) {
		LOG_WRN("Unable to look up conn pointer: %d", idx);
		return idx;
	}

	if (mcc_peer[idx].mcp_mcs_disc_status != FINISHED) {
		LOG_WRN("MCS discovery has not finished");
		return -EBUSY;
	}

	return bt_mcc_read_media_state(conn);
}

int bt_content_ctrl_media_play(struct bt_conn *conn)
{
	int ret;
	struct mpl_cmd cmd;

	if (media_player_state != BT_MCS_MEDIA_STATE_PLAYING &&
	    media_player_state != BT_MCS_MEDIA_STATE_PAUSED) {
		LOG_ERR("Invalid state: %d", media_player_state);
		return -ECANCELED;
	}

	if (media_player_state == BT_MCS_MEDIA_STATE_PLAYING) {
		LOG_WRN("Already in a playing state");
		return -EAGAIN;
	}

	cmd.opcode = BT_MCS_OPC_PLAY;
	cmd.use_param = false;

	ret = mpl_cmd_send(conn, &cmd);
	if (ret) {
		return ret;
	}

	return 0;
}

int bt_content_ctrl_media_pause(struct bt_conn *conn)
{
	int ret;
	struct mpl_cmd cmd;

	if (media_player_state != BT_MCS_MEDIA_STATE_PLAYING &&
	    media_player_state != BT_MCS_MEDIA_STATE_PAUSED) {
		LOG_ERR("Invalid state: %d", media_player_state);
		return -ECANCELED;
	}

	if (media_player_state == BT_MCS_MEDIA_STATE_PAUSED) {
		LOG_WRN("Already in a paused state");
		return -EAGAIN;
	}

	cmd.opcode = BT_MCS_OPC_PAUSE;
	cmd.use_param = false;

	ret = mpl_cmd_send(conn, &cmd);
	if (ret) {
		return ret;
	}

	return 0;
}

int bt_content_ctrl_media_conn_disconnected(struct bt_conn *conn)
{
	int idx = mcc_peer_index_get(conn);

	if (idx < 0) {
		LOG_WRN("Unable to look up conn pointer: %d", idx);
		return idx;
	}

	LOG_DBG("MCS discover state reset due to disconnection");
	mcc_peer[idx].mcp_mcs_disc_status = IDLE;
	mcc_peer[idx].conn = NULL;
	return 0;
}

int bt_content_ctrl_media_client_init(void)
{
	if (!IS_ENABLED(CONFIG_BT_MCC)) {
		LOG_ERR("MCC not enabled");
		return -ECANCELED;
	}

	static struct bt_mcc_cb mcc_cb;

	mcc_cb.discover_mcs = mcc_discover_mcs_cb;
	mcc_cb.send_cmd = mcc_send_command_cb;
	mcc_cb.cmd_ntf = mcc_cmd_notification_cb;
	mcc_cb.read_media_state = mcc_read_media_state_cb;
	return bt_mcc_init(&mcc_cb);
}

int bt_content_ctrl_media_server_init(bt_content_ctrl_media_play_pause_cb play_pause)
{
	int ret;

	if (!IS_ENABLED(CONFIG_BT_MCS)) {
		LOG_ERR("MCS not enabled");
		return -ECANCELED;
	}

	static struct media_proxy_ctrl_cbs mcs_cb;

	play_pause_cb = play_pause;

	ret = media_proxy_pl_init();
	if (ret) {
		LOG_ERR("Failed to init media proxy: %d", ret);
		return ret;
	}

	mcs_cb.command_recv = mcs_command_recv_cb;
	mcs_cb.media_state_recv = mcs_media_state_cb;
	mcs_cb.local_player_instance = mcs_local_player_instance_cb;

	ret = media_proxy_ctrl_register(&mcs_cb);
	if (ret) {
		LOG_ERR("Could not init mpl: %d", ret);
		return ret;
	}

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_content_control/media/bt_content_ctrl_media_internal.h
/*
 * Copyright (c) 2021 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BT_CONTENT_CTRL_MEDIA_INTERNAL_H_
#define _BT_CONTENT_CTRL_MEDIA_INTERNAL_H_

#include <zephyr/bluetooth/conn.h>

/**
 * @brief	Callback for changing the stream state.
 *
 * @param[in]	play	Differentiate between the play command and the pause command.
 */
typedef void (*bt_content_ctrl_media_play_pause_cb)(bool play);

/**
 * @brief	Discover Media Control Service and the included services.
 *
 * @note	Only valid for client.
 *
 * @param[in]	conn	Pointer to the active connection.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_media_discover(struct bt_conn *conn);

/**
 * @brief	Get the current state of the media player.
 *
 * @note	Only valid for client.
 *
 * @param[in]	conn	Pointer to the active connection.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_media_state_update(struct bt_conn *conn);

/**
 * @brief	Send a play command to the media player,
 *		depending on the current state.
 *
 * @param[in]	conn	Pointer to the connection to control; can be NULL.
 *
 * @note	If @p conn is NULL, play will be sent to all mcc_peers discovered.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_media_play(struct bt_conn *conn);

/**
 * @brief	Send a pause command to the media player,
 *		depending on the current state.
 *
 * @param[in]	conn	Pointer to the connection to control; can be NULL.
 *
 * @note	If @p conn is NULL, pause will be sent to all mcc_peers discovered.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_media_pause(struct bt_conn *conn);

/**
 * @brief	Reset the media control peer's discovered state
 *
 * @note	Only valid for client.
 *
 * @param[in]	conn	Pointer to the active connection.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_media_conn_disconnected(struct bt_conn *conn);

/**
 * @brief	Initialize the Media Control Client.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_media_client_init(void);

/**
 * @brief	Initialize the Media Control Server.
 *
 * @param[in]	play_pause_cb	Callback for received play/pause commands.
 *
 * @return	0 for success, error otherwise.
 */
int bt_content_ctrl_media_server_init(bt_content_ctrl_media_play_pause_cb play_pause_cb);

#endif /* _BT_CONTENT_CTRL_MEDIA_INTERNAL_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_content_control/media/Kconfig
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

menu "Media"

#----------------------------------------------------------------------------#
menu "Log level"

module = BT_CONTENT_CTRL_MEDIA
module-str = bt_content_ctrl_media
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log level
endmenu # Media


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_stream/CMakeLists.txt
#
# Copyright (c) 2023 Nordic Semiconductor
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

zephyr_library_include_directories(
    broadcast
    unicast
    bt_le_audio_tx
)

add_subdirectory(bt_le_audio_tx)

target_sources(app PRIVATE
		${CMAKE_CURRENT_SOURCE_DIR}/le_audio.c)

if (CONFIG_BT_BAP_BROADCAST_SINK)
	target_sources(app PRIVATE
			${CMAKE_CURRENT_SOURCE_DIR}/broadcast/broadcast_sink.c)
endif()

if (CONFIG_BT_BAP_BROADCAST_SOURCE)
	target_sources(app PRIVATE
			${CMAKE_CURRENT_SOURCE_DIR}/broadcast/broadcast_source.c)
endif()

if (CONFIG_BT_BAP_UNICAST_CLIENT)
	target_sources(app PRIVATE
			${CMAKE_CURRENT_SOURCE_DIR}/unicast/unicast_client.c)
endif()

if (CONFIG_BT_BAP_UNICAST_SERVER)
	target_sources(app PRIVATE
			${CMAKE_CURRENT_SOURCE_DIR}/unicast/unicast_server.c)
endif()


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_stream/le_audio.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _LE_AUDIO_H_
#define _LE_AUDIO_H_

#include <zephyr/bluetooth/audio/bap.h>
#include <audio_defines.h>

#define LE_AUDIO_ZBUS_EVENT_WAIT_TIME	  K_MSEC(5)
#define LE_AUDIO_SDU_SIZE_OCTETS(bitrate) (bitrate / (1000000 / CONFIG_AUDIO_FRAME_DURATION_US) / 8)

#if CONFIG_SAMPLE_RATE_CONVERTER
#define BT_AUDIO_CODEC_CAPABILIY_FREQ                                                              \
	BT_AUDIO_CODEC_LC3_FREQ_48KHZ | BT_AUDIO_CODEC_LC3_FREQ_24KHZ |                            \
		BT_AUDIO_CODEC_LC3_FREQ_16KHZ

#elif CONFIG_AUDIO_SAMPLE_RATE_16000_HZ
#define BT_AUDIO_CODEC_CAPABILIY_FREQ BT_AUDIO_CODEC_LC3_FREQ_16KHZ

#elif CONFIG_AUDIO_SAMPLE_RATE_24000_HZ
#define BT_AUDIO_CODEC_CAPABILIY_FREQ BT_AUDIO_CODEC_LC3_FREQ_24KHZ

#elif CONFIG_AUDIO_SAMPLE_RATE_48000_HZ
#define BT_AUDIO_CODEC_CAPABILIY_FREQ BT_AUDIO_CODEC_LC3_FREQ_48KHZ

#else
#error No sample rate supported
#endif /* CONFIG_SAMPLE_RATE_CONVERTER */

#define BT_BAP_LC3_PRESET_CONFIGURABLE(_loc, _stream_context, _bitrate)                            \
	BT_BAP_LC3_PRESET(                                                                         \
		BT_AUDIO_CODEC_LC3_CONFIG(CONFIG_BT_AUDIO_PREF_SAMPLE_RATE_VALUE,                  \
					  BT_AUDIO_CODEC_CONFIG_LC3_DURATION_10, _loc,             \
					  LE_AUDIO_SDU_SIZE_OCTETS(_bitrate), 1, _stream_context), \
		BT_AUDIO_CODEC_LC3_QOS_10_UNFRAMED(LE_AUDIO_SDU_SIZE_OCTETS(_bitrate),             \
						   CONFIG_BT_AUDIO_RETRANSMITS,                    \
						   CONFIG_BT_AUDIO_MAX_TRANSPORT_LATENCY_MS,       \
						   CONFIG_BT_AUDIO_PRESENTATION_DELAY_US))

/**
 * @brief Callback for receiving Bluetooth LE Audio data.
 *
 * @param	data		Pointer to received data.
 * @param	size		Size of received data.
 * @param	bad_frame	Indicating if the frame is a bad frame or not.
 * @param	sdu_ref		ISO timestamp.
 * @param	channel_index	Audio channel index.
 */
typedef void (*le_audio_receive_cb)(const uint8_t *const data, size_t size, bool bad_frame,
				    uint32_t sdu_ref, enum audio_channel channel_index,
				    size_t desired_size);

/**
 * @brief	Encoded audio data and information.
 *
 * @note	Container for SW codec (typically LC3) compressed audio data.
 */
struct le_audio_encoded_audio {
	uint8_t const *const data;
	size_t size;
	uint8_t num_ch;
};

/**
 * @brief	Check if an endpoint is in the given state.
 *		If the endpoint is NULL, it is not in the
 *		given state, and this function returns false.
 *
 * @param[in]	ep       The endpoint to check.
 * @param[in]	state    The state to check for.
 *
 * @retval	true	The endpoint is in the given state.
 * @retval	false	Otherwise.
 */
bool le_audio_ep_state_check(struct bt_bap_ep *ep, enum bt_bap_ep_state state);

/**
 * @brief	Decode the audio sampling frequency in the codec configuration.
 *
 * @param[in]	codec		The audio codec structure.
 * @param[out]	freq_hz		Pointer to the sampling frequency in Hz.
 *
 * @return	0 for success, error otherwise.
 */
int le_audio_freq_hz_get(const struct bt_audio_codec_cfg *codec, int *freq_hz);

/**
 * @brief	Decode the audio frame duration in us in the codec configuration.
 *
 * @param[in]	codec			The audio codec structure.
 * @param[out]	frame_dur_us	Pointer to the frame duration in us.
 *
 * @return	0 for success, error otherwise.
 */
int le_audio_duration_us_get(const struct bt_audio_codec_cfg *codec, int *frame_dur_us);

/**
 * @brief	Decode the number of octets per frame in the codec configuration.
 *
 * @param[in]	codec			The audio codec structure.
 * @param[out]	octets_per_sdu	Pointer to the number of octets per SDU.
 *
 * @return	0 for success, error otherwise.
 */
int le_audio_octets_per_frame_get(const struct bt_audio_codec_cfg *codec, uint32_t *octets_per_sdu);

/**
 * @brief	Decode the number of frame blocks per SDU in the codec configuration.
 *
 * @param[in]	codec				The audio codec structure.
 * @param[out]	frame_blks_per_sdu	Pointer to the number of frame blocks per SDU.
 *
 * @return	0 for success, error otherwise.
 */
int le_audio_frame_blocks_per_sdu_get(const struct bt_audio_codec_cfg *codec,
				      uint32_t *frame_blks_per_sdu);

/**
 * @brief	Get the bitrate for the codec configuration.
 *
 * @details	Decodes the audio frame duration and the number of octets per fram from the codec
 *		configuration, and calculates the bitrate.
 *
 * @param[in]	codec	The audio codec structure.
 * @param[out]	bitrate	Pointer to the bitrate in bps.
 */
int le_audio_bitrate_get(const struct bt_audio_codec_cfg *const codec, uint32_t *bitrate);

/**
 * @brief	Get the direction of the @p stream provided
 *
 * @param	stream	Stream to check direction for.
 *
 * @retval	BT_AUDIO_DIR_SINK	sink direction.
 * @retval	BT_AUDIO_DIR_SOURCE	source direction.
 * @retval	Negative value		Failed to get ep_info from host.
 *
 */
int le_audio_stream_dir_get(struct bt_bap_stream const *const stream);

#endif /* _LE_AUDIO_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_stream/le_audio.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "le_audio.h"

#include <zephyr/bluetooth/audio/bap.h>
#include <zephyr/bluetooth/audio/audio.h>

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(le_audio, CONFIG_BLE_LOG_LEVEL);

/*TODO: Create helper function in host to perform this action. */
bool le_audio_ep_state_check(struct bt_bap_ep *ep, enum bt_bap_ep_state state)
{
	int ret;
	struct bt_bap_ep_info ep_info;

	if (ep == NULL) {
		/* If an endpoint is NULL it is not in any of the states */
		return false;
	}

	ret = bt_bap_ep_get_info(ep, &ep_info);
	if (ret) {
		LOG_WRN("Unable to get info for ep");
		return false;
	}

	if (ep_info.state == state) {
		return true;
	}

	return false;
}

int le_audio_freq_hz_get(const struct bt_audio_codec_cfg *codec, int *freq_hz)
{
	int ret;

	ret = bt_audio_codec_cfg_get_freq(codec);
	if (ret < 0) {
		*freq_hz = 0;
		return ret;
	}

	ret = bt_audio_codec_cfg_freq_to_freq_hz(ret);
	if (ret < 0) {
		*freq_hz = 0;
		return ret;
	}

	*freq_hz = ret;

	return 0;
}

int le_audio_duration_us_get(const struct bt_audio_codec_cfg *codec, int *frame_dur_us)
{
	int ret;

	ret = bt_audio_codec_cfg_get_frame_dur(codec);
	if (ret < 0) {
		*frame_dur_us = 0;
		return ret;
	}

	ret = bt_audio_codec_cfg_frame_dur_to_frame_dur_us(ret);
	if (ret < 0) {
		*frame_dur_us = 0;
		return ret;
	}

	*frame_dur_us = ret;

	return 0;
}

int le_audio_octets_per_frame_get(const struct bt_audio_codec_cfg *codec, uint32_t *octets_per_sdu)
{
	int ret;

	ret = bt_audio_codec_cfg_get_octets_per_frame(codec);
	if (ret < 0) {
		*octets_per_sdu = 0;
		return ret;
	}

	*octets_per_sdu = ret;

	return 0;
}

int le_audio_frame_blocks_per_sdu_get(const struct bt_audio_codec_cfg *codec,
				      uint32_t *frame_blks_per_sdu)
{
	int ret;

	ret = bt_audio_codec_cfg_get_frame_blocks_per_sdu(codec, true);
	if (ret < 0) {
		*frame_blks_per_sdu = 0;
		return ret;
	}

	*frame_blks_per_sdu = ret;

	return 0;
}

int le_audio_bitrate_get(const struct bt_audio_codec_cfg *const codec, uint32_t *bitrate)
{
	int ret;
	int dur_us;

	ret = le_audio_duration_us_get(codec, &dur_us);
	if (ret) {
		*bitrate = 0;
		return ret;
	}

	int frames_per_sec = 1000000 / dur_us;
	int octets_per_sdu;

	ret = le_audio_octets_per_frame_get(codec, &octets_per_sdu);
	if (ret) {
		*bitrate = 0;
		return ret;
	}

	*bitrate = frames_per_sec * (octets_per_sdu * 8);

	return 0;
}

int le_audio_stream_dir_get(struct bt_bap_stream const *const stream)
{
	int ret;
	struct bt_bap_ep_info ep_info;

	ret = bt_bap_ep_get_info(stream->ep, &ep_info);

	if (ret) {
		LOG_WRN("Failed to get ep_info");
		return ret;
	}

	return ep_info.dir;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_stream/unicast/Kconfig.defaults
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

config BT_GATT_CLIENT
	default y

config BT_BONDABLE
	default y

config BT_PRIVACY
	default y

config BT_FILTER_ACCEPT_LIST
	default y

config BT_SMP
	default y

config BT_GAP_AUTO_UPDATE_CONN_PARAMS
	default n

config BT_AUTO_PHY_UPDATE
	default n

config BT_AUTO_DATA_LEN_UPDATE
	default n

config BT_L2CAP_TX_BUF_COUNT
	default 12

config BT_BUF_ACL_RX_SIZE
	default 502 if (AUDIO_DFU > 0)
	default 259

config SETTINGS
	default y

config BT_SETTINGS
	default y

config FLASH
	default y

config FLASH_MAP
	default y

config NVS
	default y

config NVS_LOG_LEVEL
	default 2


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_stream/unicast/unicast_client.c
/*
 * Copyright (c) 2022 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "unicast_client.h"

#include <zephyr/sys/byteorder.h>
#include <zephyr/zbus/zbus.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/sys/byteorder.h>
#include <zephyr/bluetooth/conn.h>
#include <zephyr/bluetooth/audio/audio.h>
#include <zephyr/bluetooth/audio/pacs.h>
#include <zephyr/bluetooth/audio/csip.h>
#include <zephyr/bluetooth/audio/cap.h>
#include <zephyr/bluetooth/audio/bap.h>
#include <zephyr/bluetooth/audio/bap_lc3_preset.h>
#include <../subsys/bluetooth/audio/bap_iso.h>

/* TODO: Remove when a get_info function is implemented in host */
#include <../subsys/bluetooth/audio/bap_endpoint.h>

#include "macros_common.h"
#include "nrf5340_audio_common.h"
#include "bt_le_audio_tx.h"
#include "le_audio.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(unicast_client, CONFIG_UNICAST_CLIENT_LOG_LEVEL);

ZBUS_CHAN_DEFINE(le_audio_chan, struct le_audio_msg, NULL, NULL, ZBUS_OBSERVERS_EMPTY,
		 ZBUS_MSG_INIT(0));

#define HCI_ISO_BUF_ALLOC_PER_CHAN 2
#define CIS_CONN_RETRY_TIMES	   5
#define CIS_CONN_RETRY_DELAY_MS	   500

struct le_audio_headset {
	char *ch_name;
	uint8_t num_sink_eps;
	uint8_t num_source_eps;
	struct bt_bap_stream sink_stream;
	bool waiting_for_sink_disc;
	struct bt_bap_ep *sink_ep;
	struct bt_audio_codec_cap sink_codec_cap[CONFIG_CODEC_CAP_COUNT_MAX];
	struct bt_bap_stream source_stream;
	bool waiting_for_source_disc;
	struct bt_bap_ep *source_ep;
	struct bt_audio_codec_cap source_codec_cap[CONFIG_CODEC_CAP_COUNT_MAX];
	struct bt_conn *headset_conn;
	struct k_work_delayable stream_start_sink_work;
	struct k_work_delayable stream_start_source_work;
	bool qos_reconfigure;
	uint32_t reconfigure_pd;
};

struct discover_dir {
	struct bt_conn *conn;
	bool source;
	bool sink;
};

struct worker_data {
	uint8_t channel_index;
	enum bt_audio_dir dir;
	uint8_t retries;
} __aligned(4);

struct temp_cap_storage {
	struct bt_conn *conn;
	uint8_t num_caps;
	/* Must be the same size as sink_codec_cap and source_codec_cap */
	struct bt_audio_codec_cap codec[CONFIG_CODEC_CAP_COUNT_MAX];
};

static struct le_audio_headset headsets[CONFIG_BT_MAX_CONN];
static struct discover_dir discover_list[CONFIG_BT_MAX_CONN];

K_MSGQ_DEFINE(kwork_msgq, sizeof(struct worker_data),
	      2 * (CONFIG_BT_BAP_UNICAST_CLIENT_ASE_SNK_COUNT +
		   CONFIG_BT_BAP_UNICAST_CLIENT_ASE_SRC_COUNT),
	      sizeof(uint32_t));

static struct temp_cap_storage temp_cap[CONFIG_BT_MAX_CONN];

/* Make sure that we have at least one headset device per CONFIG_BT_BAP_UNICAST_CLIENT_ASE_SNK */
BUILD_ASSERT(ARRAY_SIZE(headsets) >= CONFIG_BT_BAP_UNICAST_CLIENT_ASE_SNK_COUNT,
	     "We need to have at least one headset device per ASE SINK");

/* Make sure that we have at least one headset device per CONFIG_BT_BAP_UNICAST_CLIENT_ASE_SRC */
BUILD_ASSERT(ARRAY_SIZE(headsets) >= CONFIG_BT_BAP_UNICAST_CLIENT_ASE_SRC_COUNT,
	     "We need to have at least one headset device per ASE SOURCE");

static le_audio_receive_cb receive_cb;

static struct bt_bap_unicast_group *unicast_group;

/* Used for group creation only */
static struct bt_bap_lc3_preset lc3_preset_max = BT_BAP_LC3_PRESET_CONFIGURABLE(
	BT_AUDIO_LOCATION_FRONT_LEFT, BT_AUDIO_CONTEXT_TYPE_MEDIA, CONFIG_LC3_BITRATE_MAX);

static struct bt_bap_lc3_preset lc3_preset_sink = BT_BAP_LC3_UNICAST_PRESET_NRF5340_AUDIO_SINK;
static struct bt_bap_lc3_preset lc3_preset_sink_48_4_1 =
	BT_BAP_LC3_UNICAST_PRESET_48_4_1(BT_AUDIO_LOCATION_ANY, (BT_AUDIO_CONTEXT_TYPE_MEDIA));
static struct bt_bap_lc3_preset lc3_preset_sink_24_2_1 =
	BT_BAP_LC3_UNICAST_PRESET_24_2_1(BT_AUDIO_LOCATION_ANY, (BT_AUDIO_CONTEXT_TYPE_MEDIA));
static struct bt_bap_lc3_preset lc3_preset_sink_16_2_1 =
	BT_BAP_LC3_UNICAST_PRESET_16_2_1(BT_AUDIO_LOCATION_ANY, (BT_AUDIO_CONTEXT_TYPE_MEDIA));

static struct bt_bap_lc3_preset lc3_preset_source = BT_BAP_LC3_UNICAST_PRESET_NRF5340_AUDIO_SOURCE;
static struct bt_bap_lc3_preset lc3_preset_source_48_4_1 =
	BT_BAP_LC3_UNICAST_PRESET_48_4_1(BT_AUDIO_LOCATION_ANY, BT_AUDIO_CONTEXT_TYPE_MEDIA);
static struct bt_bap_lc3_preset lc3_preset_source_24_2_1 =
	BT_BAP_LC3_UNICAST_PRESET_24_2_1(BT_AUDIO_LOCATION_ANY, BT_AUDIO_CONTEXT_TYPE_MEDIA);
static struct bt_bap_lc3_preset lc3_preset_source_16_2_1 =
	BT_BAP_LC3_UNICAST_PRESET_16_2_1(BT_AUDIO_LOCATION_ANY, BT_AUDIO_CONTEXT_TYPE_MEDIA);

static bool playing_state = true;

static void le_audio_event_publish(enum le_audio_evt_type event, struct bt_conn *conn,
				   enum bt_audio_dir dir)
{
	int ret;
	struct le_audio_msg msg;

	msg.event = event;
	msg.conn = conn;
	msg.dir = dir;

	ret = zbus_chan_pub(&le_audio_chan, &msg, LE_AUDIO_ZBUS_EVENT_WAIT_TIME);
	ERR_CHK(ret);
}

/**
 * @brief	Add a conn pointer to the discover list.
 *
 * @param[in]	conn	Pointer to the connection to add.
 * @param[in]	dir	Directions to do discovery for.
 *
 * @retval	-ENOMEM	No more space for connections.
 * @retval	0	Successfully added connection.
 */
static int discover_list_add(struct bt_conn *conn, enum unicast_discover_dir dir)
{
	if (!(dir & BT_AUDIO_DIR_SOURCE) && !(dir & BT_AUDIO_DIR_SINK)) {
		LOG_ERR("No direction is set for the discover list entry");
		return -EINVAL;
	}

	/* Check if conn is already in the list */
	for (int i = 0; i < ARRAY_SIZE(discover_list); i++) {
		if (discover_list[i].conn == conn) {
			discover_list[i].source = false;
			discover_list[i].sink = false;

			if (dir & BT_AUDIO_DIR_SOURCE) {
				discover_list[i].source = true;
			}

			if (dir & BT_AUDIO_DIR_SINK) {
				discover_list[i].sink = true;
			}

			return 0;
		}
	}

	/* If not already in the list, add to list if there is room */
	for (int i = 0; i < ARRAY_SIZE(discover_list); i++) {
		if (discover_list[i].conn == NULL) {
			discover_list[i].conn = conn;

			if (dir & BT_AUDIO_DIR_SOURCE) {
				discover_list[i].source = true;
			}

			if (dir & BT_AUDIO_DIR_SINK) {
				discover_list[i].sink = true;
			}

			return 0;
		}
	}

	return -ENOMEM;
}

/**
 * @brief	Remove a conn pointer from the discover list.
 *
 * @param[in]	conn	Pointer to the connection to remove.
 *
 * @retval	-EINVAL	No such connection found.
 * @retval	0	Successfully removed connection.
 */
static int discover_list_remove(struct bt_conn const *const conn)
{
	for (int i = 0; i < ARRAY_SIZE(discover_list); i++) {
		if (discover_list[i].conn == conn) {
			discover_list[i].conn = NULL;
			discover_list[i].sink = false;
			discover_list[i].source = false;

			return 0;
		}
	}

	return -EINVAL;
}

/**
 * @brief	Get discover_list index for given @p conn.
 *
 * @param[in]	conn	Pointer to the connection.
 *
 * @return	-ESRCH if @p conn not found, index otherwise.
 */
static int discover_list_index_get(struct bt_conn const *const conn)
{
	for (int i = 0; i < ARRAY_SIZE(discover_list); i++) {
		if (conn == discover_list[i].conn) {
			return i;
		}
	}

	return -ESRCH;
}

/**
 * @brief  Get the common presentation delay for all headsets.
 *
 * @param[in]	index		The index of the headset to test against.
 * @param[out]	pres_dly_us	Pointer to where the presentation delay will be stored.
 *
 * @retval	0	Operation successful.
 * @retval	-EINVAL	Any error.
 */
static int headset_pres_delay_find(uint8_t index, uint32_t *pres_dly_us)
{
	uint32_t pres_dly_min = headsets[index].sink_ep->qos_pref.pd_min;
	uint32_t pres_dly_max = headsets[index].sink_ep->qos_pref.pd_max;
	uint32_t pref_dly_min = headsets[index].sink_ep->qos_pref.pref_pd_min;
	uint32_t pref_dly_max = headsets[index].sink_ep->qos_pref.pref_pd_max;

	LOG_DBG("Index: %d, Pref min: %d, pref max: %d, pres_min: %d, pres_max: %d", index,
		pref_dly_min, pref_dly_max, pres_dly_min, pres_dly_max);

	for (int i = 0; i < ARRAY_SIZE(headsets); i++) {
		if (headsets[i].sink_ep != NULL) {
			pres_dly_min = MAX(pres_dly_min, headsets[i].sink_ep->qos_pref.pd_min);
			pres_dly_max = MIN(pres_dly_max, headsets[i].sink_ep->qos_pref.pd_max);
			pref_dly_min = MAX(pref_dly_min, headsets[i].sink_ep->qos_pref.pref_pd_min);
			pref_dly_max = MIN(pref_dly_max, headsets[i].sink_ep->qos_pref.pref_pd_max);
		}
	}

	if (IS_ENABLED(CONFIG_BT_AUDIO_PRES_DELAY_SRCH_MIN)) {
		*pres_dly_us = pres_dly_min;

		return 0;
	}

	if (IS_ENABLED(CONFIG_BT_AUDIO_PRES_DELAY_SRCH_MAX)) {
		*pres_dly_us = pres_dly_max;

		return 0;
	}

	if (IS_ENABLED(CONFIG_BT_AUDIO_PRES_DELAY_SRCH_PREF_MIN)) {
		/* Preferred min is 0, so we set min supported */
		if (pref_dly_min == 0) {
			*pres_dly_us = pres_dly_min;
		} else {
			*pres_dly_us = pref_dly_min;
		}

		return 0;
	}

	if (IS_ENABLED(CONFIG_BT_AUDIO_PRES_DELAY_SRCH_PREF_MAX)) {
		/* Preferred max is 0, so we set max supported */
		if (pref_dly_max == 0) {
			*pres_dly_us = pres_dly_max;
		} else {
			*pres_dly_us = pref_dly_max;
		}

		return 0;
	}

	LOG_ERR("Trying to use unrecognized search mode");

	return -EINVAL;
}

/**
 * @brief	Get channel index based on connection.
 *
 * @param[in]	conn	The connection to search for.
 * @param[out]	index	The channel index.
 *
 * @retval	0	Operation successful.
 * @retval	-EINVAL	There is no match.
 */
static int channel_index_get(const struct bt_conn *conn, uint8_t *index)
{
	if (conn == NULL) {
		LOG_ERR("No connection provided");
		return -EINVAL;
	}

	for (int i = 0; i < ARRAY_SIZE(headsets); i++) {
		if (headsets[i].headset_conn == conn) {
			*index = i;
			return 0;
		}
	}

	LOG_WRN("Connection not found");

	return -EINVAL;
}

static void supported_sample_rates_print(uint16_t supported_sample_rates, enum bt_audio_dir dir)
{
	char supported_str[20] = "";

	if (supported_sample_rates & BT_AUDIO_CODEC_LC3_FREQ_48KHZ) {
		strcat(supported_str, "48, ");
	}

	if (supported_sample_rates & BT_AUDIO_CODEC_LC3_FREQ_24KHZ) {
		strcat(supported_str, "24, ");
	}

	if (supported_sample_rates & BT_AUDIO_CODEC_LC3_FREQ_16KHZ) {
		strcat(supported_str, "16, ");
	}

	if (dir == BT_AUDIO_DIR_SINK) {
		LOG_DBG("Headset supports: %s kHz in sink direction", supported_str);
	} else if (dir == BT_AUDIO_DIR_SOURCE) {
		LOG_DBG("Headset supports: %s kHz in source direction", supported_str);
	}
}

static bool sink_parse_cb(struct bt_data *data, void *user_data)
{
	if (data->type == BT_AUDIO_CODEC_LC3_FREQ) {
		uint16_t lc3_freq_bit = sys_get_le16(data->data);

		supported_sample_rates_print(lc3_freq_bit, BT_AUDIO_DIR_SINK);

		/* Try with the preferred sample rate first */
		switch (CONFIG_BT_AUDIO_PREF_SAMPLE_RATE_VALUE) {
		case BT_AUDIO_CODEC_CONFIG_LC3_FREQ_48KHZ:
			if (lc3_freq_bit & BT_AUDIO_CODEC_LC3_FREQ_48KHZ) {
				lc3_preset_sink = lc3_preset_sink_48_4_1;
				*(bool *)user_data = true;
				/* Found what we were looking for, stop parsing LTV */
				return false;
			}

			break;

		case BT_AUDIO_CODEC_CONFIG_LC3_FREQ_24KHZ:
			if (lc3_freq_bit & BT_AUDIO_CODEC_LC3_FREQ_24KHZ) {
				lc3_preset_sink = lc3_preset_sink_24_2_1;
				*(bool *)user_data = true;
				/* Found what we were looking for, stop parsing LTV */
				return false;
			}

			break;

		case BT_AUDIO_CODEC_CONFIG_LC3_FREQ_16KHZ:
			if (lc3_freq_bit & BT_AUDIO_CODEC_LC3_FREQ_16KHZ) {
				lc3_preset_sink = lc3_preset_sink_16_2_1;
				*(bool *)user_data = true;
				/* Found what we were looking for, stop parsing LTV */
				return false;
			}

			break;
		}

		/* If no match with the preferred, revert to trying highest first */
		if (lc3_freq_bit & BT_AUDIO_CODEC_LC3_FREQ_48KHZ) {
			lc3_preset_sink = lc3_preset_sink_48_4_1;
			*(bool *)user_data = true;
		} else if (lc3_freq_bit & BT_AUDIO_CODEC_LC3_FREQ_24KHZ) {
			lc3_preset_sink = lc3_preset_sink_24_2_1;
			*(bool *)user_data = true;
		} else if (lc3_freq_bit & BT_AUDIO_CODEC_LC3_FREQ_16KHZ) {
			lc3_preset_sink = lc3_preset_sink_16_2_1;
			*(bool *)user_data = true;
		}

		/* Found what we were looking for, stop parsing LTV */
		return false;
	}

	/* Did not find what we were looking for, continue parsing LTV */
	return true;
}

static bool source_parse_cb(struct bt_data *data, void *user_data)
{
	if (data->type == BT_AUDIO_CODEC_LC3_FREQ) {
		uint16_t lc3_freq_bit = sys_get_le16(data->data);

		supported_sample_rates_print(lc3_freq_bit, BT_AUDIO_DIR_SOURCE);

		/* Try with the preferred sample rate first */
		switch (CONFIG_BT_AUDIO_PREF_SAMPLE_RATE_VALUE) {
		case BT_AUDIO_CODEC_CONFIG_LC3_FREQ_48KHZ:
			if (lc3_freq_bit & BT_AUDIO_CODEC_LC3_FREQ_48KHZ) {
				lc3_preset_source = lc3_preset_source_48_4_1;
				*(bool *)user_data = true;
				/* Found what we were looking for, stop parsing LTV */
				return false;
			}

			break;

		case BT_AUDIO_CODEC_CONFIG_LC3_FREQ_24KHZ:
			if (lc3_freq_bit & BT_AUDIO_CODEC_LC3_FREQ_24KHZ) {
				lc3_preset_source = lc3_preset_source_24_2_1;
				*(bool *)user_data = true;
				/* Found what we were looking for, stop parsing LTV */
				return false;
			}

			break;

		case BT_AUDIO_CODEC_CONFIG_LC3_FREQ_16KHZ:
			if (lc3_freq_bit & BT_AUDIO_CODEC_LC3_FREQ_16KHZ) {
				lc3_preset_source = lc3_preset_source_16_2_1;
				*(bool *)user_data = true;
				/* Found what we were looking for, stop parsing LTV */
				return false;
			}

			break;
		}

		/* If no match with the preferred, revert to trying highest first */
		if (lc3_freq_bit & BT_AUDIO_CODEC_LC3_FREQ_48KHZ) {
			lc3_preset_source = lc3_preset_source_48_4_1;
			*(bool *)user_data = true;
		} else if (lc3_freq_bit & BT_AUDIO_CODEC_LC3_FREQ_24KHZ) {
			lc3_preset_source = lc3_preset_source_24_2_1;
			*(bool *)user_data = true;
		} else if (lc3_freq_bit & BT_AUDIO_CODEC_LC3_FREQ_16KHZ) {
			lc3_preset_source = lc3_preset_source_16_2_1;
			*(bool *)user_data = true;
		}

		/* Found what we were looking for, stop parsing LTV */
		return false;
	}

	/* Did not find what we were looking for, continue parsing LTV */
	return true;
}

/**
 * @brief	Check if the gateway can support the headset codec capabilities.
 *
 * @note	Currently only the sampling frequency is checked.
 *
 * @param[in]	cap_array	The array of pointers to codec capabilities.
 * @param[in]	num_caps	The size of cap_array.
 * @param[in]	dir		Direction of the capabilities to check.
 *
 * @return	True if valid codec capability found, false otherwise.
 */
static bool valid_codec_cap_check(struct bt_audio_codec_cap cap_array[], uint8_t num_caps,
				  enum bt_audio_dir dir)
{
	bool valid_result = false;

	/* Only the sampling frequency is checked */
	if (dir == BT_AUDIO_DIR_SINK) {
		for (int i = 0; i < num_caps; i++) {
			(void)bt_audio_data_parse(cap_array[i].data, cap_array[i].data_len,
						  sink_parse_cb, &valid_result);
		}
	} else if (dir == BT_AUDIO_DIR_SOURCE) {
		for (int i = 0; i < num_caps; i++) {
			(void)bt_audio_data_parse(cap_array[i].data, cap_array[i].data_len,
						  source_parse_cb, &valid_result);
		}
	}

	return valid_result;
}

/**
 * @brief Set the allocation to a preset codec configuration.
 *
 * @param codec The preset codec configuration.
 * @param loc   Location bitmask setting.
 *
 */
static void bt_audio_codec_allocation_set(struct bt_audio_codec_cfg *codec_cfg,
					  enum bt_audio_location loc)
{
	for (size_t i = 0U; i < codec_cfg->data_len;) {
		const uint8_t len = codec_cfg->data[i++];
		const uint8_t type = codec_cfg->data[i++];
		uint8_t *value = &codec_cfg->data[i];
		const uint8_t value_len = len - sizeof(type);

		if (type == BT_AUDIO_CODEC_CONFIG_LC3_CHAN_ALLOC) {
			const uint32_t loc_32 = loc;

			sys_put_le32(loc_32, value);

			return;
		}
		i += value_len;
	}
}

static int update_sink_stream_qos(struct le_audio_headset *headset, uint32_t pres_delay_us)
{
	int ret;

	if (headset->sink_stream.ep == NULL) {
		return -ESRCH;
	}

	if (headset->sink_stream.qos == NULL) {
		LOG_WRN("No QoS found for %p", &headset->sink_stream);
		return -ENXIO;
	}

	if (headset->sink_stream.qos->pd != pres_delay_us) {
		if (playing_state &&
		    le_audio_ep_state_check(headset->sink_stream.ep, BT_BAP_EP_STATE_STREAMING)) {
			LOG_DBG("Update streaming %s headset, connection %p, stream %p",
				headset->ch_name, &headset->headset_conn, &headset->sink_stream);

			headset->qos_reconfigure = true;
			headset->reconfigure_pd = pres_delay_us;

			ret = bt_bap_stream_disable(&headset->sink_stream);
			if (ret) {
				LOG_ERR("Unable to disable stream: %d", ret);
				return ret;
			}
		} else {
			LOG_DBG("Reset %s headset, connection %p, stream %p", headset->ch_name,
				&headset->headset_conn, &headset->sink_stream);

			headset->sink_stream.qos->pd = pres_delay_us;

			ret = bt_bap_stream_qos(headset->headset_conn, unicast_group);
			if (ret && ret != -EINVAL) {
				/* ret == -EINVAL means that the stream is not ready to
				 * be configured yet
				 */
				LOG_ERR("Unable to configure %s headset: %d", headset->ch_name,
					ret);
				return ret;
			}
		}
	}

	return 0;
}

static void unicast_client_location_cb(struct bt_conn *conn, enum bt_audio_dir dir,
				       enum bt_audio_location loc)
{
	int index = discover_list_index_get(conn);

	if (index < 0) {
		LOG_WRN("Failed to get discover_list index");
		return;
	}

	if ((loc & BT_AUDIO_LOCATION_FRONT_LEFT) || (loc & BT_AUDIO_LOCATION_SIDE_LEFT)) {
		if (headsets[AUDIO_CH_L].headset_conn == NULL) {
			headsets[AUDIO_CH_L].headset_conn = conn;
			headsets[AUDIO_CH_L].waiting_for_sink_disc = discover_list[index].sink;
			headsets[AUDIO_CH_L].waiting_for_source_disc = discover_list[index].source;
		}

	} else if ((loc & BT_AUDIO_LOCATION_FRONT_RIGHT) || (loc & BT_AUDIO_LOCATION_SIDE_RIGHT)) {
		if (headsets[AUDIO_CH_R].headset_conn == NULL) {
			headsets[AUDIO_CH_R].headset_conn = conn;
			headsets[AUDIO_CH_R].waiting_for_sink_disc = discover_list[index].sink;
			headsets[AUDIO_CH_R].waiting_for_source_disc = discover_list[index].source;
		}
	} else {
		LOG_WRN("Channel location not supported");
		le_audio_event_publish(LE_AUDIO_EVT_NO_VALID_CFG, conn, dir);
	}
}

static void available_contexts_cb(struct bt_conn *conn, enum bt_audio_context snk_ctx,
				  enum bt_audio_context src_ctx)
{
	char addr[BT_ADDR_LE_STR_LEN];

	(void)bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));

	LOG_DBG("conn: %s, snk ctx %d src ctx %d", addr, snk_ctx, src_ctx);
}

static int temp_cap_index_get(struct bt_conn *conn, uint8_t *index)
{
	if (conn == NULL) {
		LOG_ERR("No conn provided");
		return -EINVAL;
	}

	for (int i = 0; i < ARRAY_SIZE(temp_cap); i++) {
		if (temp_cap[i].conn == conn) {
			*index = i;
			return 0;
		}
	}

	/* Connection not found in temp_cap, searching for empty slot */
	for (int i = 0; i < ARRAY_SIZE(temp_cap); i++) {
		if (temp_cap[i].conn == NULL) {
			temp_cap[i].conn = conn;
			*index = i;
			return 0;
		}
	}

	LOG_WRN("No more space in temp_cap");

	return -ECANCELED;
}

static void pac_record_cb(struct bt_conn *conn, enum bt_audio_dir dir,
			  const struct bt_audio_codec_cap *codec)
{
	int ret;
	uint8_t temp_cap_index;

	ret = temp_cap_index_get(conn, &temp_cap_index);
	if (ret) {
		LOG_ERR("Could not get temporary CAP storage index");
		return;
	}

	if (codec->id != BT_HCI_CODING_FORMAT_LC3) {
		LOG_DBG("Only the LC3 codec is supported");
		return;
	}

	/* num_caps is an increasing index that starts at 0 */
	if (temp_cap[temp_cap_index].num_caps < ARRAY_SIZE(temp_cap[temp_cap_index].codec)) {
		struct bt_audio_codec_cap *codec_loc =
			&temp_cap[temp_cap_index].codec[temp_cap[temp_cap_index].num_caps];

		memcpy(codec_loc, codec, sizeof(struct bt_audio_codec_cap));

		temp_cap[temp_cap_index].num_caps++;
	} else {
		LOG_WRN("No more space. Increase CODEC_CAPAB_COUNT_MAX");
	}
}

static void endpoint_cb(struct bt_conn *conn, enum bt_audio_dir dir, struct bt_bap_ep *ep)
{
	int ret;
	uint8_t channel_index = 0;

	ret = channel_index_get(conn, &channel_index);
	if (ret) {
		LOG_ERR("Unknown connection, should not reach here");
		return;
	}

	if (dir == BT_AUDIO_DIR_SINK) {
		if (ep != NULL) {
			if (headsets[channel_index].num_sink_eps > 0) {
				LOG_WRN("More than one sink endpoint found, idx 0 is used "
					"by default");
				return;
			}

			headsets[channel_index].sink_ep = ep;
			headsets[channel_index].num_sink_eps++;
			return;
		}

		if (headsets[channel_index].sink_ep == NULL) {
			LOG_WRN("No sink endpoints found");
		}

		return;
	} else if (dir == BT_AUDIO_DIR_SOURCE) {
		if (ep != NULL) {
			if (headsets[channel_index].num_source_eps > 0) {
				LOG_WRN("More than one source endpoint found, idx 0 is "
					"used by default");
				return;
			}

			headsets[channel_index].source_ep = ep;
			headsets[channel_index].num_source_eps++;
			return;
		}

		if (headsets[channel_index].source_ep == NULL) {
			LOG_WRN("No source endpoints found");
		}

		return;
	} else {
		LOG_WRN("Endpoint direction not recognized: %d", dir);
	}
}

static void discover_cb(struct bt_conn *conn, int err, enum bt_audio_dir dir)
{
	int ret;
	uint8_t channel_index;
	uint8_t temp_cap_index;

	ret = channel_index_get(conn, &channel_index);
	if (ret) {
		LOG_ERR("Unknown connection, should not reach here");
		return;
	}

	if (err == BT_ATT_ERR_ATTRIBUTE_NOT_FOUND) {
		if (dir == BT_AUDIO_DIR_SINK) {
			LOG_WRN("No sinks found");
			headsets[channel_index].waiting_for_sink_disc = false;
		} else if (dir == BT_AUDIO_DIR_SOURCE) {
			LOG_WRN("No sources found");
			headsets[channel_index].waiting_for_source_disc = false;
			/**
			 * We usually wait until both sink and source has been discovered
			 * before configuring, but since no source was found and we have a
			 * sink, we need to configure that.
			 */
			if (headsets[channel_index].sink_ep != NULL) {
				ret = bt_bap_stream_config(conn,
							   &headsets[channel_index].sink_stream,
							   headsets[channel_index].sink_ep,
							   &lc3_preset_sink.codec_cfg);
				if (ret) {
					LOG_ERR("Could not configure sink stream, ret = %d", ret);
				}
			}
		}

		return;
	} else if (err) {
		LOG_ERR("Discovery failed: %d", err);
		return;
	}

	ret = temp_cap_index_get(conn, &temp_cap_index);
	if (ret) {
		LOG_ERR("Could not get temporary CAP storage index");
		return;
	}

	for (int i = 0; i < CONFIG_CODEC_CAP_COUNT_MAX; i++) {
		if (dir == BT_AUDIO_DIR_SINK) {
			memcpy(&headsets[channel_index].sink_codec_cap[i],
			       &temp_cap[temp_cap_index].codec[i],
			       sizeof(struct bt_audio_codec_cap));
		} else if (dir == BT_AUDIO_DIR_SOURCE) {
			memcpy(&headsets[channel_index].source_codec_cap[i],
			       &temp_cap[temp_cap_index].codec[i],
			       sizeof(struct bt_audio_codec_cap));
		}
	}

	if (dir == BT_AUDIO_DIR_SINK) {
		if (valid_codec_cap_check(headsets[channel_index].sink_codec_cap,
					  temp_cap[temp_cap_index].num_caps, BT_AUDIO_DIR_SINK)) {
			if (conn == headsets[AUDIO_CH_L].headset_conn) {
				bt_audio_codec_allocation_set(&lc3_preset_sink.codec_cfg,
							      BT_AUDIO_LOCATION_FRONT_LEFT);
			} else if (conn == headsets[AUDIO_CH_R].headset_conn) {
				bt_audio_codec_allocation_set(&lc3_preset_sink.codec_cfg,
							      BT_AUDIO_LOCATION_FRONT_RIGHT);
			} else {
				LOG_ERR("Unknown connection, cannot set allocation");
			}
		} else {
			/* NOTE: The string below is used by the Nordic CI system */
			LOG_WRN("No valid codec capability found for %s headset sink",
				headsets[channel_index].ch_name);
			headsets[channel_index].sink_ep = NULL;
		}
	} else if (dir == BT_AUDIO_DIR_SOURCE) {
		if (valid_codec_cap_check(headsets[channel_index].source_codec_cap,
					  temp_cap[temp_cap_index].num_caps, BT_AUDIO_DIR_SOURCE)) {
			if (conn == headsets[AUDIO_CH_L].headset_conn) {
				bt_audio_codec_allocation_set(&lc3_preset_source.codec_cfg,
							      BT_AUDIO_LOCATION_FRONT_LEFT);
			} else if (conn == headsets[AUDIO_CH_R].headset_conn) {
				bt_audio_codec_allocation_set(&lc3_preset_source.codec_cfg,
							      BT_AUDIO_LOCATION_FRONT_RIGHT);
			} else {
				LOG_ERR("Unknown connection, cannot set allocation");
			}
		} else {
			LOG_WRN("No valid codec capability found for %s headset source",
				headsets[channel_index].ch_name);
			headsets[channel_index].source_ep = NULL;
		}
	}

	/* Free up the slot in temp_cap */
	memset(temp_cap[temp_cap_index].codec, 0, sizeof(temp_cap[temp_cap_index].codec));
	temp_cap[temp_cap_index].conn = NULL;
	temp_cap[temp_cap_index].num_caps = 0;

	if (dir == BT_AUDIO_DIR_SINK) {
		headsets[channel_index].waiting_for_sink_disc = false;

		if (headsets[channel_index].waiting_for_source_disc) {
			ret = bt_bap_unicast_client_discover(conn, BT_AUDIO_DIR_SOURCE);
			if (ret) {
				LOG_WRN("Failed to discover source: %d", ret);
			}

			return;
		}
	} else if (dir == BT_AUDIO_DIR_SOURCE) {
		headsets[channel_index].waiting_for_source_disc = false;
	}

	if (headsets[channel_index].sink_ep) {
		ret = bt_bap_stream_config(conn, &headsets[channel_index].sink_stream,
					   headsets[channel_index].sink_ep,
					   &lc3_preset_sink.codec_cfg);
		if (ret) {
			LOG_ERR("Could not configure sink stream, ret = %d", ret);
		}
	}

	if (headsets[channel_index].source_ep) {
		ret = bt_bap_stream_config(conn, &headsets[channel_index].source_stream,
					   headsets[channel_index].source_ep,
					   &lc3_preset_source.codec_cfg);
		if (ret) {
			LOG_ERR("Could not configure source stream, ret = %d", ret);
		}
	}
}

static struct bt_bap_unicast_client_cb unicast_client_cbs = {
	.location = unicast_client_location_cb,
	.available_contexts = available_contexts_cb,
	.pac_record = pac_record_cb,
	.endpoint = endpoint_cb,
	.discover = discover_cb,
};

static void stream_sent_cb(struct bt_bap_stream *stream)
{
	int ret;
	uint8_t channel_index;

	if (le_audio_ep_state_check(stream->ep, BT_BAP_EP_STATE_STREAMING)) {

		ret = channel_index_get(stream->conn, &channel_index);
		if (ret) {
			LOG_ERR("Channel index not found");
		} else {
			ERR_CHK(bt_le_audio_tx_stream_sent(channel_index));
		}
	} else {
		LOG_WRN("Not in streaming state");
	}
}

static void stream_configured_cb(struct bt_bap_stream *stream,
				 const struct bt_audio_codec_qos_pref *pref)
{
	int ret;
	uint8_t channel_index;
	uint32_t new_pres_dly_us;

	ret = channel_index_get(stream->conn, &channel_index);
	if (ret) {
		LOG_ERR("Channel index not found");
		return;
	}

	if (stream->ep->dir == BT_AUDIO_DIR_SINK) {
		/* NOTE: The string below is used by the Nordic CI system */
		LOG_INF("%s sink stream configured", headsets[channel_index].ch_name);
	} else if (stream->ep->dir == BT_AUDIO_DIR_SOURCE) {
		LOG_INF("%s source stream configured", headsets[channel_index].ch_name);
	} else {
		LOG_WRN("Endpoint direction not recognized: %d", stream->ep->dir);
		return;
	}
	LOG_DBG("Configured Stream info: %s, %p, dir %d", headsets[channel_index].ch_name,
		(void *)stream, stream->ep->dir);

	ret = headset_pres_delay_find(channel_index, &new_pres_dly_us);
	if (ret) {
		LOG_ERR("Cannot get a valid presentation delay");
		return;
	}

	if (headsets[channel_index].waiting_for_source_disc) {
		return;
	}

	if (le_audio_ep_state_check(headsets[channel_index].sink_stream.ep,
				    BT_BAP_EP_STATE_CODEC_CONFIGURED)) {
		for (int i = 0; i < ARRAY_SIZE(headsets); i++) {
			if (i != channel_index && headsets[i].headset_conn != NULL) {
				ret = update_sink_stream_qos(&headsets[i], new_pres_dly_us);
				if (ret && ret != -ESRCH) {
					LOG_ERR("Presentation delay not set for %s "
						"headset: %d",
						headsets[channel_index].ch_name, ret);
				}
			}
		}

		LOG_DBG("Set %s headset, connection %p, stream %p", headsets[channel_index].ch_name,
			&headsets[channel_index].headset_conn,
			&headsets[channel_index].sink_stream);

		headsets[channel_index].sink_stream.qos->pd = new_pres_dly_us;
	}

	le_audio_event_publish(LE_AUDIO_EVT_CONFIG_RECEIVED, stream->conn, stream->ep->dir);

	/* Make sure both sink and source ep (if both are discovered) are configured before
	 * QoS
	 */
	if ((headsets[channel_index].sink_ep != NULL &&
	     !le_audio_ep_state_check(headsets[channel_index].sink_stream.ep,
				      BT_BAP_EP_STATE_CODEC_CONFIGURED)) ||
	    (headsets[channel_index].source_ep != NULL &&
	     !le_audio_ep_state_check(headsets[channel_index].source_stream.ep,
				      BT_BAP_EP_STATE_CODEC_CONFIGURED))) {
		return;
	}

	ret = bt_bap_stream_qos(headsets[channel_index].headset_conn, unicast_group);
	if (ret) {
		LOG_ERR("QoS not set for %s headset: %d", headsets[channel_index].ch_name, ret);
	}
}

static void stream_qos_set_cb(struct bt_bap_stream *stream)
{
	int ret;
	uint8_t channel_index;

	ret = channel_index_get(stream->conn, &channel_index);

	if (headsets[channel_index].qos_reconfigure) {
		LOG_DBG("Reconfiguring: %s to PD: %d", headsets[channel_index].ch_name,
			headsets[channel_index].reconfigure_pd);

		headsets[channel_index].qos_reconfigure = false;
		headsets[channel_index].sink_stream.qos->pd =
			headsets[channel_index].reconfigure_pd;

		ret = bt_bap_stream_qos(headsets[channel_index].headset_conn, unicast_group);
		if (ret) {
			LOG_ERR("Unable to reconfigure %s: %d", headsets[channel_index].ch_name,
				ret);
		}
	} else {
		LOG_DBG("Set %s to PD: %d", headsets[channel_index].ch_name, stream->qos->pd);

		if (playing_state) {
			ret = bt_bap_stream_enable(stream, lc3_preset_sink.codec_cfg.meta,
						   lc3_preset_sink.codec_cfg.meta_len);
			if (ret) {
				LOG_ERR("Unable to enable stream: %d", ret);
				return;
			}

			LOG_INF("Enable stream %p", stream);
		}
	}
}

static void stream_enabled_cb(struct bt_bap_stream *stream)
{
	int ret;
	uint8_t channel_index;
	struct worker_data work_data;
	enum bt_audio_dir dir;

	dir = le_audio_stream_dir_get(stream);
	if (dir <= 0) {
		LOG_ERR("Failed to get dir of stream %p", stream);
		return;
	}

	LOG_DBG("Stream enabled: %p", stream);

	ret = channel_index_get(stream->conn, &channel_index);
	if (ret) {
		LOG_ERR("Error getting channel index");
		return;
	}

	if (dir == BT_AUDIO_DIR_SINK &&
	    le_audio_ep_state_check(headsets[channel_index].sink_stream.ep,
				    BT_BAP_EP_STATE_ENABLING)) {
		if (!k_work_delayable_is_pending(&headsets[channel_index].stream_start_sink_work)) {
			work_data.channel_index = channel_index;
			work_data.retries = 0;
			work_data.dir = BT_AUDIO_DIR_SINK;

			LOG_DBG("k_msg_put: ch: %d, dir: %d, retries %d", work_data.channel_index,
				work_data.dir, work_data.retries);

			ret = k_msgq_put(&kwork_msgq, &work_data, K_NO_WAIT);
			if (ret) {
				LOG_ERR("No space in the queue for work_data");
				return;
			}

			k_work_schedule(&headsets[channel_index].stream_start_sink_work, K_NO_WAIT);
		}
	}

	if (dir == BT_AUDIO_DIR_SOURCE &&
	    le_audio_ep_state_check(headsets[channel_index].source_stream.ep,
				    BT_BAP_EP_STATE_ENABLING)) {
		if (!k_work_delayable_is_pending(
			    &headsets[channel_index].stream_start_source_work)) {
			work_data.channel_index = channel_index;
			work_data.retries = 0;
			work_data.dir = BT_AUDIO_DIR_SOURCE;

			LOG_DBG("k_msg_put: ch: %d, dir: %d, retries %d", work_data.channel_index,
				work_data.dir, work_data.retries);

			ret = k_msgq_put(&kwork_msgq, &work_data, K_NO_WAIT);
			if (ret) {
				LOG_ERR("No space in the queue for work_data");
				return;
			}

			k_work_schedule(&headsets[channel_index].stream_start_source_work,
					K_NO_WAIT);
		}
	}
}

static void stream_started_cb(struct bt_bap_stream *stream)
{
	int ret;
	uint8_t channel_index;
	enum bt_audio_dir dir;

	dir = le_audio_stream_dir_get(stream);
	if (dir <= 0) {
		LOG_ERR("Failed to get dir of stream %p", stream);
		return;
	}

	ret = channel_index_get(stream->conn, &channel_index);
	if (ret) {
		LOG_ERR("Channel index not found");
	} else {
		ERR_CHK(bt_le_audio_tx_stream_started(channel_index));
	}

	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Stream %p started", (void *)stream);

	le_audio_event_publish(LE_AUDIO_EVT_STREAMING, stream->conn, dir);
}

static void stream_metadata_updated_cb(struct bt_bap_stream *stream)
{
	LOG_DBG("Audio Stream %p metadata updated", (void *)stream);
}

static void stream_disabled_cb(struct bt_bap_stream *stream)
{
	LOG_DBG("Audio Stream %p disabled", (void *)stream);
}

static void stream_stopped_cb(struct bt_bap_stream *stream, uint8_t reason)
{
	int ret;
	uint8_t channel_index;

	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Stream %p stopped. Reason %d", (void *)stream, reason);

	ret = channel_index_get(stream->conn, &channel_index);
	if (ret) {
		LOG_ERR("Channel index not found");
	} else {
		ERR_CHK(bt_le_audio_tx_stream_stopped(channel_index));
	}

	/* Check if the other stream is streaming, send event if not */
	if (stream == &headsets[AUDIO_CH_L].sink_stream) {
		if (!le_audio_ep_state_check(headsets[AUDIO_CH_R].sink_stream.ep,
					     BT_BAP_EP_STATE_STREAMING)) {
			le_audio_event_publish(LE_AUDIO_EVT_NOT_STREAMING, stream->conn,
					       BT_AUDIO_DIR_SINK);
		}
	} else if (stream == &headsets[AUDIO_CH_R].sink_stream) {
		if (!le_audio_ep_state_check(headsets[AUDIO_CH_L].sink_stream.ep,
					     BT_BAP_EP_STATE_STREAMING)) {
			le_audio_event_publish(LE_AUDIO_EVT_NOT_STREAMING, stream->conn,
					       BT_AUDIO_DIR_SINK);
		}
	} else {
		LOG_WRN("Unknown stream");
	}
}

static void stream_released_cb(struct bt_bap_stream *stream)
{
	LOG_DBG("Audio Stream %p released", (void *)stream);

	/* Check if the other stream is streaming, send event if not */
	if (stream == &headsets[AUDIO_CH_L].sink_stream) {
		if (!le_audio_ep_state_check(headsets[AUDIO_CH_R].sink_stream.ep,
					     BT_BAP_EP_STATE_STREAMING)) {
			le_audio_event_publish(LE_AUDIO_EVT_NOT_STREAMING, stream->conn,
					       BT_AUDIO_DIR_SINK);
		}

		LOG_DBG("Left sink stream released");
	} else if (stream == &headsets[AUDIO_CH_R].sink_stream) {
		if (!le_audio_ep_state_check(headsets[AUDIO_CH_L].sink_stream.ep,
					     BT_BAP_EP_STATE_STREAMING)) {
			le_audio_event_publish(LE_AUDIO_EVT_NOT_STREAMING, stream->conn,
					       BT_AUDIO_DIR_SINK);
		}

		LOG_DBG("Right sink stream released");
	} else if (stream == &headsets[AUDIO_CH_L].source_stream) {
		LOG_DBG("Left source stream released");
	} else if (stream == &headsets[AUDIO_CH_R].source_stream) {
		LOG_DBG("Right source stream released");
	} else {
		LOG_WRN("Unknown stream");
	}
}

#if (CONFIG_BT_AUDIO_RX)
static void stream_recv_cb(struct bt_bap_stream *stream, const struct bt_iso_recv_info *info,
			   struct net_buf *buf)
{
	int ret;
	bool bad_frame = false;
	uint8_t channel_index;

	if (receive_cb == NULL) {
		LOG_ERR("The RX callback has not been set");
		return;
	}

	if (!(info->flags & BT_ISO_FLAGS_VALID)) {
		bad_frame = true;
	}

	ret = channel_index_get(stream->conn, &channel_index);
	if (ret) {
		LOG_ERR("Channel index not found");
		return;
	}

	receive_cb(buf->data, buf->len, bad_frame, info->ts, channel_index,
		   bt_audio_codec_cfg_get_octets_per_frame(stream->codec_cfg));
}
#endif /* (CONFIG_BT_AUDIO_RX) */

static struct bt_bap_stream_ops stream_ops = {
	.configured = stream_configured_cb,
	.qos_set = stream_qos_set_cb,
	.enabled = stream_enabled_cb,
	.started = stream_started_cb,
	.metadata_updated = stream_metadata_updated_cb,
	.disabled = stream_disabled_cb,
	.stopped = stream_stopped_cb,
	.released = stream_released_cb,
#if (CONFIG_BT_AUDIO_RX)
	.recv = stream_recv_cb,
#endif /* (CONFIG_BT_AUDIO_RX) */
#if (CONFIG_BT_AUDIO_TX)
	.sent = stream_sent_cb,
#endif /* (CONFIG_BT_AUDIO_TX) */
};

static void work_stream_start(struct k_work *work)
{
	int ret;
	struct worker_data work_data;

	ret = k_msgq_get(&kwork_msgq, &work_data, K_NO_WAIT);
	if (ret) {
		LOG_ERR("Cannot get info for start stream");
		return;
	}

	LOG_DBG("k_msg_get: ch: %d, dir: %d, retries %d", work_data.channel_index, work_data.dir,
		work_data.retries);

	if (work_data.dir == BT_AUDIO_DIR_SINK) {
		if (!le_audio_ep_state_check(headsets[work_data.channel_index].sink_stream.ep,
					     BT_BAP_EP_STATE_STREAMING)) {
			ret = bt_bap_stream_start(&headsets[work_data.channel_index].sink_stream);
		}
	} else if (work_data.dir == BT_AUDIO_DIR_SOURCE) {
		if (!le_audio_ep_state_check(headsets[work_data.channel_index].source_stream.ep,
					     BT_BAP_EP_STATE_STREAMING)) {
			ret = bt_bap_stream_start(&headsets[work_data.channel_index].source_stream);
		}
	} else {
		LOG_ERR("Trying to use unknown direction: %d", work_data.dir);
		le_audio_event_publish(LE_AUDIO_EVT_NO_VALID_CFG,
				       headsets[work_data.channel_index].headset_conn,
				       work_data.dir);

		return;
	}

	work_data.retries++;

	if ((ret == -EBUSY) && (work_data.retries < CIS_CONN_RETRY_TIMES)) {
		LOG_DBG("Got connect error from stream %d Retrying. code: %d count: %d",
			work_data.channel_index, ret, work_data.retries);
		LOG_DBG("k_msg_put: ch: %d, dir: %d, retries %d", work_data.channel_index,
			work_data.dir, work_data.retries);
		ret = k_msgq_put(&kwork_msgq, &work_data, K_NO_WAIT);
		if (ret) {
			LOG_ERR("No space in the queue for work_data");
			return;
		}
		/* Delay added to prevent controller overloading */
		if (work_data.dir == BT_AUDIO_DIR_SINK) {
			k_work_reschedule(&headsets[work_data.channel_index].stream_start_sink_work,
					  K_MSEC(CIS_CONN_RETRY_DELAY_MS));
		} else if (work_data.dir == BT_AUDIO_DIR_SOURCE) {
			k_work_reschedule(
				&headsets[work_data.channel_index].stream_start_source_work,
				K_MSEC(CIS_CONN_RETRY_DELAY_MS));
		}
	} else if (ret != 0) {
		LOG_WRN("Failed to establish CIS, ret = %d", ret);
		/** The connection could have invalid configs, or abnormal behavior cause the CIS
		 * failed to establish. Sending an event for triggering disconnection could clean up
		 * the abnormal state and restart the connection.
		 */
		le_audio_event_publish(LE_AUDIO_EVT_NO_VALID_CFG,
				       headsets[work_data.channel_index].headset_conn,
				       work_data.dir);
	} else if (k_msgq_peek(&kwork_msgq, &work_data) != -ENOMSG) {
		if (work_data.dir == BT_AUDIO_DIR_SINK &&
		    !k_work_delayable_is_pending(
			    &headsets[work_data.channel_index].stream_start_sink_work)) {
			k_work_reschedule(&headsets[work_data.channel_index].stream_start_sink_work,
					  K_MSEC(CIS_CONN_RETRY_DELAY_MS));
		} else if (work_data.dir == BT_AUDIO_DIR_SOURCE &&
			   !k_work_delayable_is_pending(
				   &headsets[work_data.channel_index].stream_start_source_work)) {
			k_work_reschedule(
				&headsets[work_data.channel_index].stream_start_source_work,
				K_MSEC(CIS_CONN_RETRY_DELAY_MS));
		}
	}
}

static void disconnected_headset_cleanup(uint8_t chan_idx)
{
	headsets[chan_idx].headset_conn = NULL;
	k_work_cancel_delayable(&headsets[chan_idx].stream_start_sink_work);
	headsets[chan_idx].sink_ep = NULL;
	memset(headsets[chan_idx].sink_codec_cap, 0, sizeof(headsets[chan_idx].sink_codec_cap));
	k_work_cancel_delayable(&headsets[chan_idx].stream_start_source_work);
	headsets[chan_idx].source_ep = NULL;
	memset(headsets[chan_idx].source_codec_cap, 0, sizeof(headsets[chan_idx].source_codec_cap));

	headsets[chan_idx].num_sink_eps = 0;
	headsets[chan_idx].num_source_eps = 0;
}

int unicast_client_config_get(struct bt_conn *conn, enum bt_audio_dir dir, uint32_t *bitrate,
			      uint32_t *sampling_rate_hz)
{
	int ret;
	uint8_t headset_idx;

	if (conn == NULL) {
		LOG_ERR("No valid connection pointer received");
		return -EINVAL;
	}

	if (bitrate == NULL && sampling_rate_hz == NULL) {
		LOG_ERR("No valid pointers received");
		return -ENXIO;
	}

	ret = channel_index_get(conn, &headset_idx);
	if (ret) {
		LOG_WRN("No configured streams found");
		return ret;
	}

	if (dir == BT_AUDIO_DIR_SINK) {
		if (headsets[headset_idx].sink_stream.codec_cfg == NULL) {
			LOG_ERR("No codec found for the stream");

			return -ENXIO;
		}

		if (sampling_rate_hz != NULL) {
			ret = le_audio_freq_hz_get(headsets[headset_idx].sink_stream.codec_cfg,
						   sampling_rate_hz);
			if (ret) {
				LOG_ERR("Invalid sampling frequency: %d", ret);
				return -ENXIO;
			}
		}

		if (bitrate != NULL) {
			ret = le_audio_bitrate_get(headsets[headset_idx].sink_stream.codec_cfg,
						   bitrate);
			if (ret) {
				LOG_ERR("Unable to calculate bitrate: %d", ret);
				return -ENXIO;
			}
		}
	} else if (dir == BT_AUDIO_DIR_SOURCE) {
		if (headsets[headset_idx].source_stream.codec_cfg == NULL) {
			LOG_ERR("No codec found for the stream");
			return -ENXIO;
		}

		if (sampling_rate_hz != NULL) {
			ret = le_audio_freq_hz_get(headsets[headset_idx].source_stream.codec_cfg,
						   sampling_rate_hz);
			if (ret) {
				LOG_ERR("Invalid sampling frequency: %d", ret);
				return -ENXIO;
			}
		}

		if (bitrate != NULL) {
			ret = le_audio_bitrate_get(headsets[headset_idx].source_stream.codec_cfg,
						   bitrate);
			if (ret) {
				LOG_ERR("Unable to calculate bitrate: %d", ret);
				return -ENXIO;
			}
		}
	}

	return 0;
}

void unicast_client_conn_disconnected(struct bt_conn *conn)
{
	int ret;
	uint8_t channel_index;

	/* Make sure discovery_list is purged for the disconnected conn */
	ret = discover_list_remove(conn);
	if (ret) {
		LOG_WRN("Failed to remove conn from discover_list: %d", ret);
	}

	ret = channel_index_get(conn, &channel_index);
	if (ret) {
		LOG_WRN("Unknown connection disconnected");
	} else {
		disconnected_headset_cleanup(channel_index);
	}
}

int unicast_client_discover(struct bt_conn *conn, enum unicast_discover_dir dir)
{
	int ret;

	ret = discover_list_add(conn, dir);
	if (ret) {
		LOG_ERR("Failed to add to discover_list: %d", ret);
		return ret;
	}

	if (dir == UNICAST_SERVER_BIDIR) {
		/* If we need to discover both source and sink, do sink first */
		ret = bt_bap_unicast_client_discover(conn, BT_AUDIO_DIR_SINK);
		return ret;
	}

	ret = bt_bap_unicast_client_discover(conn, dir);
	return ret;
}

int unicast_client_start(void)
{
	int ret_left = 0;
	int ret_right = 0;

	if (le_audio_ep_state_check(headsets[AUDIO_CH_L].sink_stream.ep,
				    BT_BAP_EP_STATE_QOS_CONFIGURED)) {
		ret_left = bt_bap_stream_enable(&headsets[AUDIO_CH_L].sink_stream,
						lc3_preset_sink.codec_cfg.meta,
						lc3_preset_sink.codec_cfg.meta_len);

		if (ret_left) {
			LOG_WRN("Failed to enable left stream: %d", ret_left);
		}
	}

	if (le_audio_ep_state_check(headsets[AUDIO_CH_R].sink_stream.ep,
				    BT_BAP_EP_STATE_QOS_CONFIGURED)) {
		ret_right = bt_bap_stream_enable(&headsets[AUDIO_CH_R].sink_stream,
						 lc3_preset_sink.codec_cfg.meta,
						 lc3_preset_sink.codec_cfg.meta_len);

		if (ret_right) {
			LOG_WRN("Failed to enable right stream: %d", ret_right);
		}
	}

	if (ret_left || ret_right) {
		return -EIO;
	}

	playing_state = true;

	return 0;
}

int unicast_client_stop(void)
{
	int ret_left = 0;
	int ret_right = 0;

	le_audio_event_publish(LE_AUDIO_EVT_NOT_STREAMING, NULL, 0);

	if (le_audio_ep_state_check(headsets[AUDIO_CH_L].sink_stream.ep,
				    BT_BAP_EP_STATE_STREAMING)) {
		ret_left = bt_bap_stream_disable(&headsets[AUDIO_CH_L].sink_stream);

		if (ret_left) {
			LOG_WRN("Failed to disable left stream: %d", ret_left);
		}
	}

	if (le_audio_ep_state_check(headsets[AUDIO_CH_R].sink_stream.ep,
				    BT_BAP_EP_STATE_STREAMING)) {
		ret_right = bt_bap_stream_disable(&headsets[AUDIO_CH_R].sink_stream);

		if (ret_right) {
			LOG_WRN("Failed to disable right stream: %d", ret_right);
		}
	}

	if (ret_left || ret_right) {
		return -EIO;
	}

	playing_state = false;

	return 0;
}

int unicast_client_send(struct le_audio_encoded_audio enc_audio)
{
	int ret;
#if CONFIG_BT_AUDIO_TX
	struct bt_bap_stream *bap_tx_streams[CONFIG_BT_BAP_UNICAST_CLIENT_ASE_SNK_COUNT];

	for (int i = 0; i < CONFIG_BT_BAP_UNICAST_CLIENT_ASE_SNK_COUNT; i++) {
		bap_tx_streams[i] = &headsets[i].sink_stream;
	}

	ret = bt_le_audio_tx_send(bap_tx_streams, enc_audio,
				  CONFIG_BT_BAP_UNICAST_CLIENT_ASE_SNK_COUNT);
	if (ret) {
		return ret;
	}
#endif /*CONFIG_BT_AUDIO_TX*/

	return 0;
}

int unicast_client_disable(void)
{
	return -ENOTSUP;
}

int unicast_client_enable(le_audio_receive_cb recv_cb)
{
	int ret;
	static bool initialized;
	int headset_iterator = 0;
	int stream_iterator = 0;
	struct bt_bap_unicast_group_stream_pair_param pair_params[ARRAY_SIZE(headsets)];
	/* 2 streams (one sink and one source stream) for each headset */
	struct bt_bap_unicast_group_stream_param group_stream_params[(ARRAY_SIZE(headsets) * 2)];
	struct bt_bap_unicast_group_param group_param;

	if (initialized) {
		LOG_WRN("Already initialized");
		return -EALREADY;
	}

	if (recv_cb == NULL) {
		LOG_ERR("Receive callback is NULL");
		return -EINVAL;
	}

	receive_cb = recv_cb;

	LOG_DBG("Start workers");

	for (int i = 0; i < ARRAY_SIZE(headsets); i++) {
		headsets[i].sink_stream.ops = &stream_ops;
		headsets[i].source_stream.ops = &stream_ops;
		k_work_init_delayable(&headsets[i].stream_start_sink_work, work_stream_start);
		k_work_init_delayable(&headsets[i].stream_start_source_work, work_stream_start);
	}

	ret = bt_bap_unicast_client_register_cb(&unicast_client_cbs);
	if (ret != 0) {
		LOG_ERR("Failed to register client callbacks: %d", ret);
		return ret;
	}

	ret = bt_le_audio_tx_init();
	if (ret) {
		return ret;
	}

	for (int i = 0; i < ARRAY_SIZE(headsets); i++) {
		switch (i) {
		case AUDIO_CH_L:
			headsets[i].ch_name = "LEFT";
			break;
		case AUDIO_CH_R:
			headsets[i].ch_name = "RIGHT";
			break;
		default:
			LOG_WRN("Trying to set name to undefined channel");
			headsets[i].ch_name = "UNDEFINED";
			break;
		}
	}

	for (int i = 0; i < ARRAY_SIZE(group_stream_params); i++) {
		/* Every other stream should be sink or source */
		if ((i % 2) == 0) {
			group_stream_params[i].qos = &lc3_preset_max.qos;
			group_stream_params[i].stream = &headsets[headset_iterator].sink_stream;
		} else {
			group_stream_params[i].qos = &lc3_preset_max.qos;
			group_stream_params[i].stream = &headsets[headset_iterator].source_stream;
			headset_iterator++;
		}
	}

	for (int i = 0; i < ARRAY_SIZE(pair_params); i++) {
		pair_params[i].tx_param = &group_stream_params[stream_iterator];
		stream_iterator++;

		if (IS_ENABLED(CONFIG_BT_AUDIO_RX)) {
			pair_params[i].rx_param = &group_stream_params[stream_iterator];
		} else {
			pair_params[i].rx_param = NULL;
		}

		stream_iterator++;
	}

	group_param.params = pair_params;
	group_param.params_count = ARRAY_SIZE(pair_params);

	if (IS_ENABLED(CONFIG_BT_AUDIO_PACKING_INTERLEAVED)) {
		group_param.packing = BT_ISO_PACKING_INTERLEAVED;
	} else {
		group_param.packing = BT_ISO_PACKING_SEQUENTIAL;
	}

	ret = bt_bap_unicast_group_create(&group_param, &unicast_group);
	if (ret) {
		LOG_ERR("Failed to create unicast group: %d", ret);
		return ret;
	}

	initialized = true;

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_stream/unicast/unicast_server.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _UNICAST_SERVER_H_
#define _UNICAST_SERVER_H_

#include "bt_le_audio_tx.h"
#include "le_audio.h"

#include <audio_defines.h>

/**
 * @brief	Get configuration for audio stream.
 *
 * @param[in]	conn			Pointer to the connection to get the configuration for.
 * @param[in]	dir			Direction to get the configuration from.
 * @param[out]	bitrate			Pointer to the bit rate used; can be NULL.
 * @param[out]	sampling_rate_hz	Pointer to the sampling rate used; can be NULL.
 * @param[out]	pres_delay_us		Pointer to the presentation delay used; can be NULL. Only
 *					valid for the sink direction.
 *
 * @retval	0		Operation successful.
 * @retval	-ENXIO		The feature is disabled.
 */
int unicast_server_config_get(struct bt_conn *conn, enum bt_audio_dir dir, uint32_t *bitrate,
			      uint32_t *sampling_rate_hz, uint32_t *pres_delay_us);

/**
 * @brief	Put the UUIDs from this module into the buffer.
 *
 * @note	This partial data is used to build a complete extended advertising packet.
 *
 * @param[out]	uuid_buf	Buffer being populated with UUIDs.
 *
 * @return	0 for success, error otherwise.
 */
int unicast_server_uuid_populate(struct net_buf_simple *uuid_buf);

/**
 * @brief	Put the advertising data from this module into the buffer.
 *
 * @note	This partial data is used to build a complete extended advertising packet.
 *
 * @param[out]	adv_buf		Buffer being populated with ext adv elements.
 * @param[in]	adv_buf_vacant	Number of vacant elements in @p adv_buf.
 *
 * @return	Negative values for errors or number of elements added to @p adv_buf.
 */
int unicast_server_adv_populate(struct bt_data *adv_buf, uint8_t adv_buf_vacant);

/**
 * @brief	Send data from the LE Audio unicast (CIS) server, if configured as a source.
 *
 * @param[in]	enc_audio	Encoded audio struct.
 *
 * @return	0 for success, error otherwise.
 */
int unicast_server_send(struct le_audio_encoded_audio enc_audio);

/**
 * @brief	Disable the Bluetooth LE Audio unicast (CIS) server.
 *
 * @return	0 for success, error otherwise.
 */
int unicast_server_disable(void);

/**
 * @brief	Enable the Bluetooth LE Audio unicast (CIS) server.
 *
 * @return	0 for success, error otherwise.
 */
int unicast_server_enable(le_audio_receive_cb rx_cb);

#endif /* _UNICAST_SERVER_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_stream/unicast/Kconfig
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

rsource "Kconfig.defaults"

menu "Unicast"

choice BT_BAP_UNICAST_BAP_CONFIGURATION
	prompt "Unicast codec configuration"
	depends on TRANSPORT_CIS
	default BT_BAP_UNICAST_CONFIGURABLE
	help
	  Select the unicast codec configuration as given in
	  Table 5.2 of the Bluetooth Audio Profile Specification.
	  USB only supports 48 kHz samplig rate.

config BT_BAP_UNICAST_CONFIGURABLE
	bool "Configurable unicast settings"
	depends on TRANSPORT_CIS
	help
	  Configurable option that doesn't follow any preset. Allows for more flexibility.

config BT_BAP_UNICAST_16_2_1
	bool "16_2_1"
	depends on TRANSPORT_CIS
	help
	  Unicast mandatory codec capability 16_2_1.
	  16kHz, 32kbps, 2 retransmits, 10ms transport latency, and 40ms presentation delay.

config BT_BAP_UNICAST_24_2_1
	bool "24_2_1"
	depends on TRANSPORT_CIS
	help
	  Unicast codec capability 24_2_1.
	  24kHz, 48kbps, 2 retransmits, 10ms transport latency, and 40ms presentation delay.

config BT_BAP_UNICAST_48_4_1
	bool "48_4_1"
	depends on TRANSPORT_CIS
	help
	  Unicast codec capability 48_4_1.
	  48kHz, 96kbps, 5 retransmits, 20ms transport latency, and 40ms presentation delay.
endchoice

choice	BT_AUDIO_PRES_DLY_SRCH
	prompt "Default search mode for the presentation delay"
	default BT_AUDIO_PRES_DELAY_SRCH_PREF_MIN
	help
	  Set the default search mode for the presentation delay.

config BT_AUDIO_PRES_DELAY_SRCH_MIN
	bool "Largest minimum delay over all audio receivers"
	help
	  Search for the largest minimum delay over all audio receivers.

config BT_AUDIO_PRES_DELAY_SRCH_MAX
	bool "Smallest maximum delay over all audio receivers"
	help
	  Search for the smallest maximum delay over all audio receivers.

config BT_AUDIO_PRES_DELAY_SRCH_PREF_MIN
	bool "Largest minimum preferred delay over all audio receivers"
	help
	  Search for the largest minimum preferred delay over all audio receivers.

config BT_AUDIO_PRES_DELAY_SRCH_PREF_MAX
	bool "Smallest maximum preferred delay over all audio receivers"
	help
	  Search for the smallest maximum preferred delay over all audio receivers.

config BT_AUDIO_PRES_DELAY_SRCH_SOURCE
	bool "Use the presentation delay of audio source or client"
	help
	  Use the presentation delay defined by the broadcast_source or unicast_client if it
	  is within the range set by AUDIO_MIN_PRES_DLY_US and AUDIO_MAX_PRES_DLY_US. This will
	  override the audio receiver presentation delay as long as it is in range of
	  the max and min supported by the audio receivers. If it is outside this range,
	  then it will revert to the closest supported value.
endchoice

config CODEC_CAP_COUNT_MAX
	int "Max storage of codec capabilities"
	default 5
	help
	  Max number of codec capabilities to store per stream.

config BT_AUDIO_PREFERRED_MIN_PRES_DLY_US
	int "The preferred minimum presentation delay"
	range AUDIO_MIN_PRES_DLY_US AUDIO_MAX_PRES_DLY_US
	default 10000
	help
	  The preferred minimum presentation delay in microseconds. This can not
	  be less than the absolute minimum presentation delay.

config BT_AUDIO_PREFERRED_MAX_PRES_DLY_US
	int "The preferred maximum presentation delay"
	range BT_AUDIO_PREFERRED_MIN_PRES_DLY_US AUDIO_MAX_PRES_DLY_US
	default 40000
	help
	  The preferred maximum presentation delay in microseconds. This can not
	  be less than the absolute maximum presentation delay.

config BT_AUDIO_BITRATE_UNICAST_SINK
	int "ISO stream bitrate"
	depends on TRANSPORT_CIS
	default 64000 if BT_BAP_UNICAST_CONFIGURABLE && STREAM_BIDIRECTIONAL
	default 96000 if BT_BAP_UNICAST_CONFIGURABLE
	default 32000 if BT_BAP_UNICAST_16_2_1
	default 48000 if BT_BAP_UNICAST_24_2_1
	help
	  Bitrate for the unicast sink ISO stream.

config BT_AUDIO_BITRATE_UNICAST_SRC
	int "ISO stream bitrate"
	depends on TRANSPORT_CIS
	default 32000 if BT_BAP_UNICAST_16_2_1
	default 48000 if BT_BAP_UNICAST_24_2_1
	default 64000
	help
	  Bitrate for the unicast source ISO stream.

#----------------------------------------------------------------------------#
menu "Log levels"

module = UNICAST_SERVER
module-str = unicast_server
source "subsys/logging/Kconfig.template.log_config"

module = UNICAST_CLIENT
module-str = unicast_client
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log levels
endmenu # Unicast


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_stream/unicast/unicast_client.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _UNICAST_CLIENT_H_
#define _UNICAST_CLIENT_H_

#include "bt_le_audio_tx.h"

#include <zephyr/bluetooth/audio/audio.h>
#include <audio_defines.h>

enum unicast_discover_dir {
	UNICAST_SERVER_SINK = BT_AUDIO_DIR_SINK,
	UNICAST_SERVER_SOURCE = BT_AUDIO_DIR_SOURCE,
	UNICAST_SERVER_BIDIR = (BT_AUDIO_DIR_SINK | BT_AUDIO_DIR_SOURCE)
};

#if CONFIG_BT_BAP_UNICAST_CONFIGURABLE
#define BT_BAP_LC3_UNICAST_PRESET_NRF5340_AUDIO_SINK                                               \
	BT_BAP_LC3_PRESET_CONFIGURABLE(BT_AUDIO_LOCATION_FRONT_LEFT, BT_AUDIO_CONTEXT_TYPE_MEDIA,  \
				       CONFIG_BT_AUDIO_BITRATE_UNICAST_SINK)

#define BT_BAP_LC3_UNICAST_PRESET_NRF5340_AUDIO_SOURCE                                             \
	BT_BAP_LC3_PRESET_CONFIGURABLE(BT_AUDIO_LOCATION_FRONT_LEFT, BT_AUDIO_CONTEXT_TYPE_MEDIA,  \
				       CONFIG_BT_AUDIO_BITRATE_UNICAST_SRC)

#elif CONFIG_BT_BAP_UNICAST_16_2_1
#define BT_BAP_LC3_UNICAST_PRESET_NRF5340_AUDIO_SINK                                               \
	BT_BAP_LC3_UNICAST_PRESET_16_2_1(BT_AUDIO_LOCATION_FRONT_LEFT, BT_AUDIO_CONTEXT_TYPE_MEDIA)

#define BT_BAP_LC3_UNICAST_PRESET_NRF5340_AUDIO_SOURCE                                             \
	BT_BAP_LC3_UNICAST_PRESET_16_2_1(BT_AUDIO_LOCATION_FRONT_LEFT, BT_AUDIO_CONTEXT_TYPE_MEDIA)

#elif CONFIG_BT_BAP_UNICAST_24_2_1
#define BT_BAP_LC3_UNICAST_PRESET_NRF5340_AUDIO_SINK                                               \
	BT_BAP_LC3_UNICAST_PRESET_24_2_1(BT_AUDIO_LOCATION_FRONT_LEFT, BT_AUDIO_CONTEXT_TYPE_MEDIA)

#define BT_BAP_LC3_UNICAST_PRESET_NRF5340_AUDIO_SOURCE                                             \
	BT_BAP_LC3_UNICAST_PRESET_24_2_1(BT_AUDIO_LOCATION_FRONT_LEFT, BT_AUDIO_CONTEXT_TYPE_MEDIA)
#elif CONFIG_BT_BAP_UNICAST_48_4_1
#define BT_BAP_LC3_UNICAST_PRESET_NRF5340_AUDIO_SINK                                               \
	BT_BAP_LC3_UNICAST_PRESET_48_4_1(BT_AUDIO_LOCATION_ANY, BT_AUDIO_CONTEXT_TYPE_MEDIA)

#define BT_BAP_LC3_UNICAST_PRESET_NRF5340_AUDIO_SOURCE                                             \
	BT_BAP_LC3_UNICAST_PRESET_48_4_1(BT_AUDIO_LOCATION_ANY, BT_AUDIO_CONTEXT_TYPE_MEDIA)
#else
#error Unsupported LC3 codec preset for unicast
#endif /* CONFIG_BT_BAP_UNICAST_CONFIGURABLE */

/**
 * @brief	Get configuration for the audio stream.
 *
 * @param[in]	conn			Pointer to the connection to get the configuration for.
 * @param[in]	dir			Direction to get the configuration from.
 * @param[out]	bitrate			Pointer to the bit rate used; can be NULL.
 * @param[out]	sampling_rate_hz	Pointer to the sampling rate used; can be NULL.
 *
 * @return	0 for success, error otherwise.
 */
int unicast_client_config_get(struct bt_conn *conn, enum bt_audio_dir dir, uint32_t *bitrate,
			      uint32_t *sampling_rate_hz);

/**
 * @brief	Start service discovery for a Bluetooth LE Audio unicast (CIS) server.
 *
 * @param[in]	conn	Pointer to the connection.
 * @param[in]	dir	Direction of the stream.
 *
 * @return 0 for success, error otherwise.
 */
int unicast_client_discover(struct bt_conn *conn, enum unicast_discover_dir dir);

/**
 * @brief	Handle a disconnected Bluetooth LE Audio unicast (CIS) server.
 *
 * @param[in]	conn	Pointer to the connection.
 */
void unicast_client_conn_disconnected(struct bt_conn *conn);

/**
 * @brief	Start the Bluetooth LE Audio unicast (CIS) client.
 *
 * @return	0 for success, error otherwise.
 */
int unicast_client_start(void);

/**
 * @brief	Stop the Bluetooth LE Audio unicast (CIS) client.
 *
 * @return	0 for success, error otherwise.
 */
int unicast_client_stop(void);

/**
 * @brief	Send encoded audio using the Bluetooth LE Audio unicast.
 *
 * @param[in]	enc_audio	Encoded audio struct.
 *
 * @return	0 for success, error otherwise.
 */
int unicast_client_send(struct le_audio_encoded_audio enc_audio);

/**
 * @brief       Disable the Bluetooth LE Audio unicast (CIS) client.
 *
 * @return      0 for success, error otherwise.
 */
int unicast_client_disable(void);

/**
 * @brief	Enable the Bluetooth LE Audio unicast (CIS) client.
 *
 * @param[in]   recv_cb	Callback for handling received data.
 *
 * @return	0 for success, error otherwise.
 */
int unicast_client_enable(le_audio_receive_cb recv_cb);

#endif /* _UNICAST_CLIENT_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_stream/unicast/unicast_server.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "unicast_server.h"

#include <zephyr/zbus/zbus.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/conn.h>
#include <zephyr/bluetooth/audio/audio.h>
#include <zephyr/bluetooth/audio/pacs.h>
#include <zephyr/bluetooth/audio/csip.h>
#include <zephyr/bluetooth/audio/cap.h>
#include <zephyr/bluetooth/audio/lc3.h>

#include "macros_common.h"
#include "nrf5340_audio_common.h"
#include "channel_assignment.h"
#include "bt_le_audio_tx.h"
#include "le_audio.h"

#include <../subsys/bluetooth/audio/bap_endpoint.h>

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(unicast_server, CONFIG_UNICAST_SERVER_LOG_LEVEL);

BUILD_ASSERT(CONFIG_BT_ASCS_ASE_SRC_COUNT <= 1,
	     "A maximum of one source stream is currently supported");

ZBUS_CHAN_DEFINE(le_audio_chan, struct le_audio_msg, NULL, NULL, ZBUS_OBSERVERS_EMPTY,
		 ZBUS_MSG_INIT(0));

#define BLE_ISO_LATENCY_MS 10
#define CSIP_SET_SIZE	   2
enum csip_set_rank {
	CSIP_HL_RANK = 1,
	CSIP_HR_RANK = 2
};

static le_audio_receive_cb receive_cb;
static struct bt_csip_set_member_svc_inst *csip;
/* Left or right channel headset */
static enum audio_channel channel;

/* Advertising data for peer connection */
static uint8_t csip_rsi_adv_data[BT_CSIP_RSI_SIZE];

static uint8_t flags_adv_data[] = {BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR};

static uint8_t gap_appear_adv_data[] = {BT_BYTES_LIST_LE16(CONFIG_BT_DEVICE_APPEARANCE)};

static const uint8_t cap_adv_data[] = {
	BT_UUID_16_ENCODE(BT_UUID_CAS_VAL),
	BT_AUDIO_UNICAST_ANNOUNCEMENT_TARGETED,
};

#if defined(CONFIG_BT_AUDIO_RX)
#define AVAILABLE_SINK_CONTEXT                                                                     \
	(BT_AUDIO_CONTEXT_TYPE_UNSPECIFIED | BT_AUDIO_CONTEXT_TYPE_MEDIA |                         \
	 BT_AUDIO_CONTEXT_TYPE_CONVERSATIONAL)
#else
#define AVAILABLE_SINK_CONTEXT BT_AUDIO_CONTEXT_TYPE_PROHIBITED
#endif /* CONFIG_BT_AUDIO_RX */

#if defined(CONFIG_BT_AUDIO_TX)
static struct bt_bap_stream *bap_tx_streams[CONFIG_BT_ASCS_ASE_SRC_COUNT];
#define AVAILABLE_SOURCE_CONTEXT                                                                   \
	(BT_AUDIO_CONTEXT_TYPE_UNSPECIFIED | BT_AUDIO_CONTEXT_TYPE_CONVERSATIONAL)
#else
#define AVAILABLE_SOURCE_CONTEXT BT_AUDIO_CONTEXT_TYPE_PROHIBITED
#endif /* CONFIG_BT_AUDIO_TX */

static uint8_t unicast_server_adv_data[] = {
	BT_UUID_16_ENCODE(BT_UUID_ASCS_VAL),
	BT_AUDIO_UNICAST_ANNOUNCEMENT_TARGETED,
	BT_BYTES_LIST_LE16(AVAILABLE_SINK_CONTEXT),
	BT_BYTES_LIST_LE16(AVAILABLE_SOURCE_CONTEXT),
	0x00, /* Metadata length */
};

static void le_audio_event_publish(enum le_audio_evt_type event, struct bt_conn *conn,
				   enum bt_audio_dir dir)
{
	int ret;
	struct le_audio_msg msg;

	msg.event = event;
	msg.conn = conn;
	msg.dir = dir;

	ret = zbus_chan_pub(&le_audio_chan, &msg, LE_AUDIO_ZBUS_EVENT_WAIT_TIME);
	ERR_CHK(ret);
}

/* Callback for locking state change from server side */
static void csip_lock_changed_cb(struct bt_conn *conn, struct bt_csip_set_member_svc_inst *csip,
				 bool locked)
{
	LOG_DBG("Client %p %s the lock", (void *)conn, locked ? "locked" : "released");
}

/* Callback for SIRK read request from peer side */
static uint8_t sirk_read_req_cb(struct bt_conn *conn, struct bt_csip_set_member_svc_inst *csip)
{
	/* Accept the request to read the SIRK, but return encrypted SIRK instead of plaintext */
	return BT_CSIP_READ_SIRK_REQ_RSP_ACCEPT_ENC;
}

static struct bt_csip_set_member_cb csip_callbacks = {
	.lock_changed = csip_lock_changed_cb,
	.sirk_read_req = sirk_read_req_cb,
};
struct bt_csip_set_member_register_param csip_param = {
	.set_size = CSIP_SET_SIZE,
	.lockable = true,
#if !CONFIG_BT_CSIP_SET_MEMBER_TEST_SAMPLE_DATA
	/* CSIP SIRK for demo is used, must be changed before production */
	.set_sirk = {'N', 'R', 'F', '5', '3', '4', '0', '_', 'T', 'W', 'S', '_', 'D', 'E', 'M',
		     'O'},
#else
#warning "CSIP test sample data is used, must be changed before production"
#endif
	.cb = &csip_callbacks,
};

static struct bt_audio_codec_cap lc3_codec_sink = BT_AUDIO_CODEC_CAP_LC3(
	BT_AUDIO_CODEC_CAPABILIY_FREQ,
	(BT_AUDIO_CODEC_LC3_DURATION_10 | BT_AUDIO_CODEC_LC3_DURATION_PREFER_10),
	BT_AUDIO_CODEC_LC3_CHAN_COUNT_SUPPORT(1), LE_AUDIO_SDU_SIZE_OCTETS(CONFIG_LC3_BITRATE_MIN),
	LE_AUDIO_SDU_SIZE_OCTETS(CONFIG_LC3_BITRATE_MAX), 1u, AVAILABLE_SINK_CONTEXT);

static struct bt_audio_codec_cap lc3_codec_source = BT_AUDIO_CODEC_CAP_LC3(
	BT_AUDIO_CODEC_CAPABILIY_FREQ,
	(BT_AUDIO_CODEC_LC3_DURATION_10 | BT_AUDIO_CODEC_LC3_DURATION_PREFER_10),
	BT_AUDIO_CODEC_LC3_CHAN_COUNT_SUPPORT(1), LE_AUDIO_SDU_SIZE_OCTETS(CONFIG_LC3_BITRATE_MIN),
	LE_AUDIO_SDU_SIZE_OCTETS(CONFIG_LC3_BITRATE_MAX), 1u, AVAILABLE_SOURCE_CONTEXT);

static enum bt_audio_dir caps_dirs[] = {
	BT_AUDIO_DIR_SINK,
#if (CONFIG_BT_AUDIO_TX)
	BT_AUDIO_DIR_SOURCE,
#endif /* (CONFIG_BT_AUDIO_TX) */
};

static const struct bt_audio_codec_qos_pref qos_pref = BT_AUDIO_CODEC_QOS_PREF(
	true, BT_GAP_LE_PHY_2M, CONFIG_BT_AUDIO_RETRANSMITS, BLE_ISO_LATENCY_MS,
	CONFIG_AUDIO_MIN_PRES_DLY_US, CONFIG_AUDIO_MAX_PRES_DLY_US,
	CONFIG_BT_AUDIO_PREFERRED_MIN_PRES_DLY_US, CONFIG_BT_AUDIO_PREFERRED_MAX_PRES_DLY_US);

/* clang-format off */
static struct bt_pacs_cap caps[] = {
#if (CONFIG_BT_AUDIO_RX)
				{
					 .codec_cap = &lc3_codec_sink,
				},
#endif
#if (CONFIG_BT_AUDIO_TX)
				{
					 .codec_cap = &lc3_codec_source,
				}
#endif /* (CONFIG_BT_AUDIO_TX) */
};
/* clang-format on */

static struct bt_bap_stream
	audio_streams[CONFIG_BT_ASCS_ASE_SNK_COUNT + CONFIG_BT_ASCS_ASE_SRC_COUNT];

#if (CONFIG_BT_AUDIO_TX)
BUILD_ASSERT(CONFIG_BT_ASCS_ASE_SRC_COUNT <= 1,
	     "CIS headset only supports one source stream for now");
#endif /* (CONFIG_BT_AUDIO_TX) */

static void print_codec(const struct bt_audio_codec_cfg *codec, enum bt_audio_dir dir)
{
	if (codec->id == BT_HCI_CODING_FORMAT_LC3) {
		/* LC3 uses the generic LTV format - other codecs might do as well */
		int ret;
		enum bt_audio_location chan_allocation;
		int freq_hz;
		int dur_us;
		uint32_t octets_per_sdu;
		int frame_blks_per_sdu;
		uint32_t bitrate;

		ret = le_audio_freq_hz_get(codec, &freq_hz);
		if (ret) {
			LOG_ERR("Error retrieving sampling frequency: %d", ret);
			return;
		}

		ret = le_audio_duration_us_get(codec, &dur_us);
		if (ret) {
			LOG_ERR("Error retrieving frame duration: %d", ret);
			return;
		}

		ret = le_audio_octets_per_frame_get(codec, &octets_per_sdu);
		if (ret) {
			LOG_ERR("Error retrieving octets per frame: %d", ret);
			return;
		}

		ret = le_audio_frame_blocks_per_sdu_get(codec, &frame_blks_per_sdu);
		if (ret) {
			LOG_ERR("Error retrieving frame blocks per SDU: %d", ret);
			return;
		}

		ret = bt_audio_codec_cfg_get_chan_allocation(codec, &chan_allocation);
		if (ret) {
			LOG_ERR("Error retrieving channel allocation: %d", ret);
			return;
		}

		ret = le_audio_bitrate_get(codec, &bitrate);
		if (ret) {
			LOG_ERR("Unable to calculate bitrate: %d", ret);
			return;
		}

		if (dir == BT_AUDIO_DIR_SINK) {
			LOG_INF("LC3 codec config for sink:");
		} else if (dir == BT_AUDIO_DIR_SOURCE) {
			LOG_INF("LC3 codec config for source:");
		} else {
			LOG_INF("LC3 codec config for <unknown dir>:");
		}

		LOG_INF("\tFrequency: %d Hz", freq_hz);
		LOG_INF("\tDuration: %d us", dur_us);
		LOG_INF("\tChannel allocation: 0x%x", chan_allocation);
		LOG_INF("\tOctets per frame: %d (%d bps)", octets_per_sdu, bitrate);
		LOG_INF("\tFrames per SDU: %d", frame_blks_per_sdu);
	} else {
		LOG_WRN("Codec is not LC3, codec_id: 0x%2x", codec->id);
	}
}

static int lc3_config_cb(struct bt_conn *conn, const struct bt_bap_ep *ep, enum bt_audio_dir dir,
			 const struct bt_audio_codec_cfg *codec, struct bt_bap_stream **stream,
			 struct bt_audio_codec_qos_pref *const pref, struct bt_bap_ascs_rsp *rsp)
{
	LOG_DBG("LC3 config callback");

	for (int i = 0; i < ARRAY_SIZE(audio_streams); i++) {
		struct bt_bap_stream *audio_stream = &audio_streams[i];

		if (!audio_stream->conn) {
			LOG_DBG("ASE Codec Config stream %p", (void *)audio_stream);

			int ret;
			uint32_t octets_per_sdu;

			ret = le_audio_octets_per_frame_get(codec, &octets_per_sdu);
			if (ret) {
				LOG_ERR("Error retrieving octets frame:, %d", ret);
				return ret;
			}

			if (octets_per_sdu > LE_AUDIO_SDU_SIZE_OCTETS(CONFIG_LC3_BITRATE_MAX)) {
				LOG_ERR("Too high bitrate");
				return -EINVAL;
			} else if (octets_per_sdu <
				   LE_AUDIO_SDU_SIZE_OCTETS(CONFIG_LC3_BITRATE_MIN)) {
				LOG_ERR("Too low bitrate");
				return -EINVAL;
			}

			if (dir == BT_AUDIO_DIR_SINK) {
				LOG_DBG("BT_AUDIO_DIR_SINK");
				print_codec(codec, dir);
				le_audio_event_publish(LE_AUDIO_EVT_CONFIG_RECEIVED, conn, dir);
			}
#if (CONFIG_BT_AUDIO_TX)
			else if (dir == BT_AUDIO_DIR_SOURCE) {
				LOG_DBG("BT_AUDIO_DIR_SOURCE");
				print_codec(codec, dir);
				le_audio_event_publish(LE_AUDIO_EVT_CONFIG_RECEIVED, conn, dir);

				/* CIS headset only supports one source stream for now */
				bap_tx_streams[0] = audio_stream;
			}
#endif /* (CONFIG_BT_AUDIO_TX) */
			else {
				LOG_ERR("UNKNOWN DIR");
				return -EINVAL;
			}

			*stream = audio_stream;
			*pref = qos_pref;

			return 0;
		}
	}

	LOG_WRN("No audio_stream available");
	return -ENOMEM;
}

static int lc3_reconfig_cb(struct bt_bap_stream *stream, enum bt_audio_dir dir,
			   const struct bt_audio_codec_cfg *codec,
			   struct bt_audio_codec_qos_pref *const pref, struct bt_bap_ascs_rsp *rsp)
{
	LOG_DBG("ASE Codec Reconfig: stream %p", (void *)stream);

	return 0;
}

static int lc3_qos_cb(struct bt_bap_stream *stream, const struct bt_audio_codec_qos *qos,
		      struct bt_bap_ascs_rsp *rsp)
{
	enum bt_audio_dir dir;

	dir = le_audio_stream_dir_get(stream);
	if (dir <= 0) {
		LOG_ERR("Failed to get dir of stream %p", stream);
		return -EIO;
	}

	le_audio_event_publish(LE_AUDIO_EVT_PRES_DELAY_SET, stream->conn, dir);

	LOG_DBG("QoS: stream %p qos %p", (void *)stream, (void *)qos);

	return 0;
}

static int lc3_enable_cb(struct bt_bap_stream *stream, const uint8_t *meta, size_t meta_len,
			 struct bt_bap_ascs_rsp *rsp)
{
	LOG_DBG("Enable: stream %p meta_len %d", (void *)stream, meta_len);

	return 0;
}

static int lc3_start_cb(struct bt_bap_stream *stream, struct bt_bap_ascs_rsp *rsp)
{
	LOG_DBG("Start stream %p", (void *)stream);
	return 0;
}

static int lc3_metadata_cb(struct bt_bap_stream *stream, const uint8_t *meta, size_t meta_len,
			   struct bt_bap_ascs_rsp *rsp)
{
	LOG_DBG("Metadata: stream %p meta_len %d", (void *)stream, meta_len);
	return 0;
}

static int lc3_disable_cb(struct bt_bap_stream *stream, struct bt_bap_ascs_rsp *rsp)
{
	enum bt_audio_dir dir;

	dir = le_audio_stream_dir_get(stream);
	if (dir <= 0) {
		LOG_ERR("Failed to get dir of stream %p", stream);
		return -EIO;
	}

	LOG_DBG("Disable: stream %p", (void *)stream);

	le_audio_event_publish(LE_AUDIO_EVT_NOT_STREAMING, stream->conn, dir);

	return 0;
}

static int lc3_stop_cb(struct bt_bap_stream *stream, struct bt_bap_ascs_rsp *rsp)
{
	enum bt_audio_dir dir;

	dir = le_audio_stream_dir_get(stream);
	if (dir <= 0) {
		LOG_ERR("Failed to get dir of stream %p", stream);
		return -EIO;
	}

	LOG_DBG("Stop: stream %p", (void *)stream);

	le_audio_event_publish(LE_AUDIO_EVT_NOT_STREAMING, stream->conn, dir);

	return 0;
}

static int lc3_release_cb(struct bt_bap_stream *stream, struct bt_bap_ascs_rsp *rsp)
{
	enum bt_audio_dir dir;

	dir = le_audio_stream_dir_get(stream);
	if (dir <= 0) {
		LOG_ERR("Failed to get dir of stream %p", stream);
		return -EIO;
	}

	LOG_DBG("Release: stream %p", (void *)stream);

	le_audio_event_publish(LE_AUDIO_EVT_NOT_STREAMING, stream->conn, dir);

	return 0;
}

static const struct bt_bap_unicast_server_cb unicast_server_cb = {
	.config = lc3_config_cb,
	.reconfig = lc3_reconfig_cb,
	.qos = lc3_qos_cb,
	.enable = lc3_enable_cb,
	.start = lc3_start_cb,
	.metadata = lc3_metadata_cb,
	.disable = lc3_disable_cb,
	.stop = lc3_stop_cb,
	.release = lc3_release_cb,
};

#if (CONFIG_BT_AUDIO_RX)
static void stream_recv_cb(struct bt_bap_stream *stream, const struct bt_iso_recv_info *info,
			   struct net_buf *buf)
{
	bool bad_frame = false;

	if (receive_cb == NULL) {
		LOG_ERR("The RX callback has not been set");
		return;
	}

	if (!(info->flags & BT_ISO_FLAGS_VALID)) {
		bad_frame = true;
	}

	receive_cb(buf->data, buf->len, bad_frame, info->ts, channel,
		   bt_audio_codec_cfg_get_octets_per_frame(stream->codec_cfg));
}
#endif /* (CONFIG_BT_AUDIO_RX) */

#if (CONFIG_BT_AUDIO_TX)
static void stream_sent_cb(struct bt_bap_stream *stream)
{
	/* Unicast server/CIS headset only supports one source stream for now */
	ERR_CHK(bt_le_audio_tx_stream_sent(0));
}
#endif /* (CONFIG_BT_AUDIO_TX) */

static void stream_enabled_cb(struct bt_bap_stream *stream)
{
	int ret;
	enum bt_audio_dir dir;

	dir = le_audio_stream_dir_get(stream);
	if (dir <= 0) {
		LOG_ERR("Failed to get dir of stream %p", stream);
		return;
	}

	LOG_DBG("Stream %p enabled", stream);

	if (dir == BT_AUDIO_DIR_SINK) {
		/* Automatically do the receiver start ready operation */
		ret = bt_bap_stream_start(stream);
		if (ret != 0) {
			LOG_ERR("Failed to start stream: %d", ret);
			return;
		}
	}
}

static void stream_disabled_cb(struct bt_bap_stream *stream)
{
	LOG_INF("Stream %p disabled", stream);
}

static void stream_started_cb(struct bt_bap_stream *stream)
{
	enum bt_audio_dir dir;

	dir = le_audio_stream_dir_get(stream);
	if (dir <= 0) {
		LOG_ERR("Failed to get dir of stream %p", stream);
		return;
	}

	LOG_INF("Stream %p started", stream);

	if (dir == BT_AUDIO_DIR_SOURCE) {
		ERR_CHK(bt_le_audio_tx_stream_started(0));
	}

	le_audio_event_publish(LE_AUDIO_EVT_STREAMING, stream->conn, dir);
}

static void stream_stopped_cb(struct bt_bap_stream *stream, uint8_t reason)
{
	enum bt_audio_dir dir;

	dir = le_audio_stream_dir_get(stream);
	if (dir <= 0) {
		LOG_ERR("Failed to get dir of stream %p", stream);
		return;
	}

	LOG_DBG("Stream %p stopped. Reason: %d", stream, reason);

	if (dir == BT_AUDIO_DIR_SOURCE) {
		ERR_CHK(bt_le_audio_tx_stream_stopped(0));
	}

	le_audio_event_publish(LE_AUDIO_EVT_NOT_STREAMING, stream->conn, dir);
}

static void stream_released_cb(struct bt_bap_stream *stream)
{
	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Stream %p released", stream);
}

static struct bt_bap_stream_ops stream_ops = {
#if (CONFIG_BT_AUDIO_RX)
	.recv = stream_recv_cb,
#endif /* (CONFIG_BT_AUDIO_RX) */
#if (CONFIG_BT_AUDIO_TX)
	.sent = stream_sent_cb,
#endif /* (CONFIG_BT_AUDIO_TX) */
	.enabled = stream_enabled_cb,
	.disabled = stream_disabled_cb,
	.started = stream_started_cb,
	.stopped = stream_stopped_cb,
	.released = stream_released_cb,
};

static int adv_buf_put(struct bt_data *adv_buf, uint8_t adv_buf_vacant, int *index, uint8_t type,
		       size_t data_len, const uint8_t *data)
{
	if ((adv_buf_vacant - *index) <= 0) {
		return -ENOMEM;
	}

	adv_buf[*index].type = type;
	adv_buf[*index].data_len = data_len;
	adv_buf[*index].data = data;
	(*index)++;

	return 0;
}

int unicast_server_config_get(struct bt_conn *conn, enum bt_audio_dir dir, uint32_t *bitrate,
			      uint32_t *sampling_rate_hz, uint32_t *pres_delay_us)
{
	int ret;

	if (bitrate == NULL && sampling_rate_hz == NULL && pres_delay_us == NULL) {
		LOG_ERR("No valid pointers received");
		return -ENXIO;
	}

	if (dir == BT_AUDIO_DIR_SINK) {
		/* If multiple sink streams exists, they should have the same configurations,
		 * hence we only check the first one.
		 */
		if (audio_streams[0].codec_cfg == NULL) {
			LOG_ERR("No codec found for the stream");

			return -ENXIO;
		}

		if (sampling_rate_hz != NULL) {
			ret = le_audio_freq_hz_get(audio_streams[0].codec_cfg, sampling_rate_hz);
			if (ret) {
				LOG_ERR("Invalid sampling frequency: %d", ret);
				return -ENXIO;
			}
		}

		if (bitrate != NULL) {
			ret = le_audio_bitrate_get(audio_streams[0].codec_cfg, bitrate);
			if (ret) {
				LOG_ERR("Unable to calculate bitrate: %d", ret);
				return -ENXIO;
			}
		}

		if (pres_delay_us != NULL) {
			if (audio_streams[0].qos == NULL) {
				LOG_ERR("No QoS found for the stream");
				return -ENXIO;
			}

			*pres_delay_us = audio_streams[0].qos->pd;
		}
	} else if (dir == BT_AUDIO_DIR_SOURCE) {
		/* If multiple source streams exists, they should have the same configurations,
		 * hence we only check the first one.
		 */
		if (bap_tx_streams[0]->codec_cfg == NULL) {
			LOG_ERR("No codec found for the stream");
			return -ENXIO;
		}

		if (sampling_rate_hz != NULL) {
			ret = le_audio_freq_hz_get(bap_tx_streams[0]->codec_cfg, sampling_rate_hz);
			if (ret) {
				LOG_ERR("Invalid sampling frequency: %d", ret);
				return -ENXIO;
			}
		}

		if (bitrate != NULL) {
			ret = le_audio_bitrate_get(bap_tx_streams[0]->codec_cfg, bitrate);
			if (ret) {
				LOG_ERR("Unable to calculate bitrate: %d", ret);
				return -ENXIO;
			}
		}

		if (pres_delay_us != NULL) {
			if (bap_tx_streams[0]->qos == NULL) {
				LOG_ERR("No QoS found for the stream");
				return -ENXIO;
			}

			*pres_delay_us = bap_tx_streams[0]->qos->pd;
			LOG_ERR("pres_delay_us: %d", *pres_delay_us);
		}
	}

	return 0;
}

int unicast_server_uuid_populate(struct net_buf_simple *uuid_buf)
{
	if (net_buf_simple_tailroom(uuid_buf) >= (BT_UUID_SIZE_16 * 2)) {
		net_buf_simple_add_le16(uuid_buf, BT_UUID_ASCS_VAL);
		net_buf_simple_add_le16(uuid_buf, BT_UUID_PACS_VAL);

	} else {
		LOG_ERR("Not enough space for UUIDS");
		return -ENOMEM;
	}

	return 0;
}

int unicast_server_adv_populate(struct bt_data *adv_buf, uint8_t adv_buf_vacant)
{
	int ret;
	int adv_buf_cnt = 0;

	ret = adv_buf_put(adv_buf, adv_buf_vacant, &adv_buf_cnt, BT_DATA_SVC_DATA16,
			  ARRAY_SIZE(unicast_server_adv_data), &unicast_server_adv_data[0]);
	if (ret) {
		return ret;
	}

	if (IS_ENABLED(CONFIG_BT_CSIP_SET_MEMBER)) {
		ret = adv_buf_put(adv_buf, adv_buf_vacant, &adv_buf_cnt, BT_DATA_CSIS_RSI,
				  ARRAY_SIZE(csip_rsi_adv_data), &csip_rsi_adv_data[0]);
		if (ret) {
			return ret;
		}
	}

	ret = adv_buf_put(adv_buf, adv_buf_vacant, &adv_buf_cnt, BT_DATA_GAP_APPEARANCE,
			  ARRAY_SIZE(gap_appear_adv_data), &gap_appear_adv_data[0]);
	if (ret) {
		return ret;
	}

	ret = adv_buf_put(adv_buf, adv_buf_vacant, &adv_buf_cnt, BT_DATA_FLAGS,
			  ARRAY_SIZE(flags_adv_data), &flags_adv_data[0]);
	if (ret) {
		return ret;
	}

	ret = adv_buf_put(adv_buf, adv_buf_vacant, &adv_buf_cnt, BT_DATA_SVC_DATA16,
			  ARRAY_SIZE(cap_adv_data), &cap_adv_data[0]);
	if (ret) {
		return ret;
	}

	return adv_buf_cnt;
}

int unicast_server_send(struct le_audio_encoded_audio enc_audio)
{
#if (CONFIG_BT_AUDIO_TX)
	int ret;

	ret = bt_le_audio_tx_send(bap_tx_streams, enc_audio, CONFIG_BT_ASCS_ASE_SRC_COUNT);
	if (ret) {
		return ret;
	}

	return 0;
#else
	return -ENOTSUP;
#endif /* (CONFIG_BT_AUDIO_TX) */
}

int unicast_server_disable(void)
{
	return -ENOTSUP;
}

int unicast_server_enable(le_audio_receive_cb recv_cb)
{
	int ret;
	static bool initialized;

	if (initialized) {
		LOG_WRN("Already initialized");
		return -EALREADY;
	}

	if (recv_cb == NULL) {
		LOG_ERR("Receive callback is NULL");
		return -EINVAL;
	}

	receive_cb = recv_cb;

	bt_bap_unicast_server_register_cb(&unicast_server_cb);

	channel_assignment_get(&channel);

	for (int i = 0; i < ARRAY_SIZE(caps); i++) {
		ret = bt_pacs_cap_register(caps_dirs[i], &caps[i]);
		if (ret) {
			LOG_ERR("Capability register failed");
			return ret;
		}
	}

	if (channel == AUDIO_CH_L) {
		csip_param.rank = CSIP_HL_RANK;

		ret = bt_pacs_set_location(BT_AUDIO_DIR_SINK, BT_AUDIO_LOCATION_FRONT_LEFT);
		if (ret) {
			LOG_ERR("Location set failed");
			return ret;
		}

	} else if (channel == AUDIO_CH_R) {
		csip_param.rank = CSIP_HR_RANK;

		ret = bt_pacs_set_location(BT_AUDIO_DIR_SINK, BT_AUDIO_LOCATION_FRONT_RIGHT);
		if (ret) {
			LOG_ERR("Location set failed");
			return ret;
		}

	} else {
		LOG_ERR("Channel not supported");
		return -ECANCELED;
	}

	if (IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL)) {
		ret = bt_le_audio_tx_init();
		if (ret) {
			return ret;
		}
		ret = bt_pacs_set_supported_contexts(BT_AUDIO_DIR_SINK,
						     BT_AUDIO_CONTEXT_TYPE_MEDIA |
							     BT_AUDIO_CONTEXT_TYPE_CONVERSATIONAL |
							     BT_AUDIO_CONTEXT_TYPE_UNSPECIFIED);

		if (ret) {
			LOG_ERR("Supported context set failed. Err: %d", ret);
			return ret;
		}

		ret = bt_pacs_set_available_contexts(BT_AUDIO_DIR_SINK,
						     BT_AUDIO_CONTEXT_TYPE_MEDIA |
							     BT_AUDIO_CONTEXT_TYPE_CONVERSATIONAL |
							     BT_AUDIO_CONTEXT_TYPE_UNSPECIFIED);
		if (ret) {
			LOG_ERR("Available context set failed. Err: %d", ret);
			return ret;
		}

		ret = bt_pacs_set_supported_contexts(BT_AUDIO_DIR_SOURCE,
						     BT_AUDIO_CONTEXT_TYPE_MEDIA |
							     BT_AUDIO_CONTEXT_TYPE_CONVERSATIONAL |
							     BT_AUDIO_CONTEXT_TYPE_UNSPECIFIED);

		if (ret) {
			LOG_ERR("Supported context set failed. Err: %d", ret);
			return ret;
		}

		ret = bt_pacs_set_available_contexts(BT_AUDIO_DIR_SOURCE,
						     BT_AUDIO_CONTEXT_TYPE_MEDIA |
							     BT_AUDIO_CONTEXT_TYPE_CONVERSATIONAL |
							     BT_AUDIO_CONTEXT_TYPE_UNSPECIFIED);
		if (ret) {
			LOG_ERR("Available context set failed. Err: %d", ret);
			return ret;
		}

		if (channel == AUDIO_CH_L) {
			ret = bt_pacs_set_location(BT_AUDIO_DIR_SOURCE,
						   BT_AUDIO_LOCATION_FRONT_LEFT);
			if (ret) {
				LOG_ERR("Location set failed");
				return ret;
			}
		} else if (channel == AUDIO_CH_R) {
			ret = bt_pacs_set_location(BT_AUDIO_DIR_SOURCE,
						   BT_AUDIO_LOCATION_FRONT_RIGHT);
			if (ret) {
				LOG_ERR("Location set failed");
				return ret;
			}
		} else {
			LOG_ERR("Channel not supported");
			return -ECANCELED;
		}
	} else {
		ret = bt_pacs_set_supported_contexts(BT_AUDIO_DIR_SINK,
						     BT_AUDIO_CONTEXT_TYPE_MEDIA |
							     BT_AUDIO_CONTEXT_TYPE_UNSPECIFIED);

		if (ret) {
			LOG_ERR("Supported context set failed. Err: %d ", ret);
			return ret;
		}

		ret = bt_pacs_set_available_contexts(BT_AUDIO_DIR_SINK,
						     BT_AUDIO_CONTEXT_TYPE_MEDIA |
							     BT_AUDIO_CONTEXT_TYPE_UNSPECIFIED);

		if (ret) {
			LOG_ERR("Available context set failed. Err: %d", ret);
			return ret;
		}
	}

	for (int i = 0; i < ARRAY_SIZE(audio_streams); i++) {
		bt_bap_stream_cb_register(&audio_streams[i], &stream_ops);
	}

	if (IS_ENABLED(CONFIG_BT_CSIP_SET_MEMBER)) {
		ret = bt_cap_acceptor_register(&csip_param, &csip);
		if (ret) {
			LOG_ERR("Failed to register CAP acceptor");
			return ret;
		}

		ret = bt_csip_set_member_generate_rsi(csip, csip_rsi_adv_data);
		if (ret) {
			LOG_ERR("Failed to generate RSI (ret %d)", ret);
			return ret;
		}
	}

	initialized = true;

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_stream/bt_le_audio_tx/CMakeLists.txt
#
# Copyright (c) 2024 Nordic Semiconductor
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

if (CONFIG_BT_AUDIO_TX)
	target_sources(app PRIVATE
		${CMAKE_CURRENT_SOURCE_DIR}/bt_le_audio_tx.c)
endif()


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_stream/bt_le_audio_tx/bt_le_audio_tx.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _LE_AUDIO_TX_H_
#define _LE_AUDIO_TX_H_

#include <zephyr/bluetooth/audio/audio.h>
#include <zephyr/bluetooth/audio/bap.h>

#include "le_audio.h"

/**
 * @brief Allocates buffers and sends data to the controller.
 *
 * @note	Send all available channels in a single call.
 *		Do not call this for each channel.
 *
 * @param bap_streams	Pointer to an array of BAP streams.
 * @param enc_audio	Encoded audio data.
 * @param streams_to_tx	Number of streams to send.
 *
 * @return 0 if successful, error otherwise.
 */
int bt_le_audio_tx_send(struct bt_bap_stream **bap_streams, struct le_audio_encoded_audio enc_audio,
			uint8_t streams_to_tx);

/**
 * @brief Resets TX buffers. Must be called when a TX stream is stopped.
 *
 * @param stream_idx	Stream index
 *
 * @retval  -EACCES  The module has not been initialized.
 * @retval  0 Success.
 */
int bt_le_audio_tx_stream_stopped(uint8_t stream_idx);

/**
 * @brief Initializes a stream. Must be called when a TX stream is started.
 *
 * @param stream_idx	Stream index.
 *
 * @retval  -EACCES  The module has not been initialized.
 * @retval  0 Success.
 */
int bt_le_audio_tx_stream_started(uint8_t stream_idx);

/**
 * @brief Frees a TX buffer. Must be called when a TX stream has been sent.
 *
 * @param stream_idx	Stream index.
 *
 * @retval  -EACCES  The module has not been initialized.
 * @retval  0 Success.
 */
int bt_le_audio_tx_stream_sent(uint8_t stream_idx);

/**
 * @brief Initializes the TX path for ISO transmission.
 *
 * @retval  -EALREADY  The module has already been initialized.
 * @retval  0 Success.
 */
int bt_le_audio_tx_init(void);

#endif /* _LE_AUDIO_TX_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_stream/bt_le_audio_tx/bt_le_audio_tx.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "bt_le_audio_tx.h"

#include <zephyr/bluetooth/audio/bap.h>
#include <zephyr/zbus/zbus.h>
#include <../subsys/bluetooth/audio/bap_stream.h>

#include "nrf5340_audio_common.h"
#include "audio_sync_timer.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(bt_le_audio_tx, CONFIG_BLE_LOG_LEVEL);

ZBUS_CHAN_DEFINE(sdu_ref_chan, struct sdu_ref_msg, NULL, NULL, ZBUS_OBSERVERS_EMPTY,
		 ZBUS_MSG_INIT(0));

#ifdef CONFIG_BT_BAP_UNICAST_SERVER
#define SRC_STREAM_COUNT CONFIG_BT_ASCS_ASE_SRC_COUNT
#elif CONFIG_BT_BAP_UNICAST_CLIENT
#define SRC_STREAM_COUNT CONFIG_BT_BAP_UNICAST_CLIENT_ASE_SNK_COUNT
#elif CONFIG_BT_BAP_BROADCAST_SOURCE
#define SRC_STREAM_COUNT CONFIG_BT_BAP_BROADCAST_SRC_STREAM_COUNT
#else
#define SRC_STREAM_COUNT 0
#endif

#define HCI_ISO_BUF_ALLOC_PER_CHAN 2

/* For being able to dynamically define iso_tx_pools */
#define NET_BUF_POOL_ITERATE(i, _)                                                                 \
	NET_BUF_POOL_FIXED_DEFINE(iso_tx_pool_##i, HCI_ISO_BUF_ALLOC_PER_CHAN,                     \
				  BT_ISO_SDU_BUF_SIZE(CONFIG_BT_ISO_TX_MTU), 8, NULL);
#define NET_BUF_POOL_PTR_ITERATE(i, ...) IDENTITY(&iso_tx_pool_##i)
LISTIFY(SRC_STREAM_COUNT, NET_BUF_POOL_ITERATE, (;))
/* clang-format off */
static struct net_buf_pool *iso_tx_pools[] = { LISTIFY(SRC_STREAM_COUNT,
						       NET_BUF_POOL_PTR_ITERATE, (,)) };
/* clang-format on */

struct tx_inf {
	struct bt_iso_tx_info iso_tx;
	struct bt_iso_tx_info iso_tx_readback;
	struct net_buf_pool *iso_tx_pool;
	atomic_t iso_tx_pool_alloc;
	bool hci_wrn_printed;
};

static bool initialized;
static struct tx_inf tx_info_arr[SRC_STREAM_COUNT];

/**
 * @brief Sends audio data over a single BAP stream.
 *
 * @param data			Audio data to send.
 * @param size			Size of data.
 * @param bap_stream		Pointer to BAP stream to use.
 * @param tx_info		Pointer to tx_info struct.
 * @param ts_tx		Timestamp to send. Note that for some controllers, BT_ISO_TIMESTAMP_NONE
 *			is used. This timestamp is used to ensure that SDUs are sent in the same
 *			connection interval.
 * @return		0 if successful, error otherwise.
 */
static int iso_stream_send(uint8_t const *const data, size_t size, struct bt_bap_stream *bap_stream,
			   struct tx_inf *tx_info, uint32_t ts_tx)
{
	int ret;
	struct net_buf *buf;

	/* net_buf_alloc allocates buffers for APP->NET transfer over HCI RPMsg,
	 * but when these buffers are released it is not guaranteed that the
	 * data has actually been sent. The data might be queued on the NET core,
	 * and this can cause delays in the audio.
	 * When the sent callback is called the data has been sent, and we can free the buffer.
	 * Data will be discarded if allocation becomes too high, to avoid audio delays.
	 * If the NET and APP core operates in clock sync, discarding should not occur.
	 */
	if (atomic_get(&tx_info->iso_tx_pool_alloc) >= HCI_ISO_BUF_ALLOC_PER_CHAN) {
		if (!tx_info->hci_wrn_printed) {
			struct bt_iso_chan *iso_chan;

			iso_chan = bt_bap_stream_iso_chan_get(bap_stream);

			LOG_WRN("HCI ISO TX overrun on stream %p - Single print",
				(void *)bap_stream);
			tx_info->hci_wrn_printed = true;
		}
		return -ENOMEM;
	}

	tx_info->hci_wrn_printed = false;

	buf = net_buf_alloc(tx_info->iso_tx_pool, K_NO_WAIT);
	if (buf == NULL) {
		/* This should never occur because of the iso_tx_pool_alloc check above */
		LOG_WRN("Out of TX buffers");
		return -ENOMEM;
	}

	net_buf_reserve(buf, BT_ISO_CHAN_SEND_RESERVE);
	net_buf_add_mem(buf, data, size);

	atomic_inc(&tx_info->iso_tx_pool_alloc);

	if (IS_ENABLED(CONFIG_BT_LL_ACS_NRF53)) {
		ret = bt_bap_stream_send(bap_stream, buf, tx_info->iso_tx.seq_num,
					 BT_ISO_TIMESTAMP_NONE);
	} else {
		ret = bt_bap_stream_send(bap_stream, buf, tx_info->iso_tx.seq_num, ts_tx);
	}

	if (ret < 0) {
		if (ret != -ENOTCONN) {
			LOG_WRN("Failed to send audio data: %d stream %p", ret, bap_stream);
		}
		net_buf_unref(buf);
		atomic_dec(&tx_info->iso_tx_pool_alloc);
		return ret;
	} else {
		tx_info->iso_tx.seq_num++;
	}

	return 0;
}

int bt_le_audio_tx_send(struct bt_bap_stream **bap_streams, struct le_audio_encoded_audio enc_audio,
			uint8_t streams_to_tx)
{
	int ret;
	size_t data_size_pr_stream = 0;

	if (!initialized) {
		return -EACCES;
	}

	if (bap_streams == NULL) {
		return -EINVAL;
	}

	if (streams_to_tx == 0) {
		LOG_INF("No active streams");
		return 0;
	}

	if (streams_to_tx > SRC_STREAM_COUNT) {
		return -ENOMEM;
	}

	if ((enc_audio.num_ch == 1) || (enc_audio.num_ch == streams_to_tx)) {
		data_size_pr_stream = enc_audio.size / enc_audio.num_ch;
	} else {
		LOG_ERR("Num encoded channels must be 1 or equal to num streams");
		return -EINVAL;
	}

	/* When sending ISO data, we always send ts = 0 to the first active transmitting channel.
	 * The controller will populate with a ts which is fetched using bt_iso_chan_get_tx_sync.
	 * This timestamp will be submitted to all the other channels in order to place data on all
	 * channels in the same ISO interval.
	 */

	uint32_t common_tx_sync_ts_us = 0;
	uint32_t curr_ts_us = 0;
	bool ts_common_acquired = false;
	uint32_t common_interval = 0;

	for (int i = 0; i < streams_to_tx; i++) {
		if (tx_info_arr[i].iso_tx.seq_num == 0) {
			/* Temporary fix until /zephyr/pull/68745/ is available
			 */
#if defined(CONFIG_BT_BAP_DEBUG_STREAM_SEQ_NUM)
			bap_streams[i]->_prev_seq_num = 0;
#endif /* CONFIG_BT_BAP_DEBUG_STREAM_SEQ_NUM */
		}

		if (!le_audio_ep_state_check(bap_streams[i]->ep, BT_BAP_EP_STATE_STREAMING)) {
			/* This bap_stream is not streaming*/
			continue;
		}

		uint32_t bitrate;

		ret = le_audio_bitrate_get(bap_streams[i]->codec_cfg, &bitrate);
		if (ret) {
			LOG_ERR("Failed to calculate bitrate: %d", ret);
			return ret;
		}

		if (data_size_pr_stream != LE_AUDIO_SDU_SIZE_OCTETS(bitrate)) {
			LOG_ERR("The encoded data size does not match the SDU size");
			return -EINVAL;
		}

		if (common_interval != 0 && (common_interval != bap_streams[i]->qos->interval)) {
			LOG_ERR("Not all channels have the same ISO interval");
			return -EINVAL;
		}
		common_interval = bap_streams[i]->qos->interval;

		/* Check if same audio is sent to all channels */
		if (enc_audio.num_ch == 1) {
			ret = iso_stream_send(enc_audio.data, data_size_pr_stream, bap_streams[i],
					      &tx_info_arr[i], common_tx_sync_ts_us);
		} else {
			ret = iso_stream_send(&enc_audio.data[data_size_pr_stream * i],
					      data_size_pr_stream, bap_streams[i], &tx_info_arr[i],
					      common_tx_sync_ts_us);
		}

		if (ret) {
			/* DBG used here as prints are handled within iso_stream_send */
			LOG_DBG("Failed to send to idx: %d stream: %p, ret: %d ", i, bap_streams[i],
				ret);
			continue;
		}

		/* Strictly, it is only required to call get_tx_sync on the first streaming channel
		 * to get the timestamp which is sent to all other channels. However, to be able to
		 * detect errors, this is called on each TX.
		 */
		ret = bt_bap_stream_get_tx_sync(bap_streams[i], &tx_info_arr[i].iso_tx_readback);
		if (ret) {
			if (ret != -ENOTCONN) {
				LOG_WRN("Unable to get tx sync. ret: %d stream: %p", ret,
					bap_streams[i]);
			}
			continue;
		}

		if (!ts_common_acquired) {
			curr_ts_us = audio_sync_timer_capture();
			common_tx_sync_ts_us = tx_info_arr[i].iso_tx_readback.ts;
			ts_common_acquired = true;
		}
	}

	if (ts_common_acquired) {
		/*TODO: Disabled for LL_ACS_NRF53 BIS due to timestamp issue */
		if (IS_ENABLED(CONFIG_BT_LL_ACS_NRF53) && IS_ENABLED(CONFIG_TRANSPORT_BIS)) {
			return 0;
		}

		struct sdu_ref_msg msg;

		msg.tx_sync_ts_us = common_tx_sync_ts_us;
		msg.curr_ts_us = curr_ts_us;
		msg.adjust = true;

		ret = zbus_chan_pub(&sdu_ref_chan, &msg, K_NO_WAIT);
		if (ret) {
			LOG_WRN("Failed to publish timestamp: %d", ret);
		}
	}

	return 0;
}

int bt_le_audio_tx_stream_stopped(uint8_t stream_idx)
{
	if (!initialized) {
		return -EACCES;
	}

	atomic_clear(&tx_info_arr[stream_idx].iso_tx_pool_alloc);
	tx_info_arr[stream_idx].hci_wrn_printed = false;

	return 0;
}

int bt_le_audio_tx_stream_started(uint8_t stream_idx)
{
	if (!initialized) {
		return -EACCES;
	}

	tx_info_arr[stream_idx].iso_tx.seq_num = 0;
	tx_info_arr[stream_idx].iso_tx_readback.seq_num = 0;
	return 0;
}

int bt_le_audio_tx_stream_sent(uint8_t stream_idx)
{
	if (!initialized) {
		return -EACCES;
	}

	atomic_dec(&tx_info_arr[stream_idx].iso_tx_pool_alloc);
	return 0;
}

int bt_le_audio_tx_init(void)
{
	if (initialized) {
		return -EALREADY;
	}

	for (int i = 0; i < SRC_STREAM_COUNT; i++) {
		tx_info_arr[i].iso_tx_pool = iso_tx_pools[i];
		tx_info_arr[i].hci_wrn_printed = false;
		tx_info_arr[i].iso_tx.ts = 0;
		tx_info_arr[i].iso_tx.offset = 0;
		tx_info_arr[i].iso_tx.seq_num = 0;
		tx_info_arr[i].iso_tx_readback.ts = 0;
		tx_info_arr[i].iso_tx_readback.offset = 0;
		tx_info_arr[i].iso_tx_readback.seq_num = 0;
	}

	initialized = true;
	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_stream/broadcast/Kconfig.defaults
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

config BT_BUF_ACL_RX_SIZE
	default 502 if (AUDIO_DFU > 0)

config BT_AUDIO_CODEC_CFG_MAX_METADATA_SIZE
	default 80


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_stream/broadcast/broadcast_sink.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BROADCAST_SINK_H_
#define _BROADCAST_SINK_H_

#include "bt_le_audio_tx.h"

/**
 * @brief	Change the active audio stream if the broadcast isochronous group (BIG) contains
 *              more than one broadcast isochronous stream (BIS).
 *
 * @note	Only streams within the same broadcast source are relevant, meaning
 *		that the broadcast source is not changed.
 *		The active stream will iterate every time this function is called.
 *
 * @return	0 for success, error otherwise.
 */
int broadcast_sink_change_active_audio_stream(void);

/**
 * @brief	Get configuration for the audio stream.
 *
 * @param[out]	bitrate		Pointer to the bitrate used; can be NULL.
 * @param[out]	sampling_rate	Pointer to the sampling rate used; can be NULL.
 * @param[out]	pres_delay	Pointer to the presentation delay used; can be NULL.
 *
 * @retval	0		Operation successful.
 * @retval	-ENXIO		The feature is disabled.
 */
int broadcast_sink_config_get(uint32_t *bitrate, uint32_t *sampling_rate, uint32_t *pres_delay);

/**
 * @brief	Set periodic advertising sync.
 *
 * @param[in]	pa_sync		Pointer to the periodic advertising sync.
 * @param[in]	broadcast_id	Broadcast ID of the periodic advertising.
 *
 * @return	0 for success, error otherwise.
 */
int broadcast_sink_pa_sync_set(struct bt_le_per_adv_sync *pa_sync, uint32_t broadcast_id);

/**
 * @brief	Start the Bluetooth LE Audio broadcast sink.
 *
 * @return	0 for success, error otherwise.
 */
int broadcast_sink_start(void);

/**
 * @brief	Stop the Bluetooth LE Audio broadcast sink.
 *
 * @return	0 for success, error otherwise.
 */
int broadcast_sink_stop(void);

/**
 * @brief	Disable the LE Audio broadcast (BIS) sink.
 *
 * @return	0 for success, error otherwise.
 */
int broadcast_sink_disable(void);

/**
 * @brief	Enable the LE Audio broadcast (BIS) sink.
 *
 * @param[in]	recv_cb		Callback for receiving Bluetooth LE Audio data.
 *
 * @return	0 for success, error otherwise.
 */
int broadcast_sink_enable(le_audio_receive_cb recv_cb);

#endif /* _BROADCAST_SINK_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_stream/broadcast/Kconfig
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

rsource "Kconfig.defaults"

menu "Broadcast"

choice BT_AUDIO_BROADCAST_BAP_CONFIGURATION
	prompt "Broadcast codec configuration"
	depends on TRANSPORT_BIS
	default BT_AUDIO_BROADCAST_CONFIGURABLE
	help
	  Select the broadcast codec configuration as given
	  in Table 6.4 of the Bluetooth Audio Profile specification.
	  USB only supports 48-kHz sampling rate.

config BT_AUDIO_BROADCAST_CONFIGURABLE
	bool "Configurable broadcast settings"
	depends on TRANSPORT_BIS
	help
	  Configurable option that doesn't follow any preset. Allows for more flexibility.

config BT_BAP_BROADCAST_16_2_1
	bool "16_2_1"
	depends on TRANSPORT_BIS
	help
	  Broadcast mandatory codec capability 16_2_1.
	  16kHz, 32kbps, 2 retransmits, 10ms transport latency, and 40ms presentation delay.

config BT_BAP_BROADCAST_24_2_1
	bool "24_2_1"
	depends on TRANSPORT_BIS
	help
	  Broadcast codec capability 24_2_1.
	  24kHz, 48kbps, 2 retransmits, 10ms transport latency, and 40ms presentation delay.

config BT_BAP_BROADCAST_16_2_2
	bool "16_2_2"
	depends on TRANSPORT_BIS
	help
	  Broadcast mandatory codec capability 16_2_2.
	  16kHz, 32kbps, 4 retransmits, 60ms transport latency, and 40ms presentation delay.

config BT_BAP_BROADCAST_24_2_2
	bool "24_2_2"
	depends on TRANSPORT_BIS
	help
	  Broadcast codec capability 24_2_2.
	  24kHz, 48kbps, 4 retransmits, 60ms transport latency, and 40ms presentation delay.
endchoice

config BT_AUDIO_BROADCAST_NAME
	string "Broadcast name"
	default "NRF5340_BROADCASTER"
	# TODO: Add back 'depends on TRANSPORT_BIS' once applications are ready
	help
	  Name of the broadcast; not the same as BT_DEVICE_NAME.

config BT_AUDIO_BROADCAST_NAME_ALT
	string "Alternative broadcast name"
	default "NRF5340_BROADCASTER_ALT"
	# TODO: Add back 'depends on TRANSPORT_BIS' once applications are ready
	help
	  Alternative name of the broadcast.

config BT_AUDIO_USE_BROADCAST_NAME_ALT
	bool "Use the alternative broadcast name"
	default n
	# TODO: Add back 'depends on TRANSPORT_BIS' once applications are ready
	help
	  Use the alternative broadcast name.

config BT_AUDIO_BROADCAST_ENCRYPTED
	bool "Encrypted broadcast"
	depends on TRANSPORT_BIS
	default n
	help
	  Encrypt the broadcast to limit the connection possibilities.

config BT_AUDIO_BROADCAST_ENCRYPTION_KEY
	string "Broadcast encryption key"
	depends on TRANSPORT_BIS
	default "NRF5340_BIS_DEMO"
	help
	  Key to use for encryption and decryption, with maximum BT_ISO_BROADCAST_CODE_SIZE
	  characters. Encryption keys larger than BT_ISO_BROADCAST_CODE_SIZE will be truncated to
	  BT_ISO_BROADCAST_CODE_SIZE.

config BT_AUDIO_USE_BROADCAST_ID_RANDOM
	bool "Use a random broadcast ID"
	depends on TRANSPORT_BIS
	default y
	help
	  Use a randomly generated broadcast ID.

config BT_AUDIO_BROADCAST_ID_FIXED
	hex "Fixed broadcast ID"
	depends on TRANSPORT_BIS
	default 0x123456
	help
	  Fixed broadcast ID; 3 octets. Will only be used if BT_AUDIO_USE_BROADCAST_ID_RANDOM=n.
	  Only use for debugging.

config BT_AUDIO_BROADCAST_PARENTAL_RATING
	hex "Parental rating"
	depends on TRANSPORT_BIS
	default 0x00
	range 0x00 0x0F
	help
	  Set the parental rating for the broadcast.
	  BT_AUDIO_PARENTAL_RATING_NO_RATING        = 0x00,
	  BT_AUDIO_PARENTAL_RATING_AGE_ANY          = 0x01,
	  BT_AUDIO_PARENTAL_RATING_AGE_5_OR_ABOVE   = 0x02,
	  BT_AUDIO_PARENTAL_RATING_AGE_6_OR_ABOVE   = 0x03,
	  BT_AUDIO_PARENTAL_RATING_AGE_7_OR_ABOVE   = 0x04,
	  BT_AUDIO_PARENTAL_RATING_AGE_8_OR_ABOVE   = 0x05,
	  BT_AUDIO_PARENTAL_RATING_AGE_9_OR_ABOVE   = 0x06,
	  BT_AUDIO_PARENTAL_RATING_AGE_10_OR_ABOVE  = 0x07,
	  BT_AUDIO_PARENTAL_RATING_AGE_11_OR_ABOVE  = 0x08,
	  BT_AUDIO_PARENTAL_RATING_AGE_12_OR_ABOVE  = 0x09,
	  BT_AUDIO_PARENTAL_RATING_AGE_13_OR_ABOVE  = 0x0A,
	  BT_AUDIO_PARENTAL_RATING_AGE_14_OR_ABOVE  = 0x0B,
	  BT_AUDIO_PARENTAL_RATING_AGE_15_OR_ABOVE  = 0x0C,
	  BT_AUDIO_PARENTAL_RATING_AGE_16_OR_ABOVE  = 0x0D,
	  BT_AUDIO_PARENTAL_RATING_AGE_17_OR_ABOVE  = 0x0E,
	  BT_AUDIO_PARENTAL_RATING_AGE_18_OR_ABOVE  = 0x0F

config BT_AUDIO_BROADCAST_IMMEDIATE_FLAG
	bool "Immediate rendering flag"
	depends on TRANSPORT_BIS
	default n
	help
	  Set the immediate rendering flag.

config AURACAST
	bool "Enable Auracast"
	depends on TRANSPORT_BIS
	default y
	help
	  When Auracast is enabled, a Public Broadcast Announcement will be included
	  when advertising.

config BT_AUDIO_BITRATE_BROADCAST_SRC
	int "ISO stream bitrate"
	depends on TRANSPORT_BIS
	default 96000 if BT_AUDIO_BROADCAST_CONFIGURABLE
	default 32000 if BT_BAP_BROADCAST_16_2_1 || BT_BAP_BROADCAST_16_2_2
	default 48000 if BT_BAP_BROADCAST_24_2_1 || BT_BAP_BROADCAST_24_2_2
	help
	  Bitrate for the broadcast source ISO stream.

#----------------------------------------------------------------------------#
menu "Log levels"

module = BROADCAST_SOURCE
module-str = broadcast_source
source "subsys/logging/Kconfig.template.log_config"

module = BROADCAST_SINK
module-str = broadcast_sink
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log levels
endmenu # Broadcast


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_stream/broadcast/broadcast_source.c
/*
 * Copyright (c) 2022 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "broadcast_source.h"

#include <zephyr/zbus/zbus.h>
#include <zephyr/sys/byteorder.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/audio/audio.h>
#include <zephyr/bluetooth/audio/cap.h>
#include <../subsys/bluetooth/audio/bap_iso.h>
#include <zephyr/bluetooth/audio/bap_lc3_preset.h>

/* TODO: Remove when a get_info function is implemented in host */
#include <../subsys/bluetooth/audio/bap_endpoint.h>

#include "macros_common.h"
#include "bt_le_audio_tx.h"
#include "nrf5340_audio_common.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(broadcast_source, CONFIG_BROADCAST_SOURCE_LOG_LEVEL);

/* Length-type-value size for channel allocation */
#define LTV_CHAN_ALLOC_SIZE 6

BUILD_ASSERT(CONFIG_BT_BAP_BROADCAST_SRC_STREAM_COUNT <= 2,
	     "A maximum of two audio streams are currently supported");

ZBUS_CHAN_DEFINE(le_audio_chan, struct le_audio_msg, NULL, NULL, ZBUS_OBSERVERS_EMPTY,
		 ZBUS_MSG_INIT(0));

#if CONFIG_BT_AUDIO_BROADCAST_CONFIGURABLE
#define BT_BAP_LC3_BROADCAST_PRESET_NRF5340_AUDIO                                                  \
	BT_BAP_LC3_PRESET_CONFIGURABLE(                                                            \
		BT_AUDIO_LOCATION_FRONT_LEFT | BT_AUDIO_LOCATION_FRONT_RIGHT,                      \
		BT_AUDIO_CONTEXT_TYPE_MEDIA, CONFIG_BT_AUDIO_BITRATE_BROADCAST_SRC)

#elif CONFIG_BT_BAP_BROADCAST_16_2_1
#define BT_BAP_LC3_BROADCAST_PRESET_NRF5340_AUDIO                                                  \
	BT_BAP_LC3_BROADCAST_PRESET_16_2_1(BT_AUDIO_LOCATION_FRONT_LEFT |                          \
						   BT_AUDIO_LOCATION_FRONT_RIGHT,                  \
					   BT_AUDIO_CONTEXT_TYPE_MEDIA)

#elif CONFIG_BT_BAP_BROADCAST_24_2_1
#define BT_BAP_LC3_BROADCAST_PRESET_NRF5340_AUDIO                                                  \
	BT_BAP_LC3_BROADCAST_PRESET_24_2_1(BT_AUDIO_LOCATION_FRONT_LEFT |                          \
						   BT_AUDIO_LOCATION_FRONT_RIGHT,                  \
					   BT_AUDIO_CONTEXT_TYPE_MEDIA)

#elif CONFIG_BT_BAP_BROADCAST_16_2_2
#define BT_BAP_LC3_BROADCAST_PRESET_NRF5340_AUDIO                                                  \
	BT_BAP_LC3_BROADCAST_PRESET_16_2_2(BT_AUDIO_LOCATION_FRONT_LEFT |                          \
						   BT_AUDIO_LOCATION_FRONT_RIGHT,                  \
					   BT_AUDIO_CONTEXT_TYPE_MEDIA)

#elif CONFIG_BT_BAP_BROADCAST_24_2_2
#define BT_BAP_LC3_BROADCAST_PRESET_NRF5340_AUDIO                                                  \
	BT_BAP_LC3_BROADCAST_PRESET_24_2_2(BT_AUDIO_LOCATION_FRONT_LEFT |                          \
						   BT_AUDIO_LOCATION_FRONT_RIGHT,                  \
					   BT_AUDIO_CONTEXT_TYPE_MEDIA)

#else
#error Unsupported LC3 codec preset for broadcast
#endif /* CONFIG_BT_AUDIO_BROADCAST_CONFIGURABLE */

static struct bt_cap_broadcast_source *broadcast_source;
static struct bt_cap_stream cap_streams[CONFIG_BT_BAP_BROADCAST_SRC_STREAM_COUNT];
static struct bt_bap_lc3_preset lc3_preset = BT_BAP_LC3_BROADCAST_PRESET_NRF5340_AUDIO;
static struct bt_le_ext_adv *adv;
static bool initialized;
static bool delete_broadcast_src;

#if (CONFIG_AURACAST)
/* Make sure pba_buf is large enough for a 16bit UUID and meta data
 * (any addition to pba_buf requires an increase of this value)
 */
NET_BUF_SIMPLE_DEFINE(pba_buf, BT_UUID_SIZE_16 + 8);
static struct bt_data ext_ad[4];
#else
static struct bt_data ext_ad[3];
#endif /* (CONFIG_AURACAST) */

static struct bt_data per_ad[1];

static void le_audio_event_publish(enum le_audio_evt_type event)
{
	int ret;
	struct le_audio_msg msg;

	msg.event = event;

	ret = zbus_chan_pub(&le_audio_chan, &msg, LE_AUDIO_ZBUS_EVENT_WAIT_TIME);
	ERR_CHK(ret);
}

static int get_stream_index(struct bt_bap_stream *stream, uint8_t *index)
{
	for (int i = 0; i < ARRAY_SIZE(cap_streams); i++) {
		if (&cap_streams[i].bap_stream == stream) {
			*index = i;
			return 0;
		}
	}

	LOG_WRN("Stream %p not found", (void *)stream);

	return -EINVAL;
}

static void stream_sent_cb(struct bt_bap_stream *stream)
{
	uint8_t index = 0;

	get_stream_index(stream, &index);
	ERR_CHK(bt_le_audio_tx_stream_sent(index));
}

static void stream_started_cb(struct bt_bap_stream *stream)
{
	uint8_t index = 0;

	get_stream_index(stream, &index);
	ERR_CHK(bt_le_audio_tx_stream_started(index));

	le_audio_event_publish(LE_AUDIO_EVT_STREAMING);

	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Broadcast source %p started", (void *)stream);
}

static void stream_stopped_cb(struct bt_bap_stream *stream, uint8_t reason)
{
	int ret;
	uint8_t index = 0;

	get_stream_index(stream, &index);

	le_audio_event_publish(LE_AUDIO_EVT_NOT_STREAMING);

	ERR_CHK(bt_le_audio_tx_stream_stopped(index));

	LOG_INF("Broadcast source %p stopped. Reason: %d", (void *)stream, reason);

	if (delete_broadcast_src && broadcast_source != NULL) {
		ret = bt_cap_initiator_broadcast_audio_delete(broadcast_source);
		if (ret) {
			LOG_ERR("Unable to delete broadcast source %p", (void *)stream);
			delete_broadcast_src = false;
			return;
		}

		broadcast_source = NULL;

		LOG_INF("Broadcast source %p deleted", (void *)stream);

		delete_broadcast_src = false;
	}
}

static struct bt_bap_stream_ops stream_ops = {
	.sent = stream_sent_cb,
	.started = stream_started_cb,
	.stopped = stream_stopped_cb,
};

#if (CONFIG_AURACAST)
static void public_broadcast_features_set(uint8_t *features)
{
	int freq = bt_audio_codec_cfg_get_freq(&lc3_preset.codec_cfg);

	if (features == NULL) {
		LOG_ERR("No pointer to features");
		return;
	}

	if (IS_ENABLED(CONFIG_BT_AUDIO_BROADCAST_ENCRYPTED)) {
		*features |= 0x01;
	}

	if (freq == BT_AUDIO_CODEC_CONFIG_LC3_FREQ_16KHZ ||
	    freq == BT_AUDIO_CODEC_CONFIG_LC3_FREQ_24KHZ) {
		*features |= 0x02;
	} else if (freq == BT_AUDIO_CODEC_CONFIG_LC3_FREQ_48KHZ) {
		*features |= 0x04;
	} else {
		LOG_WRN("%dkHz is not compatible with Auracast, choose 16kHz, 24kHz or 48kHz",
			freq);
	}
}
#endif /* (CONFIG_AURACAST) */

static int adv_create(void)
{
	int ret;
	uint32_t broadcast_id = 0;

	/* Broadcast Audio Streaming Endpoint advertising data */
	NET_BUF_SIMPLE_DEFINE_STATIC(brdcst_id_buf, BT_UUID_SIZE_16 + BT_AUDIO_BROADCAST_ID_SIZE);
	/* Buffer for Appearance */
	NET_BUF_SIMPLE_DEFINE_STATIC(brdcst_appearance_buf, BT_UUID_SIZE_16);
	/* Buffer for Public Broadcast Announcement */
	NET_BUF_SIMPLE_DEFINE_STATIC(base_buf, 128);

	if (IS_ENABLED(CONFIG_BT_AUDIO_USE_BROADCAST_ID_RANDOM)) {
		ret = bt_cap_initiator_broadcast_get_id(broadcast_source, &broadcast_id);
		if (ret) {
			LOG_ERR("Unable to get broadcast ID: %d", ret);
			return ret;
		}
	} else {
		broadcast_id = CONFIG_BT_AUDIO_BROADCAST_ID_FIXED;
	}

	if (IS_ENABLED(CONFIG_BT_AUDIO_USE_BROADCAST_NAME_ALT)) {
		ext_ad[0] = (struct bt_data)BT_DATA(BT_DATA_BROADCAST_NAME,
						    CONFIG_BT_AUDIO_BROADCAST_NAME_ALT,
						    sizeof(CONFIG_BT_AUDIO_BROADCAST_NAME_ALT) - 1);
	} else {
		ext_ad[0] = (struct bt_data)BT_DATA(BT_DATA_BROADCAST_NAME,
						    CONFIG_BT_AUDIO_BROADCAST_NAME,
						    sizeof(CONFIG_BT_AUDIO_BROADCAST_NAME) - 1);
	}

	/* Setup extended advertising data */
	net_buf_simple_add_le16(&brdcst_id_buf, BT_UUID_BROADCAST_AUDIO_VAL);
	net_buf_simple_add_le24(&brdcst_id_buf, broadcast_id);

	ext_ad[1].data_len = brdcst_id_buf.len;
	ext_ad[1].type = BT_DATA_SVC_DATA16;
	ext_ad[1].data = brdcst_id_buf.data;

	net_buf_simple_add_le16(&brdcst_appearance_buf, CONFIG_BT_DEVICE_APPEARANCE);

	ext_ad[2].data_len = brdcst_appearance_buf.len;
	ext_ad[2].type = BT_DATA_GAP_APPEARANCE;
	ext_ad[2].data = brdcst_appearance_buf.data;

#if (CONFIG_AURACAST)
	uint8_t pba_features = 0;
	public_broadcast_features_set(&pba_features);

	net_buf_simple_add_le16(&pba_buf, 0x1856);
	net_buf_simple_add_u8(&pba_buf, pba_features);

	/* Metadata */
	/* 3 bytes for parental_rating and 3 bytes for active_flag LTVs */
	net_buf_simple_add_u8(&pba_buf, 0x06);

	/* Parental rating*/
	/* Length */
	net_buf_simple_add_u8(&pba_buf, 0x02);
	/* Type */
	net_buf_simple_add_u8(&pba_buf, BT_AUDIO_METADATA_TYPE_PARENTAL_RATING);
	/* Value */
	net_buf_simple_add_u8(&pba_buf, CONFIG_BT_AUDIO_BROADCAST_PARENTAL_RATING);

	/* Active flag */
	/* Length */
	net_buf_simple_add_u8(&pba_buf, 0x02);
	/* Type */
	net_buf_simple_add_u8(&pba_buf, BT_AUDIO_METADATA_TYPE_AUDIO_STATE);
	/* Value */
	net_buf_simple_add_u8(&pba_buf, BT_AUDIO_ACTIVE_STATE_ENABLED);

	/* If any additional data is to be added, remember to increase NET_BUF size */

	ext_ad[3].data_len = pba_buf.len;
	ext_ad[3].type = BT_DATA_SVC_DATA16;
	ext_ad[3].data = pba_buf.data;
#endif /* (CONFIG_AURACAST) */

	/* Setup periodic advertising data */
	ret = bt_cap_initiator_broadcast_get_base(broadcast_source, &base_buf);
	if (ret) {
		LOG_ERR("Failed to get encoded BASE: %d", ret);
		return ret;
	}

	per_ad[0].data_len = base_buf.len;
	per_ad[0].type = BT_DATA_SVC_DATA16;
	per_ad[0].data = base_buf.data;

	return 0;
}

/**
 * @brief Set the channel allocation to a preset codec configuration.
 *
 * @param	data		The preset codec configuration.
 * @param	data_len	Length of @p data
 * @param	loc		Location bitmask setting.
 */
static void bt_audio_codec_allocation_set(uint8_t *data, uint8_t data_len,
					  enum bt_audio_location loc)
{
	data[0] = data_len - 1;
	data[1] = BT_AUDIO_CODEC_CONFIG_LC3_CHAN_ALLOC;
	sys_put_le32((const uint32_t)loc, &data[2]);
}

void broadcast_source_adv_get(const struct bt_data **ext_adv, size_t *ext_adv_size,
			      const struct bt_data **per_adv, size_t *per_adv_size)
{
	*ext_adv = ext_ad;
	*ext_adv_size = ARRAY_SIZE(ext_ad);
	*per_adv = per_ad;
	*per_adv_size = ARRAY_SIZE(per_ad);
}

int broadcast_source_start(struct bt_le_ext_adv *ext_adv)
{
	int ret;

	if (ext_adv != NULL) {
		adv = ext_adv;
	}

	if (adv == NULL) {
		LOG_ERR("No advertising set available");
		return -EINVAL;
	}

	LOG_DBG("Starting broadcast source");

	/* All streams in a broadcast source is in the same state,
	 * so we can just check the first stream
	 */
	if (cap_streams[0].bap_stream.ep == NULL) {
		LOG_ERR("stream->ep is NULL");
		return -ECANCELED;
	}

	if (cap_streams[0].bap_stream.ep->status.state == BT_BAP_EP_STATE_STREAMING) {
		LOG_WRN("Already streaming");
		return -EALREADY;
	}

	ret = bt_cap_initiator_broadcast_audio_start(broadcast_source, adv);
	if (ret) {
		LOG_WRN("Failed to start broadcast, ret: %d", ret);
		return ret;
	}

	return 0;
}

int broadcast_source_stop(void)
{
	int ret;

	/* All streams in a broadcast source is in the same state,
	 * so we can just check the first stream
	 */
	if (cap_streams[0].bap_stream.ep == NULL) {
		LOG_ERR("stream->ep is NULL");
		return -ECANCELED;
	}

	if (cap_streams[0].bap_stream.ep->status.state == BT_BAP_EP_STATE_STREAMING) {
		ret = bt_cap_initiator_broadcast_audio_stop(broadcast_source);
		if (ret) {
			LOG_WRN("Failed to stop broadcast, ret: %d", ret);
			return ret;
		}
	} else {
		LOG_WRN("Not in a streaming state");
		return -EINVAL;
	}

	return 0;
}

int broadcast_source_send(struct le_audio_encoded_audio enc_audio)
{
	int ret;
	struct bt_bap_stream *bap_tx_streams[CONFIG_BT_BAP_BROADCAST_SRC_STREAM_COUNT];

	for (int i = 0; i < ARRAY_SIZE(cap_streams); i++) {
		bap_tx_streams[i] = &cap_streams[i].bap_stream;
	}

	ret = bt_le_audio_tx_send(bap_tx_streams, enc_audio, ARRAY_SIZE(cap_streams));
	if (ret) {
		return ret;
	}

	return 0;
}

int broadcast_source_disable(void)
{
	int ret;

	if (cap_streams[0].bap_stream.ep->status.state == BT_BAP_EP_STATE_STREAMING) {
		/* Deleting broadcast source in stream_stopped_cb() */
		delete_broadcast_src = true;

		ret = bt_cap_initiator_broadcast_audio_stop(broadcast_source);
		if (ret) {
			return ret;
		}
	} else if (broadcast_source != NULL) {
		ret = bt_cap_initiator_broadcast_audio_delete(broadcast_source);
		if (ret) {
			return ret;
		}

		broadcast_source = NULL;
	}

	initialized = false;

	LOG_DBG("Broadcast source disabled");

	return 0;
}

int broadcast_source_enable(void)
{
	int ret;

	struct bt_cap_initiator_broadcast_stream_param stream_params[ARRAY_SIZE(cap_streams)];
	uint8_t bis_codec_data[ARRAY_SIZE(stream_params)][LTV_CHAN_ALLOC_SIZE];
	struct bt_cap_initiator_broadcast_subgroup_param
		subgroup_params[CONFIG_BT_BAP_BROADCAST_SRC_SUBGROUP_COUNT];
	struct bt_cap_initiator_broadcast_create_param create_param;

	if (initialized) {
		LOG_WRN("Already initialized");
		return -EALREADY;
	}

	ret = bt_le_audio_tx_init();
	if (ret) {
		return ret;
	}

	LOG_INF("Enabling broadcast_source %s", CONFIG_BT_AUDIO_BROADCAST_NAME);

	(void)memset(cap_streams, 0, sizeof(cap_streams));

	/* Populate BISes */
	for (size_t i = 0; i < ARRAY_SIZE(stream_params); i++) {
		stream_params[i].stream = &cap_streams[i];

		bt_cap_stream_ops_register(stream_params[i].stream, &stream_ops);
		/* TODO: Remove this once the fixed call above has been upstreamed */
		bt_bap_stream_cb_register(&stream_params[i].stream->bap_stream, &stream_ops);

		stream_params[i].data_len = ARRAY_SIZE(bis_codec_data[i]);
		stream_params[i].data = bis_codec_data[i];

		/* The channel allocation is set incrementally */
		bt_audio_codec_allocation_set(stream_params[i].data, stream_params[i].data_len,
					      BIT(i));
	}

	/* Create BIGs */
	for (size_t i = 0U; i < ARRAY_SIZE(subgroup_params); i++) {
		subgroup_params[i].stream_count = ARRAY_SIZE(stream_params);
		subgroup_params[i].stream_params = &stream_params[i];
		subgroup_params[i].codec_cfg = &lc3_preset.codec_cfg;
#if (CONFIG_BT_AUDIO_BROADCAST_IMMEDIATE_FLAG)
		bt_audio_codec_cfg_meta_set_bcast_audio_immediate_rend_flag(
			subgroup_params[i].codec_cfg);
#endif /* (CONFIG_BT_AUDIO_BROADCAST_IMMEDIATE_FLAG) */
	}

	/* Create broadcast_source */
	create_param.subgroup_count = ARRAY_SIZE(subgroup_params);
	create_param.subgroup_params = subgroup_params;
	create_param.qos = &lc3_preset.qos;

	if (IS_ENABLED(CONFIG_BT_AUDIO_PACKING_INTERLEAVED)) {
		create_param.packing = BT_ISO_PACKING_INTERLEAVED;
	} else {
		create_param.packing = BT_ISO_PACKING_SEQUENTIAL;
	}

	if (IS_ENABLED(CONFIG_BT_AUDIO_BROADCAST_ENCRYPTED)) {
		create_param.encryption = true;
		memset(create_param.broadcast_code, 0, sizeof(create_param.broadcast_code));
		memcpy(create_param.broadcast_code, CONFIG_BT_AUDIO_BROADCAST_ENCRYPTION_KEY,
		       MIN(sizeof(CONFIG_BT_AUDIO_BROADCAST_ENCRYPTION_KEY),
			   sizeof(create_param.broadcast_code)));
	} else {
		create_param.encryption = false;
	}

	LOG_DBG("Creating broadcast source");

	ret = bt_cap_initiator_broadcast_audio_create(&create_param, &broadcast_source);
	if (ret) {
		LOG_ERR("Failed to create broadcast source, ret: %d", ret);
		return ret;
	}

	/* Create advertising set */
	ret = adv_create();
	if (ret) {
		LOG_ERR("Failed to create advertising set");
		return ret;
	}

	initialized = true;

	LOG_DBG("Broadcast source enabled");

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_stream/broadcast/broadcast_sink.c
/*
 * Copyright (c) 2022 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "broadcast_sink.h"

#include <zephyr/zbus/zbus.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/audio/audio.h>
#include <zephyr/bluetooth/audio/pacs.h>
#include <zephyr/sys/byteorder.h>

/* TODO: Remove when a get_info function is implemented in host */
#include <../subsys/bluetooth/audio/bap_endpoint.h>

#include "macros_common.h"
#include "nrf5340_audio_common.h"
#include "channel_assignment.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(broadcast_sink, CONFIG_BROADCAST_SINK_LOG_LEVEL);

BUILD_ASSERT(CONFIG_BT_BAP_BROADCAST_SNK_STREAM_COUNT <= 2,
	     "A maximum of two broadcast streams are currently supported");

ZBUS_CHAN_DEFINE(le_audio_chan, struct le_audio_msg, NULL, NULL, ZBUS_OBSERVERS_EMPTY,
		 ZBUS_MSG_INIT(0));

struct audio_codec_info {
	uint8_t id;
	uint16_t cid;
	uint16_t vid;
	int frequency;
	int frame_duration_us;
	enum bt_audio_location chan_allocation;
	int octets_per_sdu;
	int bitrate;
	int blocks_per_sdu;
};

struct active_audio_stream {
	struct bt_bap_stream *stream;
	struct audio_codec_info *codec;
	uint32_t pd;
};

static struct bt_bap_broadcast_sink *broadcast_sink;
static struct bt_bap_stream audio_streams[CONFIG_BT_BAP_BROADCAST_SNK_STREAM_COUNT];
static struct audio_codec_info audio_codec_info[CONFIG_BT_BAP_BROADCAST_SNK_STREAM_COUNT];
static uint32_t bis_index_bitfields[CONFIG_BT_BAP_BROADCAST_SNK_STREAM_COUNT];

static struct bt_le_per_adv_sync *pa_sync_stored;

static struct active_audio_stream active_stream;

/* The values of sync_stream_cnt and active_stream_index must never become larger
 * than the sizes of the arrays above (audio_streams etc.)
 */
static uint8_t sync_stream_cnt;
static uint8_t active_stream_index;

static struct bt_audio_codec_cap codec_cap = BT_AUDIO_CODEC_CAP_LC3(
	BT_AUDIO_CODEC_CAPABILIY_FREQ,
	(BT_AUDIO_CODEC_LC3_DURATION_10 | BT_AUDIO_CODEC_LC3_DURATION_PREFER_10),
	BT_AUDIO_CODEC_LC3_CHAN_COUNT_SUPPORT(1), LE_AUDIO_SDU_SIZE_OCTETS(CONFIG_LC3_BITRATE_MIN),
	LE_AUDIO_SDU_SIZE_OCTETS(CONFIG_LC3_BITRATE_MAX), 1u, BT_AUDIO_CONTEXT_TYPE_MEDIA);

static struct bt_pacs_cap capabilities = {
	.codec_cap = &codec_cap,
};

static le_audio_receive_cb receive_cb;

static bool init_routine_completed;
static bool paused;

static int broadcast_sink_cleanup(void)
{
	int ret;

	init_routine_completed = false;

	active_stream.pd = 0;
	active_stream.stream = NULL;
	active_stream.codec = NULL;

	if (broadcast_sink != NULL) {
		ret = bt_bap_broadcast_sink_delete(broadcast_sink);
		if (ret && ret != -EALREADY) {
			return ret;
		}

		broadcast_sink = NULL;
	}

	return 0;
}

static void bis_cleanup_worker(struct k_work *work)
{
	int ret;

	ret = broadcast_sink_cleanup();
	if (ret) {
		LOG_WRN("Failed to clean up BISes: %d", ret);
	}
}

K_WORK_DEFINE(bis_cleanup_work, bis_cleanup_worker);

static void le_audio_event_publish(enum le_audio_evt_type event)
{
	int ret;
	struct le_audio_msg msg;

	if (event == LE_AUDIO_EVT_SYNC_LOST) {
		msg.pa_sync = pa_sync_stored;
		pa_sync_stored = NULL;
	}

	msg.event = event;

	ret = zbus_chan_pub(&le_audio_chan, &msg, LE_AUDIO_ZBUS_EVENT_WAIT_TIME);
	ERR_CHK(ret);
}

static void print_codec(const struct audio_codec_info *codec)
{
	if (codec->id == BT_HCI_CODING_FORMAT_LC3) {
		LOG_INF("Codec config for LC3:");
		LOG_INF("\tFrequency: %d Hz", codec->frequency);
		LOG_INF("\tFrame Duration: %d us", codec->frame_duration_us);
		LOG_INF("\tOctets per frame: %d (%d kbps)", codec->octets_per_sdu, codec->bitrate);
		LOG_INF("\tFrames per SDU: %d", codec->blocks_per_sdu);
		if (codec->chan_allocation >= 0) {
			LOG_INF("\tChannel allocation: 0x%x", codec->chan_allocation);
		}
	} else {
		LOG_WRN("Codec is not LC3, codec_id: 0x%2hhx", codec->id);
	}
}

static void get_codec_info(const struct bt_audio_codec_cfg *codec,
			   struct audio_codec_info *codec_info)
{
	int ret;

	if (codec->id == BT_HCI_CODING_FORMAT_LC3) {
		/* LC3 uses the generic LTV format - other codecs might do as well */
		LOG_DBG("Retrieve the codec configuration for LC3");
		codec_info->id = codec->id;
		codec_info->cid = codec->cid;
		codec_info->vid = codec->vid;

		ret = le_audio_freq_hz_get(codec, &codec_info->frequency);
		if (ret) {
			LOG_ERR("Error retrieving sampling frequency: %d", ret);
			return;
		}

		ret = le_audio_duration_us_get(codec, &codec_info->frame_duration_us);
		if (ret) {
			LOG_ERR("Error retrieving frame duration: %d", ret);
			return;
		}

		ret = bt_audio_codec_cfg_get_chan_allocation(codec, &codec_info->chan_allocation);
		if (ret) {
			LOG_ERR("Error retrieving channel allocation: %d", ret);
			return;
		}

		ret = le_audio_octets_per_frame_get(codec, &codec_info->octets_per_sdu);
		if (ret) {
			LOG_ERR("Error retrieving octets per frame: %d", ret);
			return;
		}

		ret = le_audio_bitrate_get(codec, &codec_info->bitrate);
		if (ret) {
			LOG_ERR("Error calculating bitrate: %d", ret);
			return;
		}

		ret = le_audio_frame_blocks_per_sdu_get(codec, &codec_info->blocks_per_sdu);
		if (codec_info->octets_per_sdu < 0) {
			LOG_ERR("Error retrieving frame blocks per SDU: %d",
				codec_info->octets_per_sdu);
			return;
		}
	} else {
		LOG_WRN("Codec is not LC3, codec_id: 0x%2hhx", codec->id);
	}
}

static bool bitrate_check(const struct bt_audio_codec_cfg *codec)
{
	int ret;
	uint32_t octets_per_sdu;

	ret = le_audio_octets_per_frame_get(codec, &octets_per_sdu);
	if (ret) {
		LOG_ERR("Error retrieving octets per frame: %d", ret);
		return false;
	}

	if (octets_per_sdu < LE_AUDIO_SDU_SIZE_OCTETS(CONFIG_LC3_BITRATE_MIN)) {
		LOG_WRN("Bitrate too low");
		return false;
	} else if (octets_per_sdu > LE_AUDIO_SDU_SIZE_OCTETS(CONFIG_LC3_BITRATE_MAX)) {
		LOG_WRN("Bitrate too high");
		return false;
	}

	return true;
}

static void stream_started_cb(struct bt_bap_stream *stream)
{
	le_audio_event_publish(LE_AUDIO_EVT_STREAMING);

	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Stream index %d started", active_stream_index);
	print_codec(&audio_codec_info[active_stream_index]);
}

static void stream_stopped_cb(struct bt_bap_stream *stream, uint8_t reason)
{

	switch (reason) {
	case BT_HCI_ERR_LOCALHOST_TERM_CONN:
		LOG_INF("Stream stopped by user");
		le_audio_event_publish(LE_AUDIO_EVT_NOT_STREAMING);

		break;

	case BT_HCI_ERR_CONN_FAIL_TO_ESTAB:
		/* Fall-through */
	case BT_HCI_ERR_CONN_TIMEOUT:
		LOG_INF("Stream sync lost");
		k_work_submit(&bis_cleanup_work);

		le_audio_event_publish(LE_AUDIO_EVT_SYNC_LOST);

		break;

	case BT_HCI_ERR_REMOTE_USER_TERM_CONN:
		LOG_INF("Broadcast source stopped streaming");
		le_audio_event_publish(LE_AUDIO_EVT_NOT_STREAMING);

		break;

	default:
		LOG_WRN("Unhandled reason: %d", reason);

		break;
	}

	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Stream index %d stopped. Reason: %d", active_stream_index, reason);
}

static void stream_recv_cb(struct bt_bap_stream *stream, const struct bt_iso_recv_info *info,
			   struct net_buf *buf)
{
	bool bad_frame = false;

	if (receive_cb == NULL) {
		LOG_ERR("The RX callback has not been set");
		return;
	}

	if (!(info->flags & BT_ISO_FLAGS_VALID)) {
		bad_frame = true;
	}

	receive_cb(buf->data, buf->len, bad_frame, info->ts, active_stream_index,
		   active_stream.codec->octets_per_sdu);
}

static struct bt_bap_stream_ops stream_ops = {
	.started = stream_started_cb,
	.stopped = stream_stopped_cb,
	.recv = stream_recv_cb,
};

static bool parse_cb(struct bt_data *data, void *codec)
{
	if (data->type == BT_AUDIO_CODEC_CONFIG_LC3_CHAN_ALLOC) {
		((struct audio_codec_info *)codec)->chan_allocation = sys_get_le32(data->data);
		return false;
	}

	return true;
}

/**
 * @brief	Function which overwrites BIS specific codec information.
 *		I.e. level 3 specific information overwrites general level 2 information.
 *
 * @note	This will change when new host APIs are available.
 *
 * @return	0 for success, error otherwise.
 */
static int bis_specific_codec_config(struct bt_bap_base_bis_data bis_data,
				     struct audio_codec_info *codec)
{
	int ret;

	ret = bt_audio_data_parse(bis_data.data, bis_data.data_len, parse_cb, codec);
	if (ret && ret != -ECANCELED) {
		LOG_WRN("Could not overwrite BIS specific codec info: %d", ret);
		return -ENXIO;
	}

	return 0;
}

static void base_recv_cb(struct bt_bap_broadcast_sink *sink, const struct bt_bap_base *base)
{
	bool suitable_stream_found = false;

	if (init_routine_completed) {
		return;
	}

	LOG_DBG("Received BASE with %zu subgroup(s) from broadcast sink", base->subgroup_count);

	sync_stream_cnt = 0;

	/* Search each subgroup for the BIS of interest */
	for (int i = 0; i < base->subgroup_count; i++) {
		for (int j = 0; j < base->subgroups[i].bis_count; j++) {
			const uint8_t index = base->subgroups[i].bis_data[j].index;

			LOG_DBG("Subgroup: %d BIS: %d index = %d", i, j, index);

			if (bitrate_check(&base->subgroups[i].codec_cfg)) {
				suitable_stream_found = true;

				bis_index_bitfields[sync_stream_cnt] = BIT(index);

				/* Get general (level 2) codec config from the subgroup */
				audio_streams[sync_stream_cnt].codec_cfg =
					(struct bt_audio_codec_cfg *)&base->subgroups[i].codec_cfg;
				get_codec_info(audio_streams[sync_stream_cnt].codec_cfg,
					       &audio_codec_info[sync_stream_cnt]);

				/* Overwrite codec config with level 3 BIS specific codec config.
				 * For now, this is only done for channel allocation
				 */
				(void)bis_specific_codec_config(base->subgroups[i].bis_data[j],
								&audio_codec_info[sync_stream_cnt]);

				LOG_DBG("Stream %d in subgroup %d from broadcast sink",
					sync_stream_cnt, i);

				sync_stream_cnt += 1;
				if (sync_stream_cnt >= ARRAY_SIZE(audio_streams)) {
					break;
				}
			}
		}

		if (sync_stream_cnt >= ARRAY_SIZE(audio_streams)) {
			break;
		}
	}

	if (suitable_stream_found) {
		/* Set the initial active stream based on the defined channel of the device */
		channel_assignment_get((enum audio_channel *)&active_stream_index);
		active_stream.stream = &audio_streams[active_stream_index];
		active_stream.codec = &audio_codec_info[active_stream_index];
		active_stream.pd = base->pd;

		le_audio_event_publish(LE_AUDIO_EVT_CONFIG_RECEIVED);

		LOG_DBG("Channel %s active",
			((active_stream_index == AUDIO_CH_L) ? CH_L_TAG : CH_R_TAG));
		LOG_DBG("Waiting for syncable");
	} else {
		LOG_DBG("Found no suitable stream");
		le_audio_event_publish(LE_AUDIO_EVT_NO_VALID_CFG);
	}
}

static void syncable_cb(struct bt_bap_broadcast_sink *sink, bool encrypted)
{
	int ret;
	static uint8_t bis_encryption_key[BT_ISO_BROADCAST_CODE_SIZE] = {0};
	struct bt_bap_stream *audio_streams_p[] = {&audio_streams[active_stream_index]};

	LOG_DBG("Broadcast sink is syncable");

	if (IS_ENABLED(CONFIG_BT_AUDIO_BROADCAST_ENCRYPTED)) {
		memcpy(bis_encryption_key, CONFIG_BT_AUDIO_BROADCAST_ENCRYPTION_KEY,
		       MIN(strlen(CONFIG_BT_AUDIO_BROADCAST_ENCRYPTION_KEY),
			   ARRAY_SIZE(bis_encryption_key)));
	}

	if (active_stream.stream != NULL && active_stream.stream->ep != NULL) {
		if (active_stream.stream->ep->status.state == BT_BAP_EP_STATE_STREAMING) {
			LOG_WRN("Syncable received, but already in a stream");
			return;
		}
	}

	if (paused) {
		LOG_DBG("Syncable received, but in paused state");
		return;
	}

	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Syncing to broadcast stream index %d", active_stream_index);

	if (bis_index_bitfields[active_stream_index] == 0) {
		LOG_ERR("No bits set in bitfield");
		return;
	} else if (!IS_POWER_OF_TWO(bis_index_bitfields[active_stream_index])) {
		/* Check that only one bit is set */
		LOG_ERR("Application syncs to only one stream");
		return;
	}

	ret = bt_bap_broadcast_sink_sync(broadcast_sink, bis_index_bitfields[active_stream_index],
					 audio_streams_p, bis_encryption_key);

	if (ret) {
		LOG_WRN("Unable to sync to broadcast source, ret: %d", ret);
		return;
	}

	/* Only a single stream used for now */
	active_stream.stream = &audio_streams[active_stream_index];

	init_routine_completed = true;
}

static struct bt_bap_broadcast_sink_cb broadcast_sink_cbs = {
	.base_recv = base_recv_cb,
	.syncable = syncable_cb,
};

int broadcast_sink_change_active_audio_stream(void)
{
	int ret;

	if (broadcast_sink == NULL) {
		LOG_WRN("No broadcast sink");
		return -ECANCELED;
	}

	if (active_stream.stream != NULL && active_stream.stream->ep != NULL) {
		if (active_stream.stream->ep->status.state == BT_BAP_EP_STATE_STREAMING) {
			ret = bt_bap_broadcast_sink_stop(broadcast_sink);
			if (ret) {
				LOG_ERR("Failed to stop sink");
			}
		}
	}

	/* Wrap streams */
	if (++active_stream_index >= sync_stream_cnt) {
		active_stream_index = 0;
	}

	active_stream.stream = &audio_streams[active_stream_index];
	active_stream.codec = &audio_codec_info[active_stream_index];

	LOG_INF("Changed to stream %d", active_stream_index);

	return 0;
}

int broadcast_sink_config_get(uint32_t *bitrate, uint32_t *sampling_rate, uint32_t *pres_delay)
{
	if (active_stream.codec == NULL) {
		LOG_WRN("No active stream to get config from");
		return -ENXIO;
	}

	if (bitrate == NULL && sampling_rate == NULL && pres_delay == NULL) {
		LOG_ERR("No valid pointers received");
		return -ENXIO;
	}

	if (sampling_rate != NULL) {
		*sampling_rate = active_stream.codec->frequency;
	}

	if (bitrate != NULL) {
		*bitrate = active_stream.codec->bitrate;
	}

	if (pres_delay != NULL) {
		if (active_stream.stream == NULL) {
			LOG_WRN("No active stream");
			return -ENXIO;
		}

		*pres_delay = active_stream.pd;
	}

	return 0;
}

int broadcast_sink_pa_sync_set(struct bt_le_per_adv_sync *pa_sync, uint32_t broadcast_id)
{
	int ret;

	if (pa_sync == NULL) {
		LOG_ERR("Invalid PA sync received");
		return -EINVAL;
	}

	LOG_DBG("Trying to set PA sync with ID: %d", broadcast_id);

	if (active_stream.stream != NULL && active_stream.stream->ep != NULL) {
		if (active_stream.stream->ep->status.state == BT_BAP_EP_STATE_STREAMING) {
			ret = bt_bap_broadcast_sink_stop(broadcast_sink);
			if (ret) {
				LOG_ERR("Failed to stop broadcast sink: %d", ret);
				return ret;
			}

			broadcast_sink_cleanup();
		}
	}

	/* If broadcast_sink was not in an active stream we still need to clean it up */
	if (broadcast_sink != NULL) {
		broadcast_sink_cleanup();
	}

	ret = bt_bap_broadcast_sink_create(pa_sync, broadcast_id, &broadcast_sink);
	if (ret) {
		LOG_WRN("Failed to create sink: %d", ret);
		return ret;
	}

	pa_sync_stored = pa_sync;

	return 0;
}

int broadcast_sink_start(void)
{
	if (!paused) {
		LOG_WRN("Already playing");
		return -EALREADY;
	}

	paused = false;
	return 0;
}

int broadcast_sink_stop(void)
{
	int ret;

	if (paused) {
		LOG_WRN("Already paused");
		return -EALREADY;
	}

	if (active_stream.stream == NULL || active_stream.stream->ep == NULL) {
		LOG_WRN("Stream or endpoint not set");
		return -EPERM;
	}

	if (active_stream.stream->ep->status.state == BT_BAP_EP_STATE_STREAMING) {
		paused = true;
		ret = bt_bap_broadcast_sink_stop(broadcast_sink);
		if (ret) {
			LOG_ERR("Failed to stop broadcast sink: %d", ret);
			return ret;
		}
	} else {
		LOG_WRN("Current stream not in streaming state");
		return -EALREADY;
	}

	return 0;
}

int broadcast_sink_disable(void)
{
	int ret;

	if (active_stream.stream != NULL && active_stream.stream->ep != NULL) {
		if (active_stream.stream->ep->status.state == BT_BAP_EP_STATE_STREAMING) {
			ret = bt_bap_broadcast_sink_stop(broadcast_sink);
			if (ret) {
				LOG_ERR("Failed to stop sink");
			}
		}
	}

	if (pa_sync_stored != NULL) {
		ret = bt_le_per_adv_sync_delete(pa_sync_stored);
		if (ret) {
			LOG_ERR("Failed to delete pa_sync");
			return ret;
		}
	}

	ret = broadcast_sink_cleanup();
	if (ret) {
		LOG_ERR("Error cleaning up");
		return ret;
	}

	LOG_DBG("Broadcast sink disabled");

	return 0;
}

int broadcast_sink_enable(le_audio_receive_cb recv_cb)
{
	int ret;
	static bool initialized;
	enum audio_channel channel;

	if (initialized) {
		LOG_WRN("Already initialized");
		return -EALREADY;
	}

	if (recv_cb == NULL) {
		LOG_ERR("Receive callback is NULL");
		return -EINVAL;
	}

	receive_cb = recv_cb;

	channel_assignment_get(&channel);

	if (channel == AUDIO_CH_L) {
		ret = bt_pacs_set_location(BT_AUDIO_DIR_SINK, BT_AUDIO_LOCATION_FRONT_LEFT);
	} else {
		ret = bt_pacs_set_location(BT_AUDIO_DIR_SINK, BT_AUDIO_LOCATION_FRONT_RIGHT);
	}

	if (ret) {
		LOG_ERR("Location set failed");
		return ret;
	}

	ret = bt_pacs_cap_register(BT_AUDIO_DIR_SINK, &capabilities);
	if (ret) {
		LOG_ERR("Capability register failed (ret %d)", ret);
		return ret;
	}

	bt_bap_broadcast_sink_register_cb(&broadcast_sink_cbs);

	for (int i = 0; i < ARRAY_SIZE(audio_streams); i++) {
		audio_streams[i].ops = &stream_ops;
	}

	initialized = true;

	LOG_DBG("Broadcast sink enabled");

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_stream/broadcast/broadcast_source.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BROADCAST_SOURCE_H_
#define _BROADCAST_SOURCE_H_

#include "bt_le_audio_tx.h"

/**
 * @brief	Get the data to advertise.
 *
 * @param[out]	ext_adv		Pointer to the pointer of bt_data used for extended advertising.
 * @param[out]	ext_adv_size	Pointer to size of @p ext_adv.
 * @param[out]	per_adv		Pointer to the pointer of bt_data used for periodic advertising.
 * @param[out]	per_adv_size	Pointer to size of @p per_adv.
 */
void broadcast_source_adv_get(const struct bt_data **ext_adv, size_t *ext_adv_size,
			      const struct bt_data **per_adv, size_t *per_adv_size);

/**
 * @brief	Start the Bluetooth LE Audio broadcast (BIS) source.
 *
 * @param[in]	ext_adv		Pointer to the extended advertising set; can be NULL if a stream
 *				is restarted.
 *
 * @return	0 for success, error otherwise.
 */
int broadcast_source_start(struct bt_le_ext_adv *ext_adv);

/**
 * @brief	Stop the Bluetooth LE Audio broadcast (BIS) source.
 *
 * @return	0 for success, error otherwise.
 */
int broadcast_source_stop(void);

/**
 * @brief	Broadcast the Bluetooth LE Audio data.
 *
 * @param[in]	enc_audio	Encoded audio struct.
 *
 * @return	0 for success, error otherwise.
 */
int broadcast_source_send(struct le_audio_encoded_audio enc_audio);

/**
 * @brief	Disable the LE Audio broadcast (BIS) source.
 *
 * @return	0 for success, error otherwise.
 */
int broadcast_source_disable(void);

/**
 * @brief	Enable the LE Audio broadcast (BIS) source.
 *
 * @return	0 for success, error otherwise.
 */
int broadcast_source_enable(void);

#endif /* _BROADCAST_SOURCE_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_management/CMakeLists.txt
#
# Copyright (c) 2023 Nordic Semiconductor
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

zephyr_library_include_directories(
    advertising
    controller_config
    dfu
    scanning
    ${ZEPHYR_BASE}/subsys/bluetooth/host/
)

target_sources(app PRIVATE
	       ${CMAKE_CURRENT_SOURCE_DIR}/bt_mgmt.c
	       ${CMAKE_CURRENT_SOURCE_DIR}/controller_config/bt_mgmt_ctlr_cfg.c
)

if (CONFIG_BT_CENTRAL)
	target_sources(app PRIVATE
		${CMAKE_CURRENT_SOURCE_DIR}/scanning/bt_mgmt_scan_for_conn.c)
endif()

if (CONFIG_BT_BAP_BROADCAST_SINK)
target_sources(app PRIVATE
		${CMAKE_CURRENT_SOURCE_DIR}/scanning/bt_mgmt_scan_for_broadcast.c)
endif()

if (CONFIG_BT_OBSERVER)
target_sources(app PRIVATE
	        ${CMAKE_CURRENT_SOURCE_DIR}/scanning/bt_mgmt_scan.c)
endif()

if (CONFIG_BT_PERIPHERAL OR CONFIG_BT_BROADCASTER)
	target_sources(app PRIVATE
	       ${CMAKE_CURRENT_SOURCE_DIR}/advertising/bt_mgmt_adv.c)
endif()

if (CONFIG_AUDIO_DFU_ENABLE)
	target_sources(app PRIVATE
	       ${CMAKE_CURRENT_SOURCE_DIR}/dfu/bt_mgmt_dfu.c
	)
endif()


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_management/bt_mgmt.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "bt_mgmt.h"

#include <zephyr/zbus/zbus.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/conn.h>
#include <zephyr/bluetooth/hci.h>
#include <zephyr/settings/settings.h>
#include <zephyr/sys/byteorder.h>

#include "macros_common.h"
#include "nrf5340_audio_common.h"
#include "button_handler.h"
#include "button_assignments.h"
#include "bt_mgmt_ctlr_cfg_internal.h"
#include "bt_mgmt_adv_internal.h"

#if defined(CONFIG_AUDIO_DFU_ENABLE)
#include "bt_mgmt_dfu_internal.h"
#endif

#if (CONFIG_BT_LL_ACS_NRF53)
#include "ble_hci_vsc.h"
#endif /* (CONFIG_BT_LL_ACS_NRF53) */

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(bt_mgmt, CONFIG_BT_MGMT_LOG_LEVEL);

ZBUS_CHAN_DEFINE(bt_mgmt_chan, struct bt_mgmt_msg, NULL, NULL, ZBUS_OBSERVERS_EMPTY,
		 ZBUS_MSG_INIT(0));

/* The bt_enable should take less than 15 ms.
 * Buffer added as this will not add to bootup time
 */
#define BT_ENABLE_TIMEOUT_MS 100

#ifndef CONFIG_BT_MAX_CONN
#define MAX_CONN_NUM 0
#else
#define MAX_CONN_NUM CONFIG_BT_MAX_CONN
#endif

K_SEM_DEFINE(sem_bt_enabled, 0, 1);

/**
 * @brief	Iterative function used to find connected conns
 *
 * @param[in]	conn	The connection to check
 * @param[out]	data	Pointer to store number of valid conns
 */
static void conn_state_connected_check(struct bt_conn *conn, void *data)
{
	int ret;
	uint8_t *num_conn = (uint8_t *)data;
	struct bt_conn_info info;

	ret = bt_conn_get_info(conn, &info);
	if (ret) {
		LOG_ERR("Failed to get conn info for %p: %d", (void *)conn, ret);
		return;
	}

	if (info.state != BT_CONN_STATE_CONNECTED) {
		return;
	}

	(*num_conn)++;
}

static void connected_cb(struct bt_conn *conn, uint8_t err)
{
	int ret;
	char addr[BT_ADDR_LE_STR_LEN] = {0};
	uint8_t num_conn = 0;
	struct bt_mgmt_msg msg;

	if (err == BT_HCI_ERR_ADV_TIMEOUT && IS_ENABLED(CONFIG_BT_PERIPHERAL)) {
		LOG_INF("Directed adv timed out with no connection, reverting to normal adv");

		bt_mgmt_dir_adv_timed_out();

		ret = bt_mgmt_adv_start(NULL, 0, NULL, 0, true);
		if (ret) {
			LOG_ERR("Failed to restart advertising: %d", ret);
		}

		return;
	}

	(void)bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));

	if (err) {
		LOG_ERR("ACL connection to addr: %s, conn: %p, failed, error %d", addr,
			(void *)conn, err);

		bt_conn_unref(conn);

		if (IS_ENABLED(CONFIG_BT_CENTRAL)) {
			ret = bt_mgmt_scan_start(0, 0, BT_MGMT_SCAN_TYPE_CONN, NULL,
						 BRDCAST_ID_NOT_USED);
			if (ret && ret != -EALREADY) {
				LOG_ERR("Failed to restart scanning: %d", ret);
			}
		}

		if (IS_ENABLED(CONFIG_BT_PERIPHERAL)) {
			ret = bt_mgmt_adv_start(NULL, 0, NULL, 0, true);
			if (ret) {
				LOG_ERR("Failed to restart advertising: %d", ret);
			}
		}

		return;
	}

	bt_conn_foreach(BT_CONN_TYPE_LE, conn_state_connected_check, (void *)&num_conn);

	/* ACL connection established */
	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Connected: %s", addr);

	if (IS_ENABLED(CONFIG_BT_CENTRAL) && (num_conn < MAX_CONN_NUM)) {
		/* Room for more connections, start scanning again */
		ret = bt_mgmt_scan_start(0, 0, BT_MGMT_SCAN_TYPE_CONN, NULL, BRDCAST_ID_NOT_USED);
		if (ret) {
			LOG_ERR("Failed to resume scanning: %d", ret);
		}
	}

#if (CONFIG_BT_LL_ACS_NRF53)
	enum ble_hci_vs_tx_power conn_tx_pwr;
	uint16_t conn_handle;

	ret = bt_hci_get_conn_handle(conn, &conn_handle);
	if (ret) {
		LOG_ERR("Unable to get conn handle");
	} else {
		if (IS_ENABLED(CONFIG_NRF_21540_ACTIVE)) {
			conn_tx_pwr = CONFIG_NRF_21540_MAIN_DBM;
		} else {
			conn_tx_pwr = CONFIG_BLE_CONN_TX_POWER_DBM;
		}

		ret = ble_hci_vsc_conn_tx_pwr_set(conn_handle, conn_tx_pwr);
		if (ret) {
			LOG_ERR("Failed to set TX power for conn");
		} else {
			LOG_DBG("TX power set to %d dBm for connection %p", conn_tx_pwr,
				(void *)conn);
		}
	}
#endif /* (CONFIG_BT_LL_ACS_NRF53) */

	msg.event = BT_MGMT_CONNECTED;
	msg.conn = conn;

	ret = zbus_chan_pub(&bt_mgmt_chan, &msg, K_NO_WAIT);
	ERR_CHK(ret);

	if (IS_ENABLED(CONFIG_BT_CENTRAL)) {
		ret = bt_conn_set_security(conn, BT_SECURITY_L2);
		if (ret) {
			LOG_ERR("Failed to set security to L2: %d", ret);
		}
	}
}

K_MUTEX_DEFINE(mtx_duplicate_scan);

static void disconnected_cb(struct bt_conn *conn, uint8_t reason)
{
	int ret;
	char addr[BT_ADDR_LE_STR_LEN];
	struct bt_mgmt_msg msg;

	(void)bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));

	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Disconnected: %s (reason 0x%02x)", addr, reason);

	if (IS_ENABLED(CONFIG_BT_CENTRAL)) {
		bt_conn_unref(conn);
	}

	/* Publish disconnected */
	msg.event = BT_MGMT_DISCONNECTED;
	msg.conn = conn;

	ret = zbus_chan_pub(&bt_mgmt_chan, &msg, K_NO_WAIT);
	ERR_CHK(ret);

	if (IS_ENABLED(CONFIG_BT_PERIPHERAL)) {
		ret = bt_mgmt_adv_start(NULL, 0, NULL, 0, true);
		ERR_CHK(ret);
	}

	/* The mutex for preventing the racing condition if two headset disconnected too close,
	 * cause the disconnected_cb() triggered in short time leads to duplicate scanning
	 * operation.
	 */
	k_mutex_lock(&mtx_duplicate_scan, K_FOREVER);
	if (IS_ENABLED(CONFIG_BT_CENTRAL)) {
		ret = bt_mgmt_scan_start(0, 0, BT_MGMT_SCAN_TYPE_CONN, NULL, BRDCAST_ID_NOT_USED);
		if (ret && ret != -EALREADY) {
			LOG_ERR("Failed to restart scanning: %d", ret);
		}
	}
	k_mutex_unlock(&mtx_duplicate_scan);
}

#if defined(CONFIG_BT_SMP)
static void security_changed_cb(struct bt_conn *conn, bt_security_t level, enum bt_security_err err)
{
	int ret;
	struct bt_mgmt_msg msg;

	if (err) {
		LOG_WRN("Security failed: level %d err %d", level, err);
		ret = bt_conn_disconnect(conn, err);
		if (ret) {
			LOG_WRN("Failed to disconnect %d", ret);
		}
	} else {
		LOG_DBG("Security changed: level %d", level);
		/* Publish connected */
		msg.event = BT_MGMT_SECURITY_CHANGED;
		msg.conn = conn;

		ret = zbus_chan_pub(&bt_mgmt_chan, &msg, K_NO_WAIT);
		ERR_CHK(ret);
	}
}
#endif /* defined(CONFIG_BT_SMP) */

static struct bt_conn_cb conn_callbacks = {
	.connected = connected_cb,
	.disconnected = disconnected_cb,
#if defined(CONFIG_BT_SMP)
	.security_changed = security_changed_cb,
#endif /* defined(CONFIG_BT_SMP) */
};

static void bt_enabled_cb(int err)
{
	if (err) {
		LOG_ERR("Bluetooth init failed (err code: %d)", err);
		ERR_CHK(err);
	}

	k_sem_give(&sem_bt_enabled);

	LOG_DBG("Bluetooth initialized");
}

static int bonding_clear_check(void)
{
	int ret;
	bool pressed;

	ret = button_pressed(BUTTON_5, &pressed);
	if (ret) {
		return ret;
	}

	if (pressed) {
		ret = bt_mgmt_bonding_clear();
		return ret;
	}

	return 0;
}

static int ficr_static_addr_set(void)
{
	int ret;
	static bt_addr_le_t addr;

	if ((NRF_FICR->INFO.DEVICEID[0] != UINT32_MAX) ||
	    ((NRF_FICR->INFO.DEVICEID[1] & UINT16_MAX) != UINT16_MAX)) {
		/* Put the device ID from FICR into address */
		sys_put_le32(NRF_FICR->INFO.DEVICEID[0], &addr.a.val[0]);
		sys_put_le16(NRF_FICR->INFO.DEVICEID[1], &addr.a.val[4]);

		/* The FICR value is a just a random number, with no knowledge
		 * of the Bluetooth Specification requirements for random
		 * static addresses.
		 */
		BT_ADDR_SET_STATIC(&addr.a);

		addr.type = BT_ADDR_LE_RANDOM;

		ret = bt_id_create(&addr, NULL);
		if (ret < 0) {
			LOG_ERR("Failed to create ID %d", ret);
			return ret;
		}

		return 0;
	}

	/* If no address can be created (e.g. based on
	 * FICR), then a random address is created
	 */
	LOG_WRN("Unable to read from FICR");

	return 0;
}

/* This function generates a random address for bonding testing */
static int random_static_addr_set(void)
{
	int ret;
	static bt_addr_le_t addr;

	ret = bt_addr_le_create_static(&addr);
	if (ret < 0) {
		LOG_ERR("Failed to create address %d", ret);
		return ret;
	}

	ret = bt_id_create(&addr, NULL);
	if (ret < 0) {
		LOG_ERR("Failed to create ID %d", ret);
		return ret;
	}

	return 0;
}

static int local_identity_addr_print(void)
{
	size_t num_ids = 0;
	bt_addr_le_t addrs[CONFIG_BT_ID_MAX];
	char addr_str[BT_ADDR_LE_STR_LEN];

	bt_id_get(NULL, &num_ids);
	if (num_ids != CONFIG_BT_ID_MAX) {
		LOG_ERR("The default config supports %d ids, but %d was found", CONFIG_BT_ID_MAX,
			num_ids);
		return -ENOMEM;
	}

	bt_id_get(addrs, &num_ids);

	for (int i = 0; i < num_ids; i++) {
		(void)bt_addr_le_to_str(&(addrs[i]), addr_str, BT_ADDR_LE_STR_LEN);
		LOG_INF("Local identity addr: %s", addr_str);
	}

	return 0;
}

int bt_mgmt_bonding_clear(void)
{
	int ret;

	if (IS_ENABLED(CONFIG_SETTINGS)) {
		LOG_INF("Clearing all bonds");

		ret = bt_unpair(BT_ID_DEFAULT, NULL);
		if (ret) {
			LOG_ERR("Failed to clear bonding: %d", ret);
			return ret;
		}
	}

	return 0;
}

int bt_mgmt_pa_sync_delete(struct bt_le_per_adv_sync *pa_sync)
{
	if (IS_ENABLED(CONFIG_BT_PER_ADV_SYNC)) {
		int ret;

		ret = bt_le_per_adv_sync_delete(pa_sync);
		if (ret) {
			LOG_ERR("Failed to delete PA sync");
			return ret;
		}
	} else {
		LOG_WRN("Periodic advertisement sync not enabled");
		return -ENOTSUP;
	}

	return 0;
}

int bt_mgmt_conn_disconnect(struct bt_conn *conn, uint8_t reason)
{
	if (IS_ENABLED(CONFIG_BT_CONN)) {
		int ret;

		ret = bt_conn_disconnect(conn, reason);
		if (ret) {
			LOG_ERR("Failed to disconnect connection %p (%d)", (void *)conn, ret);
			return ret;
		}
	} else {
		LOG_WRN("BT conn not enabled");
		return -ENOTSUP;
	}

	return 0;
}

int bt_mgmt_init(void)
{
	int ret;

	if (!IS_ENABLED(CONFIG_BT_PRIVACY)) {
		ret = ficr_static_addr_set();
		if (ret) {
			return ret;
		}
	}

	ret = bt_enable(bt_enabled_cb);
	if (ret) {
		return ret;
	}

	ret = k_sem_take(&sem_bt_enabled, K_MSEC(BT_ENABLE_TIMEOUT_MS));
	if (ret) {
		LOG_ERR("bt_enable timed out");
		return ret;
	}

	if (IS_ENABLED(CONFIG_TESTING_BLE_ADDRESS_RANDOM)) {
		ret = random_static_addr_set();
		if (ret) {
			return ret;
		}
	}

	if (IS_ENABLED(CONFIG_SETTINGS)) {
		ret = settings_load();
		if (ret) {
			return ret;
		}

		ret = bonding_clear_check();
		if (ret) {
			return ret;
		}

		if (IS_ENABLED(CONFIG_TESTING_BLE_ADDRESS_RANDOM)) {
			ret = bt_mgmt_bonding_clear();
			if (ret) {
				return ret;
			}
		}
	}

#if defined(CONFIG_AUDIO_DFU_ENABLE)
	bool pressed;

	ret = button_pressed(BUTTON_4, &pressed);
	if (ret) {
		return ret;
	}

	if (pressed) {
		ret = bt_mgmt_ctlr_cfg_init(false);
		if (ret) {
			return ret;
		}
		/* This call will not return */
		bt_mgmt_dfu_start();
	}
#endif

	ret = bt_mgmt_ctlr_cfg_init(IS_ENABLED(CONFIG_WDT_CTLR));
	if (ret) {
		return ret;
	}

	ret = local_identity_addr_print();
	if (ret) {
		return ret;
	}

	if (IS_ENABLED(CONFIG_BT_CONN)) {
		bt_conn_cb_register(&conn_callbacks);
	}

	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) || IS_ENABLED(CONFIG_BT_BROADCASTER)) {
		bt_mgmt_adv_init();
	}

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_management/Kconfig
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

menu "BT management"

rsource "controller_config/Kconfig"

#----------------------------------------------------------------------------#
menu "Power control"

config BLE_LE_POWER_CONTROL_ENABLED
	bool "Enable the Bluetooth LE power control feature"
	default n
	help
	  The Bluetooth LE power control feature makes devices be able to change TX power
	  dynamically and automatically during connection, which may reduce power consumption.

config WDT_CTLR
	bool "Enable watchdog for controller"
	default y
	help
	  When true, the controller will be polled at regular intervals to check that it is alive.
	  Turn off to reduce overhead, or HCI traffic.
	  The watchdog will be deactivated automatically for DFU procedures.

choice	BLE_CONN_TX_POWER
	prompt "Default TX power for the Bluetooth LE connections"
	default BLE_CONN_TX_POWER_0DBM
	help
	  Set the default TX power for Bluetooth LE connections.

config BLE_CONN_TX_POWER_0DBM
	bool "0dBm"

config BLE_CONN_TX_POWER_NEG_1DBM
	bool "-1dBm"

config BLE_CONN_TX_POWER_NEG_2DBM
	bool "-2dBm"

config BLE_CONN_TX_POWER_NEG_3DBM
	bool "-3dBm"

config BLE_CONN_TX_POWER_NEG_4DBM
	bool "-4dBm"

config BLE_CONN_TX_POWER_NEG_5DBM
	bool "-5dBm"

config BLE_CONN_TX_POWER_NEG_6DBM
	bool "-6dBm"

config BLE_CONN_TX_POWER_NEG_7DBM
	bool "-7dBm"

config BLE_CONN_TX_POWER_NEG_8DBM
	bool "-8dBm"

config BLE_CONN_TX_POWER_NEG_12DBM
	bool "-12dBm"

config BLE_CONN_TX_POWER_NEG_16DBM
	bool "-14dBm"

config BLE_CONN_TX_POWER_NEG_20DBM
	bool "-20dBm"

config BLE_CONN_TX_POWER_NEG_40DBM
	bool "-40dBm"

endchoice

config BLE_CONN_TX_POWER_DBM
	int
	default 0 if BLE_CONN_TX_POWER_0DBM
	default -1 if BLE_CONN_TX_POWER_NEG_1DBM
	default -2 if BLE_CONN_TX_POWER_NEG_2DBM
	default -3 if BLE_CONN_TX_POWER_NEG_3DBM
	default -4 if BLE_CONN_TX_POWER_NEG_4DBM
	default -5 if BLE_CONN_TX_POWER_NEG_5DBM
	default -6 if BLE_CONN_TX_POWER_NEG_6DBM
	default -7 if BLE_CONN_TX_POWER_NEG_7DBM
	default -8 if BLE_CONN_TX_POWER_NEG_8DBM
	default -12 if BLE_CONN_TX_POWER_NEG_12DBM
	default -16 if BLE_CONN_TX_POWER_NEG_16DBM
	default -20 if BLE_CONN_TX_POWER_NEG_20DBM
	default -40 if BLE_CONN_TX_POWER_NEG_40DBM

choice	BLE_ADV_TX_POWER
	prompt "Default TX power for the Bluetooth LE advertising"
	default BLE_ADV_TX_POWER_0DBM
	help
	  Set the default TX power for the Bluetooth LE advertising.

config BLE_ADV_TX_POWER_0DBM
	bool "0dBm"

config BLE_ADV_TX_POWER_NEG_1DBM
	bool "-1dBm"

config BLE_ADV_TX_POWER_NEG_2DBM
	bool "-2dBm"

config BLE_ADV_TX_POWER_NEG_3DBM
	bool "-3dBm"

config BLE_ADV_TX_POWER_NEG_4DBM
	bool "-4dBm"

config BLE_ADV_TX_POWER_NEG_5DBM
	bool "-5dBm"

config BLE_ADV_TX_POWER_NEG_6DBM
	bool "-6dBm"

config BLE_ADV_TX_POWER_NEG_7DBM
	bool "-7dBm"

config BLE_ADV_TX_POWER_NEG_8DBM
	bool "-8dBm"

config BLE_ADV_TX_POWER_NEG_12DBM
	bool "-12dBm"

config BLE_ADV_TX_POWER_NEG_16DBM
	bool "-14dBm"

config BLE_ADV_TX_POWER_NEG_20DBM
	bool "-20dBm"

config BLE_ADV_TX_POWER_NEG_40DBM
	bool "-40dBm"

endchoice

config BLE_ADV_TX_POWER_DBM
	int
	default 0 if BLE_ADV_TX_POWER_0DBM
	default -1 if BLE_ADV_TX_POWER_NEG_1DBM
	default -2 if BLE_ADV_TX_POWER_NEG_2DBM
	default -3 if BLE_ADV_TX_POWER_NEG_3DBM
	default -4 if BLE_ADV_TX_POWER_NEG_4DBM
	default -5 if BLE_ADV_TX_POWER_NEG_5DBM
	default -6 if BLE_ADV_TX_POWER_NEG_6DBM
	default -7 if BLE_ADV_TX_POWER_NEG_7DBM
	default -8 if BLE_ADV_TX_POWER_NEG_8DBM
	default -12 if BLE_ADV_TX_POWER_NEG_12DBM
	default -16 if BLE_ADV_TX_POWER_NEG_16DBM
	default -20 if BLE_ADV_TX_POWER_NEG_20DBM
	default -40 if BLE_ADV_TX_POWER_NEG_40DBM

endmenu # Power control

menu "Thread priorities"

config CTLR_POLL_WORK_Q_PRIO
	int "Work queue priority for controller poll"
	default 6
	help
	  This is a preemptible work queue.
	  This work queue will poll the controller to check it is alive.

endmenu # Thread priorities

rsource "dfu/Kconfig"
rsource "advertising/Kconfig"
rsource "scanning/Kconfig"

#----------------------------------------------------------------------------#
menu "Log level"

module = BT_MGMT
module-str = bt-mgmt
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log level
endmenu # BT management


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_management/bt_mgmt.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BT_MGMT_H_
#define _BT_MGMT_H_

#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/conn.h>
#include <zephyr/bluetooth/audio/audio.h>

#define LE_AUDIO_EXTENDED_ADV_NAME                                                                 \
	BT_LE_ADV_PARAM(BT_LE_ADV_OPT_EXT_ADV | BT_LE_ADV_OPT_USE_NAME,                            \
			CONFIG_BLE_ACL_EXT_ADV_INT_MIN, CONFIG_BLE_ACL_EXT_ADV_INT_MAX, NULL)

#define LE_AUDIO_EXTENDED_ADV_CONN_NAME                                                            \
	BT_LE_ADV_PARAM(BT_LE_ADV_OPT_EXT_ADV | BT_LE_ADV_OPT_CONNECTABLE |                        \
				BT_LE_ADV_OPT_USE_NAME,                                            \
			CONFIG_BLE_ACL_EXT_ADV_INT_MIN, CONFIG_BLE_ACL_EXT_ADV_INT_MAX, NULL)

#define LE_AUDIO_EXTENDED_ADV_CONN_NAME_FILTER                                                     \
	BT_LE_ADV_PARAM(BT_LE_ADV_OPT_EXT_ADV | BT_LE_ADV_OPT_CONNECTABLE |                        \
				BT_LE_ADV_OPT_USE_NAME | BT_LE_ADV_OPT_FILTER_CONN,                \
			CONFIG_BLE_ACL_EXT_ADV_INT_MIN, CONFIG_BLE_ACL_EXT_ADV_INT_MAX, NULL)

#define LE_AUDIO_PERIODIC_ADV                                                                      \
	BT_LE_PER_ADV_PARAM(CONFIG_BLE_ACL_PER_ADV_INT_MIN, CONFIG_BLE_ACL_PER_ADV_INT_MAX,        \
			    BT_LE_PER_ADV_OPT_NONE)

#define BT_LE_ADV_FAST_CONN                                                                        \
	BT_LE_ADV_PARAM(BT_LE_ADV_OPT_CONNECTABLE, BT_GAP_ADV_FAST_INT_MIN_1,                      \
			BT_GAP_ADV_FAST_INT_MAX_1, NULL)

/* Broadcast name can be max 32 bytes long, so this will be the limit for both.
 * Add one for '\0' at the end.
 */
#define BLE_SEARCH_NAME_MAX_LEN 33

#if (CONFIG_SCAN_MODE_ACTIVE)
#define NRF5340_AUDIO_GATEWAY_SCAN_TYPE	  BT_LE_SCAN_TYPE_ACTIVE
#define NRF5340_AUDIO_GATEWAY_SCAN_PARAMS BT_LE_SCAN_ACTIVE
#elif (CONFIG_SCAN_MODE_PASSIVE)
#define NRF5340_AUDIO_GATEWAY_SCAN_TYPE	  BT_LE_SCAN_TYPE_PASSIVE
#define NRF5340_AUDIO_GATEWAY_SCAN_PARAMS BT_LE_SCAN_PASSIVE
#else
#error "Select either CONFIG_SCAN_MODE_ACTIVE or CONFIG_SCAN_MODE_PASSIVE"
#endif

enum bt_mgmt_scan_type {
	BT_MGMT_SCAN_TYPE_CONN = 1,
	BT_MGMT_SCAN_TYPE_BROADCAST = 2,
};

#define BRDCAST_ID_NOT_USED (BT_AUDIO_BROADCAST_ID_MAX + 1)

/**
 * @brief	Start scanning for advertisements.
 *
 * @param[in]	scan_intvl	Scan interval in units of 0.625ms.
 *				Valid range: 0x4 - 0xFFFF; can be 0.
 * @param[in]	scan_win	Scan window in units of 0.625ms.
 *				Valid range: 0x4 - 0xFFFF; can be 0.
 * @param[in]	type		Type to scan for: ACL connection or broadcaster.
 * @param[in]	name		Name to search for. Depending on @p type of search,
 *				device name or broadcast name. Can be max
 *				BLE_SEARCH_NAME_MAX_LEN long; everything beyond that value
 *				will be cropped. Can be NULL. Shall be '\0' terminated.
 * @param[in]	brdcast_id	Broadcast ID to search for. Only valid if @p type is
 *				BT_MGMT_SCAN_TYPE_BROADCAST. If both @p name and @p brdcast_id are
 *				provided, then brdcast_id will be used.
 *				Set to BRDCAST_ID_NOT_USED if not in use.
 *
 * @note	To restart scanning, call this function with all 0s and NULL, except for @p type.
 *		The same scanning parameters as when bt_mgmt_scan_start was last called will then
 *		be used.
 *
 * @return	0 if success, error otherwise.
 */
int bt_mgmt_scan_start(uint16_t scan_intvl, uint16_t scan_win, enum bt_mgmt_scan_type type,
		       char const *const name, uint32_t brdcast_id);
/**
 * @brief	Create and start advertising for ACL connection.
 *
 * @param[in]	ext_adv		The data to be put in the extended advertisement.
 * @param[in]	ext_adv_size	Size of @p ext_adv.
 * @param[in]	per_adv		The data for the periodic advertisement; can be NULL.
 * @param[in]	per_adv_size	Size of @p per_adv.
 * @param[in]	connectable	Specify if advertisement should be connectable or not.
 *
 * @note	To restart advertising, call this function with all 0s and NULL, except for
 *		connectable. The same advertising parameters as when bt_mgmt_adv_start was last
 *		called will then be used.
 *
 * @return	0 if success, error otherwise.
 */
int bt_mgmt_adv_start(const struct bt_data *ext_adv, size_t ext_adv_size,
		      const struct bt_data *per_adv, size_t per_adv_size, bool connectable);

/**
 * @brief	Clear all bonded devices.
 *
 * @return	0 if success, error otherwise.
 */
int bt_mgmt_bonding_clear(void);

/**
 * @brief	Delete a periodic advertisement sync.
 *
 * @param[in]	pa_sync	Pointer to the periodic advertisement sync to delete.
 *
 * @return	0 if success, error otherwise.
 */
int bt_mgmt_pa_sync_delete(struct bt_le_per_adv_sync *pa_sync);

/**
 * @brief	Disconnect from a remote device or cancel the pending connection.
 *
 * @param[in]	conn	Connection to disconnect.
 * @param[in]	reason	Reason code for the disconnection, as specified in
 *			HCI Error Codes, BT Core Spec v5.4 [Vol 1, Part F].
 *
 * @return	0 if success, error otherwise.
 */
int bt_mgmt_conn_disconnect(struct bt_conn *conn, uint8_t reason);

/**
 * @brief	Initialize the Bluetooth management module.
 *
 * @return	0 if success, error otherwise.
 */
int bt_mgmt_init(void);

#endif /* _BT_MGMT_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_management/dfu/Kconfig
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

menu "DFU"

#----------------------------------------------------------------------------#
menu "Log level"

module = BT_MGMT_DFU
module-str = bt-mgmt-dfu
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log level
endmenu # DFU


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_management/dfu/bt_mgmt_dfu.c
/*
 * Copyright (c) 2022 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

/* Override compiler definition to use size-bounded string copying and concatenation function */
#define _BSD_SOURCE
#include "bt_mgmt_dfu_internal.h"

#include <zephyr/kernel.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/conn.h>

#include "string.h"
#include "macros_common.h"
#include "channel_assignment.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(bt_mgmt_dfu, CONFIG_BT_MGMT_DFU_LOG_LEVEL);

/* These defined name only used by DFU */
#define DEVICE_NAME_DFU	    CONFIG_BT_DFU_DEVICE_NAME
#define DEVICE_NAME_DFU_LEN (sizeof(DEVICE_NAME_DFU) - 1)

/* Advertising data for SMP_SVR UUID */
static struct bt_le_adv_param adv_param;
static const struct bt_data ad_peer[] = {
	BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)),
	BT_DATA_BYTES(BT_DATA_UUID128_ALL, 0x84, 0xaa, 0x60, 0x74, 0x52, 0x8a, 0x8b, 0x86, 0xd3,
		      0x4c, 0xb7, 0x1d, 0x1d, 0xdc, 0x53, 0x8d),
};

static void smp_adv(void)
{
	int ret;

	ret = bt_le_adv_start(&adv_param, ad_peer, ARRAY_SIZE(ad_peer), NULL, 0);
	if (ret) {
		LOG_ERR("SMP_SVR Advertising failed to start (ret %d)", ret);
		return;
	}

	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Regular SMP_SVR advertising started");
}

/* These callbacks are to override callback registed in module le_audio_ */
static void dfu_connected_cb(struct bt_conn *conn, uint8_t err)
{
	LOG_INF("SMP connected\n");
}

static void dfu_disconnected_cb(struct bt_conn *conn, uint8_t reason)
{
	LOG_INF("SMP disconnected 0x%02x\n", reason);
}

static struct bt_conn_cb dfu_conn_callbacks = {
	.connected = dfu_connected_cb,
	.disconnected = dfu_disconnected_cb,
};

static void dfu_set_bt_name(void)
{
	char name[CONFIG_BT_DEVICE_NAME_MAX] = {0};

	strlcpy(name, CONFIG_BT_DEVICE_NAME, CONFIG_BT_DEVICE_NAME_MAX);
	strlcat(name, "_", CONFIG_BT_DEVICE_NAME_MAX);
#if (CONFIG_AUDIO_DEV == GATEWAY)
	strlcat(name, GW_TAG, CONFIG_BT_DEVICE_NAME_MAX);
#else
	enum audio_channel channel;

	channel_assignment_get(&channel);

	if (channel == AUDIO_CH_L) {
		strlcat(name, CH_L_TAG, CONFIG_BT_DEVICE_NAME_MAX);
	} else {
		strlcat(name, CH_R_TAG, CONFIG_BT_DEVICE_NAME_MAX);
	}

#endif
	strlcat(name, "_DFU", CONFIG_BT_DEVICE_NAME_MAX);
	bt_set_name(name);
}

void bt_mgmt_dfu_start(void)
{
	LOG_INF("Entering SMP server mode");

	bt_conn_cb_register(&dfu_conn_callbacks);
	adv_param = *BT_LE_ADV_CONN_NAME;
	dfu_set_bt_name();
	smp_adv();

	while (1) {
		k_sleep(K_MSEC(100));
	}
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_management/dfu/bt_mgmt_dfu_internal.h
/*
 * Copyright (c) 2022 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BT_MGMT_DFU_INTERNAL_H_
#define _BT_MGMT_DFU_INTERNAL_H_

/**
 * @brief Enter the DFU mode. Advertise the SMP_SVR service only.
 *
 * @note This call does not return.
 */
void bt_mgmt_dfu_start(void);

#endif /* _BT_MGMT_DFU_INTERNAL_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_management/scanning/bt_mgmt_scan_for_conn_internal.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BT_MGMT_SCAN_FOR_CONN_INTERNAL_H_
#define _BT_MGMT_SCAN_FOR_CONN_INTERNAL_H_

#include <zephyr/bluetooth/bluetooth.h>

/**
 * @brief	Scan for a connection with the given device @p name.
 *
 * @param[in]	scan_param	Scan parameters to use.
 * @param[in]	name		Device name to search for.
 *
 * @return	0 if success, error otherwise.
 */
int bt_mgmt_scan_for_conn_start(struct bt_le_scan_param *scan_param, char const *const name);

#endif /* _BT_MGMT_SCAN_FOR_CONN_INTERNAL_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_management/scanning/Kconfig.defaults
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

if BT_OBSERVER

config BT_BACKGROUND_SCAN_INTERVAL
	default 32

config BT_BACKGROUND_SCAN_WINDOW
	default 32

endif # BT_OBSERVER

config BT_SCAN_WITH_IDENTITY
	default y


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_management/scanning/Kconfig
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

rsource "Kconfig.defaults"

menu "Scanning"

choice NRF5340_AUDIO_GATEWAY_SCAN_MODE
	prompt "Select Scan Mode to find Unicast Headset"
	default SCAN_MODE_PASSIVE

config SCAN_MODE_PASSIVE
	bool "Passive Scan"

config SCAN_MODE_ACTIVE
	bool "Active Scan"

endchoice

#----------------------------------------------------------------------------#
menu "Connection"

config BLE_ACL_CONN_INTERVAL
	int "Bluetooth LE ACL Connection Interval (x*1.25ms)"
	default 32
	help
	  When the LE Audio Controller Subsystem for nRF53 is used, this
	  interval should be a multiple of the ISO interval and maximum 4x
	  larger than the lowest interval.

config BLE_ACL_SLAVE_LATENCY
	int "Bluetooth LE Slave Latency"
	default 0

config BLE_ACL_SUP_TIMEOUT
	int "Bluetooth LE Supervision Timeout (x*10ms)"
	default 100

endmenu # Connection

#----------------------------------------------------------------------------#
menu "Log level"

module = BT_MGMT_SCAN
module-str = bt-mgmt-scan
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log level
endmenu # Scanning


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_management/scanning/bt_mgmt_scan_for_broadcast_internal.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BT_MGMT_SCAN_FOR_BROADCAST_INTERNAL_H_
#define _BT_MGMT_SCAN_FOR_BROADCAST_INTERNAL_H_

#include <zephyr/bluetooth/bluetooth.h>

/**
 * @brief	Scan for a broadcaster with the given @p name.
 *
 * @param[in]	scan_param	Pointer to the struct containing parameters to use.
 * @param[in]	name		Broadcast name to search for.
 * @param[in]	brdcast_id	Broadcast ID to search for.
 *
 * @return	0 if success, error otherwise.
 */
int bt_mgmt_scan_for_broadcast_start(struct bt_le_scan_param *scan_param, char const *const name,
				     uint32_t brdcast_id);

#endif /* _BT_MGMT_SCAN_FOR_BROADCAST_INTERNAL_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_management/scanning/bt_mgmt_scan.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "bt_mgmt.h"

#include <zephyr/bluetooth/bluetooth.h>
#include <hci_core.h>

#include "bt_mgmt_scan_for_broadcast_internal.h"
#include "bt_mgmt_scan_for_conn_internal.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(bt_mgmt_scan, CONFIG_BT_MGMT_SCAN_LOG_LEVEL);

static char srch_name[BLE_SEARCH_NAME_MAX_LEN];

static void addr_print(void)
{
	char addr_str[BT_ADDR_LE_STR_LEN];
	static struct bt_le_oob _oob = {.addr = 0};

	/* NOTE: We are using an internal struct here to get the address without forcing the
	 * RPA to time out, should be changed once k_forever bug (DRGN-21459) has been fixed
	 */
	bt_addr_le_copy(&_oob.addr, &bt_dev.random_addr);

	(void)bt_addr_le_to_str(&_oob.addr, addr_str, BT_ADDR_LE_STR_LEN);
	LOG_INF("Local addr: %s. May time out. Updates not printed", addr_str);
}

int bt_mgmt_scan_start(uint16_t scan_intvl, uint16_t scan_win, enum bt_mgmt_scan_type type,
		       char const *const name, uint32_t brdcast_id)
{
	int ret;

	static int scan_interval = CONFIG_BT_BACKGROUND_SCAN_INTERVAL;
	static int scan_window = CONFIG_BT_BACKGROUND_SCAN_WINDOW;

	/* Only change search name if a new name has been supplied */
	if (name != NULL) {
		size_t name_size = MIN(strlen(name), BLE_SEARCH_NAME_MAX_LEN - 1);

		memcpy(srch_name, name, name_size);
		srch_name[name_size] = '\0';
	}

	if (scan_intvl != 0) {
		scan_interval = scan_intvl;
	}

	if (scan_win != 0) {
		scan_window = scan_win;
	}

	struct bt_le_scan_param *scan_param =
		BT_LE_SCAN_PARAM(NRF5340_AUDIO_GATEWAY_SCAN_TYPE, BT_LE_SCAN_OPT_FILTER_DUPLICATE,
				 scan_interval, scan_window);

	if (type == BT_MGMT_SCAN_TYPE_CONN && IS_ENABLED(CONFIG_BT_CENTRAL)) {
		ret = bt_mgmt_scan_for_conn_start(scan_param, srch_name);
	} else if (type == BT_MGMT_SCAN_TYPE_BROADCAST &&
		   IS_ENABLED(CONFIG_BT_BAP_BROADCAST_SINK)) {
		ret = bt_mgmt_scan_for_broadcast_start(scan_param, srch_name, brdcast_id);
	} else {
		LOG_WRN("Invalid scan type: %d, scan not started", type);
		return -EINVAL;
	}

	if (ret) {
		return ret;
	}

	addr_print();

	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Scanning successfully started");
	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_management/scanning/bt_mgmt_scan_for_conn.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "bt_mgmt_scan_for_conn_internal.h"

#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/conn.h>

#include "bt_mgmt.h"

#include <zephyr/logging/log.h>
LOG_MODULE_DECLARE(bt_mgmt_scan);

#define CONNECTION_PARAMETERS                                                                      \
	BT_LE_CONN_PARAM(CONFIG_BLE_ACL_CONN_INTERVAL, CONFIG_BLE_ACL_CONN_INTERVAL,               \
			 CONFIG_BLE_ACL_SLAVE_LATENCY, CONFIG_BLE_ACL_SUP_TIMEOUT)

static uint8_t bonded_num;
static struct bt_le_scan_cb scan_callback;
static bool cb_registered;
static char const *srch_name;

static void bond_check(const struct bt_bond_info *info, void *user_data)
{
	char addr_buf[BT_ADDR_LE_STR_LEN];

	bt_addr_le_to_str(&info->addr, addr_buf, BT_ADDR_LE_STR_LEN);

	LOG_DBG("Stored bonding found: %s", addr_buf);
	bonded_num++;
}

static void bond_connect(const struct bt_bond_info *info, void *user_data)
{
	int ret;
	const bt_addr_le_t *adv_addr = user_data;
	struct bt_conn *conn;
	char addr_string[BT_ADDR_LE_STR_LEN];

	if (!bt_addr_le_cmp(&info->addr, adv_addr)) {
		LOG_DBG("Found bonded device");

		/* Check if the device is still connected due to waiting for ACL timeout */
		struct bt_conn *bonded_conn = bt_conn_lookup_addr_le(BT_ID_DEFAULT, &info->addr);
		struct bt_conn_info info;

		if (bonded_conn != NULL) {
			ret = bt_conn_get_info(bonded_conn, &info);
			if (ret == 0 && info.state == BT_CONN_STATE_CONNECTED) {
				LOG_DBG("Trying to connect to an already connected conn");
				bt_conn_unref(bonded_conn);
				return;
			}

			/* Unref is needed due to bt_conn_lookup */
			bt_conn_unref(bonded_conn);
		}

		bt_le_scan_cb_unregister(&scan_callback);
		cb_registered = false;

		ret = bt_le_scan_stop();
		if (ret) {
			LOG_WRN("Stop scan failed: %d", ret);
		}

		bt_addr_le_to_str(adv_addr, addr_string, BT_ADDR_LE_STR_LEN);

		LOG_INF("Creating connection to bonded device: %s", addr_string);

		ret = bt_conn_le_create(adv_addr, BT_CONN_LE_CREATE_CONN, CONNECTION_PARAMETERS,
					&conn);
		if (ret) {
			LOG_WRN("Create ACL connection failed: %d", ret);

			ret = bt_mgmt_scan_start(0, 0, BT_MGMT_SCAN_TYPE_CONN, NULL,
						 BRDCAST_ID_NOT_USED);
			if (ret) {
				LOG_ERR("Failed to restart scanning: %d", ret);
			}
		}
	}
}

/**
 * @brief	Check the advertising data for the matching device name.
 *
 * @param[in]	data		The advertising data to be checked.
 * @param[in]	user_data	The user data that contains the pointer to the address.
 *
 * @retval	false	Stop going through adv data.
 * @retval	true	Continue checking the data.
 */
static bool device_name_check(struct bt_data *data, void *user_data)
{
	int ret;
	bt_addr_le_t *addr = user_data;
	struct bt_conn *conn;
	char addr_string[BT_ADDR_LE_STR_LEN];

	/* We only care about LTVs with name */
	if (data->type == BT_DATA_NAME_COMPLETE) {
		size_t srch_name_size = strlen(srch_name);

		if ((data->data_len == srch_name_size) &&
		    (strncmp(srch_name, data->data, srch_name_size) == 0)) {
			LOG_DBG("Device found: %s", srch_name);

			bt_le_scan_cb_unregister(&scan_callback);
			cb_registered = false;

			ret = bt_le_scan_stop();
			if (ret) {
				LOG_ERR("Stop scan failed: %d", ret);
			}

			bt_addr_le_to_str(addr, addr_string, BT_ADDR_LE_STR_LEN);

			LOG_INF("Creating connection to device: %s", addr_string);

			ret = bt_conn_le_create(addr, BT_CONN_LE_CREATE_CONN, CONNECTION_PARAMETERS,
						&conn);
			if (ret) {
				LOG_ERR("Could not init connection");

				ret = bt_mgmt_scan_start(0, 0, BT_MGMT_SCAN_TYPE_CONN, NULL,
							 BRDCAST_ID_NOT_USED);
				if (ret) {
					LOG_ERR("Failed to restart scanning: %d", ret);
				}
			}

			return false;
		}
	}

	return true;
}

/**
 * @brief	Callback handler for scan receive when scanning for connections.
 *
 * @param[in]	info	Advertiser packet and scan response information.
 * @param[in]	ad	Received advertising data.
 */
static void scan_recv_cb(const struct bt_le_scan_recv_info *info, struct net_buf_simple *ad)
{

	/* We only care about connectable advertisers */
	if (!(info->adv_props & BT_GAP_ADV_PROP_CONNECTABLE)) {
		return;
	}

	switch (info->adv_type) {
	case BT_GAP_ADV_TYPE_ADV_DIRECT_IND:
		/* Direct advertising has no payload, so no need to parse */
		bt_foreach_bond(BT_ID_DEFAULT, bond_connect, (void *)info->addr);
		break;
	case BT_GAP_ADV_TYPE_ADV_IND:
		/* Fall through */
	case BT_GAP_ADV_TYPE_EXT_ADV:
		/* Fall through */
	case BT_GAP_ADV_TYPE_SCAN_RSP:
		/* Note: May lead to connection creation */
		if (bonded_num < CONFIG_BT_MAX_PAIRED) {
			bt_data_parse(ad, device_name_check, (void *)info->addr);
		} else {
			/* All bonded slots are taken, so we will only
			 * accept previously bonded devices
			 */
			bt_foreach_bond(BT_ID_DEFAULT, bond_connect, (void *)info->addr);
		}
		break;
	default:
		break;
	}
}

int bt_mgmt_scan_for_conn_start(struct bt_le_scan_param *scan_param, char const *const name)
{
	int ret;

	srch_name = name;

	if (!cb_registered) {
		scan_callback.recv = scan_recv_cb;
		bt_le_scan_cb_register(&scan_callback);
		cb_registered = true;
	} else {
		/* Already scanning, stop current scan to update param in case it has changed */
		ret = bt_le_scan_stop();
		if (ret && ret != -EALREADY) {
			LOG_ERR("Failed to stop scan: %d", ret);
			return ret;
		}
	}

	/* Reset number of bonds found */
	bonded_num = 0;

	bt_foreach_bond(BT_ID_DEFAULT, bond_check, NULL);

	if (bonded_num >= CONFIG_BT_MAX_PAIRED) {
		/* NOTE: The string below is used by the Nordic CI system */
		LOG_INF("All bonded slots filled, will not accept new devices");
	}

	ret = bt_le_scan_start(scan_param, NULL);
	if (ret && ret != -EALREADY) {
		return ret;
	}

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_management/scanning/bt_mgmt_scan_for_broadcast.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "bt_mgmt_scan_for_broadcast_internal.h"

#include <zephyr/zbus/zbus.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/gap.h>
#include <zephyr/bluetooth/uuid.h>
#include <zephyr/bluetooth/audio/audio.h>
#include <zephyr/sys/byteorder.h>

#include "bt_mgmt.h"
#include "macros_common.h"
#include "nrf5340_audio_common.h"

#include <zephyr/logging/log.h>
LOG_MODULE_DECLARE(bt_mgmt_scan);

/* Any value above 0xFFFFFF is invalid, so one can use 0xFFFFFFFF to denote
 * an invalid broadcast ID.
 */
#define INVALID_BROADCAST_ID 0xFFFFFFFF
#define PA_SYNC_SKIP	     2
/* Similar to retries for connections */
#define SYNC_RETRY_COUNT     6

ZBUS_CHAN_DECLARE(bt_mgmt_chan);

struct bt_le_scan_cb scan_callback;
static bool scan_cb_registered;
static bool sync_cb_registered;
static char const *srch_name;
static uint32_t srch_brdcast_id = BRDCAST_ID_NOT_USED;
static struct bt_le_per_adv_sync *pa_sync;
static uint32_t broadcaster_broadcast_id;

struct broadcast_source {
	char name[BLE_SEARCH_NAME_MAX_LEN];
	uint32_t broadcast_id;
};

static void scan_restart_worker(struct k_work *work)
{
	int ret;

	ret = bt_le_scan_stop();
	if (ret && ret != -EALREADY) {
		LOG_WRN("Stop scan failed: %d", ret);
	}

	/* Delete pending PA sync before restarting scan */
	ret = bt_mgmt_pa_sync_delete(pa_sync);
	if (ret) {
		LOG_WRN("Failed to delete pending PA sync: %d", ret);
	}

	ret = bt_mgmt_scan_start(0, 0, BT_MGMT_SCAN_TYPE_BROADCAST, NULL, BRDCAST_ID_NOT_USED);
	if (ret) {
		LOG_WRN("Failed to restart scanning for broadcast: %d", ret);
	}
}

K_WORK_DEFINE(scan_restart_work, scan_restart_worker);

static void pa_sync_timeout(struct k_timer *timer)
{
	LOG_WRN("PA sync create timed out, restarting scanning");

	k_work_submit(&scan_restart_work);
}

K_TIMER_DEFINE(pa_sync_timer, pa_sync_timeout, NULL);

static uint16_t interval_to_sync_timeout(uint16_t interval)
{
	uint16_t timeout;

	/* Ensure that the following calculation does not overflow silently */
	__ASSERT(SYNC_RETRY_COUNT < 10, "SYNC_RETRY_COUNT shall be less than 10");

	/* Add retries and convert to unit in 10s of ms */
	timeout = ((uint32_t)interval * SYNC_RETRY_COUNT) / 10;

	/* Enforce restraints */
	timeout = CLAMP(timeout, BT_GAP_PER_ADV_MIN_TIMEOUT, BT_GAP_PER_ADV_MAX_TIMEOUT);

	return timeout;
}

static void periodic_adv_sync(const struct bt_le_scan_recv_info *info, uint32_t broadcast_id)
{
	int ret;
	struct bt_le_per_adv_sync_param param;

	bt_le_scan_cb_unregister(&scan_callback);
	scan_cb_registered = false;

	bt_addr_le_copy(&param.addr, info->addr);
	param.options = 0;
	param.sid = info->sid;
	param.skip = PA_SYNC_SKIP;
	param.timeout = interval_to_sync_timeout(info->interval);

	broadcaster_broadcast_id = broadcast_id;

	/* Set timeout to same value as PA sync timeout in ms */
	k_timer_start(&pa_sync_timer, K_MSEC(param.timeout * 10), K_NO_WAIT);

	ret = bt_le_per_adv_sync_create(&param, &pa_sync);
	if (ret) {
		LOG_ERR("Could not sync to PA: %d", ret);
		ret = bt_mgmt_pa_sync_delete(pa_sync);
		if (ret) {
			LOG_ERR("Could not delete PA sync: %d", ret);
		}
		return;
	}
}

/**
 * @brief	Check and parse advertising data for broadcast name and ID.
 *
 * @param[in]	data		Advertising data to check and parse.
 * @param[out]	user_data	Will contain pointer to broadcast_source struct to be populated.
 *
 * @retval	true	Continue to parse LTVs.
 * @retval	false	Stop parsing LTVs.
 */
static bool scan_check_broadcast_source(struct bt_data *data, void *user_data)
{
	struct broadcast_source *source = (struct broadcast_source *)user_data;
	struct bt_uuid_16 adv_uuid;

	if (data->type == BT_DATA_BROADCAST_NAME && data->data_len) {
		/* Ensure that broadcast name is at least one character shorter than the value of
		 * BLE_SEARCH_NAME_MAX_LEN
		 */
		if (data->data_len < BLE_SEARCH_NAME_MAX_LEN) {
			memcpy(source->name, data->data, data->data_len);
			source->name[data->data_len] = '\0';
		}

		return true;
	}

	if (data->type != BT_DATA_SVC_DATA16) {
		return true;
	}

	if (data->data_len < BT_UUID_SIZE_16 + BT_AUDIO_BROADCAST_ID_SIZE) {
		return true;
	}

	if (!bt_uuid_create(&adv_uuid.uuid, data->data, BT_UUID_SIZE_16)) {
		return false;
	}

	if (bt_uuid_cmp(&adv_uuid.uuid, BT_UUID_BROADCAST_AUDIO)) {
		return true;
	}

	source->broadcast_id = sys_get_le24(data->data + BT_UUID_SIZE_16);

	return true;
}

/**
 * @brief	Callback handler for scan receive when scanning for broadcasters.
 *
 * @param[in]	info	Advertiser packet and scan response information.
 * @param[in]	ad	Received advertising data.
 */
static void scan_recv_cb(const struct bt_le_scan_recv_info *info, struct net_buf_simple *ad)
{
	struct broadcast_source source = {.broadcast_id = INVALID_BROADCAST_ID};

	/* We are only interested in non-connectable periodic advertisers */
	if ((info->adv_props & BT_GAP_ADV_PROP_CONNECTABLE) || info->interval == 0) {
		return;
	}

	bt_data_parse(ad, scan_check_broadcast_source, (void *)&source);

	if (source.broadcast_id != INVALID_BROADCAST_ID) {
		if (srch_brdcast_id < BRDCAST_ID_NOT_USED) {
			/* Valid srch_brdcast_id supplied */
			if (source.broadcast_id != srch_brdcast_id) {
				/* Broadcaster does not match src_brdcast_id */
				return;
			}

		} else if (strncmp(source.name, srch_name, BLE_SEARCH_NAME_MAX_LEN) != 0) {
			/* Broadcaster does not match src_name */
			return;
		}

		LOG_INF("Broadcast source %s found, id: 0x%06x", source.name, source.broadcast_id);
		periodic_adv_sync(info, source.broadcast_id);
	}
}

static void pa_synced_cb(struct bt_le_per_adv_sync *sync,
			 struct bt_le_per_adv_sync_synced_info *info)
{
	int ret;
	struct bt_mgmt_msg msg;

	if (sync != pa_sync) {
		LOG_WRN("Synced to unknown source");
		return;
	}

	LOG_DBG("PA synced");

	k_timer_stop(&pa_sync_timer);

	ret = bt_le_scan_stop();
	if (ret && ret != -EALREADY) {
		LOG_WRN("Stop scan failed: %d", ret);
	}

	msg.event = BT_MGMT_PA_SYNCED;
	msg.pa_sync = sync;
	msg.broadcast_id = broadcaster_broadcast_id;

	ret = zbus_chan_pub(&bt_mgmt_chan, &msg, K_NO_WAIT);
	ERR_CHK(ret);
}

static void pa_sync_terminated_cb(struct bt_le_per_adv_sync *sync,
				  const struct bt_le_per_adv_sync_term_info *info)
{
	int ret;
	struct bt_mgmt_msg msg;

	LOG_DBG("Periodic advertising sync lost");

	msg.event = BT_MGMT_PA_SYNC_LOST;
	msg.pa_sync = sync;
	msg.pa_sync_term_reason = info->reason;

	ret = zbus_chan_pub(&bt_mgmt_chan, &msg, K_NO_WAIT);
	ERR_CHK(ret);
}

static struct bt_le_per_adv_sync_cb sync_callbacks = {
	.synced = pa_synced_cb,
	.term = pa_sync_terminated_cb,
};

int bt_mgmt_scan_for_broadcast_start(struct bt_le_scan_param *scan_param, char const *const name,
				     uint32_t brdcast_id)
{
	int ret;

	if (!sync_cb_registered) {
		bt_le_per_adv_sync_cb_register(&sync_callbacks);
		sync_cb_registered = true;
	}

	if (!scan_cb_registered) {
		scan_callback.recv = scan_recv_cb;
		bt_le_scan_cb_register(&scan_callback);
		scan_cb_registered = true;
	} else {
		if (name == srch_name) {
			return -EALREADY;
		}
		/* Might already be scanning, stop current scan to update param in case it has
		 * changed.
		 */
		ret = bt_le_scan_stop();
		if (ret && ret != -EALREADY) {
			LOG_ERR("Failed to stop scan: %d", ret);
			return ret;
		}
	}

	srch_name = name;
	if (brdcast_id != BRDCAST_ID_NOT_USED) {
		srch_brdcast_id = brdcast_id;
	}

	ret = bt_le_scan_start(scan_param, NULL);
	if (ret) {
		return ret;
	}

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_management/advertising/Kconfig.default
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

config BT_EXT_ADV
	default y


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_management/advertising/bt_mgmt_adv.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "bt_mgmt.h"

#include <zephyr/zbus/zbus.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/conn.h>

#include "macros_common.h"
#include "nrf5340_audio_common.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(bt_mgmt_adv, CONFIG_BT_MGMT_ADV_LOG_LEVEL);

ZBUS_CHAN_DECLARE(bt_mgmt_chan);

#ifndef CONFIG_BT_MAX_PAIRED
#define BONDS_QUEUE_SIZE 0
#else
#define BONDS_QUEUE_SIZE CONFIG_BT_MAX_PAIRED
#endif

static struct k_work adv_work;
static bool dir_adv_timed_out;
static struct bt_le_ext_adv *ext_adv;

static const struct bt_data *adv_local;
static size_t adv_local_size;
static const struct bt_data *per_adv_local;
static size_t per_adv_local_size;

/* Bonded address queue */
K_MSGQ_DEFINE(bonds_queue, sizeof(bt_addr_le_t), BONDS_QUEUE_SIZE, 4);

static void bond_find(const struct bt_bond_info *info, void *user_data)
{
	int ret;
	struct bt_conn *conn;

	if (!IS_ENABLED(CONFIG_BT_BONDABLE)) {
		return;
	}

	/* Filter already connected peers. */
	conn = bt_conn_lookup_addr_le(BT_ID_DEFAULT, &info->addr);
	if (conn) {
		struct bt_conn_info conn_info;

		ret = bt_conn_get_info(conn, &conn_info);
		if (ret) {
			LOG_WRN("Could not get conn info");
			bt_conn_unref(conn);
			return;
		}

		if (conn_info.state == BT_CONN_STATE_CONNECTED) {
			LOG_WRN("Already connected");
			bt_conn_unref(conn);
			return;
		}

		bt_conn_unref(conn);
	}

	ret = k_msgq_put(&bonds_queue, (void *)&info->addr, K_NO_WAIT);
	if (ret) {
		LOG_WRN("No space in the queue for the bond");
	}
}

static void filter_accept_list_add(const struct bt_bond_info *info, void *user_data)
{
	int ret;

	ret = bt_le_filter_accept_list_add(&info->addr);
	if (ret) {
		LOG_WRN("Could not add peer to Filter Accept List: %d", ret);
		return;
	}
}

/**
 * @brief Prints the address of the local device and the remote device.
 *
 * @note The address of the remote device is only printed if directed advertisement is active.
 */
static int addr_print(bt_addr_le_t const *const local_addr, bt_addr_le_t const *const dir_adv_addr)
{
	char local_addr_str[BT_ADDR_LE_STR_LEN] = {'\0'};
	char directed_to_addr_str[BT_ADDR_LE_STR_LEN] = {'\0'};

	if (local_addr == NULL) {
		return -EINVAL;
	}

	(void)bt_addr_le_to_str(local_addr, local_addr_str, BT_ADDR_LE_STR_LEN);
	LOG_INF("Local addr: %s", local_addr_str);

	if (dir_adv_addr != NULL) {
		(void)bt_addr_le_to_str(dir_adv_addr, directed_to_addr_str, BT_ADDR_LE_STR_LEN);
		LOG_INF("Adv directed to: %s.", directed_to_addr_str);
	}

	return 0;
}

#if defined(CONFIG_BT_PRIVACY)
static bool adv_rpa_expired_cb(struct bt_le_ext_adv *adv)
{
	int ret;
	struct bt_le_ext_adv_info ext_adv_info;

	LOG_INF("RPA (Resolvable Private Address) expired.");

	ret = bt_le_ext_adv_get_info(ext_adv, &ext_adv_info);
	ERR_CHK_MSG(ret, "bt_le_ext_adv_get_info failed");

	ret = addr_print(ext_adv_info.addr, NULL);
	if (ret) {
		LOG_ERR("addr_print failed");
	}

	return true;
}
#endif /* CONFIG_BT_PRIVACY */

static const struct bt_le_ext_adv_cb adv_cb = {
#if defined(CONFIG_BT_PRIVACY)
	.rpa_expired = adv_rpa_expired_cb,
#endif /* CONFIG_BT_PRIVACY */
};

static int direct_adv_create(bt_addr_le_t addr)
{
	int ret;
	struct bt_le_adv_param adv_param;
	struct bt_le_ext_adv_info ext_adv_info;

	adv_param = *BT_LE_ADV_CONN_DIR(&addr);
	adv_param.id = BT_ID_DEFAULT;
	adv_param.options |= BT_LE_ADV_OPT_DIR_ADDR_RPA;

	/* Clear ADV data set before update to direct advertising */
	ret = bt_le_ext_adv_set_data(ext_adv, NULL, 0, NULL, 0);
	if (ret) {
		LOG_ERR("Failed to clear advertising data. Err: %d", ret);
		return ret;
	}

	ret = bt_le_ext_adv_update_param(ext_adv, &adv_param);
	if (ret) {
		LOG_ERR("Failed to update ext_adv to direct advertising. Err = %d", ret);
		return ret;
	}

	ret = bt_le_ext_adv_get_info(ext_adv, &ext_adv_info);
	if (ret) {
		return ret;
	}

	ret = addr_print(ext_adv_info.addr, &addr);
	if (ret) {
		return ret;
	}

	return 0;
}

static int extended_adv_create(void)
{
	int ret;
	struct bt_le_ext_adv_info ext_adv_info;

	if (adv_local == NULL) {
		LOG_ERR("Adv_local not set");
		return -ENXIO;
	}

	if (dir_adv_timed_out) {
		/* If the directed adv has timed out it means we only need to update the adv data */
		bt_le_adv_update_data(adv_local, adv_local_size, NULL, 0);
	} else {
		ret = bt_le_ext_adv_set_data(ext_adv, adv_local, adv_local_size, NULL, 0);
		if (ret) {
			LOG_ERR("Failed to set advertising data: %d", ret);
			return ret;
		}
	}

	if (per_adv_local != NULL && IS_ENABLED(CONFIG_BT_PER_ADV)) {
		/* Set periodic advertising parameters */
		ret = bt_le_per_adv_set_param(ext_adv, LE_AUDIO_PERIODIC_ADV);
		if (ret) {
			LOG_ERR("Failed to set periodic advertising parameters: %d", ret);
			return ret;
		}

		ret = bt_le_per_adv_set_data(ext_adv, per_adv_local, per_adv_local_size);
		if (ret) {
			LOG_ERR("Failed to set periodic advertising data: %d", ret);
			return ret;
		}
	}

	ret = bt_le_ext_adv_get_info(ext_adv, &ext_adv_info);
	if (ret) {
		return ret;
	}

	ret = addr_print(ext_adv_info.addr, NULL);
	if (ret) {
		return ret;
	}

	return 0;
}

static void advertising_process(struct k_work *work)
{
	int ret;
	struct bt_mgmt_msg msg;

	k_msgq_purge(&bonds_queue);

	if (IS_ENABLED(CONFIG_BT_BONDABLE)) {
		bt_foreach_bond(BT_ID_DEFAULT, bond_find, NULL);
		/* Populate Filter Accept List */
		if (IS_ENABLED(CONFIG_BT_FILTER_ACCEPT_LIST)) {
			ret = bt_le_filter_accept_list_clear();
			if (ret) {
				LOG_ERR("Failed to clear filter accept list");
				return;
			}

			bt_foreach_bond(BT_ID_DEFAULT, filter_accept_list_add, NULL);
		}
	}

	bt_addr_le_t addr;

	if (!k_msgq_get(&bonds_queue, &addr, K_NO_WAIT) && !dir_adv_timed_out) {
		ret = direct_adv_create(addr);
		if (ret) {
			LOG_WRN("Failed to create direct advertisement: %d", ret);
			return;
		}

		ret = bt_le_ext_adv_start(
			ext_adv,
			BT_LE_EXT_ADV_START_PARAM(BT_GAP_ADV_HIGH_DUTY_CYCLE_MAX_TIMEOUT, 0));
	} else {
		ret = extended_adv_create();
		if (ret) {
			LOG_WRN("Failed to create extended advertisement: %d", ret);
			return;
		}

		dir_adv_timed_out = false;
		ret = bt_le_ext_adv_start(ext_adv, BT_LE_EXT_ADV_START_DEFAULT);
	}

	if (ret) {
		LOG_ERR("Failed to start advertising set. Err: %d", ret);
		return;
	}

	if (per_adv_local != NULL && IS_ENABLED(CONFIG_BT_PER_ADV)) {
		/* Enable Periodic Advertising */
		ret = bt_le_per_adv_start(ext_adv);
		if (ret) {
			LOG_ERR("Failed to enable periodic advertising: %d", ret);
			return;
		}

		msg.event = BT_MGMT_EXT_ADV_WITH_PA_READY;
		msg.ext_adv = ext_adv;

		ret = zbus_chan_pub(&bt_mgmt_chan, &msg, K_NO_WAIT);
		ERR_CHK(ret);
	}

	/* NOTE: The string below is used by the Nordic CI system */
	LOG_INF("Advertising successfully started");
}

void bt_mgmt_dir_adv_timed_out(void)
{
	int ret;

	dir_adv_timed_out = true;

	LOG_DBG("Clearing ext_adv");

	ret = bt_le_ext_adv_delete(ext_adv);
	if (ret) {
		LOG_ERR("Failed to clear ext_adv");
	}

	if (IS_ENABLED(CONFIG_BT_FILTER_ACCEPT_LIST)) {
		ret = bt_le_ext_adv_create(LE_AUDIO_EXTENDED_ADV_CONN_NAME_FILTER, &adv_cb,
					   &ext_adv);
	} else {
		ret = bt_le_ext_adv_create(LE_AUDIO_EXTENDED_ADV_CONN_NAME, &adv_cb, &ext_adv);
	}

	if (ret) {
		LOG_ERR("Unable to create a connectable extended advertising set: %d", ret);
		return;
	}

	/* Restart normal advertising */
	bt_mgmt_adv_start(NULL, 0, NULL, 0, true);
}

int bt_mgmt_adv_start(const struct bt_data *adv, size_t adv_size, const struct bt_data *per_adv,
		      size_t per_adv_size, bool connectable)
{
	int ret;

	/* Special case for restarting advertising */
	if (adv == NULL && adv_size == 0 && per_adv == NULL && per_adv_size == 0) {
		if (adv_local == NULL) {
			LOG_ERR("No valid advertising data stored");
			return -ENOENT;
		}

		k_work_submit(&adv_work);

		return 0;
	}

	if (adv == NULL) {
		LOG_ERR("No adv struct received");
		return -EINVAL;
	}

	if (adv_size == 0) {
		LOG_ERR("Invalid size of adv struct");
		return -EINVAL;
	}

	adv_local = adv;
	adv_local_size = adv_size;
	per_adv_local = per_adv;
	per_adv_local_size = per_adv_size;

	if (connectable) {
		ret = bt_le_ext_adv_create(LE_AUDIO_EXTENDED_ADV_CONN_NAME, &adv_cb, &ext_adv);
		if (ret) {
			LOG_ERR("Unable to create a connectable extended advertising set: %d", ret);
			return ret;
		}
	} else {
		ret = bt_le_ext_adv_create(LE_AUDIO_EXTENDED_ADV_NAME, &adv_cb, &ext_adv);
		if (ret) {
			LOG_ERR("Unable to create extended advertising set: %d", ret);
			return ret;
		}
	}

	k_work_submit(&adv_work);

	return 0;
}

void bt_mgmt_adv_init(void)
{
	k_work_init(&adv_work, advertising_process);
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_management/advertising/bt_mgmt_adv_internal.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BT_MGMT_ADV_INTERNAL_H_
#define _BT_MGMT_ADV_INTERNAL_H_

#include <zephyr/bluetooth/bluetooth.h>

/**
 * @brief	Initialize the advertising part of the Bluetooth management module.
 */
void bt_mgmt_adv_init(void);

/**
 * @brief	Handle timed-out directed advertisement.
 *
 *		This function deletes the old ext_adv and creates a new one.
 *		It also sets the dir_adv_timed_out flag and restarts advertisement.
 */
void bt_mgmt_dir_adv_timed_out(void);

#endif /* _BT_MGMT_ADV_INTERNAL_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_management/advertising/Kconfig
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

menu "Advertising"

config BLE_ACL_PER_ADV_INT_MIN
	hex "Minimum periodic advertising interval"
	range 0x0018 0x03C0
	default 0x0078
	help
	  Minimum hexadecimal value for the interval of periodic advertisements.
	  For ms, multiply the provided value by 1.25.

config BLE_ACL_PER_ADV_INT_MAX
	hex "Maximum periodic advertising interval"
	range 0x0018 0x03C0
	default 0x00A0
	help
	  Maximum hexadecimal value for the interval of periodic advertisements.
	  For ms, multiply the provided value by 1.25.

config BLE_ACL_EXT_ADV_INT_MIN
	hex "Minimum extended advertising interval"
	range 0x0030 0x0780
	default 0x30 if TRANSPORT_BIS
	default 0x00A0
	help
	  Minimum hexadecimal value for the interval of extended advertisements.
	  When the LE Audio Controller Subsystem for nRF53 is used, this interval
	  should be a multiple of the ISO interval and maximum 4x larger than the
	  lowest interval if using BIS.
	  For ms, multiply the provided value by 0.625.

config BLE_ACL_EXT_ADV_INT_MAX
	hex "Maximum extended advertising interval"
	range 0x0030 0x0780
	default 0x40 if TRANSPORT_BIS
	default 0x00F0
	help
	  Maximum hexadecimal value for the interval of extended advertisements.
	  When the LE Audio Controller Subsystem for nRF53 is used, this interval
	  should be a multiple of the ISO interval and maximum 4x larger than the
	  lowest interval if using BIS.
	  For ms, multiply the provided value by 0.625.

config EXT_ADV_BUF_MAX
	int "Maximum number of extended advertising data parameters"
	default 20

config EXT_ADV_UUID_BUF_MAX
	int "Maximum number of UUIDs to add to extended advertisements"
	default 20

#----------------------------------------------------------------------------#
menu "Log level"

module = BT_MGMT_ADV
module-str = bt-mgmt-adv
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log level
endmenu # Advertising


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_management/controller_config/Kconfig.defaults
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

# Bluetooth controller type
if BT_LL_ACS_NRF53

# Not supported on LE Audio Controller Subsystem for nRF53
config BT_ATT_ENFORCE_FLOW
	default n

# Disable Zephyr HCI Vendor-Specific extensions
config BT_HCI_VS_EXT
	default n

# HCI ACL flow control is not supported on BT_LL_ACS_NRF53
config BT_HCI_ACL_FLOW_CONTROL
	default n

endif # BT_LL_ACS_NRF53


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_management/controller_config/Kconfig
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

rsource "Kconfig.defaults"

menu "Controller config"

#----------------------------------------------------------------------------#
menu "nRF21540"

config NRF_21540_ACTIVE
	def_bool $(shields_list_contains,nrf21540ek_fwd)
	select EXPERIMENTAL
	help
	  The front end module can help boost the TX power as high as 20 dBm.

choice NRF_21540_MAIN_TX_POWER
	prompt "TX power for the secondary channels"
	default NRF_21540_MAIN_TX_POWER_10DBM
	help
	  Set the TX power for the secondary Bluetooth LE channels (0-36).
	  Check your local regulations for max output power. If the
	  nRF21540 is used with the nRF5340 Audio DK the actual output power
	  will be about 25% lower due to the VDD being 1.8V instead of the
	  nominal 3.3V.

config NRF_21540_MAIN_TX_POWER_0DBM
	bool "0dBm"

config NRF_21540_MAIN_TX_POWER_10DBM
	bool "+10dBm"

config NRF_21540_MAIN_TX_POWER_20DBM
	bool "+20dBm"

endchoice

config NRF_21540_MAIN_DBM
	int
	default 0 if NRF_21540_MAIN_TX_POWER_0DBM
	default 10 if NRF_21540_MAIN_TX_POWER_10DBM
	default 20 if NRF_21540_MAIN_TX_POWER_20DBM

choice NRF_21540_PRI_ADV_TX_POWER
	prompt "TX power for the primary advertising channels"
	default NRF_21540_PRI_ADV_TX_POWER_10DBM
	help
	  Set the TX power for the primary Bluetooth LE advertising channels
	  (37, 38, 39).
	  Check your local regulations for max output power. If the
	  nRF21540 is used with the nRF5340 Audio DK the actual output power
	  will be about 25% lower due to the VDD being 1.8V instead of the
	  nominal 3.3V.

config NRF_21540_PRI_ADV_TX_POWER_0DBM
	bool "0dBm"

config NRF_21540_PRI_ADV_TX_POWER_10DBM
	bool "+10dBm"

config NRF_21540_PRI_ADV_TX_POWER_20DBM
	bool "+20dBm"

endchoice

config NRF_21540_PRI_ADV_DBM
	int
	default 0 if NRF_21540_PRI_ADV_TX_POWER_0DBM
	default 10 if NRF_21540_PRI_ADV_TX_POWER_10DBM
	default 20 if NRF_21540_PRI_ADV_TX_POWER_20DBM

endmenu # nRF21540

#----------------------------------------------------------------------------#
menu "Log level"

module = BT_MGMT_CTLR_CFG
module-str = bt-mgmt-ctlr-cfg
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log level
endmenu # Controller config


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_management/controller_config/bt_mgmt_ctlr_cfg_internal.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BT_MGMT_CTRL_CFG_INTERNAL_H_
#define _BT_MGMT_CTRL_CFG_INTERNAL_H_

#include <stdbool.h>
#include <stdint.h>

/**
 * @brief	Get the Bluetooth controller manufacturer.
 *
 * @param[in]   print_version   Print the controller version.
 * @param[out]	manufacturer	The controller manufacturer.
 *
 * @return	0 if success, error otherwise.
 */
int bt_mgmt_ctlr_cfg_manufacturer_get(bool print_version, uint16_t *manufacturer);

/**
 * @brief	Configure the Bluetooth controller.
 *
 * @param[in]	watchdog_enable	If true, the function will, at given intervals, poll the controller
 *				to ensure it is still alive.
 *
 * @return	0 if success, error otherwise.
 */
int bt_mgmt_ctlr_cfg_init(bool watchdog_enable);

#endif /* _BT_MGMT_CTRL_CFG_INTERNAL_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_management/controller_config/bt_mgmt_ctlr_cfg.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "bt_mgmt_ctlr_cfg_internal.h"

#include <zephyr/bluetooth/hci.h>
#include <zephyr/sys/byteorder.h>
#include <zephyr/drivers/watchdog.h>
#include <zephyr/task_wdt/task_wdt.h>

#include "macros_common.h"
#if (CONFIG_BT_LL_ACS_NRF53)
#include "ble_hci_vsc.h"
#endif /* (CONFIG_BT_LL_ACS_NRF53) */

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(bt_mgmt_ctlr_cfg, CONFIG_BT_MGMT_CTLR_CFG_LOG_LEVEL);

#define COMPANY_ID_NORDIC      0x0059
#define COMPANY_ID_PACKETCRAFT 0x07E8

#define WDT_TIMEOUT_MS	      1500
#define CTLR_POLL_INTERVAL_MS (WDT_TIMEOUT_MS - 500)

static struct k_work work_ctlr_poll;

#define CTLR_POLL_WORK_STACK_SIZE 1024

K_THREAD_STACK_DEFINE(ctlr_poll_stack_area, CTLR_POLL_WORK_STACK_SIZE);

struct k_work_q ctrl_poll_work_q;

struct k_work_queue_config ctrl_poll_work_q_config = {
	.name = "ctlr_poll",
	.no_yield = false,
};

static void ctlr_poll_timer_handler(struct k_timer *timer_id);
static int wdt_ch_id;

K_TIMER_DEFINE(ctlr_poll_timer, ctlr_poll_timer_handler, NULL);

static int bt_ll_acs_nrf53_cfg(void)
{
#if (CONFIG_BT_LL_ACS_NRF53)
	int ret;
	/* Enable notification of lost ISO packets */
	ret = ble_hci_vsc_op_flag_set(BLE_HCI_VSC_OP_ISO_LOST_NOTIFY, 1);
	if (ret) {
		return ret;
	}

#if (CONFIG_NRF_21540_ACTIVE)
	/* Indexes for the pins gotten from nrf21540ek_fwd.overlay */
	uint8_t tx_pin = NRF_DT_GPIOS_TO_PSEL_BY_IDX(DT_PATH(nrf_gpio_forwarder, nrf21540_gpio_if),
						     gpios, 0);
	uint8_t rx_pin = NRF_DT_GPIOS_TO_PSEL_BY_IDX(DT_PATH(nrf_gpio_forwarder, nrf21540_gpio_if),
						     gpios, 1);
	uint8_t pdn_pin = NRF_DT_GPIOS_TO_PSEL_BY_IDX(DT_PATH(nrf_gpio_forwarder, nrf21540_gpio_if),
						      gpios, 2);
	uint8_t ant_pin = NRF_DT_GPIOS_TO_PSEL_BY_IDX(DT_PATH(nrf_gpio_forwarder, nrf21540_gpio_if),
						      gpios, 3);
	uint8_t mode_pin = NRF_DT_GPIOS_TO_PSEL_BY_IDX(
		DT_PATH(nrf_gpio_forwarder, nrf21540_gpio_if), gpios, 4);

	struct ble_hci_vs_cp_nrf21540_pins nrf21540_pins = {
		.mode = mode_pin,
		.txen = tx_pin,
		.rxen = rx_pin,
		.antsel = ant_pin,
		.pdn = pdn_pin,
		/* Set CS pin to ffff since we are not using the SPI */
		.csn = 0xffff};

	ret = ble_hci_vsc_nrf21540_pins_set(&nrf21540_pins);
	if (ret) {
		return ret;
	}

	ret = ble_hci_vsc_radio_high_pwr_mode_set(
		MAX(CONFIG_NRF_21540_MAIN_DBM, CONFIG_NRF_21540_PRI_ADV_DBM));
	if (ret) {
		return ret;
	}

	ret = ble_hci_vsc_adv_tx_pwr_set(CONFIG_NRF_21540_MAIN_DBM);
	if (ret) {
		return ret;
	}

	LOG_DBG("TX power set to %d", CONFIG_NRF_21540_MAIN_DBM);

	ret = ble_hci_vsc_pri_adv_chan_max_tx_pwr_set(CONFIG_NRF_21540_PRI_ADV_DBM);
	if (ret) {
		return ret;
	}

	LOG_DBG("Primary advertising TX power set to %d", CONFIG_NRF_21540_PRI_ADV_DBM);
#else
	ret = ble_hci_vsc_adv_tx_pwr_set(CONFIG_BLE_ADV_TX_POWER_DBM);
	if (ret) {
		return ret;
	}

	LOG_DBG("TX power set to %d", CONFIG_BLE_ADV_TX_POWER_DBM);

	/* Disabled by default, only used if another TX power for primary adv channels is needed */
	ret = ble_hci_vsc_pri_adv_chan_max_tx_pwr_set(BLE_HCI_VSC_PRI_EXT_ADV_MAX_TX_PWR_DISABLE);
	if (ret) {
		return ret;
	}

#endif /*CONFIG_NRF_21540_ACTIVE*/

	/* Map controller LEDs*/

	ret = ble_hci_vsc_led_pin_map(PAL_LED_ID_CPU_ACTIVE,
				      DT_GPIO_FLAGS_BY_IDX(DT_NODELABEL(rgb2_green), gpios, 0),
				      DT_GPIO_PIN_BY_IDX(DT_NODELABEL(rgb2_green), gpios, 0));
	if (ret) {
		return ret;
	}

	ret = ble_hci_vsc_led_pin_map(PAL_LED_ID_ERROR,
				      DT_GPIO_FLAGS_BY_IDX(DT_NODELABEL(rgb2_red), gpios, 0),
				      DT_GPIO_PIN_BY_IDX(DT_NODELABEL(rgb2_red), gpios, 0));
	if (ret) {
		return ret;
	}

	return 0;
#else
	return -ENODEV;
#endif /* CONFIG_BT_LL_ACS_NRF53*/
}

static void work_ctlr_poll_handler(struct k_work *work)
{
	int ret;
	uint16_t manufacturer = 0;

	ret = bt_mgmt_ctlr_cfg_manufacturer_get(false, &manufacturer);
	ERR_CHK_MSG(ret, "Failed to contact net core");

	ret = task_wdt_feed(wdt_ch_id);
	ERR_CHK_MSG(ret, "Failed to feed watchdog");
}

static void ctlr_poll_timer_handler(struct k_timer *timer_id)
{
	int ret;

	ret = k_work_submit_to_queue(&ctrl_poll_work_q, &work_ctlr_poll);
	if (ret < 0) {
		LOG_ERR("Work q submit failed: %d", ret);
	}
}

static void wdt_timeout_cb(int channel_id, void *user_data)
{
	ERR_CHK_MSG(-ETIMEDOUT, "No response from IPC or controller");
}

int bt_mgmt_ctlr_cfg_manufacturer_get(bool print_version, uint16_t *manufacturer)
{
	int ret;
	struct net_buf *rsp;

	ret = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_VERSION_INFO, NULL, &rsp);
	if (ret) {
		return ret;
	}

	struct bt_hci_rp_read_local_version_info *rp = (void *)rsp->data;

	if (print_version) {
		if (rp->manufacturer == COMPANY_ID_PACKETCRAFT) {
			/* NOTE: The string below is used by the Nordic CI system */
			LOG_INF("Controller: LL_ACS_NRF53: Version %s (0x%02x), Revision %d",
				bt_hci_get_ver_str(rp->hci_version), rp->hci_version,
				rp->hci_revision);
		} else if (rp->manufacturer == COMPANY_ID_NORDIC) {
			/* NOTE: The string below is used by the Nordic CI system */
			LOG_INF("Controller: SoftDevice: Version %s (0x%02x), Revision %d",
				bt_hci_get_ver_str(rp->hci_version), rp->hci_version,
				rp->hci_revision);
		} else {
			LOG_ERR("Unsupported controller");
			return -EPERM;
		}
	}

	*manufacturer = sys_le16_to_cpu(rp->manufacturer);

	net_buf_unref(rsp);

	return 0;
}

int bt_mgmt_ctlr_cfg_init(bool watchdog_enable)
{
	int ret;
	uint16_t manufacturer = 0;

	ret = bt_mgmt_ctlr_cfg_manufacturer_get(true, &manufacturer);
	if (ret) {
		return ret;
	}

	if ((IS_ENABLED(CONFIG_BT_LL_ACS_NRF53) && (manufacturer != COMPANY_ID_PACKETCRAFT)) ||
	    (!IS_ENABLED(CONFIG_BT_LL_ACS_NRF53) && (manufacturer == COMPANY_ID_PACKETCRAFT))) {
		LOG_ERR("Controller config on APP and controller on NET mismatch.");
	}

	if (IS_ENABLED(CONFIG_BT_LL_ACS_NRF53) && (manufacturer == COMPANY_ID_PACKETCRAFT)) {
		ret = bt_ll_acs_nrf53_cfg();
		if (ret) {
			return ret;
		}
	}

	if (watchdog_enable) {
		ret = task_wdt_init(NULL);
		if (ret != 0) {
			LOG_ERR("task wdt init failure: %d\n", ret);
			return ret;
		}

		wdt_ch_id = task_wdt_add(WDT_TIMEOUT_MS, wdt_timeout_cb, NULL);
		if (wdt_ch_id < 0) {
			return wdt_ch_id;
		}
		k_work_queue_init(&ctrl_poll_work_q);

		k_work_queue_start(&ctrl_poll_work_q, ctlr_poll_stack_area,
				   K_THREAD_STACK_SIZEOF(ctlr_poll_stack_area),
				   K_PRIO_PREEMPT(CONFIG_CTLR_POLL_WORK_Q_PRIO),
				   &ctrl_poll_work_q_config);

		k_work_init(&work_ctlr_poll, work_ctlr_poll_handler);
		k_timer_start(&ctlr_poll_timer, K_MSEC(CTLR_POLL_INTERVAL_MS),
			      K_MSEC(CTLR_POLL_INTERVAL_MS));
	}

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_renderer/CMakeLists.txt
#
# Copyright (c) 2023 Nordic Semiconductor
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

zephyr_library_include_directories(
    volume
)

target_sources(app PRIVATE
	       ${CMAKE_CURRENT_SOURCE_DIR}/bt_rend.c)

if (CONFIG_BT_VCP_VOL_CTLR OR CONFIG_BT_VCP_VOL_REND)
target_sources(app PRIVATE
	        ${CMAKE_CURRENT_SOURCE_DIR}/volume/bt_rend_vol.c)
endif()


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_renderer/bt_rend.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "bt_rend.h"

#include <zephyr/zbus/zbus.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/uuid.h>

#include "bt_rend_vol_internal.h"
#include "nrf5340_audio_common.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(bt_rend, CONFIG_BT_REND_LOG_LEVEL);

ZBUS_CHAN_DEFINE(volume_chan, struct volume_msg, NULL, NULL, ZBUS_OBSERVERS_EMPTY,
		 ZBUS_MSG_INIT(0));

int bt_rend_volume_up(void)
{
	int ret;
	struct volume_msg msg;

	if (IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR) || IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) {
		ret = bt_rend_vol_up();
		return ret;
	}

	msg.event = VOLUME_UP;

	ret = zbus_chan_pub(&volume_chan, &msg, K_NO_WAIT);
	return ret;
}

int bt_rend_volume_down(void)
{
	int ret;
	struct volume_msg msg;

	if (IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR) || IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) {
		ret = bt_rend_vol_down();
		return ret;
	}

	msg.event = VOLUME_DOWN;

	ret = zbus_chan_pub(&volume_chan, &msg, K_NO_WAIT);
	return ret;
}

int bt_rend_volume_set(uint8_t volume, bool from_vcp)
{
	int ret;
	struct volume_msg msg;

	if ((IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR) || IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) &&
	    !from_vcp) {
		ret = bt_rend_vol_set(volume);
		return ret;
	}

	msg.event = VOLUME_SET;
	msg.volume = volume;

	ret = zbus_chan_pub(&volume_chan, &msg, K_NO_WAIT);
	return ret;
}

int bt_rend_volume_mute(bool from_vcp)
{
	int ret;
	struct volume_msg msg;

	if ((IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR) || IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) &&
	    !from_vcp) {
		ret = bt_rend_vol_mute();
		return ret;
	}

	msg.event = VOLUME_MUTE;

	ret = zbus_chan_pub(&volume_chan, &msg, K_NO_WAIT);
	return ret;
}

int bt_rend_volume_unmute(void)
{
	int ret;
	struct volume_msg msg;

	if (IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR) || IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) {
		ret = bt_rend_vol_unmute();
		return ret;
	}

	msg.event = VOLUME_UNMUTE;

	ret = zbus_chan_pub(&volume_chan, &msg, K_NO_WAIT);
	return ret;
}

int bt_rend_discover(struct bt_conn *conn)
{
	int ret;

	/* Only do a VCS discover if we are volume controller */
	if (IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR)) {
		ret = bt_rend_vol_discover(conn);
		if (ret) {
			LOG_WRN("Failed to discover VCS: %d", ret);
			return ret;
		}
	}

	return 0;
}

int bt_rend_uuid_populate(struct net_buf_simple *uuid_buf)
{
	if (IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) {
		if (net_buf_simple_tailroom(uuid_buf) >= BT_UUID_SIZE_16) {
			net_buf_simple_add_le16(uuid_buf, BT_UUID_VCS_VAL);
		} else {
			return -ENOMEM;
		}
	}

	return 0;
}

int bt_rend_init(void)
{
	int ret;

	if (IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR)) {
		ret = bt_rend_vol_ctlr_init();

		if (ret) {
			LOG_WRN("Failed to initialize VCS controller: %d", ret);
			return ret;
		}
	}

	if (IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) {
		ret = bt_rend_vol_rend_init();

		if (ret) {
			LOG_WRN("Failed to initialize VCS renderer: %d", ret);
			return ret;
		}
	}

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_renderer/Kconfig
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

menu "BT renderer"

rsource "volume/Kconfig"

#----------------------------------------------------------------------------#
menu "Log level"

module = BT_REND
module-str = bt-rend
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log level
endmenu # BT renderer


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_renderer/bt_rend.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BT_REND_H_
#define _BT_REND_H_

#include <zephyr/bluetooth/conn.h>

/**
 * @brief	Adjust volume up by one step.
 *
 * @return	0 if success, error otherwise.
 */
int bt_rend_volume_up(void);

/**
 * @brief	Adjust volume down by one step.
 *
 * @return	0 if success, error otherwise.
 */
int bt_rend_volume_down(void);

/**
 * @brief	Set the volume to the given @p volume value.
 *
 * @param[in]	volume		Value to set the volume to (0-255).
 * @param[in]	from_vcp	Describe if the function was called from a service
 *				or from somewhere else (buttons, shell, etc).
 *
 * @return	0 if success, error otherwise.
 */
int bt_rend_volume_set(uint8_t volume, bool from_vcp);

/**
 * @brief	Mute the volume.
 *
 * @param[in]	from_vcp	Describe if the function was called from a service
 *				or from somewhere else (buttons, shell, etc).
 *
 * @return	0 if success, error otherwise.
 */
int bt_rend_volume_mute(bool from_vcp);

/**
 * @brief	Unmute the volume.
 *
 * @return	0 if success, error otherwise.
 */
int bt_rend_volume_unmute(void);

/**
 * @brief	Discover the rendering services.
 *
 * @param[in]	conn	Pointer to the connection on which to do the discovery.
 *
 * @return	0 if success, error otherwise.
 */
int bt_rend_discover(struct bt_conn *conn);

/**
 * @brief	Put the UUIDs from this module into the buffer.
 *
 * @note	This partial data is used to build a complete extended advertising packet.
 *
 * @param[out]	uuid_buf	Buffer being populated with UUIDs.
 *
 * @return	0 for success, error otherwise.
 */
int bt_rend_uuid_populate(struct net_buf_simple *uuid_buf);

/**
 * @brief	Initialize the rendering services or profiles, or both.
 *
 * @return	0 if success, error otherwise.
 */
int bt_rend_init(void);

#endif /* _BT_REND_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_renderer/volume/bt_rend_vol_internal.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BT_REND_VOL_INTERNAL_H_
#define _BT_REND_VOL_INTERNAL_H_

#include <zephyr/bluetooth/conn.h>

/**
 * @brief	Set volume to a specific value.
 *
 * @param[in]	volume	The absolute volume to be set.
 *
 * @retval	0	Volume change success.
 * @retval	-ENXIO	The feature is disabled.
 * @retval	other	Errors from underlying drivers.
 */
int bt_rend_vol_set(uint8_t volume);

/**
 * @brief	Turn the volume up by one step.
 *
 * @retval	0	Volume change success.
 * @retval	-ENXIO	The feature is disabled.
 * @retval	other	Errors from underlying drivers.
 */
int bt_rend_vol_up(void);

/**
 * @brief	Turn the volume down by one step.
 *
 * @retval	0	Volume change success.
 * @retval	-ENXIO	The feature is disabled.
 * @retval	other	Errors from underlying drivers.
 */
int bt_rend_vol_down(void);

/**
 * @brief	Mute the output volume of the device.
 *
 * @retval	0	Volume change success.
 * @retval	-ENXIO	The feature is disabled.
 * @retval	other	Errors from underlying drivers.
 */
int bt_rend_vol_mute(void);

/**
 * @brief	Unmute the output volume of the device.
 *
 * @retval	0	Volume change success.
 * @retval	-ENXIO	The feature is disabled.
 * @retval	other	Errors from underlying drivers.
 */
int bt_rend_vol_unmute(void);

/**
 * @brief	Discover Volume Control Service and included services.
 *
 * @param[in]	conn	Pointer to the connection on which to discover the services.
 *
 * @note	This function starts a GATT discovery and sets up handles and
 *		subscriptions for the VCS and included services.
 *		Call it once before any other actions related to the VCS.
 *
 * @return	0 for success, error otherwise.
 */
int bt_rend_vol_discover(struct bt_conn *conn);

/**
 * @brief	Initialize the Volume Control Service client.
 *
 * @return	0 for success, error otherwise.
 */
int bt_rend_vol_ctlr_init(void);

/**
 * @brief	Initialize the Volume renderer.
 *
 * @return	0 for success, error otherwise.
 */
int bt_rend_vol_rend_init(void);

#endif /* _BT_REND_VOL_INTERNAL_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_renderer/volume/Kconfig
#
# Copyright (c) 2023 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

menu "Volume"

config BT_AUDIO_VOL_DEFAULT
	int "Default volume"
	range 0 255
	default 195
	help
	  The default volume when starting a volume control renderer.

config BT_AUDIO_VOL_STEP_SIZE
	int "Volume adjust step size"
	range 6 32
	default 16

#----------------------------------------------------------------------------#
menu "Log level"

module = BT_REND_VOL
module-str = bt-rend-vol
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log level
endmenu # Volume


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/bluetooth/bt_renderer/volume/bt_rend_vol.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "bt_rend_vol_internal.h"

#include <zephyr/kernel.h>
#include <zephyr/types.h>
#include <zephyr/bluetooth/conn.h>
#include <zephyr/bluetooth/audio/vcp.h>

#include "macros_common.h"
#include "bt_rend.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(bt_rend_vol, CONFIG_BT_REND_VOL_LOG_LEVEL);

static struct bt_vcp_vol_ctlr *vcs_client_peer[CONFIG_BT_MAX_CONN];

/**
 * @brief	Get the index of the first available vcs_client_peer.
 *
 * @retval	Index if success.
 * @retval	-ENOMEM if no available indexes.
 */
static int vcs_client_peer_index_free_get(void)
{
	for (int i = 0; i < ARRAY_SIZE(vcs_client_peer); i++) {
		if (vcs_client_peer[i] == NULL) {
			return i;
		}
	}

	LOG_WRN("No more indexes for VCS peer clients");

	return -ENOMEM;
}

/**
 * @brief	Check if the given @p conn has a vcs_client_peer pointer.
 *
 * @param[in]	conn	The connection pointer to be checked.
 *
 * @retval	True if vcs_client_peer exists.
 * @retval	False otherwise.
 */
static bool vcs_client_peer_exists(struct bt_conn *conn)
{
	int ret;

	struct bt_conn *result_conn = NULL;

	for (int i = 0; i < ARRAY_SIZE(vcs_client_peer); i++) {
		ret = bt_vcp_vol_ctlr_conn_get(vcs_client_peer[i], &result_conn);

		if (!ret && conn == result_conn) {
			return true;
		}

		if (ret == -ENOTCONN) {
			/* VCS client no longer connected, free the index */
			vcs_client_peer[i] = NULL;
			return false;
		}
	}

	return false;
}

/**
 * @brief	Callback handler for the volume state.
 *
 * @note	This callback handler will be triggered if volume state has changed,
 *		or the playback was muted or unmuted.
 */
static void vcs_state_ctlr_cb_handler(struct bt_vcp_vol_ctlr *vcs, int err, uint8_t volume,
				      uint8_t mute)
{
	int ret;

	if (err) {
		LOG_ERR("VCS state callback error: %d", err);
		return;
	}

	for (int i = 0; i < ARRAY_SIZE(vcs_client_peer); i++) {
		if (vcs == vcs_client_peer[i]) {
			LOG_DBG("VCS state from remote device %d:", i);
			continue;
		}

		LOG_DBG("Sync with other devices %d", i);

		if (vcs_client_peer[i] == NULL) {
			/* Skip */
			continue;
		}

		ret = bt_vcp_vol_ctlr_set_vol(vcs_client_peer[i], volume);
		if (ret) {
			LOG_DBG("Failed to sync volume to remote device %d, err = "
				"%d",
				i, ret);
		}
	}
}

/**
 * @brief	Callback handler for the VCS controller flags.
 *
 * @note	This callback handler will be triggered if VCS flags changed.
 */
static void vcs_flags_ctlr_cb_handler(struct bt_vcp_vol_ctlr *vcs, int err, uint8_t flags)
{
	if (err) {
		LOG_ERR("VCS flag callback error: %d", err);
	} else {
		LOG_DBG("Volume flags = 0x%01X", flags);
	}
}

/**
 * @brief	Callback handler for the volume state.
 *
 * @note	This callback handler will be triggered if volume state has changed,
 *		or the playback was muted or unmuted from the volume_controller.
 */
static void vcs_state_rend_cb_handler(int err, uint8_t volume, uint8_t mute)
{
	int ret;

	if (err) {
		LOG_ERR("VCS state callback error: %d", err);
		return;
	}
	LOG_INF("Volume = %d, mute state = %d", volume, mute);

	/* Send to bt_rend */
	ret = bt_rend_volume_set(volume, true);
	if (ret) {
		LOG_WRN("Failed to set volume");
	}

	if (mute) {
		ret = bt_rend_volume_mute(true);
		if (ret) {
			LOG_WRN("Error muting volume");
		}
	}
}

/**
 * @brief	Callback handler for the changed VCS renderer flags.
 *
 * @note	This callback handler will be triggered if the VCS flags has changed.
 */
static void vcs_flags_rend_cb_handler(int err, uint8_t flags)
{
	if (err) {
		LOG_ERR("VCS flag callback error: %d", err);
	} else {
		LOG_DBG("Volume flags = 0x%01X", flags);
	}
}

/**
 * @brief	Callback handler for the finished VCS discovery.
 *
 * @note	This callback handler will be triggered when the VCS discovery has finished.
 */
static void vcs_discover_cb_handler(struct bt_vcp_vol_ctlr *vcs, int err, uint8_t vocs_count,
				    uint8_t aics_count)
{
	if (err) {
		LOG_WRN("VCS discover finished callback error: %d", err);
	} else {
		LOG_INF("VCS discover finished");
	}
}

int bt_rend_vol_set(uint8_t volume)
{
	if (IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR)) {
		int ret;

		for (int i = 0; i < ARRAY_SIZE(vcs_client_peer); i++) {
			if (vcs_client_peer[i] != NULL) {
				ret = bt_vcp_vol_ctlr_set_vol(vcs_client_peer[i], volume);
				if (ret) {
					LOG_WRN("Failed to set volume for remote channel %d, ret = "
						"%d",
						i, ret);
				}
			}
		}

		return 0;
	} else if (IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) {
		return bt_vcp_vol_rend_set_vol(volume);
	}

	LOG_WRN("VCP not enabled");
	return -EIO;
}

int bt_rend_vol_up(void)
{
	if (IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR)) {
		int ret;

		for (int i = 0; i < ARRAY_SIZE(vcs_client_peer); i++) {
			if (vcs_client_peer[i] != NULL) {
				ret = bt_vcp_vol_ctlr_unmute_vol_up(vcs_client_peer[i]);
				if (ret) {
					LOG_WRN("Failed to volume up for remote channel %d, ret = "
						"%d",
						i, ret);
				}
			}
		}

		return 0;
	} else if (IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) {
		return bt_vcp_vol_rend_unmute_vol_up();
	}

	LOG_WRN("VCP not enabled");
	return -EIO;
}

int bt_rend_vol_down(void)
{
	if (IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR)) {
		int ret;

		for (int i = 0; i < ARRAY_SIZE(vcs_client_peer); i++) {
			if (vcs_client_peer[i] != NULL) {
				ret = bt_vcp_vol_ctlr_unmute_vol_down(vcs_client_peer[i]);
				if (ret) {
					LOG_WRN("Failed to volume down for remote channel %d, ret "
						"= %d",
						i, ret);
				}
			}
		}

		return 0;
	} else if (IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) {
		return bt_vcp_vol_rend_unmute_vol_down();
	}

	LOG_WRN("VCP not enabled");
	return -EIO;
}

int bt_rend_vol_mute(void)
{
	if (IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR)) {
		int ret;

		for (int i = 0; i < ARRAY_SIZE(vcs_client_peer); i++) {
			if (vcs_client_peer[i] != NULL) {
				ret = bt_vcp_vol_ctlr_mute(vcs_client_peer[i]);
				if (ret) {
					LOG_WRN("Failed to mute for remote channel %d, ret "
						"= %d",
						i, ret);
				}
			}
		}

		return 0;
	} else if (IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) {
		return bt_vcp_vol_rend_mute();
	}

	LOG_WRN("VCP not enabled");
	return -EIO;
}

int bt_rend_vol_unmute(void)
{
	if (IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR)) {
		int ret;

		for (int i = 0; i < ARRAY_SIZE(vcs_client_peer); i++) {
			if (vcs_client_peer[i] != NULL) {
				ret = bt_vcp_vol_ctlr_unmute(vcs_client_peer[i]);
				if (ret) {
					LOG_WRN("Failed to unmute for remote channel %d, "
						"ret = %d",
						i, ret);
				}
			}
		}

		return 0;
	} else if (IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) {
		return bt_vcp_vol_rend_unmute();
	}

	LOG_WRN("VCP not enabled");
	return -EIO;
}

int bt_rend_vol_discover(struct bt_conn *conn)
{
	if (IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR)) {

		int ret, index;

		if (vcs_client_peer_exists(conn)) {
			return -EAGAIN;
		}

		index = vcs_client_peer_index_free_get();
		if (index < 0) {
			return index;
		}

		ret = bt_vcp_vol_ctlr_discover(conn, &vcs_client_peer[index]);
		return ret;
	}

	LOG_ERR("VCP volume controller not enabled");
	return -ECANCELED;
}

int bt_rend_vol_ctlr_init(void)
{
	if (!IS_ENABLED(CONFIG_BT_VCP_VOL_CTLR)) {
		LOG_ERR("VCP volume controller not enabled");
		return -ECANCELED;
	}

	static struct bt_vcp_vol_ctlr_cb vcs_client_callback;

	vcs_client_callback.discover = vcs_discover_cb_handler;
	vcs_client_callback.state = vcs_state_ctlr_cb_handler;
	vcs_client_callback.flags = vcs_flags_ctlr_cb_handler;

	return bt_vcp_vol_ctlr_cb_register(&vcs_client_callback);
}

int bt_rend_vol_rend_init(void)
{
	if (!IS_ENABLED(CONFIG_BT_VCP_VOL_REND)) {
		LOG_ERR("VCP volume renderer not enabled");
		return -ECANCELED;
	}

	int ret;
	struct bt_vcp_vol_rend_register_param vcs_param;
	static struct bt_vcp_vol_rend_cb vcs_server_callback;

	vcs_server_callback.state = vcs_state_rend_cb_handler;
	vcs_server_callback.flags = vcs_flags_rend_cb_handler;
	vcs_param.cb = &vcs_server_callback;
	vcs_param.mute = BT_VCP_STATE_UNMUTED;
	vcs_param.step = CONFIG_BT_AUDIO_VOL_STEP_SIZE;
	vcs_param.volume = CONFIG_BT_AUDIO_VOL_DEFAULT;

	ret = bt_vcp_vol_rend_register(&vcs_param);
	if (ret) {
		return ret;
	}

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/modules/led.c
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "led.h"

#include <zephyr/kernel.h>
#include <zephyr/devicetree.h>
#include <zephyr/drivers/gpio.h>
#include <string.h>
#include <stdlib.h>
#include <zephyr/device.h>

#include "macros_common.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(led, CONFIG_MODULE_LED_LOG_LEVEL);

#define BLINK_FREQ_MS			    1000
/* Maximum number of LED_UNITS. 1 RGB LED = 1 UNIT of 3 LEDS */
#define LED_UNIT_MAX			    10
#define NUM_COLORS_RGB			    3
#define BASE_10				    10
#define DT_LABEL_AND_COMMA(node_id)	    DT_PROP(node_id, label),
#define GPIO_DT_SPEC_GET_AND_COMMA(node_id) GPIO_DT_SPEC_GET(node_id, gpios),

/* The following arrays are populated compile time from the .dts*/
static const char *const led_labels[] = {DT_FOREACH_CHILD(DT_PATH(leds), DT_LABEL_AND_COMMA)};

static const struct gpio_dt_spec leds[] = {
	DT_FOREACH_CHILD(DT_PATH(leds), GPIO_DT_SPEC_GET_AND_COMMA)};

enum led_type {
	LED_MONOCHROME,
	LED_COLOR,
};

struct user_config {
	bool blink;
	enum led_color color;
};

struct led_unit_cfg {
	uint8_t led_no;
	enum led_type unit_type;
	union {
		const struct gpio_dt_spec *mono;
		const struct gpio_dt_spec *color[NUM_COLORS_RGB];
	} type;
	struct user_config user_cfg;
};

static uint8_t leds_num;
static bool initialized;
static struct led_unit_cfg led_units[LED_UNIT_MAX];

/**
 * @brief Configures fields for a RGB LED
 */
static int configure_led_color(uint8_t led_unit, uint8_t led_color, uint8_t led)
{
	if (!device_is_ready(leds[led].port)) {
		LOG_ERR("LED GPIO controller not ready");
		return -ENODEV;
	}

	led_units[led_unit].type.color[led_color] = &leds[led];
	led_units[led_unit].unit_type = LED_COLOR;

	return gpio_pin_configure_dt(led_units[led_unit].type.color[led_color],
				     GPIO_OUTPUT_INACTIVE);
}

/**
 * @brief Configures fields for a monochrome LED
 */
static int config_led_monochrome(uint8_t led_unit, uint8_t led)
{
	if (!device_is_ready(leds[led].port)) {
		LOG_ERR("LED GPIO controller not ready");
		return -ENODEV;
	}

	led_units[led_unit].type.mono = &leds[led];
	led_units[led_unit].unit_type = LED_MONOCHROME;

	return gpio_pin_configure_dt(led_units[led_unit].type.mono, GPIO_OUTPUT_INACTIVE);
}

/**
 * @brief Parses the device tree for LED settings.
 */
static int led_device_tree_parse(void)
{
	int ret;

	for (uint8_t i = 0; i < leds_num; i++) {
		char *end_ptr = NULL;
		uint32_t led_unit = strtoul(led_labels[i], &end_ptr, BASE_10);

		if (led_labels[i] == end_ptr) {
			LOG_ERR("No match for led unit. The dts is likely not properly formatted");
			return -ENXIO;
		}

		if (strstr(led_labels[i], "LED_RGB_RED")) {
			ret = configure_led_color(led_unit, RED, i);
			if (ret) {
				return ret;
			}

		} else if (strstr(led_labels[i], "LED_RGB_GREEN")) {
			ret = configure_led_color(led_unit, GRN, i);
			if (ret) {
				return ret;
			}

		} else if (strstr(led_labels[i], "LED_RGB_BLUE")) {
			ret = configure_led_color(led_unit, BLU, i);
			if (ret) {
				return ret;
			}

		} else if (strstr(led_labels[i], "LED_MONO")) {
			ret = config_led_monochrome(led_unit, i);
			if (ret) {
				return ret;
			}
		} else {
			LOG_ERR("No color identifier for LED %d LED unit %d", i, led_unit);
			return -ENODEV;
		}
	}
	return 0;
}

/**
 * @brief Internal handling to set the status of a led unit
 */
static int led_set_int(uint8_t led_unit, enum led_color color)
{
	int ret;

	if (led_units[led_unit].unit_type == LED_MONOCHROME) {
		if (color) {
			ret = gpio_pin_set_dt(led_units[led_unit].type.mono, 1);
			if (ret) {
				return ret;
			}
		} else {
			ret = gpio_pin_set_dt(led_units[led_unit].type.mono, 0);
			if (ret) {
				return ret;
			}
		}
	} else {
		for (uint8_t i = 0; i < NUM_COLORS_RGB; i++) {
			if (color & BIT(i)) {
				ret = gpio_pin_set_dt(led_units[led_unit].type.color[i], 1);
				if (ret) {
					return ret;
				}
			} else {
				ret = gpio_pin_set_dt(led_units[led_unit].type.color[i], 0);
				if (ret) {
					return ret;
				}
			}
		}
	}

	return 0;
}

static void led_blink_work_handler(struct k_work *work);

K_WORK_DEFINE(led_blink_work, led_blink_work_handler);

/**
 * @brief Submit a k_work on timer expiry.
 */
void led_blink_timer_handler(struct k_timer *dummy)
{
	k_work_submit(&led_blink_work);
}

K_TIMER_DEFINE(led_blink_timer, led_blink_timer_handler, NULL);

/**
 * @brief Periodically invoked by the timer to blink LEDs.
 */
static void led_blink_work_handler(struct k_work *work)
{
	int ret;
	static bool on_phase;

	for (uint8_t i = 0; i < leds_num; i++) {
		if (led_units[i].user_cfg.blink) {
			if (on_phase) {
				ret = led_set_int(i, led_units[i].user_cfg.color);
				ERR_CHK(ret);
			} else {
				ret = led_set_int(i, LED_COLOR_OFF);
				ERR_CHK(ret);
			}
		}
	}

	on_phase = !on_phase;
}

static int led_set(uint8_t led_unit, enum led_color color, bool blink)
{
	int ret;

	if (!initialized) {
		return -EPERM;
	}

	ret = led_set_int(led_unit, color);
	if (ret) {
		return ret;
	}

	led_units[led_unit].user_cfg.blink = blink;
	led_units[led_unit].user_cfg.color = color;

	return 0;
}

int led_on(uint8_t led_unit, ...)
{
	if (led_units[led_unit].unit_type == LED_MONOCHROME) {
		return led_set(led_unit, LED_ON, LED_SOLID);
	}

	va_list args;

	va_start(args, led_unit);
	int color = va_arg(args, int);

	va_end(args);

	if (color <= 0 || color >= LED_COLOR_NUM) {
		LOG_ERR("Invalid color code %d", color);
		return -EINVAL;
	}
	return led_set(led_unit, color, LED_SOLID);
}

int led_blink(uint8_t led_unit, ...)
{
	if (led_units[led_unit].unit_type == LED_MONOCHROME) {
		return led_set(led_unit, LED_ON, LED_BLINK);
	}

	va_list args;

	va_start(args, led_unit);

	int color = va_arg(args, int);

	va_end(args);

	if (color <= 0 || color >= LED_COLOR_NUM) {
		LOG_ERR("Invalid color code %d", color);
		return -EINVAL;
	}

	return led_set(led_unit, color, LED_BLINK);
}

int led_off(uint8_t led_unit)
{
	return led_set(led_unit, LED_COLOR_OFF, LED_SOLID);
}

int led_init(void)
{
	int ret;

	if (initialized) {
		return -EPERM;
	}

	__ASSERT(ARRAY_SIZE(leds) != 0, "No LEDs found in dts");

	leds_num = ARRAY_SIZE(leds);

	ret = led_device_tree_parse();
	if (ret) {
		return ret;
	}

	k_timer_start(&led_blink_timer, K_MSEC(BLINK_FREQ_MS / 2), K_MSEC(BLINK_FREQ_MS / 2));
	initialized = true;
	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/modules/audio_sync_timer.c
/*
 *  Copyright (c) 2021, PACKETCRAFT, INC.
 *
 *  SPDX-License-Identifier: LicenseRef-PCFT
 */

#include "audio_sync_timer.h"

#include <zephyr/kernel.h>
#include <zephyr/init.h>
#include <nrfx_dppi.h>
#include <nrfx_i2s.h>
#include <nrfx_ipc.h>
#include <nrfx_timer.h>


#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(audio_sync_timer, CONFIG_AUDIO_SYNC_TIMER_LOG_LEVEL);

#define AUDIO_SYNC_TIMER_INSTANCE_NUMBER 1

#define AUDIO_SYNC_TIMER_I2S_FRAME_START_EVT_CAPTURE_CHANNEL 0
#define AUDIO_SYNC_TIMER_CURR_TIME_CAPTURE_CHANNEL	     1
#define AUDIO_SYNC_TIMER_I2S_FRAME_START_EVT_CAPTURE NRF_TIMER_TASK_CAPTURE0

#define AUDIO_SYNC_TIMER_NET_APP_IPC_EVT NRF_IPC_EVENT_RECEIVE_4

static const nrfx_timer_t audio_sync_timer_instance =
	NRFX_TIMER_INSTANCE(AUDIO_SYNC_TIMER_INSTANCE_NUMBER);

static uint8_t dppi_channel_timer_clear;
static uint8_t dppi_channel_i2s_frame_start;

static nrfx_timer_config_t cfg = {.frequency = NRFX_MHZ_TO_HZ(1UL),
				  .mode = NRF_TIMER_MODE_TIMER,
				  .bit_width = NRF_TIMER_BIT_WIDTH_32,
				  .interrupt_priority = NRFX_TIMER_DEFAULT_CONFIG_IRQ_PRIORITY,
				  .p_context = NULL};

uint32_t audio_sync_timer_capture(void)
{
	return nrfx_timer_capture(&audio_sync_timer_instance,
				  AUDIO_SYNC_TIMER_CURR_TIME_CAPTURE_CHANNEL);
}

uint32_t audio_sync_timer_capture_get(void)
{
	return nrfx_timer_capture_get(&audio_sync_timer_instance,
				      AUDIO_SYNC_TIMER_I2S_FRAME_START_EVT_CAPTURE_CHANNEL);
}

static void event_handler(nrf_timer_event_t event_type, void *ctx)
{
}

/**
 * @brief Initialize audio sync timer
 *
 * @note Clearing of the nRF5340 APP core sync
 * timer is initialized here. The sync timers on
 * APP core and NET core are cleared at exactly
 * the same time using an IPC signal sent from
 * the NET core. This makes the two timers
 * synchronized.
 *
 * @param unused Unused
 *
 * @return 0 if successful, error otherwise
 */
static int audio_sync_timer_init(void)
{
	nrfx_err_t ret;

	ret = nrfx_timer_init(&audio_sync_timer_instance, &cfg, event_handler);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx timer init error - Return value: %d", ret);
		return ret;
	}

	nrfx_timer_enable(&audio_sync_timer_instance);

	/* Initialize capturing of I2S frame start event timestamps */
	ret = nrfx_dppi_channel_alloc(&dppi_channel_i2s_frame_start);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx DPPI channel alloc error (I2S frame start) - Return value: %d", ret);
		return ret;
	}

	nrf_timer_subscribe_set(audio_sync_timer_instance.p_reg,
				AUDIO_SYNC_TIMER_I2S_FRAME_START_EVT_CAPTURE,
				dppi_channel_i2s_frame_start);
	nrf_i2s_publish_set(NRF_I2S0, NRF_I2S_EVENT_FRAMESTART, dppi_channel_i2s_frame_start);
	ret = nrfx_dppi_channel_enable(dppi_channel_i2s_frame_start);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx DPPI channel enable error (I2S frame start) - Return value: %d", ret);
		return ret;
	}

	/* Initialize functionality for synchronization between APP and NET core */
	ret = nrfx_dppi_channel_alloc(&dppi_channel_timer_clear);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx DPPI channel alloc error (timer clear) - Return value: %d", ret);
		return ret;
	}

	nrf_ipc_publish_set(NRF_IPC, AUDIO_SYNC_TIMER_NET_APP_IPC_EVT, dppi_channel_timer_clear);
	nrf_timer_subscribe_set(audio_sync_timer_instance.p_reg, NRF_TIMER_TASK_CLEAR,
				dppi_channel_timer_clear);
	ret = nrfx_dppi_channel_enable(dppi_channel_timer_clear);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx DPPI channel enable error (timer clear) - Return value: %d", ret);
		return ret;
	}

	LOG_DBG("Audio sync timer initialized");

	return 0;
}

SYS_INIT(audio_sync_timer_init, POST_KERNEL, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/modules/audio_i2s.c
/*
 *  Copyright (c) 2021, PACKETCRAFT, INC.
 *
 *  SPDX-License-Identifier: LicenseRef-PCFT
 */

#include "audio_i2s.h"

#include <zephyr/kernel.h>
#include <zephyr/device.h>
#include <zephyr/drivers/pinctrl.h>
#include <nrfx_i2s.h>
#include <nrfx_clock.h>

#include "audio_sync_timer.h"

#define I2S_NL DT_NODELABEL(i2s0)

#define HFCLKAUDIO_12_288_MHZ 0x9BAE

enum audio_i2s_state {
	AUDIO_I2S_STATE_UNINIT,
	AUDIO_I2S_STATE_IDLE,
	AUDIO_I2S_STATE_STARTED,
};

static enum audio_i2s_state state = AUDIO_I2S_STATE_UNINIT;

PINCTRL_DT_DEFINE(I2S_NL);

#if CONFIG_AUDIO_SAMPLE_RATE_16000_HZ
#define CONFIG_AUDIO_RATIO NRF_I2S_RATIO_384X
#elif CONFIG_AUDIO_SAMPLE_RATE_24000_HZ
#define CONFIG_AUDIO_RATIO NRF_I2S_RATIO_256X
#elif CONFIG_AUDIO_SAMPLE_RATE_48000_HZ
#define CONFIG_AUDIO_RATIO NRF_I2S_RATIO_128X
#else
#error "Current AUDIO_SAMPLE_RATE_HZ setting not supported"
#endif

static nrfx_i2s_t i2s_inst = NRFX_I2S_INSTANCE(0);

static nrfx_i2s_config_t cfg = {
	/* Pins are configured by pinctrl. */
	.skip_gpio_cfg = true,
	.skip_psel_cfg = true,
	.irq_priority = DT_IRQ(I2S_NL, priority),
	.mode = NRF_I2S_MODE_MASTER,
	.format = NRF_I2S_FORMAT_I2S,
	.alignment = NRF_I2S_ALIGN_LEFT,
	.ratio = CONFIG_AUDIO_RATIO,
	.mck_setup = 0x66666000,
#if (CONFIG_AUDIO_BIT_DEPTH_16)
	.sample_width = NRF_I2S_SWIDTH_16BIT,
#elif (CONFIG_AUDIO_BIT_DEPTH_32)
	.sample_width = NRF_I2S_SWIDTH_32BIT,
#else
#error Invalid bit depth selected
#endif /* (CONFIG_AUDIO_BIT_DEPTH_16) */
	.channels = NRF_I2S_CHANNELS_STEREO,
	.clksrc = NRF_I2S_CLKSRC_ACLK,
	.enable_bypass = false,
};

static i2s_blk_comp_callback_t i2s_blk_comp_callback;

static void i2s_comp_handler(nrfx_i2s_buffers_t const *released_bufs, uint32_t status)
{
	uint32_t frame_start_ts = audio_sync_timer_capture_get();

	if ((status == NRFX_I2S_STATUS_NEXT_BUFFERS_NEEDED) && released_bufs &&
	    i2s_blk_comp_callback && (released_bufs->p_rx_buffer || released_bufs->p_tx_buffer)) {
		i2s_blk_comp_callback(frame_start_ts, released_bufs->p_rx_buffer,
				      released_bufs->p_tx_buffer);
	}
}

void audio_i2s_set_next_buf(const uint8_t *tx_buf, uint32_t *rx_buf)
{
	__ASSERT_NO_MSG(state == AUDIO_I2S_STATE_STARTED);
	if (IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL) || (CONFIG_AUDIO_DEV == GATEWAY)) {
		__ASSERT_NO_MSG(rx_buf != NULL);
	}

	if (IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL) || (CONFIG_AUDIO_DEV == HEADSET)) {
		__ASSERT_NO_MSG(tx_buf != NULL);
	}

	const nrfx_i2s_buffers_t i2s_buf = { .p_rx_buffer = rx_buf,
					     .p_tx_buffer = (uint32_t *)tx_buf };

	nrfx_err_t ret;

	ret = nrfx_i2s_next_buffers_set(&i2s_inst, &i2s_buf);
	__ASSERT_NO_MSG(ret == NRFX_SUCCESS);
}

void audio_i2s_start(const uint8_t *tx_buf, uint32_t *rx_buf)
{
	__ASSERT_NO_MSG(state == AUDIO_I2S_STATE_IDLE);
	if (IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL) || (CONFIG_AUDIO_DEV == GATEWAY)) {
		__ASSERT_NO_MSG(rx_buf != NULL);
	}

	if (IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL) || (CONFIG_AUDIO_DEV == HEADSET)) {
		__ASSERT_NO_MSG(tx_buf != NULL);
	}

	const nrfx_i2s_buffers_t i2s_buf = { .p_rx_buffer = rx_buf,
					     .p_tx_buffer = (uint32_t *)tx_buf };

	nrfx_err_t ret;

	/* Buffer size in 32-bit words */
	ret = nrfx_i2s_start(&i2s_inst, &i2s_buf, I2S_SAMPLES_NUM, 0);
	__ASSERT_NO_MSG(ret == NRFX_SUCCESS);

	state = AUDIO_I2S_STATE_STARTED;
}

void audio_i2s_stop(void)
{
	__ASSERT_NO_MSG(state == AUDIO_I2S_STATE_STARTED);

	nrfx_i2s_stop(&i2s_inst);

	state = AUDIO_I2S_STATE_IDLE;
}

void audio_i2s_blk_comp_cb_register(i2s_blk_comp_callback_t blk_comp_callback)
{
	i2s_blk_comp_callback = blk_comp_callback;
}

void audio_i2s_init(void)
{
	__ASSERT_NO_MSG(state == AUDIO_I2S_STATE_UNINIT);

	nrfx_err_t ret;

	nrfx_clock_hfclkaudio_config_set(HFCLKAUDIO_12_288_MHZ);

	NRF_CLOCK->TASKS_HFCLKAUDIOSTART = 1;

	/* Wait for ACLK to start */
	while (!NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED) {
		k_sleep(K_MSEC(1));
	}

	ret = pinctrl_apply_state(PINCTRL_DT_DEV_CONFIG_GET(I2S_NL), PINCTRL_STATE_DEFAULT);
	__ASSERT_NO_MSG(ret == 0);

	IRQ_CONNECT(DT_IRQN(I2S_NL), DT_IRQ(I2S_NL, priority), nrfx_isr, nrfx_i2s_0_irq_handler, 0);
	irq_enable(DT_IRQN(I2S_NL));

	ret = nrfx_i2s_init(&i2s_inst, &cfg, i2s_comp_handler);
	__ASSERT_NO_MSG(ret == NRFX_SUCCESS);

	state = AUDIO_I2S_STATE_IDLE;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/modules/sd_card.c
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "sd_card.h"

#include <zephyr/kernel.h>
#include <zephyr/device.h>
#include <zephyr/storage/disk_access.h>
#include <zephyr/fs/fs.h>
#include <ff.h>
#include <string.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/devicetree.h>

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(sd_card, CONFIG_MODULE_SD_CARD_LOG_LEVEL);

#define SD_ROOT_PATH	      "/SD:/"
/* Maximum length for path support by Windows file system */
#define PATH_MAX_LEN	      260
#define K_SEM_OPER_TIMEOUT_MS 100

K_SEM_DEFINE(m_sem_sd_oper_ongoing, 1, 1);

static const char *sd_root_path = "/SD:";
static FATFS fat_fs;
static bool sd_init_success;

static struct fs_mount_t mnt_pt = {
	.type = FS_FATFS,
	.fs_data = &fat_fs,
};

int sd_card_list_files(char const *const path, char *buf, size_t *buf_size)
{
	int ret;
	struct fs_dir_t dirp;
	static struct fs_dirent entry;
	char abs_path_name[PATH_MAX_LEN + 1] = SD_ROOT_PATH;
	size_t used_buf_size = 0;

	ret = k_sem_take(&m_sem_sd_oper_ongoing, K_MSEC(K_SEM_OPER_TIMEOUT_MS));
	if (ret) {
		LOG_ERR("Sem take failed. Ret: %d", ret);
		return ret;
	}

	if (!sd_init_success) {
		k_sem_give(&m_sem_sd_oper_ongoing);
		return -ENODEV;
	}

	fs_dir_t_init(&dirp);

	if (path == NULL) {
		ret = fs_opendir(&dirp, sd_root_path);
		if (ret) {
			LOG_ERR("Open SD card root dir failed");
			k_sem_give(&m_sem_sd_oper_ongoing);
			return ret;
		}
	} else {
		if (strlen(path) > CONFIG_FS_FATFS_MAX_LFN) {
			LOG_ERR("Path is too long");
			k_sem_give(&m_sem_sd_oper_ongoing);
			return -FR_INVALID_NAME;
		}

		strcat(abs_path_name, path);

		ret = fs_opendir(&dirp, abs_path_name);
		if (ret) {
			LOG_ERR("Open assigned path failed");
			k_sem_give(&m_sem_sd_oper_ongoing);
			return ret;
		}
	}

	while (1) {
		ret = fs_readdir(&dirp, &entry);
		if (ret) {
			k_sem_give(&m_sem_sd_oper_ongoing);
			return ret;
		}

		if (entry.name[0] == 0) {
			break;
		}

		if (buf != NULL) {
			size_t remaining_buf_size = *buf_size - used_buf_size;
			ssize_t len = snprintk(
				&buf[used_buf_size], remaining_buf_size, "[%s]\t%s\n",
				entry.type == FS_DIR_ENTRY_DIR ? "DIR " : "FILE", entry.name);

			if (len >= remaining_buf_size) {
				LOG_ERR("Failed to append to buffer, error: %d", len);
				k_sem_give(&m_sem_sd_oper_ongoing);
				return -EINVAL;
			}

			used_buf_size += len;
		}

		LOG_INF("[%s] %s", entry.type == FS_DIR_ENTRY_DIR ? "DIR " : "FILE", entry.name);
	}

	ret = fs_closedir(&dirp);
	if (ret) {
		LOG_ERR("Close SD card root dir failed");
		k_sem_give(&m_sem_sd_oper_ongoing);
		return ret;
	}

	*buf_size = used_buf_size;
	k_sem_give(&m_sem_sd_oper_ongoing);
	return 0;
}

int sd_card_open_write_close(char const *const filename, char const *const data, size_t *size)
{
	int ret;
	struct fs_file_t f_entry;
	char abs_path_name[PATH_MAX_LEN + 1] = SD_ROOT_PATH;

	ret = k_sem_take(&m_sem_sd_oper_ongoing, K_MSEC(K_SEM_OPER_TIMEOUT_MS));
	if (ret) {
		LOG_ERR("Sem take failed. Ret: %d", ret);
		return ret;
	}

	if (!sd_init_success) {
		k_sem_give(&m_sem_sd_oper_ongoing);
		return -ENODEV;
	}

	if (strlen(filename) > CONFIG_FS_FATFS_MAX_LFN) {
		LOG_ERR("Filename is too long");
		k_sem_give(&m_sem_sd_oper_ongoing);
		return -ENAMETOOLONG;
	}

	strcat(abs_path_name, filename);
	fs_file_t_init(&f_entry);

	ret = fs_open(&f_entry, abs_path_name, FS_O_CREATE | FS_O_WRITE | FS_O_APPEND);
	if (ret) {
		LOG_ERR("Create file failed");
		k_sem_give(&m_sem_sd_oper_ongoing);
		return ret;
	}

	/* If the file exists, moves the file position pointer to the end of the file */
	ret = fs_seek(&f_entry, 0, FS_SEEK_END);
	if (ret) {
		LOG_ERR("Seek file pointer failed");
		k_sem_give(&m_sem_sd_oper_ongoing);
		return ret;
	}

	ret = fs_write(&f_entry, data, *size);
	if (ret < 0) {
		LOG_ERR("Write file failed");
		k_sem_give(&m_sem_sd_oper_ongoing);
		return ret;
	}

	*size = ret;

	ret = fs_close(&f_entry);
	if (ret) {
		LOG_ERR("Close file failed");
		k_sem_give(&m_sem_sd_oper_ongoing);
		return ret;
	}

	k_sem_give(&m_sem_sd_oper_ongoing);
	return 0;
}

int sd_card_open_read_close(char const *const filename, char *const buf, size_t *size)
{
	int ret;
	struct fs_file_t f_entry;
	char abs_path_name[PATH_MAX_LEN + 1] = SD_ROOT_PATH;

	ret = k_sem_take(&m_sem_sd_oper_ongoing, K_MSEC(K_SEM_OPER_TIMEOUT_MS));
	if (ret) {
		LOG_ERR("Sem take failed. Ret: %d", ret);
		return ret;
	}

	if (!sd_init_success) {
		k_sem_give(&m_sem_sd_oper_ongoing);
		return -ENODEV;
	}

	if (strlen(filename) > CONFIG_FS_FATFS_MAX_LFN) {
		LOG_ERR("Filename is too long");
		k_sem_give(&m_sem_sd_oper_ongoing);
		return -FR_INVALID_NAME;
	}

	strcat(abs_path_name, filename);
	fs_file_t_init(&f_entry);

	ret = fs_open(&f_entry, abs_path_name, FS_O_READ);
	if (ret) {
		LOG_ERR("Open file failed");
		k_sem_give(&m_sem_sd_oper_ongoing);
		return ret;
	}

	ret = fs_read(&f_entry, buf, *size);
	if (ret < 0) {
		LOG_ERR("Read file failed. Ret: %d", ret);
		k_sem_give(&m_sem_sd_oper_ongoing);
		return ret;
	}

	*size = ret;
	if (*size == 0) {
		LOG_WRN("File is empty");
	}

	ret = fs_close(&f_entry);
	if (ret) {
		LOG_ERR("Close file failed");
		k_sem_give(&m_sem_sd_oper_ongoing);
		return ret;
	}

	k_sem_give(&m_sem_sd_oper_ongoing);
	return 0;
}

int sd_card_open(char const *const filename, struct fs_file_t *f_seg_read_entry)
{
	int ret;
	char abs_path_name[PATH_MAX_LEN + 1] = SD_ROOT_PATH;
	size_t avilable_path_space = PATH_MAX_LEN - strlen(SD_ROOT_PATH);

	ret = k_sem_take(&m_sem_sd_oper_ongoing, K_MSEC(K_SEM_OPER_TIMEOUT_MS));
	if (ret) {
		LOG_ERR("Sem take failed. Ret: %d", ret);
		return ret;
	}

	if (!sd_init_success) {
		k_sem_give(&m_sem_sd_oper_ongoing);
		return -ENODEV;
	}

	if (strlen(filename) > CONFIG_FS_FATFS_MAX_LFN) {
		LOG_ERR("Filename is too long");
		k_sem_give(&m_sem_sd_oper_ongoing);
		return -ENAMETOOLONG;
	}

	if ((strlen(abs_path_name) + strlen(filename)) > PATH_MAX_LEN) {
		LOG_ERR("Filepath is too long");
		k_sem_give(&m_sem_sd_oper_ongoing);
		return -EINVAL;
	}

	strncat(abs_path_name, filename, avilable_path_space);

	LOG_INF("abs path name:\t%s", abs_path_name);

	fs_file_t_init(f_seg_read_entry);

	ret = fs_open(f_seg_read_entry, abs_path_name, FS_O_READ);
	if (ret) {
		LOG_ERR("Open file failed: %d", ret);
		k_sem_give(&m_sem_sd_oper_ongoing);
		return ret;
	}

	return 0;
}

int sd_card_read(char *buf, size_t *size, struct fs_file_t *f_seg_read_entry)
{
	int ret;

	if (!(k_sem_count_get(&m_sem_sd_oper_ongoing) <= 0)) {
		LOG_ERR("SD operation not ongoing");
		return -EPERM;
	}

	ret = fs_read(f_seg_read_entry, buf, *size);
	if (ret < 0) {
		LOG_ERR("Read file failed. Ret: %d", ret);
		k_sem_give(&m_sem_sd_oper_ongoing);
		return ret;
	}

	*size = ret;

	return 0;
}

int sd_card_close(struct fs_file_t *f_seg_read_entry)
{
	int ret;

	if (k_sem_count_get(&m_sem_sd_oper_ongoing) != 0) {
		LOG_ERR("SD operation not ongoing");
		return -EPERM;
	}

	ret = fs_close(f_seg_read_entry);
	if (ret) {
		LOG_ERR("Close file failed: %d", ret);
		k_sem_give(&m_sem_sd_oper_ongoing);
		return ret;
	}

	k_sem_give(&m_sem_sd_oper_ongoing);
	return 0;
}

int sd_card_init(void)
{
	int ret;
	static const char *sd_dev = "SD";
	uint64_t sd_card_size_bytes;
	uint32_t sector_count;
	size_t sector_size;

	ret = disk_access_init(sd_dev);
	if (ret) {
		LOG_DBG("SD card init failed, please check if SD card inserted");
		return -ENODEV;
	}

	ret = disk_access_ioctl(sd_dev, DISK_IOCTL_GET_SECTOR_COUNT, &sector_count);
	if (ret) {
		LOG_ERR("Unable to get sector count");
		return ret;
	}

	LOG_DBG("Sector count: %d", sector_count);

	ret = disk_access_ioctl(sd_dev, DISK_IOCTL_GET_SECTOR_SIZE, &sector_size);
	if (ret) {
		LOG_ERR("Unable to get sector size");
		return ret;
	}

	LOG_DBG("Sector size: %d bytes", sector_size);

	sd_card_size_bytes = (uint64_t)sector_count * sector_size;

	LOG_INF("SD card volume size: %d MB", (uint32_t)(sd_card_size_bytes >> 20));

	mnt_pt.mnt_point = sd_root_path;

	ret = fs_mount(&mnt_pt);
	if (ret) {
		LOG_ERR("Mnt. disk failed, could be format issue. should be FAT/exFAT");
		return ret;
	}

	sd_init_success = true;

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/modules/CMakeLists.txt
#
# Copyright (c) 2022 Nordic Semiconductor
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

set(SRCS
  ${CMAKE_CURRENT_SOURCE_DIR}/audio_i2s.c
  ${CMAKE_CURRENT_SOURCE_DIR}/audio_usb.c
  ${CMAKE_CURRENT_SOURCE_DIR}/button_handler.c
  ${CMAKE_CURRENT_SOURCE_DIR}/hw_codec.c
  ${CMAKE_CURRENT_SOURCE_DIR}/led.c
  ${CMAKE_CURRENT_SOURCE_DIR}/power_meas.c
  ${CMAKE_CURRENT_SOURCE_DIR}/sd_card.c
)

if (CONFIG_AUDIO_SYNC_TIMER_USES_RTC)
  list(APPEND SRCS ${CMAKE_CURRENT_SOURCE_DIR}/audio_sync_timer_rtc.c)
else()
  list(APPEND SRCS ${CMAKE_CURRENT_SOURCE_DIR}/audio_sync_timer.c)
endif()

if (CONFIG_SD_CARD_PLAYBACK)
  list(APPEND SRCS ${CMAKE_CURRENT_SOURCE_DIR}/sd_card_playback.c)
endif()

target_sources(app PRIVATE ${SRCS})


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/modules/Kconfig.defaults
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

# GATEWAY
if AUDIO_DEV = 2

if AUDIO_SOURCE_USB

config USB_DEVICE_STACK
	default y

# Net buf options needed for USB stack
config NET_BUF
	default y

config USB_DEVICE_AUDIO
	default y

## TODO: Nordic VID, change accordingly
config USB_DEVICE_VID
	default 0x1915

## TODO: Change for final product
config USB_DEVICE_PID
	default 0x530A

config USB_DEVICE_PRODUCT
	default "nRF5340 USB Audio"

config USB_DEVICE_MANUFACTURER
	default "Nordic Semiconductor AS"

## Avoid redundant warnings for endpoint setting in USB stack
config USB_DRIVER_LOG_LEVEL
	default 1

config USB_DEVICE_LOG_LEVEL
	default 1

endif # AUDIO_SOURCE_USB

endif # AUDIO_DEV = 2 (GATEWAY)


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/modules/power_meas.c
/*
 * Copyright (c) 2022 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include <zephyr/kernel.h>
#include <zephyr/device.h>
#include <zephyr/drivers/sensor.h>
#include <zephyr/logging/log.h>
#include <zephyr/shell/shell.h>
#include <zephyr/sys/util.h>

LOG_MODULE_REGISTER(power_meas, CONFIG_MODULE_POWER_LOG_LEVEL);

#define POWER_RAIL_NUM 4U
static k_tid_t pwr_meas_thread_id;

struct power_rail_config {
	const char *name;
	const struct device *sensor;
};

static const struct power_rail_config rail_config[POWER_RAIL_NUM] = {
	{"VBAT", DEVICE_DT_GET(DT_NODELABEL(vbat_sensor))},
	{"VDD1_CODEC", DEVICE_DT_GET(DT_NODELABEL(vdd1_codec_sensor))},
	{"VDD2_CODEC", DEVICE_DT_GET(DT_NODELABEL(vdd2_codec_sensor))},
	{"VDD2_NRF", DEVICE_DT_GET(DT_NODELABEL(vdd2_nrf_sensor))},
};
static bool rail_enabled[POWER_RAIL_NUM];

K_THREAD_STACK_DEFINE(meas_stack, CONFIG_POWER_MEAS_STACK_SIZE);
static struct k_thread meas_thread;
K_SEM_DEFINE(meas_sem, 0, 1);
static bool meas_enabled;

/**
 * @brief Read a power rail data (voltage/current/power) and log results.
 *
 * @param[in] config Power rail configuration.
 *
 * @retval 0 on success
 * @retval -errno on sensor fetch/get error.
 */
static int read_and_log(const struct power_rail_config *config)
{
	int ret;
	struct sensor_value voltage, current, power;

	ret = sensor_sample_fetch(config->sensor);
	if (ret < 0) {
		return ret;
	}

	ret = sensor_channel_get(config->sensor, SENSOR_CHAN_VOLTAGE, &voltage);
	if (ret < 0) {
		return ret;
	}

	ret = sensor_channel_get(config->sensor, SENSOR_CHAN_CURRENT, &current);
	if (ret < 0) {
		return ret;
	}

	ret = sensor_channel_get(config->sensor, SENSOR_CHAN_POWER, &power);
	if (ret < 0) {
		return ret;
	}

	LOG_INF("%-10s:\t%.3fV, %06.3fmA, %06.3fmW", config->name, sensor_value_to_double(&voltage),
		sensor_value_to_double(&current) * 1000.0f,
		sensor_value_to_double(&power) * 1000.0f);

	return 0;
}

/** @brief Measurement thread */
static void meas_thread_fn(void *dummy1, void *dummy2, void *dummy3)
{
	ARG_UNUSED(dummy1);
	ARG_UNUSED(dummy2);
	ARG_UNUSED(dummy3);

	while (1) {
		if (!meas_enabled) {
			k_sem_take(&meas_sem, K_FOREVER);
		}

		for (size_t i = 0U; i < POWER_RAIL_NUM; i++) {
			int ret;

			if (!rail_enabled[i]) {
				continue;
			}

			ret = read_and_log(&rail_config[i]);
			if (ret < 0) {
				LOG_ERR("Could not read %s", rail_config->name);
			}
		}

		k_msleep(CONFIG_POWER_MEAS_INTERVAL_MS);
	}
}

static int power_meas_init(void)
{
	int ret;

	/* check if all sensors are ready */
	for (size_t i = 0U; i < POWER_RAIL_NUM; i++) {
		if (!device_is_ready(rail_config[i].sensor)) {
			LOG_ERR("INA231 device not ready: %s\n", rail_config->name);
			return -ENODEV;
		}
	}

	/* enable all sensors and measurement if configured */
	if (IS_ENABLED(CONFIG_POWER_MEAS_START_ON_BOOT)) {
		meas_enabled = true;

		for (size_t i = 0U; i < POWER_RAIL_NUM; i++) {
			rail_enabled[i] = true;
		}
	}

	/* start measurement thread */
	pwr_meas_thread_id = k_thread_create(
		&meas_thread, meas_stack, CONFIG_POWER_MEAS_STACK_SIZE, meas_thread_fn, NULL, NULL,
		NULL, K_PRIO_PREEMPT(CONFIG_POWER_MEAS_THREAD_PRIO), 0, K_NO_WAIT);
	ret = k_thread_name_set(pwr_meas_thread_id, "pwr_meas");
	if (ret) {
		return ret;
	}

	return 0;
}

SYS_INIT(power_meas_init, APPLICATION, CONFIG_APPLICATION_INIT_PRIORITY);

static int cmd_info(const struct shell *shell, size_t argc, char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	for (size_t i = 0U; i < POWER_RAIL_NUM; i++) {
		shell_print(shell, "%-10s: %s", rail_config[i].name,
			    rail_enabled[i] ? "enabled" : "disabled");
	}

	return 0;
}

static int cmd_config(const struct shell *shell, size_t argc, const char **argv)
{
	bool enable;

	if (argc != 3) {
		shell_error(shell, "Usage: power config RAIL|all enable|disable");
		return -EINVAL;
	}

	enable = strcmp(argv[2], "enable") == 0;

	if (strcmp(argv[1], "all") == 0) {
		for (size_t i = 0U; i < POWER_RAIL_NUM; i++) {
			rail_enabled[i] = enable;
		}

		shell_print(shell, "All rails %s", enable ? "enabled" : "disabled");
	} else {
		size_t i;

		for (i = 0U; i < POWER_RAIL_NUM; i++) {
			if (strcmp(argv[1], rail_config[i].name) == 0) {
				break;
			}
		}

		if (i == POWER_RAIL_NUM) {
			shell_error(shell, "Invalid power rail");
			return -EINVAL;
		}

		rail_enabled[i] = enable;

		shell_print(shell, "Rail %s %s", rail_config[i].name,
			    enable ? "enabled" : "disabled");
	}

	return 0;
}

static int cmd_meas_start(const struct shell *shell, size_t argc, const char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	if (meas_enabled) {
		shell_error(shell, "Measurement already started");
		return -EALREADY;
	}

	meas_enabled = true;
	k_sem_give(&meas_sem);

	shell_print(shell, "Measurement started");

	return 0;
}

static int cmd_meas_stop(const struct shell *shell, size_t argc, const char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	meas_enabled = false;

	shell_print(shell, "Measurement stopped");

	return 0;
}

SHELL_STATIC_SUBCMD_SET_CREATE(
	power_meas_cmd, SHELL_COND_CMD(CONFIG_SHELL, info, NULL, "Show power rails info", cmd_info),
	SHELL_COND_CMD(CONFIG_SHELL, config, NULL, "Configure power rails", cmd_config),
	SHELL_COND_CMD(CONFIG_SHELL, start, NULL, "Start measurements", cmd_meas_start),
	SHELL_COND_CMD(CONFIG_SHELL, stop, NULL, "Stop measurements", cmd_meas_stop),
	SHELL_SUBCMD_SET_END);

SHELL_CMD_REGISTER(power, &power_meas_cmd, "Configure power measurements", NULL);


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/modules/sd_card_playback.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _SD_CARD_PLAYBACK_H_
#define _SD_CARD_PLAYBACK_H_

/**
 * @file
 * @defgroup sd_card_playback SD card playback.
 * @{
 * @brief The SD card playback module for nRF5340 Audio.
 */

#include <zephyr/kernel.h>

/**
 * @brief	Check whether or not the SD card playback module is active.
 *
 * @retval	true    Active.
 * @retval	false   Not active.
 */
bool sd_card_playback_is_active(void);

/**
 * @brief	Play audio from a WAV file from the SD card. Only support for mono files.
 *
 * @note	Supports only 48k mono files.
 *
 * @param[in]	filename	Name of file to be played. Path from the root of the SD card is
 *                              accepted.
 *
 * @retval	0       Success.
 * @retval	-EACCES SW codec is not initialized.
 */
int sd_card_playback_wav(char *filename);

/**
 * @brief	Play audio from an LC3 file from the SD card.
 *
 * @note	Supports only mono files.
 *
 * @param[in]	filename	Name of file to be played. Path from the root of the SD card is
 * accepted.
 *
 * @retval	0       Success.
 * @retval	-EACCES SW codec is not initialized.
 */
int sd_card_playback_lc3(char *filename);

/**
 * @brief	Mix the PCM data from the SD card playback module with the audio stream out.
 *
 * @param[in, out]	pcm_a           Buffer into which to mix PCM data from the LC3 module.
 * @param[in]		pcm_a_size	Size of the input buffer.
 *
 * @retval	0       Success.
 * @retval      -EACCES SD card playback is not active.
 * @retval      Otherwise, error from underlying drivers.
 */
int sd_card_playback_mix_with_stream(void *const pcm_a, size_t pcm_a_size);

/**
 * @brief	Initialize the SD card playback module. Create the SD card playback thread.
 *
 * @return	0 on success, otherwise, error from underlying drivers.
 */
int sd_card_playback_init(void);

/**
 * @}
 */

#endif /* _SD_CARD_PLAYBACK_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/modules/button_handler.c
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "button_handler.h"
#include "button_assignments.h"

#include <zephyr/kernel.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/sys/util.h>
#include <zephyr/shell/shell.h>
#include <zephyr/zbus/zbus.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>

#include "macros_common.h"
#include "nrf5340_audio_common.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(button_handler, CONFIG_MODULE_BUTTON_HANDLER_LOG_LEVEL);

ZBUS_CHAN_DEFINE(button_chan, struct button_msg, NULL, NULL, ZBUS_OBSERVERS_EMPTY,
		 ZBUS_MSG_INIT(0));

/* How many buttons does the module support. Increase at memory cost */
#define BUTTONS_MAX 5
#define BASE_10	    10

/* Only allow one button msg at a time, as a mean of debounce */
K_MSGQ_DEFINE(button_queue, sizeof(struct button_msg), 1, 4);

static bool debounce_is_ongoing;
static struct gpio_callback btn_callback[BUTTONS_MAX];

/* clang-format off */
const static struct btn_config btn_cfg[] = {
	{
		.btn_name = STRINGIFY(BUTTON_VOLUME_DOWN),
		.btn_pin = BUTTON_VOLUME_DOWN,
		.btn_cfg_mask = DT_GPIO_FLAGS(DT_ALIAS(sw0), gpios),
	},
	{
		.btn_name = STRINGIFY(BUTTON_VOLUME_UP),
		.btn_pin = BUTTON_VOLUME_UP,
		.btn_cfg_mask = DT_GPIO_FLAGS(DT_ALIAS(sw1), gpios),
	},
	{
		.btn_name = STRINGIFY(BUTTON_PLAY_PAUSE),
		.btn_pin = BUTTON_PLAY_PAUSE,
		.btn_cfg_mask = DT_GPIO_FLAGS(DT_ALIAS(sw2), gpios),
	},
	{
		.btn_name = STRINGIFY(BUTTON_4),
		.btn_pin = BUTTON_4,
		.btn_cfg_mask = DT_GPIO_FLAGS(DT_ALIAS(sw3), gpios),
	},
	{
		.btn_name = STRINGIFY(BUTTON_5),
		.btn_pin = BUTTON_5,
		.btn_cfg_mask = DT_GPIO_FLAGS(DT_ALIAS(sw4), gpios),
	}
};
/* clang-format on */

static const struct device *gpio_53_dev;

/**@brief Simple debouncer for buttons
 *
 * @note Needed as low-level driver debouce is not
 * implemented in Zephyr for nRF53 yet
 */
static void on_button_debounce_timeout(struct k_timer *timer)
{
	debounce_is_ongoing = false;
}

K_TIMER_DEFINE(button_debounce_timer, on_button_debounce_timeout, NULL);

/** @brief Find the index of a button from the pin number
 */
static int pin_to_btn_idx(uint8_t btn_pin, uint32_t *pin_idx)
{
	for (uint8_t i = 0; i < ARRAY_SIZE(btn_cfg); i++) {
		if (btn_pin == btn_cfg[i].btn_pin) {
			*pin_idx = i;
			return 0;
		}
	}

	LOG_WRN("Button idx not found");
	return -ENODEV;
}

/** @brief Convert from mask to pin
 *
 * @note: Will check that a single bit and a single bit only is set in the mask.
 */
static int pin_msk_to_pin(uint32_t pin_msk, uint32_t *pin_out)
{
	if (!pin_msk) {
		LOG_ERR("Mask is empty");
		return -EACCES;
	}

	if (pin_msk & (pin_msk - 1)) {
		LOG_ERR("Two or more buttons set in mask");
		return -EACCES;
	}

	*pin_out = 0;

	while (pin_msk) {
		pin_msk = pin_msk >> 1;
		(*pin_out)++;
	}

	/* Deduct 1 for zero indexing */
	(*pin_out)--;

	return 0;
}

static void button_publish_thread(void)
{
	int ret;
	struct button_msg msg;

	while (1) {
		k_msgq_get(&button_queue, &msg, K_FOREVER);

		ret = zbus_chan_pub(&button_chan, &msg, K_NO_WAIT);
		if (ret) {
			LOG_ERR("Failed to publish button msg, ret: %d", ret);
		}
	}
}

K_THREAD_DEFINE(button_publish, CONFIG_BUTTON_PUBLISH_STACK_SIZE, button_publish_thread, NULL, NULL,
		NULL, K_PRIO_PREEMPT(CONFIG_BUTTON_PUBLISH_THREAD_PRIO), 0, 0);

/*  ISR triggered by GPIO when assigned button(s) are pushed */
static void button_isr(const struct device *port, struct gpio_callback *cb, uint32_t pin_msk)
{
	int ret;
	struct button_msg msg;

	if (debounce_is_ongoing) {
		LOG_DBG("Btn debounce in action");
		return;
	}

	uint32_t btn_pin = 0;
	uint32_t btn_idx = 0;

	ret = pin_msk_to_pin(pin_msk, &btn_pin);
	ERR_CHK(ret);

	ret = pin_to_btn_idx(btn_pin, &btn_idx);
	ERR_CHK(ret);

	LOG_DBG("Pushed button idx: %d pin: %d name: %s", btn_idx, btn_pin,
		btn_cfg[btn_idx].btn_name);

	msg.button_pin = btn_pin;
	msg.button_action = BUTTON_PRESS;

	ret = k_msgq_put(&button_queue, (void *)&msg, K_NO_WAIT);
	if (ret == -EAGAIN) {
		LOG_WRN("Btn msg queue full");
	}

	debounce_is_ongoing = true;
	k_timer_start(&button_debounce_timer, K_MSEC(CONFIG_BUTTON_DEBOUNCE_MS), K_NO_WAIT);
}

int button_pressed(gpio_pin_t button_pin, bool *button_pressed)
{
	int ret;

	if (!device_is_ready(gpio_53_dev)) {
		return -ENODEV;
	}

	if (button_pressed == NULL) {
		return -EINVAL;
	}

	ret = gpio_pin_get(gpio_53_dev, button_pin);
	switch (ret) {
	case 0:
		*button_pressed = false;
		break;
	case 1:
		*button_pressed = true;
		break;
	default:
		return ret;
	}

	return 0;
}

int button_handler_init(void)
{
	int ret;

	if (ARRAY_SIZE(btn_cfg) == 0) {
		LOG_WRN("No buttons assigned");
		return -EINVAL;
	}

	gpio_53_dev = DEVICE_DT_GET(DT_NODELABEL(gpio0));

	if (!device_is_ready(gpio_53_dev)) {
		LOG_ERR("Device driver not ready.");
		return -ENODEV;
	}

	for (uint8_t i = 0; i < ARRAY_SIZE(btn_cfg); i++) {
		ret = gpio_pin_configure(gpio_53_dev, btn_cfg[i].btn_pin,
					 GPIO_INPUT | btn_cfg[i].btn_cfg_mask);
		if (ret) {
			return ret;
		}

		gpio_init_callback(&btn_callback[i], button_isr, BIT(btn_cfg[i].btn_pin));

		ret = gpio_add_callback(gpio_53_dev, &btn_callback[i]);
		if (ret) {
			return ret;
		}

		ret = gpio_pin_interrupt_configure(gpio_53_dev, btn_cfg[i].btn_pin,
						   GPIO_INT_EDGE_TO_INACTIVE);
		if (ret) {
			return ret;
		}
	}

	return 0;
}

/* Shell functions */
static int cmd_print_all_btns(const struct shell *shell, size_t argc, char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	for (uint8_t i = 0; i < ARRAY_SIZE(btn_cfg); i++) {
		shell_print(shell, "Id %d: pin: %d %s", i, btn_cfg[i].btn_pin, btn_cfg[i].btn_name);
	}

	return 0;
}

static int cmd_push_btn(const struct shell *shell, size_t argc, char **argv)
{
	int ret;
	uint8_t btn_idx;
	struct button_msg msg;

	/* First argument is function, second is button idx */
	if (argc != 2) {
		shell_error(shell, "Wrong number of arguments provided");
		return -EINVAL;
	}

	if (!isdigit((int)argv[1][0])) {
		shell_error(shell, "Supplied argument is not numeric");
		return -EINVAL;
	}

	btn_idx = strtoul(argv[1], NULL, BASE_10);

	if (btn_idx >= ARRAY_SIZE(btn_cfg)) {
		shell_error(shell, "Selected button ID out of range");
		return -EINVAL;
	}

	msg.button_pin = btn_cfg[btn_idx].btn_pin;
	msg.button_action = BUTTON_PRESS;

	ret = zbus_chan_pub(&button_chan, &msg, K_NO_WAIT);
	if (ret) {
		LOG_ERR("Failed to publish button msg, ret: %d", ret);
	}

	shell_print(shell, "Pushed button idx: %d pin: %d : %s", btn_idx, btn_cfg[btn_idx].btn_pin,
		    btn_cfg[btn_idx].btn_name);

	return 0;
}

/* Creating subcommands (level 1 command) array for command "demo". */
SHELL_STATIC_SUBCMD_SET_CREATE(buttons_cmd,
			       SHELL_COND_CMD(CONFIG_SHELL, print, NULL, "Print all buttons.",
					      cmd_print_all_btns),
			       SHELL_COND_CMD(CONFIG_SHELL, push, NULL, "Push button.",
					      cmd_push_btn),
			       SHELL_SUBCMD_SET_END);
/* Creating root (level 0) command "demo" without a handler */
SHELL_CMD_REGISTER(buttons, &buttons_cmd, "List and push buttons", NULL);


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/modules/Kconfig
#
# Copyright (c) 2022 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

rsource "Kconfig.defaults"

menu "Modules"

config BUTTON_DEBOUNCE_MS
	int "Button debounce time in ms"
	default 50

config AUDIO_SYNC_TIMER_USES_RTC
	bool
	default !BT_LL_ACS_NRF53
	select NRFX_RTC0

#----------------------------------------------------------------------------#
menu "Power measurement"

config POWER_MEAS_INTERVAL_MS
	int "Power measurement interval in milliseconds"
	default 8500
	help
	  Power measurement runs continuously, this option just establishes the
	  results polling period. Note that this value needs to be >= the configured
	  sampling interval on the current sensor. When below, repeated measurements
	  will be observed.

config POWER_MEAS_START_ON_BOOT
	bool "Start power measurements for all rails on boot"
	help
	  This option will automatically start and periodically print
	  the voltage, current consumption, and power usage for the
	  following rails: VBAT, VDD1_CODEC, VDD2_CODEC, and VDD2_NRF

endmenu # Power measurement

#----------------------------------------------------------------------------#
menu "I2S"

config I2S_LRCK_FREQ_HZ
	int
	default AUDIO_SAMPLE_RATE_HZ
	help
	 The sample rate of I2S. For now this is tied directly to
	 AUDIO_SAMPLE_RATE_HZ
	 Note that this setting is only valid in I2S master mode.

config I2S_CH_NUM
	int
	default 2
	help
	 The I2S driver itself supports both mono and stereo.
	 Parts of the implementation are configured for only stereo.

endmenu # I2S

#----------------------------------------------------------------------------#
menu "Log levels"

module = MODULE_AUDIO_USB
module-str = module-audio-usb
source "subsys/logging/Kconfig.template.log_config"

module = MODULE_BUTTON_HANDLER
module-str = module-button-handler
source "subsys/logging/Kconfig.template.log_config"

module = MODULE_HW_CODEC
module-str = module-hw-codec
source "subsys/logging/Kconfig.template.log_config"

module = MODULE_LED
module-str = module-led
source "subsys/logging/Kconfig.template.log_config"

module = MODULE_POWER
module-str = module-power
source "subsys/logging/Kconfig.template.log_config"

module = MODULE_SD_CARD
module-str = module-sd-card
source "subsys/logging/Kconfig.template.log_config"

module = MODULE_SD_CARD_PLAYBACK
module-str = module-sd-card-playback
source "subsys/logging/Kconfig.template.log_config"

module = MODULE_NRF5340_AUDIO_DK
module-str = module-nrf5340-audio_dk
source "subsys/logging/Kconfig.template.log_config"

endmenu # Log levels

#----------------------------------------------------------------------------#
menu "Thread priorities"

config POWER_MEAS_THREAD_PRIO
	int "Priority for power measurement thread"
	default 6
	help
	  This is a preemptible thread.

config BUTTON_PUBLISH_THREAD_PRIO
	int "Priority for button publish thread"
	default 5
	help
	  This is a preemptible thread.
	  This thread will publish button events to zbus.

config VOLUME_MSG_SUB_THREAD_PRIO
	int "Priority for volume message subscribe thread"
	default 5
	help
	  This is a preemptible thread.
	  This thread will subscribe to volume events from zbus.

endmenu # Thread priorities

#----------------------------------------------------------------------------#
menu "Stack sizes"

config POWER_MEAS_STACK_SIZE
	int "Stack size for power measurement thread"
	default 1152

config BUTTON_PUBLISH_STACK_SIZE
	int "Stack size for button publish thread"
	default 450

config VOLUME_MSG_SUB_STACK_SIZE
	int "Stack size for volume message subscribe thread"
	default 768

endmenu # Stack sizes

#----------------------------------------------------------------------------#
menu "Zbus"

config VOLUME_MSG_SUB_QUEUE_SIZE
	int "Queue size for volume message subscriber"
	default 4

endmenu # Zbus

#----------------------------------------------------------------------------#
menuconfig SD_CARD_PLAYBACK
	bool "Enable playback from SD card"
	select EXPERIMENTAL
	default n
	select RING_BUFFER

if SD_CARD_PLAYBACK

config SD_CARD_PLAYBACK_STACK_SIZE
	int "Stack size for the SD card playback thread"
	default 4096

config SD_CARD_PLAYBACK_RING_BUF_SIZE
	int "Size of the ring buffer for the SD card playback module"
	default 960

config SD_CARD_PLAYBACK_THREAD_PRIORITY
	int "Priority for the SD card playback thread"
	default 7

endif # SD_CARD_PLAYBACK

endmenu # Modules


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/modules/audio_usb.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _AUDIO_USB_H_
#define _AUDIO_USB_H_

#include "data_fifo.h"

#if (CONFIG_AUDIO_SOURCE_USB && !CONFIG_AUDIO_SAMPLE_RATE_48000_HZ)
/* Only 48kHz is supported when using USB */
#error USB only supports 48kHz
#endif /* (CONFIG_AUDIO_SOURCE_USB && !CONFIG_AUDIO_SAMPLE_RATE_48000_HZ) */

/**
 * @brief Set fifo buffers to be used by USB module and start sending/receiving data
 *
 * @param fifo_tx_in  Pointer to fifo structure for tx
 * @param fifo_rx_in  Pointer to fifo structure for rx
 *
 * @return 0 if successful, error otherwise
 */
int audio_usb_start(struct data_fifo *fifo_tx_in, struct data_fifo *fifo_rx_in);

/**
 * @brief Stop sending/receiving data
 *
 * @note The USB device will still be running, but all data sent to
 *       it will be discarded
 */
void audio_usb_stop(void);

/**
 * @brief Stop and disable USB device
 *
 * @return 0 if successful, error otherwise
 */
int audio_usb_disable(void);

/**
 * @brief Register and enable USB device
 *
 * @return 0 if successful, error otherwise
 */
int audio_usb_init(void);

#endif /* _AUDIO_USB_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/modules/hw_codec.c
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "hw_codec.h"

#include <zephyr/kernel.h>
#include <stdlib.h>
#include <stdint.h>
#include <ctype.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/device.h>
#include <zephyr/shell/shell.h>
#include <zephyr/zbus/zbus.h>

#include "macros_common.h"
#include "nrf5340_audio_common.h"
#include "cs47l63.h"
#include "cs47l63_spec.h"
#include "cs47l63_reg_conf.h"
#include "cs47l63_comm.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(hw_codec, CONFIG_MODULE_HW_CODEC_LOG_LEVEL);

#define VOLUME_ADJUST_STEP_DB 3
#define BASE_10		      10

ZBUS_SUBSCRIBER_DEFINE(volume_evt_sub, CONFIG_VOLUME_MSG_SUB_QUEUE_SIZE);

static uint32_t prev_volume_reg_val = OUT_VOLUME_DEFAULT;

static cs47l63_t cs47l63_driver;

static k_tid_t volume_msg_sub_thread_id;
static struct k_thread volume_msg_sub_thread_data;

K_THREAD_STACK_DEFINE(volume_msg_sub_thread_stack, CONFIG_VOLUME_MSG_SUB_STACK_SIZE);

/**
 * @brief	Convert the zbus volume to the actual volume setting for the HW codec.
 *
 * @note	The range for zbus volume is from 0 to 255 and the
 *		range for HW codec volume is from 0 to 128.
 */
static uint16_t zbus_vol_conversion(uint8_t volume)
{
	return (((uint16_t)volume + 1) / 2);
}

/**
 * @brief	Handle volume events from zbus.
 */
static void volume_msg_sub_thread(void)
{
	int ret;

	const struct zbus_channel *chan;

	while (1) {
		ret = zbus_sub_wait(&volume_evt_sub, &chan, K_FOREVER);
		ERR_CHK(ret);

		struct volume_msg msg;

		ret = zbus_chan_read(chan, &msg, ZBUS_READ_TIMEOUT_MS);
		if (ret) {
			LOG_ERR("Failed to read from zbus: %d", ret);
		}

		uint8_t event = msg.event;
		uint8_t volume = msg.volume;

		LOG_DBG("Received event = %d, volume = %d", event, volume);

		switch (event) {
		case VOLUME_UP:
			LOG_DBG("Volume up received");
			ret = hw_codec_volume_increase();
			if (ret) {
				LOG_ERR("Failed to increase volume, ret: %d", ret);
			}
			break;
		case VOLUME_DOWN:
			LOG_DBG("Volume down received");
			ret = hw_codec_volume_decrease();
			if (ret) {
				LOG_ERR("Failed to decrease volume, ret: %d", ret);
			}
			break;
		case VOLUME_SET:
			LOG_DBG("Volume set received");
			ret = hw_codec_volume_set(zbus_vol_conversion(volume));
			if (ret) {
				LOG_ERR("Failed to set the volume to %d, ret: %d", volume, ret);
			}
			break;
		case VOLUME_MUTE:
			LOG_DBG("Volume mute received");
			ret = hw_codec_volume_mute();
			if (ret) {
				LOG_ERR("Failed to mute volume, ret: %d", ret);
			}
			break;
		case VOLUME_UNMUTE:
			LOG_DBG("Volume unmute received");
			ret = hw_codec_volume_unmute();
			if (ret) {
				LOG_ERR("Failed to unmute volume, ret: %d", ret);
			}
			break;
		default:
			LOG_WRN("Unexpected/unhandled volume event: %d", event);
			break;
		}

		STACK_USAGE_PRINT("volume_msg_thread", &volume_msg_sub_thread_data);
	}
}

/**
 * @brief Write to multiple registers in CS47L63.
 */
static int cs47l63_comm_reg_conf_write(const uint32_t config[][2], uint32_t num_of_regs)
{
	int ret;
	uint32_t reg;
	uint32_t value;

	for (int i = 0; i < num_of_regs; i++) {
		reg = config[i][0];
		value = config[i][1];

		if (reg == SPI_BUSY_WAIT) {
			LOG_DBG("Busy waiting instead of writing to CS47L63");
			/* Wait for us defined in value */
			k_busy_wait(value);
		} else {
			ret = cs47l63_write_reg(&cs47l63_driver, reg, value);
			if (ret) {
				return ret;
			}
		}
	}

	return 0;
}

int hw_codec_volume_set(uint8_t set_val)
{
	int ret;
	uint32_t volume_reg_val;

	volume_reg_val = set_val;
	if (volume_reg_val == 0) {
		LOG_WRN("Volume at MIN (-64dB)");
	} else if (volume_reg_val >= MAX_VOLUME_REG_VAL) {
		LOG_WRN("Volume at MAX (0dB)");
		volume_reg_val = MAX_VOLUME_REG_VAL;
	}

	ret = cs47l63_write_reg(&cs47l63_driver, CS47L63_OUT1L_VOLUME_1,
				volume_reg_val | CS47L63_OUT_VU);
	if (ret) {
		return ret;
	}

	prev_volume_reg_val = volume_reg_val;

	/* This is rounded down to nearest integer */
	LOG_DBG("Volume: %" PRId32 " dB", (volume_reg_val / 2) - MAX_VOLUME_DB);

	return 0;
}

int hw_codec_volume_adjust(int8_t adjustment_db)
{
	int ret;
	int32_t new_volume_reg_val;

	LOG_DBG("Adj dB in: %d", adjustment_db);

	if (adjustment_db == 0) {
		new_volume_reg_val = prev_volume_reg_val;
	} else {
		uint32_t volume_reg_val;

		ret = cs47l63_read_reg(&cs47l63_driver, CS47L63_OUT1L_VOLUME_1, &volume_reg_val);
		if (ret) {
			LOG_ERR("Failed to get volume from CS47L63");
			return ret;
		}

		volume_reg_val &= CS47L63_OUT1L_VOL_MASK;

		/* The adjustment is in dB, 1 bit equals 0.5 dB,
		 * so multiply by 2 to get increments of 1 dB
		 */
		new_volume_reg_val = volume_reg_val + (adjustment_db * 2);
		if (new_volume_reg_val <= 0) {
			LOG_WRN("Volume at MIN (-64dB)");
			new_volume_reg_val = 0;
		} else if (new_volume_reg_val >= MAX_VOLUME_REG_VAL) {
			LOG_WRN("Volume at MAX (0dB)");
			new_volume_reg_val = MAX_VOLUME_REG_VAL;
		}
	}

	ret = hw_codec_volume_set(new_volume_reg_val);
	if (ret) {
		return ret;
	}

	return 0;
}

int hw_codec_volume_decrease(void)
{
	int ret;

	ret = hw_codec_volume_adjust(-VOLUME_ADJUST_STEP_DB);
	if (ret) {
		return ret;
	}

	return 0;
}

int hw_codec_volume_increase(void)
{
	int ret;

	ret = hw_codec_volume_adjust(VOLUME_ADJUST_STEP_DB);
	if (ret) {
		return ret;
	}

	return 0;
}

int hw_codec_volume_mute(void)
{
	int ret;
	uint32_t volume_reg_val;

	ret = cs47l63_read_reg(&cs47l63_driver, CS47L63_OUT1L_VOLUME_1, &volume_reg_val);
	if (ret) {
		return ret;
	}

	BIT_SET(volume_reg_val, CS47L63_OUT1L_MUTE_MASK);

	ret = cs47l63_write_reg(&cs47l63_driver, CS47L63_OUT1L_VOLUME_1,
				volume_reg_val | CS47L63_OUT_VU);
	if (ret) {
		return ret;
	}

	return 0;
}

int hw_codec_volume_unmute(void)
{
	int ret;
	uint32_t volume_reg_val;

	ret = cs47l63_read_reg(&cs47l63_driver, CS47L63_OUT1L_VOLUME_1, &volume_reg_val);
	if (ret) {
		return ret;
	}

	BIT_CLEAR(volume_reg_val, CS47L63_OUT1L_MUTE_MASK);

	ret = cs47l63_write_reg(&cs47l63_driver, CS47L63_OUT1L_VOLUME_1,
				volume_reg_val | CS47L63_OUT_VU);
	if (ret) {
		return ret;
	}

	return 0;
}

int hw_codec_default_conf_enable(void)
{
	int ret;

	ret = cs47l63_comm_reg_conf_write(clock_configuration, ARRAY_SIZE(clock_configuration));
	if (ret) {
		return ret;
	}

	ret = cs47l63_comm_reg_conf_write(GPIO_configuration, ARRAY_SIZE(GPIO_configuration));
	if (ret) {
		return ret;
	}

	ret = cs47l63_comm_reg_conf_write(asp1_enable, ARRAY_SIZE(asp1_enable));
	if (ret) {
		return ret;
	}

	ret = cs47l63_comm_reg_conf_write(output_enable, ARRAY_SIZE(output_enable));
	if (ret) {
		return ret;
	}

	ret = hw_codec_volume_adjust(0);
	if (ret) {
		return ret;
	}

#if ((CONFIG_AUDIO_DEV == GATEWAY) && (CONFIG_AUDIO_SOURCE_I2S))
	if (IS_ENABLED(CONFIG_WALKIE_TALKIE_DEMO)) {
		ret = cs47l63_comm_reg_conf_write(pdm_mic_enable_configure,
						  ARRAY_SIZE(pdm_mic_enable_configure));
		if (ret) {
			return ret;
		}
	} else {
		ret = cs47l63_comm_reg_conf_write(line_in_enable, ARRAY_SIZE(line_in_enable));
		if (ret) {
			return ret;
		}
	}
#endif /* ((CONFIG_AUDIO_DEV == GATEWAY) && (CONFIG_AUDIO_SOURCE_I2S)) */

#if ((CONFIG_AUDIO_DEV == HEADSET) && CONFIG_STREAM_BIDIRECTIONAL)
	ret = cs47l63_comm_reg_conf_write(pdm_mic_enable_configure,
					  ARRAY_SIZE(pdm_mic_enable_configure));
	if (ret) {
		return ret;
	}
#endif /* ((CONFIG_AUDIO_DEV == HEADSET) && CONFIG_STREAM_BIDIRECTIONAL) */

	/* Toggle FLL to start up CS47L63 */
	ret = cs47l63_comm_reg_conf_write(FLL_toggle, ARRAY_SIZE(FLL_toggle));
	if (ret) {
		return ret;
	}

	return 0;
}

int hw_codec_soft_reset(void)
{
	int ret;

	ret = cs47l63_comm_reg_conf_write(output_disable, ARRAY_SIZE(output_disable));
	if (ret) {
		return ret;
	}

	ret = cs47l63_comm_reg_conf_write(soft_reset, ARRAY_SIZE(soft_reset));
	if (ret) {
		return ret;
	}

	return 0;
}

int hw_codec_init(void)
{
	int ret;

	ret = cs47l63_comm_init(&cs47l63_driver);
	if (ret) {
		return ret;
	}

	/* Run a soft reset on start to make sure all registers are default values */
	ret = cs47l63_comm_reg_conf_write(soft_reset, ARRAY_SIZE(soft_reset));
	if (ret) {
		return ret;
	}
	cs47l63_driver.state = CS47L63_STATE_STANDBY;

	volume_msg_sub_thread_id = k_thread_create(
		&volume_msg_sub_thread_data, volume_msg_sub_thread_stack,
		CONFIG_VOLUME_MSG_SUB_STACK_SIZE, (k_thread_entry_t)volume_msg_sub_thread, NULL,
		NULL, NULL, K_PRIO_PREEMPT(CONFIG_VOLUME_MSG_SUB_THREAD_PRIO), 0, K_NO_WAIT);
	ret = k_thread_name_set(volume_msg_sub_thread_id, "VOLUME_MSG_SUB");
	ERR_CHK(ret);

	return 0;
}

static int cmd_input(const struct shell *shell, size_t argc, char **argv)
{
	int ret;
	uint8_t idx;

	enum hw_codec_input {
		LINE_IN,
		PDM_MIC,
		NUM_INPUTS,
	};

	if (argc != 2) {
		shell_error(shell, "Only one argument required, provided: %d", argc);
		return -EINVAL;
	}

	if ((CONFIG_AUDIO_DEV == GATEWAY) && IS_ENABLED(CONFIG_AUDIO_SOURCE_USB)) {
		shell_error(shell, "Can't select PDM mic if audio source is USB");
		return -EINVAL;
	}

	if ((CONFIG_AUDIO_DEV == HEADSET) && !IS_ENABLED(CONFIG_STREAM_BIDIRECTIONAL)) {
		shell_error(shell, "Can't select input if headset is not in bidirectional stream");
		return -EINVAL;
	}

	if (!isdigit((int)argv[1][0])) {
		shell_error(shell, "Supplied argument is not numeric");
		return -EINVAL;
	}

	idx = strtoul(argv[1], NULL, BASE_10);

	switch (idx) {
	case LINE_IN: {
		if (CONFIG_AUDIO_DEV == HEADSET) {
			ret = cs47l63_comm_reg_conf_write(line_in_enable,
							  ARRAY_SIZE(line_in_enable));
			if (ret) {
				shell_error(shell, "Failed to enable LINE-IN");
				return ret;
			}
		}

		ret = cs47l63_write_reg(&cs47l63_driver, CS47L63_ASP1TX1_INPUT1, 0x800012);
		if (ret) {
			shell_error(shell, "Failed to route LINE-IN to I2S");
			return ret;
		}

		ret = cs47l63_write_reg(&cs47l63_driver, CS47L63_ASP1TX2_INPUT1, 0x800013);
		if (ret) {
			shell_error(shell, "Failed to route LINE-IN to I2S");
			return ret;
		}

		shell_print(shell, "Selected LINE-IN as input");
		break;
	}
	case PDM_MIC: {
		if (CONFIG_AUDIO_DEV == GATEWAY) {
			ret = cs47l63_comm_reg_conf_write(pdm_mic_enable_configure,
							  ARRAY_SIZE(pdm_mic_enable_configure));
			if (ret) {
				shell_error(shell, "Failed to enable PDM mic");
				return ret;
			}
		}

		ret = cs47l63_write_reg(&cs47l63_driver, CS47L63_ASP1TX1_INPUT1, 0x800010);
		if (ret) {
			shell_error(shell, "Failed to route PDM mic to I2S");
			return ret;
		}

		ret = cs47l63_write_reg(&cs47l63_driver, CS47L63_ASP1TX2_INPUT1, 0x800011);
		if (ret) {
			shell_error(shell, "Failed to route PDM mic to I2S");
			return ret;
		}

		shell_print(shell, "Selected PDM mic as input");
		break;
	}
	default:
		shell_error(shell, "Invalid input");
		return -EINVAL;
	}

	return 0;
}

SHELL_STATIC_SUBCMD_SET_CREATE(hw_codec_cmd,
			       SHELL_COND_CMD(CONFIG_SHELL, input, NULL,
					      " Select input\n\t0: LINE_IN\n\t\t1: PDM_MIC",
					      cmd_input),
			       SHELL_SUBCMD_SET_END);

SHELL_CMD_REGISTER(hw_codec, &hw_codec_cmd, "Change settings on HW codec", NULL);


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/modules/audio_i2s.h
/*
 *  Copyright (c) 2021, PACKETCRAFT, INC.
 *
 *  SPDX-License-Identifier: LicenseRef-PCFT
 */

#ifndef _AUDIO_I2S_H_
#define _AUDIO_I2S_H_

#include <zephyr/kernel.h>
#include <stdint.h>

/*
 * Calculate the number of bytes of one frame, as per now, this frame can either
 * be 10 or 7.5 ms. Since we can't have floats in a define we use 15/2 instead
 */

#if ((CONFIG_AUDIO_FRAME_DURATION_US == 7500) && CONFIG_SW_CODEC_LC3)

#define FRAME_SIZE_BYTES                                                                           \
	((CONFIG_I2S_LRCK_FREQ_HZ / 1000 * 15 / 2) * CONFIG_I2S_CH_NUM *                           \
	 CONFIG_AUDIO_BIT_DEPTH_OCTETS)
#else
#define FRAME_SIZE_BYTES                                                                           \
	((CONFIG_I2S_LRCK_FREQ_HZ / 1000 * 10) * CONFIG_I2S_CH_NUM * CONFIG_AUDIO_BIT_DEPTH_OCTETS)
#endif /* ((CONFIG_AUDIO_FRAME_DURATION_US == 7500) && CONFIG_SW_CODEC_LC3) */

#define BLOCK_SIZE_BYTES (FRAME_SIZE_BYTES / CONFIG_FIFO_FRAME_SPLIT_NUM)

/*
 * Calculate the number of samples in a block, divided by the number of samples
 * that will fit within a 32-bit word
 */
#define I2S_SAMPLES_NUM                                                                            \
	(BLOCK_SIZE_BYTES / (CONFIG_AUDIO_BIT_DEPTH_OCTETS) / (32 / CONFIG_AUDIO_BIT_DEPTH_BITS))

/**
 * @brief I2S block complete event callback type
 *
 * @param frame_start_ts I2S frame start timestamp
 * @param rx_buf_released Pointer to the released buffer containing received data
 * @param tx_buf_released Pointer to the released buffer that was used to sent data
 */
typedef void (*i2s_blk_comp_callback_t)(uint32_t frame_start_ts, uint32_t *rx_buf_released,
					uint32_t const *tx_buf_released);

/**
 * @brief Supply the buffers to be used in the next part of the I2S transfer
 *
 * @param tx_buf Pointer to the buffer with data to be sent
 * @param rx_buf Pointer to the buffer for received data
 */
void audio_i2s_set_next_buf(const uint8_t *tx_buf, uint32_t *rx_buf);

/**
 * @brief Start the continuous I2S transfer
 *
 * @param tx_buf Pointer to the buffer with data to be sent
 * @param rx_buf Pointer to the buffer for received data
 */
void audio_i2s_start(const uint8_t *tx_buf, uint32_t *rx_buf);

/**
 * @brief Stop the continuous I2S transfer
 */
void audio_i2s_stop(void);

/**
 * @brief Register callback function for I2S block complete event
 *
 * @param blk_comp_callback Callback function
 */
void audio_i2s_blk_comp_cb_register(i2s_blk_comp_callback_t blk_comp_callback);

/**
 * @brief Initialize I2S module
 */
void audio_i2s_init(void);

#endif /* _AUDIO_I2S_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/modules/audio_sync_timer.h
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _AUDIO_SYNC_TIMER_H_
#define _AUDIO_SYNC_TIMER_H_

#include <zephyr/kernel.h>
#include <stdint.h>

/**
 * @brief Capture a timestamp on the sync timer.
 *
 * @retval The current timestamp of the audio sync timer.
 */
uint32_t audio_sync_timer_capture(void);

/**
 * @brief Returns the last captured value of the sync timer.
 *
 * The captured time is corresponding to the I2S frame start.
 *
 * See @ref audio_sync_timer_capture().
 *
 * @retval The last captured timestamp of the audio sync timer.
 */
uint32_t audio_sync_timer_capture_get(void);

#endif /* _AUDIO_SYNC_TIMER_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/modules/led.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _LED_H_
#define _LED_H_

#include <stdint.h>

#define LED_APP_RGB 0
#define LED_NET_RGB 1
#define LED_APP_1_BLUE 2
#define LED_APP_2_GREEN 3
#define LED_APP_3_GREEN 4

#define RED 0
#define GREEN 1
#define BLUE 2

#define GRN GREEN
#define BLU BLUE

enum led_color {
	LED_COLOR_OFF, /* 000 */
	LED_COLOR_RED, /* 001 */
	LED_COLOR_GREEN, /* 010 */
	LED_COLOR_YELLOW, /* 011 */
	LED_COLOR_BLUE, /* 100 */
	LED_COLOR_MAGENTA, /* 101 */
	LED_COLOR_CYAN, /* 110 */
	LED_COLOR_WHITE, /* 111 */
	LED_COLOR_NUM,
};

#define LED_ON LED_COLOR_WHITE

#define LED_BLINK true
#define LED_SOLID false

/**
 * @brief Set the state of a given LED unit to blink.
 *
 * @note A led unit is defined as an RGB LED or a monochrome LED.
 *
 * @param led_unit	Selected LED unit. Defines are located in board.h
 * @note		If the given LED unit is an RGB LED, color must be
 *			provided as a single vararg. See led_color.
 *			For monochrome LEDs, the vararg will be ignored.
 *			Using a LED unit assigned to another core will do nothing and return 0.
 * @return		0 on success
 *			-EPERM if the module has not been initialised
 *			-EINVAL if the color argument is illegal
 *			Other errors from underlying drivers.
 */
int led_blink(uint8_t led_unit, ...);

/**
 * @brief Turn the given LED unit on.
 *
 * @note A led unit is defined as an RGB LED or a monochrome LED.
 *
 * @param led_unit	Selected LED unit. Defines are located in board.h
 * @note		If the given LED unit is an RGB LED, color must be
 *			provided as a single vararg. See led_color.
 *			For monochrome LEDs, the vararg will be ignored.
*			Using a LED unit assigned to another core will do nothing and return 0.
 * @return		0 on success
 *			-EPERM if the module has not been initialised
 *			-EINVAL if the color argument is illegal
 *			Other errors from underlying drivers.
 */
int led_on(uint8_t led_unit, ...);

/**
 * @brief Set the state of a given LED unit to off.
 *
 * @note A led unit is defined as an RGB LED or a monochrome LED.
 *		Using a LED unit assigned to another core will do nothing and return 0.
 *
 * @param led_unit	Selected LED unit. Defines are located in board.h
 * @return		0 on success
 *			-EPERM if the module has not been initialised
 *			-EINVAL if the color argument is illegal
 *			Other errors from underlying drivers.
 */
int led_off(uint8_t led_unit);

/**
 * @brief Initialise the LED module
 *
 * @note This will parse the .dts files and configure all LEDs.
 *
 * @return	0 on success
 *		-EPERM if already initialsed
 *		-ENXIO if a LED is missing unit number in dts
 *		-ENODEV if a LED is missing color identifier
 */
int led_init(void);

#endif /* _LED_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/modules/sd_card_playback.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "sd_card_playback.h"

#include <stdint.h>
#include <math.h>
#include <zephyr/sys/ring_buffer.h>
#include <zephyr/shell/shell.h>

#include "sd_card.h"
#include "sw_codec_lc3.h"
#include "sw_codec_select.h"
#include "pcm_mix.h"
#include "audio_system.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(sd_card_playback, CONFIG_MODULE_SD_CARD_PLAYBACK_LOG_LEVEL);

#define MAX_PATH_LEN	    (CONFIG_FS_FATFS_MAX_LFN)
#define LIST_FILES_BUF_SIZE 512
#define FRAME_DURATION_MS   (CONFIG_AUDIO_FRAME_DURATION_US / 1000)

#define WAV_FORMAT_PCM	    1
#define WAV_SAMPLE_RATE_48K 48000

/* WAV header */
struct wav_header {
	/* RIFF Header */
	char riff_header[4];
	uint32_t wav_size;  /* File size excluding first eight bytes */
	char wav_header[4]; /* Contains "WAVE" */

	/* Format Header */
	char fmt_header[4];
	uint32_t wav_chunk_size; /* Should be 16 for PCM */
	short audio_format;	 /* Should be 1 for PCM */
	short num_channels;
	uint32_t sample_rate;
	uint32_t byte_rate;
	short block_alignment; /* num_channels * Bytes Per Sample */
	short bit_depth;

	/* Data */
	char data_header[4];
	uint32_t data_bytes; /* Number of bytes in data */
} __packed;

/* LC3 header */
struct lc3_header {
	uint16_t file_id;	 /* Constant value, 0xCC1C */
	uint16_t hdr_size;	 /* Header size, 0x0012 */
	uint16_t sample_rate;	 /* Sample frequency / 100 */
	uint16_t bit_rate;	 /* Bit rate / 100 (total for all channels) */
	uint16_t channels;	 /* Number of channels */
	uint16_t frame_duration; /* Frame duration in ms * 100 */
	uint16_t rfu;		 /* Reserved for future use */
	uint16_t signal_len_lsb; /* Number of samples in signal, 16 LSB */
	uint16_t signal_len_msb; /* Number of samples in signal, 16 MSB (>> 16) */
} __packed;

struct lc3_playback_config {
	uint16_t lc3_frames_num;
	uint16_t lc3_frame_length_bytes;
};

enum audio_formats {
	SD_CARD_PLAYBACK_WAV,
	SD_CARD_PLAYBACK_LC3,
};

RING_BUF_DECLARE(m_ringbuf_audio_data_lc3, CONFIG_SD_CARD_PLAYBACK_RING_BUF_SIZE);
K_SEM_DEFINE(m_sem_ringbuf_space_available, 0, 1);
K_MUTEX_DEFINE(mtx_ringbuf);
K_SEM_DEFINE(m_sem_playback, 0, 1);
K_THREAD_STACK_DEFINE(sd_card_playback_thread_stack, CONFIG_SD_CARD_PLAYBACK_STACK_SIZE);

/* Thread */
static struct k_thread sd_card_playback_thread_data;
static k_tid_t sd_card_playback_thread_id;

/* Playback */
static bool sd_card_playback_active;
static char *playback_file_name;
static enum audio_formats playback_file_format;
static uint16_t pcm_frame_size;
static char playback_file_path[MAX_PATH_LEN] = "";
static struct lc3_header lc3_file_header;
static struct wav_header wav_file_header;
static struct lc3_playback_config lc3_playback_cfg;

static struct fs_file_t f_seg_read_entry;

static int sd_card_playback_ringbuf_read(uint8_t *buf, size_t *size)
{
	int ret;
	uint16_t read_size;

	ret = k_mutex_lock(&mtx_ringbuf, K_NO_WAIT);
	if (ret) {
		LOG_ERR("Unable to take mutex. Ret: %d", ret);
		return ret;
	}

	read_size = ring_buf_get(&m_ringbuf_audio_data_lc3, buf, *size);
	if (read_size != *size) {
		LOG_WRN("Read size (%d) not equal requested size (%d)", read_size, *size);
	}

	ret = k_mutex_unlock(&mtx_ringbuf);
	if (ret) {
		LOG_ERR("Mutex unlock err: %d", ret);
		return ret;
	}

	if (ring_buf_space_get(&m_ringbuf_audio_data_lc3) >= pcm_frame_size) {
		k_sem_give(&m_sem_ringbuf_space_available);
	}

	*size = read_size;

	return 0;
}

static int sd_card_playback_ringbuf_write(uint8_t *buffer, size_t numbytes)
{
	int ret;
	uint8_t *buf_ptr;

	/* The ringbuffer is read every 10 ms by audio datapath when SD card playback is enabled.
	 * Timeout value should therefore not be less than 10 ms
	 */
	ret = k_sem_take(&m_sem_ringbuf_space_available, K_MSEC(20));
	if (ret) {
		LOG_ERR("Sem take err: %d. Skipping frame", ret);
		return ret;
	}

	ret = k_mutex_lock(&mtx_ringbuf, K_NO_WAIT);
	if (ret) {
		LOG_ERR("Unable to take mutex. Ret: %d", ret);
		return ret;
	}

	numbytes = ring_buf_put_claim(&m_ringbuf_audio_data_lc3, &buf_ptr, numbytes);
	memcpy(buf_ptr, buffer, numbytes);
	ret = ring_buf_put_finish(&m_ringbuf_audio_data_lc3, numbytes);
	if (ret) {
		LOG_ERR("Ring buf put finish err: %d", ret);
		return ret;
	}

	ret = k_mutex_unlock(&mtx_ringbuf);
	if (ret) {
		LOG_ERR("Mutex unlock err: %d", ret);
		return ret;
	}

	return numbytes;
}

static int sd_card_playback_check_wav_header(struct wav_header wav_file_header)
{
	if (wav_file_header.audio_format != WAV_FORMAT_PCM) {
		LOG_ERR("This is not a PCM file");
		return -EPERM;
	}

	if (wav_file_header.num_channels != SW_CODEC_MONO) {
		LOG_ERR("This is not a MONO file");
		return -EPERM;
	}

	if (wav_file_header.sample_rate != WAV_SAMPLE_RATE_48K) {
		LOG_ERR("Unsupported sample rate: %d", wav_file_header.sample_rate);
		return -EPERM;
	}

	if (wav_file_header.bit_depth != CONFIG_AUDIO_BIT_DEPTH_BITS) {
		LOG_ERR("Bit depth in WAV file is not 16, but %d", wav_file_header.bit_depth);
		return -EPERM;
	}

	return 0;
}

static int sd_card_playback_play_wav(void)
{
	int ret;
	int ret_sd_card_close;
	size_t wav_read_size;
	size_t wav_file_header_size = sizeof(wav_file_header);
	int audio_length_bytes;
	int n_iter;

	ret = sd_card_open(playback_file_name, &f_seg_read_entry);
	if (ret) {
		LOG_ERR("Open SD card file err: %d", ret);
		return ret;
	}

	ret = sd_card_read((char *)&wav_file_header, &wav_file_header_size, &f_seg_read_entry);
	if (ret) {
		LOG_ERR("Read SD card err: %d", ret);
		ret_sd_card_close = sd_card_close(&f_seg_read_entry);
		if (ret_sd_card_close) {
			LOG_ERR("Close SD card err: %d", ret_sd_card_close);
			return ret_sd_card_close;
		}
		return ret;
	}

	/* Verify that there is support for playing the specified file */
	ret = sd_card_playback_check_wav_header(wav_file_header);
	if (ret) {
		LOG_ERR("WAV header check failed. Ret: %d", ret);
		ret_sd_card_close = sd_card_close(&f_seg_read_entry);
		if (ret_sd_card_close) {
			LOG_ERR("Close SD card err: %d", ret_sd_card_close);
			return ret_sd_card_close;
		}
		return ret;
	}

	/* Size corresponding to frame size of audio BT stream */
	pcm_frame_size = wav_file_header.byte_rate * FRAME_DURATION_MS / 1000;
	wav_read_size = pcm_frame_size;
	uint8_t pcm_mono_frame[wav_read_size];

	audio_length_bytes = wav_file_header.wav_size + 8 - sizeof(wav_file_header);
	n_iter = ceil((float)audio_length_bytes / (float)wav_read_size);

	for (int i = 0; i < n_iter; i++) {
		/* Read a chunk of audio data from file */
		ret = sd_card_read(pcm_mono_frame, &wav_read_size, &f_seg_read_entry);
		if (ret < 0) {
			LOG_ERR("SD card read err: %d", ret);
			break;
		}

		/* Write audio data to the ringbuffer */
		ret = sd_card_playback_ringbuf_write(pcm_mono_frame, wav_read_size);
		if (ret < 0) {
			LOG_ERR("Load ringbuf err: %d", ret);
			break;
		}

		if (i == 0) {
			/* Data can now be read from the ringbuffer */
			sd_card_playback_active = true;
		}
	}

	sd_card_playback_active = false;

	ret_sd_card_close = sd_card_close(&f_seg_read_entry);
	/* Check if something inside the for loop failed */
	if (ret < 0) {
		LOG_ERR("WAV playback err: %d", ret);
		return ret;
	}

	if (ret_sd_card_close) {
		LOG_ERR("SD card close err: %d", ret);
		return ret;
	}

	return 0;
}

static int sd_card_playback_play_lc3(void)
{
	int ret;
	int ret_sd_card_close;
	uint16_t pcm_mono_write_size;
	uint8_t decoder_num_ch = audio_system_decoder_num_ch_get();
	size_t lc3_file_header_size = sizeof(lc3_file_header);
	size_t lc3_frame_header_size = sizeof(uint16_t);

	ret = sd_card_open(playback_file_name, &f_seg_read_entry);
	if (ret) {
		LOG_ERR("Open SD card file err: %d", ret);
		return ret;
	}

	/* Read the file header */
	ret = sd_card_read((char *)&lc3_file_header, &lc3_file_header_size, &f_seg_read_entry);
	if (ret < 0) {
		LOG_ERR("Read SD card file err: %d", ret);
		ret_sd_card_close = sd_card_close(&f_seg_read_entry);
		if (ret_sd_card_close) {
			LOG_ERR("Close SD card err: %d", ret_sd_card_close);
			return ret_sd_card_close;
		}
		return ret;
	}

	pcm_frame_size = sizeof(uint16_t) * lc3_file_header.sample_rate *
			 lc3_file_header.frame_duration / 1000;
	lc3_playback_cfg.lc3_frames_num =
		sizeof(uint16_t) *
		((lc3_file_header.signal_len_msb << 16) + lc3_file_header.signal_len_lsb) /
		pcm_frame_size;

	uint8_t pcm_mono_frame[pcm_frame_size];

	for (int i = 0; i < lc3_playback_cfg.lc3_frames_num; i++) {
		/* Read the frame header */
		ret = sd_card_read((char *)&lc3_playback_cfg.lc3_frame_length_bytes,
				   &lc3_frame_header_size, &f_seg_read_entry);
		if (ret < 0) {
			LOG_ERR("SD card read err: %d", ret);
			break;
		}

		char lc3_frame[lc3_playback_cfg.lc3_frame_length_bytes];
		size_t lc3_fr_len = lc3_playback_cfg.lc3_frame_length_bytes;

		/* Read the audio data frame to be decoded */
		ret = sd_card_read(lc3_frame, &lc3_fr_len, &f_seg_read_entry);
		if (ret < 0) {
			LOG_ERR("SD card read err: %d", ret);
			break;
		}

		if (lc3_fr_len != lc3_playback_cfg.lc3_frame_length_bytes) {
			LOG_ERR("SD card read size (%d) not equal requested size (%d)", lc3_fr_len,
				lc3_playback_cfg.lc3_frame_length_bytes);
			ret = -EPERM;
			break;
		}

		/* Decode audio data frame */
		ret = sw_codec_lc3_dec_run(lc3_frame, lc3_playback_cfg.lc3_frame_length_bytes,
					   pcm_frame_size, decoder_num_ch - 1, pcm_mono_frame,
					   &pcm_mono_write_size, false);
		if (ret) {
			LOG_ERR("Decoding err: %d", ret);
			break;
		}

		ret = sd_card_playback_ringbuf_write((char *)pcm_mono_frame, pcm_mono_write_size);
		if (ret < 0) {
			LOG_ERR("Load ringbuf err: %d", ret);
			break;
		}

		if (i == 0) {
			sd_card_playback_active = true;
		}
	}

	sd_card_playback_active = false;
	ret_sd_card_close = sd_card_close(&f_seg_read_entry);
	if (ret < 0) {
		LOG_ERR("LC3 playback err: %d", ret);
		sd_card_playback_active = false;
		return ret;
	}

	if (ret_sd_card_close) {
		LOG_ERR("SD card close err: %d", ret);
		sd_card_playback_active = false;
		return ret;
	}

	return 0;
}

static void sd_card_playback_thread(void *arg1, void *arg2, void *arg3)
{
	int ret;

	while (1) {
		k_sem_take(&m_sem_playback, K_FOREVER);
		switch (playback_file_format) {
		case SD_CARD_PLAYBACK_WAV:
			ring_buf_reset(&m_ringbuf_audio_data_lc3);
			k_sem_reset(&m_sem_ringbuf_space_available);
			k_sem_give(&m_sem_ringbuf_space_available);
			ret = sd_card_playback_play_wav();
			if (ret) {
				LOG_ERR("Wav playback err: %d", ret);
			}

			break;

		case SD_CARD_PLAYBACK_LC3:
			ring_buf_reset(&m_ringbuf_audio_data_lc3);
			k_sem_reset(&m_sem_ringbuf_space_available);
			k_sem_give(&m_sem_ringbuf_space_available);
			ret = sd_card_playback_play_lc3();
			if (ret) {
				LOG_ERR("LC3 playback err: %d", ret);
			}

			break;
		}
	}
}

bool sd_card_playback_is_active(void)
{
	return sd_card_playback_active;
}

int sd_card_playback_wav(char *filename)
{
	if (!sw_codec_is_initialized()) {
		LOG_ERR("Sw codec not initialized");
		return -EACCES;
	}

	playback_file_format = SD_CARD_PLAYBACK_WAV;
	playback_file_name = filename;
	k_sem_give(&m_sem_playback);

	return 0;
}

int sd_card_playback_lc3(char *filename)
{
	if (!sw_codec_is_initialized()) {
		LOG_ERR("Sw codec not initialized");
		return -EACCES;
	}

	playback_file_format = SD_CARD_PLAYBACK_LC3;
	playback_file_name = filename;
	k_sem_give(&m_sem_playback);

	return 0;
}

int sd_card_playback_mix_with_stream(void *const pcm_a, size_t pcm_a_size)
{
	int ret;
	uint8_t pcm_b[pcm_frame_size];
	size_t read_size = pcm_frame_size;

	if (!sd_card_playback_active) {
		LOG_ERR("SD card playback is not active");
		return -EACCES;
	}

	ret = sd_card_playback_ringbuf_read(pcm_b, &read_size);
	if (ret) {
		LOG_ERR("Loading data into buffer err: %d", ret);
		return ret;
	}

	if (read_size > 0) {
		ret = pcm_mix(pcm_a, pcm_a_size, pcm_b, read_size, B_MONO_INTO_A_STEREO_L);
		if (ret) {
			LOG_ERR("Pcm mix err: %d", ret);
			return ret;
		}
	} else {
		LOG_WRN("Size read from ringbuffer: %d. Skipping", read_size);
	}

	return 0;
}

int sd_card_playback_init(void)
{
	int ret;

	sd_card_playback_thread_id = k_thread_create(
		&sd_card_playback_thread_data, sd_card_playback_thread_stack,
		CONFIG_SD_CARD_PLAYBACK_STACK_SIZE, (k_thread_entry_t)sd_card_playback_thread, NULL,
		NULL, NULL, K_PRIO_PREEMPT(CONFIG_SD_CARD_PLAYBACK_THREAD_PRIORITY), 0, K_NO_WAIT);
	ret = k_thread_name_set(sd_card_playback_thread_id, "sd_card_playback");
	if (ret) {
		return ret;
	}

	return 0;
}

/* Shell functions */
static int cmd_play_wav_file(const struct shell *shell, size_t argc, char **argv)
{
	int ret;

	char file_loc[MAX_PATH_LEN] = "";

	if (argc != 2) {
		shell_error(shell, "Incorrect number of args");
		return -EINVAL;
	}

	if ((strlen(playback_file_path) + strlen(argv[1])) >= ARRAY_SIZE(file_loc)) {
		return -ENOMEM;
	}

	strcat(file_loc, playback_file_path);
	strcat(file_loc, argv[1]);
	ret = sd_card_playback_wav(file_loc);
	if (ret) {
		shell_error(shell, "WAV playback err: %d", ret);
		return ret;
	}

	return 0;
}

static int cmd_play_lc3_file(const struct shell *shell, size_t argc, char **argv)
{
	int ret;

	if (argc != 2) {
		shell_error(shell, "Incorrect number of args");
		return -EINVAL;
	}

	char file_loc[MAX_PATH_LEN] = "";

	if ((strlen(playback_file_path) + strlen(argv[1])) >= ARRAY_SIZE(file_loc)) {
		return -ENOMEM;
	}

	strcat(file_loc, playback_file_path);
	strcat(file_loc, argv[1]);
	ret = sd_card_playback_lc3(file_loc);
	if (ret) {
		shell_error(shell, "LC3 playback err: %d", ret);
		return ret;
	}

	return 0;
}

static int cmd_change_dir(const struct shell *shell, size_t argc, char **argv)
{
	if (argc != 2) {
		shell_error(shell, "Incorrect number of args");
		return -EINVAL;
	}

	if (argv[1][0] == '/') {
		playback_file_path[0] = '\0';
		shell_print(shell, "Current directory: root");
	} else {
		if ((strlen(playback_file_path) + strlen(argv[1])) >=
		    ARRAY_SIZE(playback_file_path)) {
			return -ENOMEM;
		}

		strcat(playback_file_path, argv[1]);
		strcat(playback_file_path, "/");
		shell_print(shell, "Current directory: %s", playback_file_path);
	}

	return 0;
}

static int cmd_list_files(const struct shell *shell, size_t argc, char **argv)
{
	int ret;
	char buf[LIST_FILES_BUF_SIZE];
	size_t buf_size = LIST_FILES_BUF_SIZE;

	ret = sd_card_list_files(playback_file_path, buf, &buf_size);
	if (ret) {
		shell_error(shell, "List files err: %d", ret);
		return ret;
	}

	shell_print(shell, "%s", buf);

	return 0;
}

SHELL_STATIC_SUBCMD_SET_CREATE(
	sd_card_playback_cmd,
	SHELL_COND_CMD(CONFIG_SHELL, play_lc3, NULL, "Play LC3 file", cmd_play_lc3_file),
	SHELL_COND_CMD(CONFIG_SHELL, play_wav, NULL, "Play WAV file", cmd_play_wav_file),
	SHELL_COND_CMD(CONFIG_SHELL, cd, NULL, "Change directory", cmd_change_dir),
	SHELL_COND_CMD(CONFIG_SHELL, list_files, NULL, "List files", cmd_list_files),
	SHELL_SUBCMD_SET_END);

SHELL_CMD_REGISTER(sd_card_playback, &sd_card_playback_cmd, "Play audio files from SD card", NULL);


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/modules/sd_card.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _SD_CARD_H_
#define _SD_CARD_H_

#include <stddef.h>
#include <zephyr/fs/fs.h>

/**
 * @brief	Print out the contents under SD card root path and write the content to buffer.
 *
 * @param[in]		path		Path of the folder which is going to be listed.
 *					If assigned path is null, then listing the contents under
 *					root. If assigned path doesn't exist, an error will be
 *					returned.
 * @param[out]		buf		Buffer where data is written. If set to NULL, it will be
 *					ignored.
 * @param[in, out]	buf_size	Buffer size.
 *
 * @retval	0 on success.
 * @retval	-EPERM SD card operation is ongoing somewhere else.
 * @retval	-ENODEV SD init failed. SD card likely not inserted.
 * @retval	-EINVAL Failed to append to buffer.
 * @retval	-FR_INVALID_NAME Path is too long.
 * @retval	Otherwise, error from underlying drivers.
 */
int sd_card_list_files(char const *const path, char *buf, size_t *buf_size);

/**
 * @brief	Write data from buffer into the file.
 *
 * @note	If the file already exists, data will be appended to the end of the file.
 *
 * @param[in]		filename	Name of the target file for writing, the default
 *					location is the root directoy of SD card, accept
					absolute path under root of SD card.
 * @param[in]		data		which is going to be written into the file.
 * @param[in, out]	size		Pointer to the number of bytes which is going to be written.
 *					The actual written size will be returned.
 *
 * @retval	0 on success.
 * @retval	-EPERM SD card operation is ongoing somewhere else.
 * @retval	-ENODEV SD init failed. SD card likely not inserted.
 * @retval	Otherwise, error from underlying drivers.
 */
int sd_card_open_write_close(char const *const filename, char const *const data, size_t *size);

/**
 * @brief	Read data from file into the buffer.
 *
 * @param[in]		filename	Name of the target file for reading, the default location is
 *					the root directoy of SD card, accept absolute path under
 *					root of SD card.
 * @param[out]		buf		Pointer to the buffer to write the read data into.
 * @param[in, out]	size		Pointer to the number of bytes which wait to be read from
 *					the file. The actual read size will be returned. If the
 *					actual read size is 0, there will be a warning message which
					indicates that the file is empty.
 *
 * @retval	0 on success.
 * @retval	-EPERM SD card operation is ongoing somewhere else.
 * @retval	-ENODEV SD init failed. SD card likely not inserted.
 * @retval	Otherwise, error from underlying drivers.
 */
int sd_card_open_read_close(char const *const filename, char *const buf, size_t *size);

/**
 * @brief	Open file on SD card.
 *
 * @param[in]		filename		Name of file to open. Default
 *						location is the root directoy of SD card.
 *						Absolute path under root of SD card is accepted.
 * @param[in, out]	f_seg_read_entry	Pointer to a file object.
 *						The pointer gets initialized and ready for use.
 *
 *
 * @retval	0 on success.
 * @retval	-EPERM SD card operation is ongoing somewhere else.
 * @retval	-ENODEV SD init failed. SD likely not inserted.
 * @retval	Otherwise, error from underlying drivers.
 */
int sd_card_open(char const *const filename, struct fs_file_t *f_seg_read_entry);

/**
 * @brief	Read segment on the open file on the SD card.
 *
 * @param[out]		buf			Pointer to the buffer to write the read data into.
 * @param[in, out]	size			Number of bytes to be read from file.
 *						The actual read size will be returned.
 *						If the actual read size is 0, there will be a
 *						warning message which indicates that the file is
 *						empty.
 * @param[in, out]	f_seg_read_entry	Pointer to a file object. After call to this
 *						function, the pointer gets updated and can be used
 *						as entry in next function call.
 *
 * @retval	0 on success.
 * @retval	-EPERM SD card operation is not ongoing.
 * @retval	-ENODEV SD init failed. SD likely not inserted.
 * @retval	Otherwise, error from underlying drivers.
 */
int sd_card_read(char *buf, size_t *size, struct fs_file_t *f_seg_read_entry);

/**
 * @brief	Close the file opened by the sd_card_segment_read_open function.
 *
 * @param[in, out]	f_seg_read_entry	Pointer to a file object. After call to this
 *						function, the pointer is reset and can be used for
 *						another file.
 *
 *
 * @retval	0 on success.
 * @retval	-EPERM SD card operation is not ongoing.
 * @retval	-EBUSY Segment read operation has not started.
 * @retval	Otherwise, error from underlying drivers.
 */
int sd_card_close(struct fs_file_t *f_seg_read_entry);

/**
 * @brief	Initialize the SD card interface and print out SD card details.
 *
 * @retval	0 on success.
 * @retval	-ENODEV SD init failed. SD card likely not inserted.
 * @retval	Otherwise, error from underlying drivers.
 */
int sd_card_init(void);

#endif /* _SD_CARD_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/modules/button_handler.h
/*
 * Copyright (c) 2022 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _BUTTON_HANDLER_H_
#define _BUTTON_HANDLER_H_

#include <stdint.h>
#include <zephyr/drivers/gpio.h>

struct btn_config {
	const char *btn_name;
	uint8_t btn_pin;
	uint32_t btn_cfg_mask;
};

/** @brief Initialize button handler, with buttons defined in button_assignments.h.
 *
 * @note This function may only be called once - there is no reinitialize.
 *
 * @return 0 if successful.
 * @return -ENODEV	gpio driver not found
 */
int button_handler_init(void);

/** @brief Check button state.
 *
 * @param[in] button_pin Button pin
 * @param[out] button_pressed Button state. True if currently pressed, false otherwise
 *
 * @return 0 if success, an error code otherwise.
 */
int button_pressed(gpio_pin_t button_pin, bool *button_pressed);

#endif /* _BUTTON_HANDLER_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/modules/board.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef __BOARD_H__
#define __BOARD_H__

#include <zephyr/kernel.h>

/* Voltage divider PCA10121 board versions.
 * The defines give what value the ADC will read back.
 * This is determined by the on-board voltage divider.
 */

struct board_version {
	char name[10];
	uint32_t mask;
	uint32_t adc_reg_val;
};

#define BOARD_PCA10121_0_0_0_MSK (BIT(0))
#define BOARD_PCA10121_0_6_0_MSK (BIT(1))
#define BOARD_PCA10121_0_7_0_MSK (BIT(2))
#define BOARD_PCA10121_0_7_1_MSK (BIT(3))
#define BOARD_PCA10121_0_8_0_MSK (BIT(4))
#define BOARD_PCA10121_0_8_1_MSK (BIT(5))
#define BOARD_PCA10121_0_8_2_MSK (BIT(6))
#define BOARD_PCA10121_0_9_0_MSK (BIT(7))
#define BOARD_PCA10121_0_10_0_MSK (BIT(8))
#define BOARD_PCA10121_1_0_0_MSK (BIT(9))
#define BOARD_PCA10121_1_1_0_MSK (BIT(10))
#define BOARD_PCA10121_1_2_0_MSK (BIT(11))

static const struct board_version BOARD_VERSION_ARR[] = {
	{ "0.0.0", BOARD_PCA10121_0_0_0_MSK, INT_MIN },
	{ "0.6.0", BOARD_PCA10121_0_6_0_MSK, 61 },
	{ "0.7.0", BOARD_PCA10121_0_7_0_MSK, 102 },
	{ "0.7.1", BOARD_PCA10121_0_7_1_MSK, 303 },
	{ "0.8.0", BOARD_PCA10121_0_8_0_MSK, 534 },
	{ "0.8.1", BOARD_PCA10121_0_8_1_MSK, 780 },
	{ "0.8.2", BOARD_PCA10121_0_8_2_MSK, 1018 },
	{ "0.9.0", BOARD_PCA10121_0_9_0_MSK, 1260 },
	/* Lower value used on 0.10.0 due to high ohm divider */
	{ "0.10.0", BOARD_PCA10121_0_10_0_MSK, 1480 },
	{ "1.0.0", BOARD_PCA10121_1_0_0_MSK, 1743 },
	{ "1.1.0", BOARD_PCA10121_1_1_0_MSK, 1982 },
	{ "1.2.0", BOARD_PCA10121_1_2_0_MSK, 2219 },
};

#define BOARD_VERSION_VALID_MSK                                                                    \
	(BOARD_PCA10121_0_8_0_MSK | BOARD_PCA10121_0_8_1_MSK | BOARD_PCA10121_0_8_2_MSK |          \
	 BOARD_PCA10121_0_9_0_MSK | BOARD_PCA10121_0_10_0_MSK | BOARD_PCA10121_1_0_0_MSK |         \
	 BOARD_PCA10121_1_1_0_MSK | BOARD_PCA10121_1_2_0_MSK)

#define BOARD_VERSION_VALID_MSK_SD_CARD                                                            \
	(BOARD_PCA10121_0_8_0_MSK | BOARD_PCA10121_0_8_1_MSK | BOARD_PCA10121_0_8_2_MSK |          \
	 BOARD_PCA10121_0_9_0_MSK | BOARD_PCA10121_0_10_0_MSK | BOARD_PCA10121_1_0_0_MSK |         \
	 BOARD_PCA10121_1_1_0_MSK | BOARD_PCA10121_1_2_0_MSK)

#endif


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/modules/button_assignments.h
/*
 * Copyright (c) 2022 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

/** @file
 *  @brief Button assignments
 *
 * Button mappings are listed here.
 *
 */

#ifndef _BUTTON_ASSIGNMENTS_H_
#define _BUTTON_ASSIGNMENTS_H_

#include <zephyr/drivers/gpio.h>

/** @brief List of buttons and associated metadata
 */
enum button_pin_names {
	BUTTON_VOLUME_DOWN = DT_GPIO_PIN(DT_ALIAS(sw0), gpios),
	BUTTON_VOLUME_UP = DT_GPIO_PIN(DT_ALIAS(sw1), gpios),
	BUTTON_PLAY_PAUSE = DT_GPIO_PIN(DT_ALIAS(sw2), gpios),
	BUTTON_4 = DT_GPIO_PIN(DT_ALIAS(sw3), gpios),
	BUTTON_5 = DT_GPIO_PIN(DT_ALIAS(sw4), gpios),
};

#endif /* _BUTTON_ASSIGNMENTS_H_ */


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/modules/audio_usb.c
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "audio_usb.h"

#include <zephyr/kernel.h>
#include <zephyr/usb/usb_device.h>
#include <zephyr/usb/class/usb_audio.h>

#include "macros_common.h"
#include "data_fifo.h"

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(audio_usb, CONFIG_MODULE_AUDIO_USB_LOG_LEVEL);

#define USB_FRAME_SIZE_STEREO                                                                      \
	(((CONFIG_AUDIO_SAMPLE_RATE_HZ * CONFIG_AUDIO_BIT_DEPTH_OCTETS) / 1000) * 2)

static struct data_fifo *fifo_tx;
static struct data_fifo *fifo_rx;

NET_BUF_POOL_FIXED_DEFINE(pool_out, CONFIG_FIFO_FRAME_SPLIT_NUM, USB_FRAME_SIZE_STEREO, 8,
			  net_buf_destroy);

static uint32_t rx_num_overruns;
static bool rx_first_data;
static bool tx_first_data;

#if (CONFIG_STREAM_BIDIRECTIONAL)
static uint32_t tx_num_underruns;

static void data_write(const struct device *dev)
{
	int ret;

	if (fifo_tx == NULL) {
		return;
	}

	void *data_out;
	size_t data_out_size;
	struct net_buf *buf_out;

	buf_out = net_buf_alloc(&pool_out, K_NO_WAIT);

	ret = data_fifo_pointer_last_filled_get(fifo_tx, &data_out, &data_out_size, K_NO_WAIT);
	if (ret) {
		tx_num_underruns++;
		if ((tx_num_underruns % 100) == 1) {
			LOG_WRN("USB TX underrun. Num: %d", tx_num_underruns);
		}
		net_buf_unref(buf_out);

		return;
	}

	memcpy(buf_out->data, data_out, data_out_size);
	data_fifo_block_free(fifo_tx, data_out);

	if (data_out_size == usb_audio_get_in_frame_size(dev)) {
		ret = usb_audio_send(dev, buf_out, data_out_size);
		if (ret) {
			LOG_WRN("USB TX failed, ret: %d", ret);
			net_buf_unref(buf_out);
		}

	} else {
		LOG_WRN("Wrong size write: %d", data_out_size);
	}

	if (!tx_first_data) {
		LOG_INF("USB TX first data sent.");
		tx_first_data = true;
	}
}
#endif /* (CONFIG_STREAM_BIDIRECTIONAL) */

static void data_received(const struct device *dev, struct net_buf *buffer, size_t size)
{
	int ret;
	void *data_in;

	if (fifo_rx == NULL) {
		/* Throwing away data */
		net_buf_unref(buffer);
		return;
	}

	if (buffer == NULL || size == 0 || buffer->data == NULL) {
		/* This should never happen */
		ERR_CHK(-EINVAL);
	}

	/* Receive data from USB */
	if (size != USB_FRAME_SIZE_STEREO) {
		LOG_WRN("Wrong length: %d", size);
		net_buf_unref(buffer);
		return;
	}

	ret = data_fifo_pointer_first_vacant_get(fifo_rx, &data_in, K_NO_WAIT);

	/* RX FIFO can fill up due to retransmissions or disconnect */
	if (ret == -ENOMEM) {
		void *temp;
		size_t temp_size;

		rx_num_overruns++;
		if ((rx_num_overruns % 100) == 1) {
			LOG_WRN("USB RX overrun. Num: %d", rx_num_overruns);
		}

		ret = data_fifo_pointer_last_filled_get(fifo_rx, &temp, &temp_size, K_NO_WAIT);
		ERR_CHK(ret);

		data_fifo_block_free(fifo_rx, temp);

		ret = data_fifo_pointer_first_vacant_get(fifo_rx, &data_in, K_NO_WAIT);
	}

	ERR_CHK_MSG(ret, "RX failed to get block");

	memcpy(data_in, buffer->data, size);

	ret = data_fifo_block_lock(fifo_rx, &data_in, size);
	ERR_CHK_MSG(ret, "Failed to lock block");

	net_buf_unref(buffer);

	if (!rx_first_data) {
		LOG_INF("USB RX first data received.");
		rx_first_data = true;
	}
}

static void feature_update(const struct device *dev, const struct usb_audio_fu_evt *evt)
{
	LOG_DBG("Control selector %d for channel %d updated", evt->cs, evt->channel);
	switch (evt->cs) {
	case USB_AUDIO_FU_MUTE_CONTROL:
		/* Fall through */
	default:
		break;
	}
}

static const struct usb_audio_ops ops = {
	.data_received_cb = data_received,
	.feature_update_cb = feature_update,
#if (CONFIG_STREAM_BIDIRECTIONAL)
	.data_request_cb = data_write,
#endif /* (CONFIG_STREAM_BIDIRECTIONAL) */
};

int audio_usb_start(struct data_fifo *fifo_tx_in, struct data_fifo *fifo_rx_in)
{
	if (fifo_tx_in == NULL || fifo_rx_in == NULL) {
		return -EINVAL;
	}

	fifo_tx = fifo_tx_in;
	fifo_rx = fifo_rx_in;

	return 0;
}

void audio_usb_stop(void)
{
	rx_first_data = false;
	tx_first_data = false;
	fifo_tx = NULL;
	fifo_rx = NULL;
}

int audio_usb_disable(void)
{
	int ret;

	audio_usb_stop();

	ret = usb_disable();
	if (ret) {
		LOG_ERR("Failed to disable USB");
		return ret;
	}

	return 0;
}

int audio_usb_init(void)
{
	int ret;
	const struct device *hs_dev = DEVICE_DT_GET(DT_NODELABEL(hs_0));

	if (!device_is_ready(hs_dev)) {
		LOG_ERR("USB Headset Device not ready");
		return -EIO;
	}

	usb_audio_register(hs_dev, &ops);

	ret = usb_enable(NULL);
	if (ret) {
		LOG_ERR("Failed to enable USB");
		return ret;
	}

	LOG_INF("Ready for USB host to send/receive.");

	return 0;
}


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/modules/audio_sync_timer_rtc.c
/*
 * Copyright (c) 2023 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include "audio_sync_timer.h"

#include <zephyr/kernel.h>
#include <zephyr/init.h>
#include <nrfx_dppi.h>
#include <nrfx_i2s.h>
#include <nrfx_ipc.h>
#include <nrfx_rtc.h>
#include <nrfx_timer.h>
#include <nrfx_egu.h>


#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(audio_sync_timer, CONFIG_AUDIO_SYNC_TIMER_LOG_LEVEL);

#define AUDIO_SYNC_TIMER_NET_APP_IPC_EVT_CHANNEL                4
#define AUDIO_SYNC_TIMER_NET_APP_IPC_EVT                        NRF_IPC_EVENT_RECEIVE_4

#define AUDIO_SYNC_HF_TIMER_INSTANCE_NUMBER                     1

#define AUDIO_SYNC_HF_TIMER_I2S_FRAME_START_EVT_CAPTURE_CHANNEL 0
#define AUDIO_SYNC_HF_TIMER_I2S_FRAME_START_EVT_CAPTURE         NRF_TIMER_TASK_CAPTURE0
#define AUDIO_SYNC_HF_TIMER_CURR_TIME_CAPTURE_CHANNEL           1
#define AUDIO_SYNC_HF_TIMER_CURR_TIME_CAPTURE                   NRF_TIMER_TASK_CAPTURE1

static const nrfx_timer_t audio_sync_hf_timer_instance =
	NRFX_TIMER_INSTANCE(AUDIO_SYNC_HF_TIMER_INSTANCE_NUMBER);

static uint8_t dppi_channel_i2s_frame_start;

#define AUDIO_SYNC_LF_TIMER_INSTANCE_NUMBER                     0

#define AUDIO_SYNC_LF_TIMER_I2S_FRAME_START_EVT_CAPTURE_CHANNEL 0
#define AUDIO_SYNC_LF_TIMER_I2S_FRAME_START_EVT_CAPTURE         NRF_RTC_TASK_CAPTURE_0
#define AUDIO_SYNC_LF_TIMER_CURR_TIME_CAPTURE_CHANNEL           1
#define AUDIO_SYNC_LF_TIMER_CURR_TIME_CAPTURE                   NRF_RTC_TASK_CAPTURE_1

static uint8_t dppi_channel_curr_time_capture;

static const nrfx_rtc_config_t rtc_cfg = NRFX_RTC_DEFAULT_CONFIG;

static const nrfx_rtc_t audio_sync_lf_timer_instance =
	NRFX_RTC_INSTANCE(AUDIO_SYNC_LF_TIMER_INSTANCE_NUMBER);

static uint8_t dppi_channel_timer_sync_with_rtc;
static uint8_t dppi_channel_rtc_start;
static volatile uint32_t num_rtc_overflows;

static nrfx_timer_config_t cfg = {.frequency = NRFX_MHZ_TO_HZ(1UL),
				  .mode = NRF_TIMER_MODE_TIMER,
				  .bit_width = NRF_TIMER_BIT_WIDTH_32,
				  .interrupt_priority = NRFX_TIMER_DEFAULT_CONFIG_IRQ_PRIORITY,
				  .p_context = NULL};

static uint32_t timestamp_from_rtc_and_timer_get(uint32_t ticks, uint32_t remainder_us)
{
	const uint64_t rtc_ticks_in_femto_units = 30517578125UL;
	const uint32_t rtc_overflow_time_us = 512000000UL;

	return ((ticks * rtc_ticks_in_femto_units) / 1000000000UL) +
		(num_rtc_overflows * rtc_overflow_time_us) +
		remainder_us;
}

uint32_t audio_sync_timer_capture(void)
{
	/* Ensure that the follow product specification statement is handled:
	 *
	 * There is a delay of 6 PCLK16M periods from when the TASKS_CAPTURE[n] is triggered
	 * until the corresponding CC[n] register is updated.
	 *
	 * Lets have a stale value in the CC[n] register and compare that it is different when
	 * we capture using DPPI.
	 *
	 * We ensure it is stale by setting it as the previous tick relative to current
	 * counter value.
	 */
	uint32_t tick_stale = nrf_rtc_counter_get(audio_sync_lf_timer_instance.p_reg);

	/* Set a stale value in the CC[n] register */
	tick_stale--;
	nrf_rtc_cc_set(audio_sync_lf_timer_instance.p_reg,
		       AUDIO_SYNC_LF_TIMER_CURR_TIME_CAPTURE_CHANNEL, tick_stale);

	/* Trigger EGU task to capture RTC and TIMER value */
	nrf_egu_task_trigger(NRF_EGU0, NRF_EGU_TASK_TRIGGER0);

	/* Read captured RTC value */
	uint32_t tick = nrf_rtc_cc_get(audio_sync_lf_timer_instance.p_reg,
				       AUDIO_SYNC_LF_TIMER_CURR_TIME_CAPTURE_CHANNEL);

	/* If required, wait until CC[n] register is updated */
	while (tick == tick_stale) {
		tick = nrf_rtc_cc_get(audio_sync_lf_timer_instance.p_reg,
				      AUDIO_SYNC_LF_TIMER_CURR_TIME_CAPTURE_CHANNEL);
	}

	/* Read captured TIMER value */
	uint32_t remainder_us = nrf_timer_cc_get(NRF_TIMER1,
						 AUDIO_SYNC_HF_TIMER_CURR_TIME_CAPTURE_CHANNEL);

	return timestamp_from_rtc_and_timer_get(tick, remainder_us);
}

uint32_t audio_sync_timer_capture_get(void)
{
	uint32_t remainder_us;
	uint32_t tick;

	tick = nrf_rtc_cc_get(audio_sync_lf_timer_instance.p_reg,
			      AUDIO_SYNC_LF_TIMER_I2S_FRAME_START_EVT_CAPTURE_CHANNEL);
	remainder_us = nrf_timer_cc_get(NRF_TIMER1,
					AUDIO_SYNC_HF_TIMER_I2S_FRAME_START_EVT_CAPTURE_CHANNEL);

	return timestamp_from_rtc_and_timer_get(tick, remainder_us);
}

static void unused_timer_isr_handler(nrf_timer_event_t event_type, void *ctx)
{
	ARG_UNUSED(event_type);
	ARG_UNUSED(ctx);
}

static void rtc_isr_handler(nrfx_rtc_int_type_t int_type)
{
	if (int_type == NRFX_RTC_INT_OVERFLOW) {
		num_rtc_overflows++;
	}
}

/**
 * @brief Initialize audio sync timer
 *
 * @note The audio sync timers is replicating the controller's clock.
 * The controller starts or clears the sync timer using a PPI signal
 * sent from the controller. This makes the two clocks synchronized.
 *
 * @return 0 if successful, error otherwise
 */
static int audio_sync_timer_init(void)
{
	nrfx_err_t ret;

	ret = nrfx_timer_init(&audio_sync_hf_timer_instance, &cfg, unused_timer_isr_handler);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx timer init error: %d", ret);
		return -ENODEV;
	}

	ret = nrfx_rtc_init(&audio_sync_lf_timer_instance, &rtc_cfg, rtc_isr_handler);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx rtc init error: %d", ret);
		return -ENODEV;
	}

	IRQ_CONNECT(RTC0_IRQn, IRQ_PRIO_LOWEST, nrfx_rtc_0_irq_handler, NULL, 0);
	nrfx_rtc_overflow_enable(&audio_sync_lf_timer_instance, true);

	/* Initialize capturing of I2S frame start event timestamps */
	ret = nrfx_dppi_channel_alloc(&dppi_channel_i2s_frame_start);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx DPPI channel alloc error (I2S frame start): %d", ret);
		return -ENOMEM;
	}

	nrf_timer_subscribe_set(audio_sync_hf_timer_instance.p_reg,
				AUDIO_SYNC_HF_TIMER_I2S_FRAME_START_EVT_CAPTURE,
				dppi_channel_i2s_frame_start);

	/* Initialize capturing of I2S frame start event timestamps at the RTC as well. */
	nrf_rtc_subscribe_set(audio_sync_lf_timer_instance.p_reg,
			      AUDIO_SYNC_LF_TIMER_I2S_FRAME_START_EVT_CAPTURE,
			      dppi_channel_i2s_frame_start);

	nrf_i2s_publish_set(NRF_I2S0, NRF_I2S_EVENT_FRAMESTART, dppi_channel_i2s_frame_start);
	ret = nrfx_dppi_channel_enable(dppi_channel_i2s_frame_start);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx DPPI channel enable error (I2S frame start): %d", ret);
		return -EIO;
	}

	/* Initialize capturing of current timestamps */
	ret = nrfx_dppi_channel_alloc(&dppi_channel_curr_time_capture);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx DPPI channel alloc error (I2S frame start) - Return value: %d", ret);
		return -ENOMEM;
	}

	nrf_rtc_subscribe_set(audio_sync_lf_timer_instance.p_reg,
			      AUDIO_SYNC_LF_TIMER_CURR_TIME_CAPTURE,
			      dppi_channel_curr_time_capture);

	nrf_timer_subscribe_set(audio_sync_hf_timer_instance.p_reg,
				AUDIO_SYNC_HF_TIMER_CURR_TIME_CAPTURE,
				dppi_channel_curr_time_capture);

	nrf_egu_publish_set(NRF_EGU0, NRF_EGU_EVENT_TRIGGERED0, dppi_channel_curr_time_capture);

	ret = nrfx_dppi_channel_enable(dppi_channel_curr_time_capture);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx DPPI channel enable error (I2S frame start) - Return value: %d", ret);
		return -EIO;
	}

	/* Initialize functionality for synchronization between APP and NET core */
	ret = nrfx_dppi_channel_alloc(&dppi_channel_rtc_start);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx DPPI channel alloc error (timer clear): %d", ret);
		return -ENOMEM;
	}

	nrf_rtc_subscribe_set(audio_sync_lf_timer_instance.p_reg, NRF_RTC_TASK_START,
			      dppi_channel_rtc_start);
	nrf_timer_subscribe_set(audio_sync_hf_timer_instance.p_reg, NRF_TIMER_TASK_START,
				dppi_channel_rtc_start);

	nrf_ipc_receive_config_set(NRF_IPC, AUDIO_SYNC_TIMER_NET_APP_IPC_EVT_CHANNEL,
				   NRF_IPC_CHANNEL_4);
	nrf_ipc_publish_set(NRF_IPC, AUDIO_SYNC_TIMER_NET_APP_IPC_EVT, dppi_channel_rtc_start);

	ret = nrfx_dppi_channel_enable(dppi_channel_rtc_start);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx DPPI channel enable error (timer clear): %d", ret);
		return -EIO;
	}

	/* Initialize functionality for synchronization between RTC and TIMER */
	ret = nrfx_dppi_channel_alloc(&dppi_channel_timer_sync_with_rtc);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx DPPI channel alloc error (timer clear): %d", ret);
		return -ENOMEM;
	}

	nrf_rtc_publish_set(audio_sync_lf_timer_instance.p_reg, NRF_RTC_EVENT_TICK,
			    dppi_channel_timer_sync_with_rtc);
	nrf_timer_subscribe_set(audio_sync_hf_timer_instance.p_reg, NRF_TIMER_TASK_CLEAR,
				dppi_channel_timer_sync_with_rtc);

	nrfx_rtc_tick_enable(&audio_sync_lf_timer_instance, false);

	ret = nrfx_dppi_channel_enable(dppi_channel_timer_sync_with_rtc);
	if (ret - NRFX_ERROR_BASE_NUM) {
		LOG_ERR("nrfx DPPI channel enable error (timer clear): %d", ret);
		return -EIO;
	}

	LOG_DBG("Audio sync timer initialized");

	return 0;
}

SYS_INIT(audio_sync_timer_init, POST_KERNEL, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);


// File: /Users/devyn/splitr/nrf5340_audio_nordic_ex/src/modules/hw_codec.h
/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#ifndef _HW_CODEC_H_
#define _HW_CODEC_H_

#include <stdint.h>

/**
 * @brief  Set volume on HW_CODEC
 *
 * @details Also unmutes the volume on HW_CODEC
 *
 * @param  set_val  Set the volume to a specific value.
 *                  This range of the value is between 0 to 128.
 *
 * @return 0 if successful, error otherwise
 */
int hw_codec_volume_set(uint8_t set_val);

/**
 * @brief  Adjust volume on HW_CODEC
 *
 * @details Also unmute the volume on HW_CODEC
 *
 * @param  adjustment  The adjustment in dB, can be negative or positive.
 *			If the value 0 is used, the previous known value will be
 *			written, default value will be used if no previous value
 *			exists
 *
 * @return 0 if successful, error otherwise
 */
int hw_codec_volume_adjust(int8_t adjustment);

/**
 * @brief Decrease output volume on HW_CODEC by 3 dB
 *
 * @details Also unmute the volume on HW_CODEC
 *
 * @return 0 if successful, error otherwise
 */
int hw_codec_volume_decrease(void);

/**
 * @brief Increase output volume on HW_CODEC by 3 dB
 *
 * @details Also unmute the volume on HW_CODEC
 *
 * @return 0 if successful, error otherwise
 */
int hw_codec_volume_increase(void);

/**
 * @brief  Mute volume on HW_CODEC
 *
 * @return 0 if successful, error otherwise
 */
int hw_codec_volume_mute(void);

/**
 * @brief  Unmute volume on HW_CODEC
 *
 * @return 0 if successful, error otherwise
 */
int hw_codec_volume_unmute(void);

/**
 * @brief Enable relevant settings in HW_CODEC to
 *        send and receive PCM data over I2S
 *
 * @note  FLL1 must be toggled after I2S has started to enable HW_CODEC
 *
 * @return 0 if successful, error otherwise
 */
int hw_codec_default_conf_enable(void);

/**
 * @brief Reset HW_CODEC
 *
 * @note  This will first disable output, then do a soft reset
 *
 * @return 0 if successful, error otherwise
 */
int hw_codec_soft_reset(void);

/**
 * @brief Initialize HW_CODEC
 *
 * @return 0 if successful, error otherwise
 */
int hw_codec_init(void);

#endif /* _HW_CODEC_H_ */


// File: /Users/devyn/splitr/esp32_wifi_ap_api/sdkconfig
#
# Automatically generated file. DO NOT EDIT.
# Espressif IoT Development Framework (ESP-IDF) 5.2.5 Project Configuration
#
CONFIG_SOC_MPU_MIN_REGION_SIZE=0x20000000
CONFIG_SOC_MPU_REGIONS_MAX_NUM=8
CONFIG_SOC_ADC_SUPPORTED=y
CONFIG_SOC_UART_SUPPORTED=y
CONFIG_SOC_PCNT_SUPPORTED=y
CONFIG_SOC_WIFI_SUPPORTED=y
CONFIG_SOC_TWAI_SUPPORTED=y
CONFIG_SOC_GDMA_SUPPORTED=y
CONFIG_SOC_AHB_GDMA_SUPPORTED=y
CONFIG_SOC_GPTIMER_SUPPORTED=y
CONFIG_SOC_LCDCAM_SUPPORTED=y
CONFIG_SOC_MCPWM_SUPPORTED=y
CONFIG_SOC_DEDICATED_GPIO_SUPPORTED=y
CONFIG_SOC_CACHE_SUPPORT_WRAP=y
CONFIG_SOC_ULP_SUPPORTED=y
CONFIG_SOC_ULP_FSM_SUPPORTED=y
CONFIG_SOC_RISCV_COPROC_SUPPORTED=y
CONFIG_SOC_BT_SUPPORTED=y
CONFIG_SOC_USB_OTG_SUPPORTED=y
CONFIG_SOC_USB_SERIAL_JTAG_SUPPORTED=y
CONFIG_SOC_CCOMP_TIMER_SUPPORTED=y
CONFIG_SOC_ASYNC_MEMCPY_SUPPORTED=y
CONFIG_SOC_SUPPORTS_SECURE_DL_MODE=y
CONFIG_SOC_EFUSE_KEY_PURPOSE_FIELD=y
CONFIG_SOC_EFUSE_SUPPORTED=y
CONFIG_SOC_SDMMC_HOST_SUPPORTED=y
CONFIG_SOC_RTC_FAST_MEM_SUPPORTED=y
CONFIG_SOC_RTC_SLOW_MEM_SUPPORTED=y
CONFIG_SOC_RTC_MEM_SUPPORTED=y
CONFIG_SOC_PSRAM_DMA_CAPABLE=y
CONFIG_SOC_XT_WDT_SUPPORTED=y
CONFIG_SOC_I2S_SUPPORTED=y
CONFIG_SOC_RMT_SUPPORTED=y
CONFIG_SOC_SDM_SUPPORTED=y
CONFIG_SOC_GPSPI_SUPPORTED=y
CONFIG_SOC_LEDC_SUPPORTED=y
CONFIG_SOC_I2C_SUPPORTED=y
CONFIG_SOC_SYSTIMER_SUPPORTED=y
CONFIG_SOC_SUPPORT_COEXISTENCE=y
CONFIG_SOC_TEMP_SENSOR_SUPPORTED=y
CONFIG_SOC_AES_SUPPORTED=y
CONFIG_SOC_MPI_SUPPORTED=y
CONFIG_SOC_SHA_SUPPORTED=y
CONFIG_SOC_HMAC_SUPPORTED=y
CONFIG_SOC_DIG_SIGN_SUPPORTED=y
CONFIG_SOC_FLASH_ENC_SUPPORTED=y
CONFIG_SOC_SECURE_BOOT_SUPPORTED=y
CONFIG_SOC_MEMPROT_SUPPORTED=y
CONFIG_SOC_TOUCH_SENSOR_SUPPORTED=y
CONFIG_SOC_BOD_SUPPORTED=y
CONFIG_SOC_CLK_TREE_SUPPORTED=y
CONFIG_SOC_MPU_SUPPORTED=y
CONFIG_SOC_WDT_SUPPORTED=y
CONFIG_SOC_SPI_FLASH_SUPPORTED=y
CONFIG_SOC_XTAL_SUPPORT_40M=y
CONFIG_SOC_APPCPU_HAS_CLOCK_GATING_BUG=y
CONFIG_SOC_ADC_RTC_CTRL_SUPPORTED=y
CONFIG_SOC_ADC_DIG_CTRL_SUPPORTED=y
CONFIG_SOC_ADC_ARBITER_SUPPORTED=y
CONFIG_SOC_ADC_DIG_IIR_FILTER_SUPPORTED=y
CONFIG_SOC_ADC_MONITOR_SUPPORTED=y
CONFIG_SOC_ADC_DMA_SUPPORTED=y
CONFIG_SOC_ADC_PERIPH_NUM=2
CONFIG_SOC_ADC_MAX_CHANNEL_NUM=10
CONFIG_SOC_ADC_ATTEN_NUM=4
CONFIG_SOC_ADC_DIGI_CONTROLLER_NUM=2
CONFIG_SOC_ADC_PATT_LEN_MAX=24
CONFIG_SOC_ADC_DIGI_MIN_BITWIDTH=12
CONFIG_SOC_ADC_DIGI_MAX_BITWIDTH=12
CONFIG_SOC_ADC_DIGI_RESULT_BYTES=4
CONFIG_SOC_ADC_DIGI_DATA_BYTES_PER_CONV=4
CONFIG_SOC_ADC_DIGI_IIR_FILTER_NUM=2
CONFIG_SOC_ADC_DIGI_MONITOR_NUM=2
CONFIG_SOC_ADC_SAMPLE_FREQ_THRES_HIGH=83333
CONFIG_SOC_ADC_SAMPLE_FREQ_THRES_LOW=611
CONFIG_SOC_ADC_RTC_MIN_BITWIDTH=12
CONFIG_SOC_ADC_RTC_MAX_BITWIDTH=12
CONFIG_SOC_ADC_CALIBRATION_V1_SUPPORTED=y
CONFIG_SOC_ADC_SELF_HW_CALI_SUPPORTED=y
CONFIG_SOC_ADC_SHARED_POWER=y
CONFIG_SOC_APB_BACKUP_DMA=y
CONFIG_SOC_BROWNOUT_RESET_SUPPORTED=y
CONFIG_SOC_CACHE_WRITEBACK_SUPPORTED=y
CONFIG_SOC_CACHE_FREEZE_SUPPORTED=y
CONFIG_SOC_CPU_CORES_NUM=2
CONFIG_SOC_CPU_INTR_NUM=32
CONFIG_SOC_CPU_HAS_FPU=y
CONFIG_SOC_HP_CPU_HAS_MULTIPLE_CORES=y
CONFIG_SOC_CPU_BREAKPOINTS_NUM=2
CONFIG_SOC_CPU_WATCHPOINTS_NUM=2
CONFIG_SOC_CPU_WATCHPOINT_MAX_REGION_SIZE=64
CONFIG_SOC_DS_SIGNATURE_MAX_BIT_LEN=4096
CONFIG_SOC_DS_KEY_PARAM_MD_IV_LENGTH=16
CONFIG_SOC_DS_KEY_CHECK_MAX_WAIT_US=1100
CONFIG_SOC_AHB_GDMA_VERSION=1
CONFIG_SOC_GDMA_NUM_GROUPS_MAX=1
CONFIG_SOC_GDMA_PAIRS_PER_GROUP=5
CONFIG_SOC_GDMA_PAIRS_PER_GROUP_MAX=5
CONFIG_SOC_AHB_GDMA_SUPPORT_PSRAM=y
CONFIG_SOC_GPIO_PORT=1
CONFIG_SOC_GPIO_PIN_COUNT=49
CONFIG_SOC_GPIO_SUPPORT_PIN_GLITCH_FILTER=y
CONFIG_SOC_GPIO_FILTER_CLK_SUPPORT_APB=y
CONFIG_SOC_GPIO_SUPPORT_RTC_INDEPENDENT=y
CONFIG_SOC_GPIO_SUPPORT_FORCE_HOLD=y
CONFIG_SOC_GPIO_VALID_GPIO_MASK=0x1FFFFFFFFFFFF
CONFIG_SOC_GPIO_IN_RANGE_MAX=48
CONFIG_SOC_GPIO_OUT_RANGE_MAX=48
CONFIG_SOC_GPIO_VALID_DIGITAL_IO_PAD_MASK=0x0001FFFFFC000000
CONFIG_SOC_GPIO_CLOCKOUT_BY_IO_MUX=y
CONFIG_SOC_DEDIC_GPIO_OUT_CHANNELS_NUM=8
CONFIG_SOC_DEDIC_GPIO_IN_CHANNELS_NUM=8
CONFIG_SOC_DEDIC_GPIO_OUT_AUTO_ENABLE=y
CONFIG_SOC_I2C_NUM=2
CONFIG_SOC_I2C_FIFO_LEN=32
CONFIG_SOC_I2C_CMD_REG_NUM=8
CONFIG_SOC_I2C_SUPPORT_SLAVE=y
CONFIG_SOC_I2C_SUPPORT_HW_CLR_BUS=y
CONFIG_SOC_I2C_SUPPORT_XTAL=y
CONFIG_SOC_I2C_SUPPORT_RTC=y
CONFIG_SOC_I2C_SUPPORT_10BIT_ADDR=y
CONFIG_SOC_I2C_SLAVE_SUPPORT_BROADCAST=y
CONFIG_SOC_I2C_SLAVE_SUPPORT_I2CRAM_ACCESS=y
CONFIG_SOC_I2S_NUM=2
CONFIG_SOC_I2S_HW_VERSION_2=y
CONFIG_SOC_I2S_SUPPORTS_XTAL=y
CONFIG_SOC_I2S_SUPPORTS_PLL_F160M=y
CONFIG_SOC_I2S_SUPPORTS_PCM=y
CONFIG_SOC_I2S_SUPPORTS_PDM=y
CONFIG_SOC_I2S_SUPPORTS_PDM_TX=y
CONFIG_SOC_I2S_PDM_MAX_TX_LINES=2
CONFIG_SOC_I2S_SUPPORTS_PDM_RX=y
CONFIG_SOC_I2S_PDM_MAX_RX_LINES=4
CONFIG_SOC_I2S_SUPPORTS_TDM=y
CONFIG_SOC_LEDC_SUPPORT_APB_CLOCK=y
CONFIG_SOC_LEDC_SUPPORT_XTAL_CLOCK=y
CONFIG_SOC_LEDC_CHANNEL_NUM=8
CONFIG_SOC_LEDC_TIMER_BIT_WIDTH=14
CONFIG_SOC_LEDC_SUPPORT_FADE_STOP=y
CONFIG_SOC_MCPWM_GROUPS=2
CONFIG_SOC_MCPWM_TIMERS_PER_GROUP=3
CONFIG_SOC_MCPWM_OPERATORS_PER_GROUP=3
CONFIG_SOC_MCPWM_COMPARATORS_PER_OPERATOR=2
CONFIG_SOC_MCPWM_GENERATORS_PER_OPERATOR=2
CONFIG_SOC_MCPWM_TRIGGERS_PER_OPERATOR=2
CONFIG_SOC_MCPWM_GPIO_FAULTS_PER_GROUP=3
CONFIG_SOC_MCPWM_CAPTURE_TIMERS_PER_GROUP=y
CONFIG_SOC_MCPWM_CAPTURE_CHANNELS_PER_TIMER=3
CONFIG_SOC_MCPWM_GPIO_SYNCHROS_PER_GROUP=3
CONFIG_SOC_MCPWM_SWSYNC_CAN_PROPAGATE=y
CONFIG_SOC_MMU_LINEAR_ADDRESS_REGION_NUM=1
CONFIG_SOC_MMU_PERIPH_NUM=1
CONFIG_SOC_PCNT_GROUPS=1
CONFIG_SOC_PCNT_UNITS_PER_GROUP=4
CONFIG_SOC_PCNT_CHANNELS_PER_UNIT=2
CONFIG_SOC_PCNT_THRES_POINT_PER_UNIT=2
CONFIG_SOC_RMT_GROUPS=1
CONFIG_SOC_RMT_TX_CANDIDATES_PER_GROUP=4
CONFIG_SOC_RMT_RX_CANDIDATES_PER_GROUP=4
CONFIG_SOC_RMT_CHANNELS_PER_GROUP=8
CONFIG_SOC_RMT_MEM_WORDS_PER_CHANNEL=48
CONFIG_SOC_RMT_SUPPORT_RX_PINGPONG=y
CONFIG_SOC_RMT_SUPPORT_RX_DEMODULATION=y
CONFIG_SOC_RMT_SUPPORT_TX_ASYNC_STOP=y
CONFIG_SOC_RMT_SUPPORT_TX_LOOP_COUNT=y
CONFIG_SOC_RMT_SUPPORT_TX_LOOP_AUTO_STOP=y
CONFIG_SOC_RMT_SUPPORT_TX_SYNCHRO=y
CONFIG_SOC_RMT_SUPPORT_TX_CARRIER_DATA_ONLY=y
CONFIG_SOC_RMT_SUPPORT_XTAL=y
CONFIG_SOC_RMT_SUPPORT_RC_FAST=y
CONFIG_SOC_RMT_SUPPORT_APB=y
CONFIG_SOC_RMT_SUPPORT_DMA=y
CONFIG_SOC_LCD_I80_SUPPORTED=y
CONFIG_SOC_LCD_RGB_SUPPORTED=y
CONFIG_SOC_LCD_I80_BUSES=1
CONFIG_SOC_LCD_RGB_PANELS=1
CONFIG_SOC_LCD_I80_BUS_WIDTH=16
CONFIG_SOC_LCD_RGB_DATA_WIDTH=16
CONFIG_SOC_LCD_SUPPORT_RGB_YUV_CONV=y
CONFIG_SOC_RTC_CNTL_CPU_PD_DMA_BUS_WIDTH=128
CONFIG_SOC_RTC_CNTL_CPU_PD_REG_FILE_NUM=549
CONFIG_SOC_RTC_CNTL_TAGMEM_PD_DMA_BUS_WIDTH=128
CONFIG_SOC_RTCIO_PIN_COUNT=22
CONFIG_SOC_RTCIO_INPUT_OUTPUT_SUPPORTED=y
CONFIG_SOC_RTCIO_HOLD_SUPPORTED=y
CONFIG_SOC_RTCIO_WAKE_SUPPORTED=y
CONFIG_SOC_SDM_GROUPS=y
CONFIG_SOC_SDM_CHANNELS_PER_GROUP=8
CONFIG_SOC_SDM_CLK_SUPPORT_APB=y
CONFIG_SOC_SPI_PERIPH_NUM=3
CONFIG_SOC_SPI_MAX_CS_NUM=6
CONFIG_SOC_SPI_MAXIMUM_BUFFER_SIZE=64
CONFIG_SOC_SPI_SUPPORT_DDRCLK=y
CONFIG_SOC_SPI_SLAVE_SUPPORT_SEG_TRANS=y
CONFIG_SOC_SPI_SUPPORT_CD_SIG=y
CONFIG_SOC_SPI_SUPPORT_CONTINUOUS_TRANS=y
CONFIG_SOC_SPI_SUPPORT_SLAVE_HD_VER2=y
CONFIG_SOC_SPI_SUPPORT_CLK_APB=y
CONFIG_SOC_SPI_SUPPORT_CLK_XTAL=y
CONFIG_SOC_SPI_PERIPH_SUPPORT_CONTROL_DUMMY_OUT=y
CONFIG_SOC_MEMSPI_IS_INDEPENDENT=y
CONFIG_SOC_SPI_MAX_PRE_DIVIDER=16
CONFIG_SOC_SPI_SUPPORT_OCT=y
CONFIG_SOC_MEMSPI_SRC_FREQ_120M=y
CONFIG_SOC_MEMSPI_SRC_FREQ_80M_SUPPORTED=y
CONFIG_SOC_MEMSPI_SRC_FREQ_40M_SUPPORTED=y
CONFIG_SOC_MEMSPI_SRC_FREQ_20M_SUPPORTED=y
CONFIG_SOC_SPIRAM_SUPPORTED=y
CONFIG_SOC_SPIRAM_XIP_SUPPORTED=y
CONFIG_SOC_SYSTIMER_COUNTER_NUM=2
CONFIG_SOC_SYSTIMER_ALARM_NUM=3
CONFIG_SOC_SYSTIMER_BIT_WIDTH_LO=32
CONFIG_SOC_SYSTIMER_BIT_WIDTH_HI=20
CONFIG_SOC_SYSTIMER_FIXED_DIVIDER=y
CONFIG_SOC_SYSTIMER_INT_LEVEL=y
CONFIG_SOC_SYSTIMER_ALARM_MISS_COMPENSATE=y
CONFIG_SOC_TIMER_GROUPS=2
CONFIG_SOC_TIMER_GROUP_TIMERS_PER_GROUP=2
CONFIG_SOC_TIMER_GROUP_COUNTER_BIT_WIDTH=54
CONFIG_SOC_TIMER_GROUP_SUPPORT_XTAL=y
CONFIG_SOC_TIMER_GROUP_SUPPORT_APB=y
CONFIG_SOC_TIMER_GROUP_TOTAL_TIMERS=4
CONFIG_SOC_TOUCH_VERSION_2=y
CONFIG_SOC_TOUCH_SENSOR_NUM=15
CONFIG_SOC_TOUCH_PROXIMITY_CHANNEL_NUM=3
CONFIG_SOC_TOUCH_PROXIMITY_MEAS_DONE_SUPPORTED=y
CONFIG_SOC_TOUCH_PAD_THRESHOLD_MAX=0x1FFFFF
CONFIG_SOC_TOUCH_PAD_MEASURE_WAIT_MAX=0xFF
CONFIG_SOC_TWAI_CONTROLLER_NUM=1
CONFIG_SOC_TWAI_CLK_SUPPORT_APB=y
CONFIG_SOC_TWAI_BRP_MIN=2
CONFIG_SOC_TWAI_BRP_MAX=16384
CONFIG_SOC_TWAI_SUPPORTS_RX_STATUS=y
CONFIG_SOC_UART_NUM=3
CONFIG_SOC_UART_HP_NUM=3
CONFIG_SOC_UART_FIFO_LEN=128
CONFIG_SOC_UART_BITRATE_MAX=5000000
CONFIG_SOC_UART_SUPPORT_FSM_TX_WAIT_SEND=y
CONFIG_SOC_UART_SUPPORT_WAKEUP_INT=y
CONFIG_SOC_UART_SUPPORT_APB_CLK=y
CONFIG_SOC_UART_SUPPORT_RTC_CLK=y
CONFIG_SOC_UART_SUPPORT_XTAL_CLK=y
CONFIG_SOC_USB_OTG_PERIPH_NUM=1
CONFIG_SOC_SHA_DMA_MAX_BUFFER_SIZE=3968
CONFIG_SOC_SHA_SUPPORT_DMA=y
CONFIG_SOC_SHA_SUPPORT_RESUME=y
CONFIG_SOC_SHA_GDMA=y
CONFIG_SOC_SHA_SUPPORT_SHA1=y
CONFIG_SOC_SHA_SUPPORT_SHA224=y
CONFIG_SOC_SHA_SUPPORT_SHA256=y
CONFIG_SOC_SHA_SUPPORT_SHA384=y
CONFIG_SOC_SHA_SUPPORT_SHA512=y
CONFIG_SOC_SHA_SUPPORT_SHA512_224=y
CONFIG_SOC_SHA_SUPPORT_SHA512_256=y
CONFIG_SOC_SHA_SUPPORT_SHA512_T=y
CONFIG_SOC_MPI_MEM_BLOCKS_NUM=4
CONFIG_SOC_MPI_OPERATIONS_NUM=3
CONFIG_SOC_RSA_MAX_BIT_LEN=4096
CONFIG_SOC_AES_SUPPORT_DMA=y
CONFIG_SOC_AES_GDMA=y
CONFIG_SOC_AES_SUPPORT_AES_128=y
CONFIG_SOC_AES_SUPPORT_AES_256=y
CONFIG_SOC_PM_SUPPORT_EXT0_WAKEUP=y
CONFIG_SOC_PM_SUPPORT_EXT1_WAKEUP=y
CONFIG_SOC_PM_SUPPORT_EXT_WAKEUP=y
CONFIG_SOC_PM_SUPPORT_WIFI_WAKEUP=y
CONFIG_SOC_PM_SUPPORT_BT_WAKEUP=y
CONFIG_SOC_PM_SUPPORT_TOUCH_SENSOR_WAKEUP=y
CONFIG_SOC_PM_SUPPORT_CPU_PD=y
CONFIG_SOC_PM_SUPPORT_TAGMEM_PD=y
CONFIG_SOC_PM_SUPPORT_RTC_PERIPH_PD=y
CONFIG_SOC_PM_SUPPORT_RC_FAST_PD=y
CONFIG_SOC_PM_SUPPORT_VDDSDIO_PD=y
CONFIG_SOC_PM_SUPPORT_MAC_BB_PD=y
CONFIG_SOC_PM_SUPPORT_MODEM_PD=y
CONFIG_SOC_CONFIGURABLE_VDDSDIO_SUPPORTED=y
CONFIG_SOC_PM_SUPPORT_DEEPSLEEP_CHECK_STUB_ONLY=y
CONFIG_SOC_PM_CPU_RETENTION_BY_RTCCNTL=y
CONFIG_SOC_PM_MODEM_RETENTION_BY_BACKUPDMA=y
CONFIG_SOC_CLK_RC_FAST_D256_SUPPORTED=y
CONFIG_SOC_RTC_SLOW_CLK_SUPPORT_RC_FAST_D256=y
CONFIG_SOC_CLK_RC_FAST_SUPPORT_CALIBRATION=y
CONFIG_SOC_CLK_XTAL32K_SUPPORTED=y
CONFIG_SOC_EFUSE_DIS_DOWNLOAD_ICACHE=y
CONFIG_SOC_EFUSE_DIS_DOWNLOAD_DCACHE=y
CONFIG_SOC_EFUSE_HARD_DIS_JTAG=y
CONFIG_SOC_EFUSE_DIS_USB_JTAG=y
CONFIG_SOC_EFUSE_SOFT_DIS_JTAG=y
CONFIG_SOC_EFUSE_DIS_DIRECT_BOOT=y
CONFIG_SOC_EFUSE_DIS_ICACHE=y
CONFIG_SOC_EFUSE_BLOCK9_KEY_PURPOSE_QUIRK=y
CONFIG_SOC_SECURE_BOOT_V2_RSA=y
CONFIG_SOC_EFUSE_SECURE_BOOT_KEY_DIGESTS=3
CONFIG_SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS=y
CONFIG_SOC_SUPPORT_SECURE_BOOT_REVOKE_KEY=y
CONFIG_SOC_FLASH_ENCRYPTED_XTS_AES_BLOCK_MAX=64
CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES=y
CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES_OPTIONS=y
CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES_128=y
CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES_256=y
CONFIG_SOC_MEMPROT_CPU_PREFETCH_PAD_SIZE=16
CONFIG_SOC_MEMPROT_MEM_ALIGN_SIZE=256
CONFIG_SOC_PHY_DIG_REGS_MEM_SIZE=21
CONFIG_SOC_MAC_BB_PD_MEM_SIZE=192
CONFIG_SOC_WIFI_LIGHT_SLEEP_CLK_WIDTH=12
CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_WAIT_IDLE=y
CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND=y
CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_RESUME=y
CONFIG_SOC_SPI_MEM_SUPPORT_SW_SUSPEND=y
CONFIG_SOC_SPI_MEM_SUPPORT_OPI_MODE=y
CONFIG_SOC_SPI_MEM_SUPPORT_TIMING_TUNING=y
CONFIG_SOC_SPI_MEM_SUPPORT_CONFIG_GPIO_BY_EFUSE=y
CONFIG_SOC_SPI_MEM_SUPPORT_WRAP=y
CONFIG_SOC_MEMSPI_TIMING_TUNING_BY_MSPI_DELAY=y
CONFIG_SOC_MEMSPI_CORE_CLK_SHARED_WITH_PSRAM=y
CONFIG_SOC_COEX_HW_PTI=y
CONFIG_SOC_EXTERNAL_COEX_LEADER_TX_LINE=y
CONFIG_SOC_SDMMC_USE_GPIO_MATRIX=y
CONFIG_SOC_SDMMC_NUM_SLOTS=2
CONFIG_SOC_SDMMC_SUPPORT_XTAL_CLOCK=y
CONFIG_SOC_SDMMC_DELAY_PHASE_NUM=4
CONFIG_SOC_TEMPERATURE_SENSOR_SUPPORT_FAST_RC=y
CONFIG_SOC_WIFI_HW_TSF=y
CONFIG_SOC_WIFI_FTM_SUPPORT=y
CONFIG_SOC_WIFI_GCMP_SUPPORT=y
CONFIG_SOC_WIFI_WAPI_SUPPORT=y
CONFIG_SOC_WIFI_CSI_SUPPORT=y
CONFIG_SOC_WIFI_MESH_SUPPORT=y
CONFIG_SOC_WIFI_SUPPORT_VARIABLE_BEACON_WINDOW=y
CONFIG_SOC_WIFI_PHY_NEEDS_USB_WORKAROUND=y
CONFIG_SOC_BLE_SUPPORTED=y
CONFIG_SOC_BLE_MESH_SUPPORTED=y
CONFIG_SOC_BLE_50_SUPPORTED=y
CONFIG_SOC_BLE_DEVICE_PRIVACY_SUPPORTED=y
CONFIG_SOC_BLUFI_SUPPORTED=y
CONFIG_SOC_ULP_HAS_ADC=y
CONFIG_SOC_PHY_COMBO_MODULE=y
CONFIG_IDF_CMAKE=y
CONFIG_IDF_TOOLCHAIN="gcc"
CONFIG_IDF_TARGET_ARCH_XTENSA=y
CONFIG_IDF_TARGET_ARCH="xtensa"
CONFIG_IDF_TARGET="esp32s3"
CONFIG_IDF_INIT_VERSION="5.2.5"
CONFIG_IDF_TARGET_ESP32S3=y
CONFIG_IDF_FIRMWARE_CHIP_ID=0x0009

#
# Build type
#
CONFIG_APP_BUILD_TYPE_APP_2NDBOOT=y
# CONFIG_APP_BUILD_TYPE_RAM is not set
CONFIG_APP_BUILD_GENERATE_BINARIES=y
CONFIG_APP_BUILD_BOOTLOADER=y
CONFIG_APP_BUILD_USE_FLASH_SECTIONS=y
# CONFIG_APP_REPRODUCIBLE_BUILD is not set
# CONFIG_APP_NO_BLOBS is not set
# end of Build type

#
# Bootloader config
#

#
# Bootloader manager
#
CONFIG_BOOTLOADER_COMPILE_TIME_DATE=y
CONFIG_BOOTLOADER_PROJECT_VER=1
# end of Bootloader manager

CONFIG_BOOTLOADER_OFFSET_IN_FLASH=0x0
CONFIG_BOOTLOADER_COMPILER_OPTIMIZATION_SIZE=y
# CONFIG_BOOTLOADER_COMPILER_OPTIMIZATION_DEBUG is not set
# CONFIG_BOOTLOADER_COMPILER_OPTIMIZATION_PERF is not set
# CONFIG_BOOTLOADER_COMPILER_OPTIMIZATION_NONE is not set
# CONFIG_BOOTLOADER_LOG_LEVEL_NONE is not set
# CONFIG_BOOTLOADER_LOG_LEVEL_ERROR is not set
# CONFIG_BOOTLOADER_LOG_LEVEL_WARN is not set
CONFIG_BOOTLOADER_LOG_LEVEL_INFO=y
# CONFIG_BOOTLOADER_LOG_LEVEL_DEBUG is not set
# CONFIG_BOOTLOADER_LOG_LEVEL_VERBOSE is not set
CONFIG_BOOTLOADER_LOG_LEVEL=3

#
# Serial Flash Configurations
#
# CONFIG_BOOTLOADER_FLASH_DC_AWARE is not set
CONFIG_BOOTLOADER_FLASH_XMC_SUPPORT=y
# end of Serial Flash Configurations

CONFIG_BOOTLOADER_VDDSDIO_BOOST_1_9V=y
# CONFIG_BOOTLOADER_FACTORY_RESET is not set
# CONFIG_BOOTLOADER_APP_TEST is not set
CONFIG_BOOTLOADER_REGION_PROTECTION_ENABLE=y
CONFIG_BOOTLOADER_WDT_ENABLE=y
# CONFIG_BOOTLOADER_WDT_DISABLE_IN_USER_CODE is not set
CONFIG_BOOTLOADER_WDT_TIME_MS=9000
# CONFIG_BOOTLOADER_APP_ROLLBACK_ENABLE is not set
# CONFIG_BOOTLOADER_SKIP_VALIDATE_IN_DEEP_SLEEP is not set
# CONFIG_BOOTLOADER_SKIP_VALIDATE_ON_POWER_ON is not set
# CONFIG_BOOTLOADER_SKIP_VALIDATE_ALWAYS is not set
CONFIG_BOOTLOADER_RESERVE_RTC_SIZE=0
# CONFIG_BOOTLOADER_CUSTOM_RESERVE_RTC is not set
# end of Bootloader config

#
# Security features
#
CONFIG_SECURE_BOOT_V2_RSA_SUPPORTED=y
CONFIG_SECURE_BOOT_V2_PREFERRED=y
# CONFIG_SECURE_SIGNED_APPS_NO_SECURE_BOOT is not set
# CONFIG_SECURE_BOOT is not set
# CONFIG_SECURE_FLASH_ENC_ENABLED is not set
CONFIG_SECURE_ROM_DL_MODE_ENABLED=y
# end of Security features

#
# Application manager
#
CONFIG_APP_COMPILE_TIME_DATE=y
# CONFIG_APP_EXCLUDE_PROJECT_VER_VAR is not set
# CONFIG_APP_EXCLUDE_PROJECT_NAME_VAR is not set
# CONFIG_APP_PROJECT_VER_FROM_CONFIG is not set
CONFIG_APP_RETRIEVE_LEN_ELF_SHA=9
# end of Application manager

CONFIG_ESP_ROM_HAS_CRC_LE=y
CONFIG_ESP_ROM_HAS_CRC_BE=y
CONFIG_ESP_ROM_HAS_MZ_CRC32=y
CONFIG_ESP_ROM_HAS_JPEG_DECODE=y
CONFIG_ESP_ROM_UART_CLK_IS_XTAL=y
CONFIG_ESP_ROM_HAS_RETARGETABLE_LOCKING=y
CONFIG_ESP_ROM_USB_OTG_NUM=3
CONFIG_ESP_ROM_USB_SERIAL_DEVICE_NUM=4
CONFIG_ESP_ROM_HAS_ERASE_0_REGION_BUG=y
CONFIG_ESP_ROM_HAS_ENCRYPTED_WRITES_USING_LEGACY_DRV=y
CONFIG_ESP_ROM_GET_CLK_FREQ=y
CONFIG_ESP_ROM_HAS_HAL_WDT=y
CONFIG_ESP_ROM_NEEDS_SWSETUP_WORKAROUND=y
CONFIG_ESP_ROM_HAS_LAYOUT_TABLE=y
CONFIG_ESP_ROM_HAS_SPI_FLASH=y
CONFIG_ESP_ROM_HAS_ETS_PRINTF_BUG=y
CONFIG_ESP_ROM_HAS_NEWLIB_NANO_FORMAT=y
CONFIG_ESP_ROM_NEEDS_SET_CACHE_MMU_SIZE=y
CONFIG_ESP_ROM_RAM_APP_NEEDS_MMU_INIT=y
CONFIG_ESP_ROM_HAS_FLASH_COUNT_PAGES_BUG=y
CONFIG_ESP_ROM_HAS_CACHE_SUSPEND_WAITI_BUG=y
CONFIG_ESP_ROM_HAS_CACHE_WRITEBACK_BUG=y
CONFIG_ESP_ROM_HAS_SW_FLOAT=y

#
# Boot ROM Behavior
#
CONFIG_BOOT_ROM_LOG_ALWAYS_ON=y
# CONFIG_BOOT_ROM_LOG_ALWAYS_OFF is not set
# CONFIG_BOOT_ROM_LOG_ON_GPIO_HIGH is not set
# CONFIG_BOOT_ROM_LOG_ON_GPIO_LOW is not set
# end of Boot ROM Behavior

#
# Serial flasher config
#
# CONFIG_ESPTOOLPY_NO_STUB is not set
# CONFIG_ESPTOOLPY_OCT_FLASH is not set
CONFIG_ESPTOOLPY_FLASH_MODE_AUTO_DETECT=y
# CONFIG_ESPTOOLPY_FLASHMODE_QIO is not set
# CONFIG_ESPTOOLPY_FLASHMODE_QOUT is not set
CONFIG_ESPTOOLPY_FLASHMODE_DIO=y
# CONFIG_ESPTOOLPY_FLASHMODE_DOUT is not set
CONFIG_ESPTOOLPY_FLASH_SAMPLE_MODE_STR=y
CONFIG_ESPTOOLPY_FLASHMODE="dio"
# CONFIG_ESPTOOLPY_FLASHFREQ_120M is not set
CONFIG_ESPTOOLPY_FLASHFREQ_80M=y
# CONFIG_ESPTOOLPY_FLASHFREQ_40M is not set
# CONFIG_ESPTOOLPY_FLASHFREQ_20M is not set
CONFIG_ESPTOOLPY_FLASHFREQ_80M_DEFAULT=y
CONFIG_ESPTOOLPY_FLASHFREQ="80m"
# CONFIG_ESPTOOLPY_FLASHSIZE_1MB is not set
CONFIG_ESPTOOLPY_FLASHSIZE_2MB=y
# CONFIG_ESPTOOLPY_FLASHSIZE_4MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_8MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_16MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_32MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_64MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_128MB is not set
CONFIG_ESPTOOLPY_FLASHSIZE="2MB"
# CONFIG_ESPTOOLPY_HEADER_FLASHSIZE_UPDATE is not set
CONFIG_ESPTOOLPY_BEFORE_RESET=y
# CONFIG_ESPTOOLPY_BEFORE_NORESET is not set
CONFIG_ESPTOOLPY_BEFORE="default_reset"
CONFIG_ESPTOOLPY_AFTER_RESET=y
# CONFIG_ESPTOOLPY_AFTER_NORESET is not set
CONFIG_ESPTOOLPY_AFTER="hard_reset"
CONFIG_ESPTOOLPY_MONITOR_BAUD=115200
# end of Serial flasher config

#
# Partition Table
#
CONFIG_PARTITION_TABLE_SINGLE_APP=y
# CONFIG_PARTITION_TABLE_SINGLE_APP_LARGE is not set
# CONFIG_PARTITION_TABLE_TWO_OTA is not set
# CONFIG_PARTITION_TABLE_CUSTOM is not set
CONFIG_PARTITION_TABLE_CUSTOM_FILENAME="partitions.csv"
CONFIG_PARTITION_TABLE_FILENAME="partitions_singleapp.csv"
CONFIG_PARTITION_TABLE_OFFSET=0x8000
CONFIG_PARTITION_TABLE_MD5=y
# end of Partition Table

#
# Compiler options
#
CONFIG_COMPILER_OPTIMIZATION_DEBUG=y
# CONFIG_COMPILER_OPTIMIZATION_SIZE is not set
# CONFIG_COMPILER_OPTIMIZATION_PERF is not set
# CONFIG_COMPILER_OPTIMIZATION_NONE is not set
CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_ENABLE=y
# CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_SILENT is not set
# CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_DISABLE is not set
CONFIG_COMPILER_FLOAT_LIB_FROM_GCCLIB=y
CONFIG_COMPILER_OPTIMIZATION_ASSERTION_LEVEL=2
# CONFIG_COMPILER_OPTIMIZATION_CHECKS_SILENT is not set
CONFIG_COMPILER_HIDE_PATHS_MACROS=y
# CONFIG_COMPILER_CXX_EXCEPTIONS is not set
# CONFIG_COMPILER_CXX_RTTI is not set
CONFIG_COMPILER_STACK_CHECK_MODE_NONE=y
# CONFIG_COMPILER_STACK_CHECK_MODE_NORM is not set
# CONFIG_COMPILER_STACK_CHECK_MODE_STRONG is not set
# CONFIG_COMPILER_STACK_CHECK_MODE_ALL is not set
# CONFIG_COMPILER_WARN_WRITE_STRINGS is not set
# CONFIG_COMPILER_DISABLE_GCC12_WARNINGS is not set
# CONFIG_COMPILER_DISABLE_GCC13_WARNINGS is not set
# CONFIG_COMPILER_DUMP_RTL_FILES is not set
CONFIG_COMPILER_RT_LIB_GCCLIB=y
CONFIG_COMPILER_RT_LIB_NAME="gcc"
# CONFIG_COMPILER_ORPHAN_SECTIONS_WARNING is not set
CONFIG_COMPILER_ORPHAN_SECTIONS_PLACE=y
# end of Compiler options

#
# Component config
#

#
# Application Level Tracing
#
# CONFIG_APPTRACE_DEST_JTAG is not set
CONFIG_APPTRACE_DEST_NONE=y
# CONFIG_APPTRACE_DEST_UART1 is not set
# CONFIG_APPTRACE_DEST_UART2 is not set
# CONFIG_APPTRACE_DEST_USB_CDC is not set
CONFIG_APPTRACE_DEST_UART_NONE=y
CONFIG_APPTRACE_UART_TASK_PRIO=1
CONFIG_APPTRACE_LOCK_ENABLE=y
# end of Application Level Tracing

#
# Bluetooth
#
# CONFIG_BT_ENABLED is not set
CONFIG_BT_ALARM_MAX_NUM=50
# end of Bluetooth

#
# Driver Configurations
#

#
# Legacy ADC Configuration
#
# CONFIG_ADC_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_ADC_SKIP_LEGACY_CONFLICT_CHECK is not set

#
# Legacy ADC Calibration Configuration
#
# CONFIG_ADC_CALI_SUPPRESS_DEPRECATE_WARN is not set
# end of Legacy ADC Calibration Configuration
# end of Legacy ADC Configuration

#
# SPI Configuration
#
# CONFIG_SPI_MASTER_IN_IRAM is not set
CONFIG_SPI_MASTER_ISR_IN_IRAM=y
# CONFIG_SPI_SLAVE_IN_IRAM is not set
CONFIG_SPI_SLAVE_ISR_IN_IRAM=y
# end of SPI Configuration

#
# TWAI Configuration
#
# CONFIG_TWAI_ISR_IN_IRAM is not set
CONFIG_TWAI_ERRATA_FIX_LISTEN_ONLY_DOM=y
# end of TWAI Configuration

#
# Temperature sensor Configuration
#
# CONFIG_TEMP_SENSOR_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_TEMP_SENSOR_SKIP_LEGACY_CONFLICT_CHECK is not set
# CONFIG_TEMP_SENSOR_ENABLE_DEBUG_LOG is not set
# end of Temperature sensor Configuration

#
# UART Configuration
#
# CONFIG_UART_ISR_IN_IRAM is not set
# end of UART Configuration

#
# GPIO Configuration
#
# CONFIG_GPIO_CTRL_FUNC_IN_IRAM is not set
# end of GPIO Configuration

#
# Sigma Delta Modulator Configuration
#
# CONFIG_SDM_CTRL_FUNC_IN_IRAM is not set
# CONFIG_SDM_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_SDM_SKIP_LEGACY_CONFLICT_CHECK is not set
# CONFIG_SDM_ENABLE_DEBUG_LOG is not set
# end of Sigma Delta Modulator Configuration

#
# GPTimer Configuration
#
CONFIG_GPTIMER_ISR_HANDLER_IN_IRAM=y
# CONFIG_GPTIMER_CTRL_FUNC_IN_IRAM is not set
# CONFIG_GPTIMER_ISR_IRAM_SAFE is not set
# CONFIG_GPTIMER_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_GPTIMER_SKIP_LEGACY_CONFLICT_CHECK is not set
# CONFIG_GPTIMER_ENABLE_DEBUG_LOG is not set
# end of GPTimer Configuration

#
# PCNT Configuration
#
# CONFIG_PCNT_CTRL_FUNC_IN_IRAM is not set
# CONFIG_PCNT_ISR_IRAM_SAFE is not set
# CONFIG_PCNT_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_PCNT_SKIP_LEGACY_CONFLICT_CHECK is not set
# CONFIG_PCNT_ENABLE_DEBUG_LOG is not set
# end of PCNT Configuration

#
# RMT Configuration
#
# CONFIG_RMT_ISR_IRAM_SAFE is not set
# CONFIG_RMT_RECV_FUNC_IN_IRAM is not set
# CONFIG_RMT_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_RMT_SKIP_LEGACY_CONFLICT_CHECK is not set
# CONFIG_RMT_ENABLE_DEBUG_LOG is not set
# end of RMT Configuration

#
# MCPWM Configuration
#
# CONFIG_MCPWM_ISR_IRAM_SAFE is not set
# CONFIG_MCPWM_CTRL_FUNC_IN_IRAM is not set
# CONFIG_MCPWM_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_MCPWM_ENABLE_DEBUG_LOG is not set
# CONFIG_MCPWM_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of MCPWM Configuration

#
# I2S Configuration
#
# CONFIG_I2S_ISR_IRAM_SAFE is not set
# CONFIG_I2S_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_I2S_SKIP_LEGACY_CONFLICT_CHECK is not set
# CONFIG_I2S_ENABLE_DEBUG_LOG is not set
# end of I2S Configuration

#
# USB Serial/JTAG Configuration
#
# end of USB Serial/JTAG Configuration

#
# LEDC Configuration
#
# CONFIG_LEDC_CTRL_FUNC_IN_IRAM is not set
# end of LEDC Configuration

#
# I2C Configuration
#
# CONFIG_I2C_ISR_IRAM_SAFE is not set
# CONFIG_I2C_ENABLE_DEBUG_LOG is not set
# end of I2C Configuration
# end of Driver Configurations

#
# eFuse Bit Manager
#
# CONFIG_EFUSE_CUSTOM_TABLE is not set
# CONFIG_EFUSE_VIRTUAL is not set
CONFIG_EFUSE_MAX_BLK_LEN=256
# end of eFuse Bit Manager

#
# ESP-TLS
#
CONFIG_ESP_TLS_USING_MBEDTLS=y
CONFIG_ESP_TLS_USE_DS_PERIPHERAL=y
# CONFIG_ESP_TLS_CLIENT_SESSION_TICKETS is not set
# CONFIG_ESP_TLS_SERVER is not set
# CONFIG_ESP_TLS_PSK_VERIFICATION is not set
# CONFIG_ESP_TLS_INSECURE is not set
# end of ESP-TLS

#
# ADC and ADC Calibration
#
# CONFIG_ADC_ONESHOT_CTRL_FUNC_IN_IRAM is not set
# CONFIG_ADC_CONTINUOUS_ISR_IRAM_SAFE is not set
# CONFIG_ADC_CONTINUOUS_FORCE_USE_ADC2_ON_C3_S3 is not set
# end of ADC and ADC Calibration

#
# Wireless Coexistence
#
# CONFIG_ESP_COEX_EXTERNAL_COEXIST_ENABLE is not set
# CONFIG_ESP_COEX_GPIO_DEBUG is not set
# end of Wireless Coexistence

#
# Common ESP-related
#
CONFIG_ESP_ERR_TO_NAME_LOOKUP=y
# end of Common ESP-related

#
# Ethernet
#
CONFIG_ETH_ENABLED=y
CONFIG_ETH_USE_SPI_ETHERNET=y
# CONFIG_ETH_SPI_ETHERNET_DM9051 is not set
# CONFIG_ETH_SPI_ETHERNET_W5500 is not set
# CONFIG_ETH_SPI_ETHERNET_KSZ8851SNL is not set
# CONFIG_ETH_USE_OPENETH is not set
# CONFIG_ETH_TRANSMIT_MUTEX is not set
# end of Ethernet

#
# Event Loop Library
#
# CONFIG_ESP_EVENT_LOOP_PROFILING is not set
CONFIG_ESP_EVENT_POST_FROM_ISR=y
CONFIG_ESP_EVENT_POST_FROM_IRAM_ISR=y
# end of Event Loop Library

#
# GDB Stub
#
CONFIG_ESP_GDBSTUB_ENABLED=y
# CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME is not set
CONFIG_ESP_GDBSTUB_SUPPORT_TASKS=y
CONFIG_ESP_GDBSTUB_MAX_TASKS=32
# end of GDB Stub

#
# ESP HTTP client
#
CONFIG_ESP_HTTP_CLIENT_ENABLE_HTTPS=y
# CONFIG_ESP_HTTP_CLIENT_ENABLE_BASIC_AUTH is not set
# CONFIG_ESP_HTTP_CLIENT_ENABLE_DIGEST_AUTH is not set
# end of ESP HTTP client

#
# HTTP Server
#
CONFIG_HTTPD_MAX_REQ_HDR_LEN=512
CONFIG_HTTPD_MAX_URI_LEN=512
CONFIG_HTTPD_ERR_RESP_NO_DELAY=y
CONFIG_HTTPD_PURGE_BUF_LEN=32
# CONFIG_HTTPD_LOG_PURGE_DATA is not set
# CONFIG_HTTPD_WS_SUPPORT is not set
# CONFIG_HTTPD_QUEUE_WORK_BLOCKING is not set
# end of HTTP Server

#
# ESP HTTPS OTA
#
# CONFIG_ESP_HTTPS_OTA_DECRYPT_CB is not set
# CONFIG_ESP_HTTPS_OTA_ALLOW_HTTP is not set
# end of ESP HTTPS OTA

#
# ESP HTTPS server
#
# CONFIG_ESP_HTTPS_SERVER_ENABLE is not set
# end of ESP HTTPS server

#
# Hardware Settings
#

#
# Chip revision
#
CONFIG_ESP32S3_REV_MIN_0=y
# CONFIG_ESP32S3_REV_MIN_1 is not set
# CONFIG_ESP32S3_REV_MIN_2 is not set
CONFIG_ESP32S3_REV_MIN_FULL=0
CONFIG_ESP_REV_MIN_FULL=0

#
# Maximum Supported ESP32-S3 Revision (Rev v0.99)
#
CONFIG_ESP32S3_REV_MAX_FULL=99
CONFIG_ESP_REV_MAX_FULL=99
CONFIG_ESP_EFUSE_BLOCK_REV_MIN_FULL=0
CONFIG_ESP_EFUSE_BLOCK_REV_MAX_FULL=199

#
# Maximum Supported ESP32-S3 eFuse Block Revision (eFuse Block Rev v1.99)
#
# end of Chip revision

#
# MAC Config
#
CONFIG_ESP_MAC_ADDR_UNIVERSE_WIFI_STA=y
CONFIG_ESP_MAC_ADDR_UNIVERSE_WIFI_AP=y
CONFIG_ESP_MAC_ADDR_UNIVERSE_BT=y
CONFIG_ESP_MAC_ADDR_UNIVERSE_ETH=y
CONFIG_ESP_MAC_UNIVERSAL_MAC_ADDRESSES_FOUR=y
# CONFIG_ESP32S3_UNIVERSAL_MAC_ADDRESSES_TWO is not set
CONFIG_ESP32S3_UNIVERSAL_MAC_ADDRESSES_FOUR=y
CONFIG_ESP32S3_UNIVERSAL_MAC_ADDRESSES=4
# CONFIG_ESP_MAC_USE_CUSTOM_MAC_AS_BASE_MAC is not set
# end of MAC Config

#
# Sleep Config
#
# CONFIG_ESP_SLEEP_POWER_DOWN_FLASH is not set
CONFIG_ESP_SLEEP_FLASH_LEAKAGE_WORKAROUND=y
CONFIG_ESP_SLEEP_MSPI_NEED_ALL_IO_PU=y
CONFIG_ESP_SLEEP_RTC_BUS_ISO_WORKAROUND=y
CONFIG_ESP_SLEEP_GPIO_RESET_WORKAROUND=y
CONFIG_ESP_SLEEP_WAIT_FLASH_READY_EXTRA_DELAY=2000
# CONFIG_ESP_SLEEP_CACHE_SAFE_ASSERTION is not set
# CONFIG_ESP_SLEEP_DEBUG is not set
CONFIG_ESP_SLEEP_GPIO_ENABLE_INTERNAL_RESISTORS=y
# end of Sleep Config

#
# RTC Clock Config
#
CONFIG_RTC_CLK_SRC_INT_RC=y
# CONFIG_RTC_CLK_SRC_EXT_CRYS is not set
# CONFIG_RTC_CLK_SRC_EXT_OSC is not set
# CONFIG_RTC_CLK_SRC_INT_8MD256 is not set
CONFIG_RTC_CLK_CAL_CYCLES=1024
# end of RTC Clock Config

#
# Peripheral Control
#
CONFIG_PERIPH_CTRL_FUNC_IN_IRAM=y
# end of Peripheral Control

#
# GDMA Configuration
#
# CONFIG_GDMA_CTRL_FUNC_IN_IRAM is not set
# CONFIG_GDMA_ISR_IRAM_SAFE is not set
# CONFIG_GDMA_ENABLE_DEBUG_LOG is not set
# end of GDMA Configuration

#
# Main XTAL Config
#
CONFIG_XTAL_FREQ_40=y
CONFIG_XTAL_FREQ=40
# end of Main XTAL Config
# end of Hardware Settings

#
# LCD and Touch Panel
#

#
# LCD Touch Drivers are maintained in the IDF Component Registry
#

#
# LCD Peripheral Configuration
#
CONFIG_LCD_PANEL_IO_FORMAT_BUF_SIZE=32
# CONFIG_LCD_ENABLE_DEBUG_LOG is not set
# CONFIG_LCD_RGB_ISR_IRAM_SAFE is not set
# CONFIG_LCD_RGB_RESTART_IN_VSYNC is not set
# end of LCD Peripheral Configuration
# end of LCD and Touch Panel

#
# ESP NETIF Adapter
#
CONFIG_ESP_NETIF_IP_LOST_TIMER_INTERVAL=120
CONFIG_ESP_NETIF_TCPIP_LWIP=y
# CONFIG_ESP_NETIF_LOOPBACK is not set
CONFIG_ESP_NETIF_USES_TCPIP_WITH_BSD_API=y
# CONFIG_ESP_NETIF_RECEIVE_REPORT_ERRORS is not set
# CONFIG_ESP_NETIF_L2_TAP is not set
# CONFIG_ESP_NETIF_BRIDGE_EN is not set
# CONFIG_ESP_NETIF_SET_DNS_PER_DEFAULT_NETIF is not set
# end of ESP NETIF Adapter

#
# Partition API Configuration
#
# end of Partition API Configuration

#
# PHY
#
CONFIG_ESP_PHY_CALIBRATION_AND_DATA_STORAGE=y
# CONFIG_ESP_PHY_INIT_DATA_IN_PARTITION is not set
CONFIG_ESP_PHY_MAX_WIFI_TX_POWER=20
CONFIG_ESP_PHY_MAX_TX_POWER=20
# CONFIG_ESP_PHY_REDUCE_TX_POWER is not set
CONFIG_ESP_PHY_ENABLE_USB=y
# CONFIG_ESP_PHY_ENABLE_CERT_TEST is not set
CONFIG_ESP_PHY_RF_CAL_PARTIAL=y
# CONFIG_ESP_PHY_RF_CAL_NONE is not set
# CONFIG_ESP_PHY_RF_CAL_FULL is not set
CONFIG_ESP_PHY_CALIBRATION_MODE=0
# CONFIG_ESP_PHY_PLL_TRACK_DEBUG is not set
# end of PHY

#
# Power Management
#
# CONFIG_PM_ENABLE is not set
# CONFIG_PM_SLP_IRAM_OPT is not set
CONFIG_PM_POWER_DOWN_CPU_IN_LIGHT_SLEEP=y
CONFIG_PM_RESTORE_CACHE_TAGMEM_AFTER_LIGHT_SLEEP=y
# end of Power Management

#
# ESP PSRAM
#
# CONFIG_SPIRAM is not set
# end of ESP PSRAM

#
# ESP Ringbuf
#
# CONFIG_RINGBUF_PLACE_FUNCTIONS_INTO_FLASH is not set
# end of ESP Ringbuf

#
# ESP System Settings
#
# CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_80 is not set
CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_160=y
# CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_240 is not set
CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ=160

#
# Cache config
#
CONFIG_ESP32S3_INSTRUCTION_CACHE_16KB=y
# CONFIG_ESP32S3_INSTRUCTION_CACHE_32KB is not set
CONFIG_ESP32S3_INSTRUCTION_CACHE_SIZE=0x4000
# CONFIG_ESP32S3_INSTRUCTION_CACHE_4WAYS is not set
CONFIG_ESP32S3_INSTRUCTION_CACHE_8WAYS=y
CONFIG_ESP32S3_ICACHE_ASSOCIATED_WAYS=8
# CONFIG_ESP32S3_INSTRUCTION_CACHE_LINE_16B is not set
CONFIG_ESP32S3_INSTRUCTION_CACHE_LINE_32B=y
CONFIG_ESP32S3_INSTRUCTION_CACHE_LINE_SIZE=32
# CONFIG_ESP32S3_DATA_CACHE_16KB is not set
CONFIG_ESP32S3_DATA_CACHE_32KB=y
# CONFIG_ESP32S3_DATA_CACHE_64KB is not set
CONFIG_ESP32S3_DATA_CACHE_SIZE=0x8000
# CONFIG_ESP32S3_DATA_CACHE_4WAYS is not set
CONFIG_ESP32S3_DATA_CACHE_8WAYS=y
CONFIG_ESP32S3_DCACHE_ASSOCIATED_WAYS=8
# CONFIG_ESP32S3_DATA_CACHE_LINE_16B is not set
CONFIG_ESP32S3_DATA_CACHE_LINE_32B=y
# CONFIG_ESP32S3_DATA_CACHE_LINE_64B is not set
CONFIG_ESP32S3_DATA_CACHE_LINE_SIZE=32
# end of Cache config

#
# Memory
#
# CONFIG_ESP32S3_RTCDATA_IN_FAST_MEM is not set
# CONFIG_ESP32S3_USE_FIXED_STATIC_RAM_SIZE is not set
# end of Memory

#
# Trace memory
#
# CONFIG_ESP32S3_TRAX is not set
CONFIG_ESP32S3_TRACEMEM_RESERVE_DRAM=0x0
# end of Trace memory

# CONFIG_ESP_SYSTEM_PANIC_PRINT_HALT is not set
CONFIG_ESP_SYSTEM_PANIC_PRINT_REBOOT=y
# CONFIG_ESP_SYSTEM_PANIC_SILENT_REBOOT is not set
# CONFIG_ESP_SYSTEM_PANIC_GDBSTUB is not set
CONFIG_ESP_SYSTEM_PANIC_REBOOT_DELAY_SECONDS=0
CONFIG_ESP_SYSTEM_RTC_FAST_MEM_AS_HEAP_DEPCHECK=y
CONFIG_ESP_SYSTEM_ALLOW_RTC_FAST_MEM_AS_HEAP=y

#
# Memory protection
#
CONFIG_ESP_SYSTEM_MEMPROT_FEATURE=y
CONFIG_ESP_SYSTEM_MEMPROT_FEATURE_LOCK=y
# end of Memory protection

CONFIG_ESP_SYSTEM_EVENT_QUEUE_SIZE=32
CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE=2304
CONFIG_ESP_MAIN_TASK_STACK_SIZE=3584
CONFIG_ESP_MAIN_TASK_AFFINITY_CPU0=y
# CONFIG_ESP_MAIN_TASK_AFFINITY_CPU1 is not set
# CONFIG_ESP_MAIN_TASK_AFFINITY_NO_AFFINITY is not set
CONFIG_ESP_MAIN_TASK_AFFINITY=0x0
CONFIG_ESP_MINIMAL_SHARED_STACK_SIZE=2048
CONFIG_ESP_CONSOLE_UART_DEFAULT=y
# CONFIG_ESP_CONSOLE_USB_CDC is not set
# CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG is not set
# CONFIG_ESP_CONSOLE_UART_CUSTOM is not set
# CONFIG_ESP_CONSOLE_NONE is not set
# CONFIG_ESP_CONSOLE_SECONDARY_NONE is not set
CONFIG_ESP_CONSOLE_SECONDARY_USB_SERIAL_JTAG=y
CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG_ENABLED=y
CONFIG_ESP_CONSOLE_UART=y
CONFIG_ESP_CONSOLE_UART_NUM=0
CONFIG_ESP_CONSOLE_UART_BAUDRATE=115200
CONFIG_ESP_INT_WDT=y
CONFIG_ESP_INT_WDT_TIMEOUT_MS=300
CONFIG_ESP_INT_WDT_CHECK_CPU1=y
CONFIG_ESP_TASK_WDT_EN=y
CONFIG_ESP_TASK_WDT_INIT=y
# CONFIG_ESP_TASK_WDT_PANIC is not set
CONFIG_ESP_TASK_WDT_TIMEOUT_S=5
CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU0=y
CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU1=y
# CONFIG_ESP_PANIC_HANDLER_IRAM is not set
# CONFIG_ESP_DEBUG_STUBS_ENABLE is not set
CONFIG_ESP_DEBUG_OCDAWARE=y
CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL_4=y

#
# Brownout Detector
#
CONFIG_ESP_BROWNOUT_DET=y
CONFIG_ESP_BROWNOUT_DET_LVL_SEL_7=y
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_6 is not set
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_5 is not set
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_4 is not set
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_3 is not set
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_2 is not set
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_1 is not set
CONFIG_ESP_BROWNOUT_DET_LVL=7
# end of Brownout Detector

CONFIG_ESP_SYSTEM_BROWNOUT_INTR=y
CONFIG_ESP_SYSTEM_BBPLL_RECALIB=y
# end of ESP System Settings

#
# IPC (Inter-Processor Call)
#
CONFIG_ESP_IPC_TASK_STACK_SIZE=1280
CONFIG_ESP_IPC_USES_CALLERS_PRIORITY=y
CONFIG_ESP_IPC_ISR_ENABLE=y
# end of IPC (Inter-Processor Call)

#
# High resolution timer (esp_timer)
#
# CONFIG_ESP_TIMER_PROFILING is not set
CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER=y
CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER=y
CONFIG_ESP_TIMER_TASK_STACK_SIZE=3584
CONFIG_ESP_TIMER_INTERRUPT_LEVEL=1
# CONFIG_ESP_TIMER_SHOW_EXPERIMENTAL is not set
CONFIG_ESP_TIMER_TASK_AFFINITY=0x0
CONFIG_ESP_TIMER_TASK_AFFINITY_CPU0=y
CONFIG_ESP_TIMER_ISR_AFFINITY=0x1
CONFIG_ESP_TIMER_ISR_AFFINITY_CPU0=y
# CONFIG_ESP_TIMER_SUPPORTS_ISR_DISPATCH_METHOD is not set
CONFIG_ESP_TIMER_IMPL_SYSTIMER=y
# end of High resolution timer (esp_timer)

#
# Wi-Fi
#
CONFIG_ESP_WIFI_ENABLED=y
CONFIG_ESP_WIFI_STATIC_RX_BUFFER_NUM=10
CONFIG_ESP_WIFI_DYNAMIC_RX_BUFFER_NUM=32
# CONFIG_ESP_WIFI_STATIC_TX_BUFFER is not set
CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER=y
CONFIG_ESP_WIFI_TX_BUFFER_TYPE=1
CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER_NUM=32
CONFIG_ESP_WIFI_STATIC_RX_MGMT_BUFFER=y
# CONFIG_ESP_WIFI_DYNAMIC_RX_MGMT_BUFFER is not set
CONFIG_ESP_WIFI_DYNAMIC_RX_MGMT_BUF=0
CONFIG_ESP_WIFI_RX_MGMT_BUF_NUM_DEF=5
# CONFIG_ESP_WIFI_CSI_ENABLED is not set
CONFIG_ESP_WIFI_AMPDU_TX_ENABLED=y
CONFIG_ESP_WIFI_TX_BA_WIN=6
CONFIG_ESP_WIFI_AMPDU_RX_ENABLED=y
CONFIG_ESP_WIFI_RX_BA_WIN=6
CONFIG_ESP_WIFI_NVS_ENABLED=y
CONFIG_ESP_WIFI_TASK_PINNED_TO_CORE_0=y
# CONFIG_ESP_WIFI_TASK_PINNED_TO_CORE_1 is not set
CONFIG_ESP_WIFI_SOFTAP_BEACON_MAX_LEN=752
CONFIG_ESP_WIFI_MGMT_SBUF_NUM=32
CONFIG_ESP_WIFI_IRAM_OPT=y
# CONFIG_ESP_WIFI_EXTRA_IRAM_OPT is not set
CONFIG_ESP_WIFI_RX_IRAM_OPT=y
CONFIG_ESP_WIFI_ENABLE_WPA3_SAE=y
CONFIG_ESP_WIFI_ENABLE_SAE_PK=y
CONFIG_ESP_WIFI_SOFTAP_SAE_SUPPORT=y
CONFIG_ESP_WIFI_ENABLE_WPA3_OWE_STA=y
# CONFIG_ESP_WIFI_SLP_IRAM_OPT is not set
CONFIG_ESP_WIFI_SLP_DEFAULT_MIN_ACTIVE_TIME=50
CONFIG_ESP_WIFI_SLP_DEFAULT_MAX_ACTIVE_TIME=10
CONFIG_ESP_WIFI_SLP_DEFAULT_WAIT_BROADCAST_DATA_TIME=15
# CONFIG_ESP_WIFI_FTM_ENABLE is not set
CONFIG_ESP_WIFI_STA_DISCONNECTED_PM_ENABLE=y
# CONFIG_ESP_WIFI_GCMP_SUPPORT is not set
CONFIG_ESP_WIFI_GMAC_SUPPORT=y
CONFIG_ESP_WIFI_SOFTAP_SUPPORT=y
# CONFIG_ESP_WIFI_SLP_BEACON_LOST_OPT is not set
CONFIG_ESP_WIFI_ESPNOW_MAX_ENCRYPT_NUM=7
CONFIG_ESP_WIFI_MBEDTLS_CRYPTO=y
CONFIG_ESP_WIFI_MBEDTLS_TLS_CLIENT=y
# CONFIG_ESP_WIFI_WAPI_PSK is not set
# CONFIG_ESP_WIFI_SUITE_B_192 is not set
# CONFIG_ESP_WIFI_11KV_SUPPORT is not set
# CONFIG_ESP_WIFI_MBO_SUPPORT is not set
# CONFIG_ESP_WIFI_DPP_SUPPORT is not set
# CONFIG_ESP_WIFI_11R_SUPPORT is not set
# CONFIG_ESP_WIFI_WPS_SOFTAP_REGISTRAR is not set

#
# WPS Configuration Options
#
# CONFIG_ESP_WIFI_WPS_STRICT is not set
# CONFIG_ESP_WIFI_WPS_PASSPHRASE is not set
# end of WPS Configuration Options

# CONFIG_ESP_WIFI_DEBUG_PRINT is not set
# CONFIG_ESP_WIFI_TESTING_OPTIONS is not set
CONFIG_ESP_WIFI_ENTERPRISE_SUPPORT=y
# CONFIG_ESP_WIFI_ENT_FREE_DYNAMIC_BUFFER is not set
# end of Wi-Fi

#
# Core dump
#
# CONFIG_ESP_COREDUMP_ENABLE_TO_FLASH is not set
# CONFIG_ESP_COREDUMP_ENABLE_TO_UART is not set
CONFIG_ESP_COREDUMP_ENABLE_TO_NONE=y
# end of Core dump

#
# FAT Filesystem support
#
CONFIG_FATFS_VOLUME_COUNT=2
CONFIG_FATFS_LFN_NONE=y
# CONFIG_FATFS_LFN_HEAP is not set
# CONFIG_FATFS_LFN_STACK is not set
# CONFIG_FATFS_SECTOR_512 is not set
CONFIG_FATFS_SECTOR_4096=y
# CONFIG_FATFS_CODEPAGE_DYNAMIC is not set
CONFIG_FATFS_CODEPAGE_437=y
# CONFIG_FATFS_CODEPAGE_720 is not set
# CONFIG_FATFS_CODEPAGE_737 is not set
# CONFIG_FATFS_CODEPAGE_771 is not set
# CONFIG_FATFS_CODEPAGE_775 is not set
# CONFIG_FATFS_CODEPAGE_850 is not set
# CONFIG_FATFS_CODEPAGE_852 is not set
# CONFIG_FATFS_CODEPAGE_855 is not set
# CONFIG_FATFS_CODEPAGE_857 is not set
# CONFIG_FATFS_CODEPAGE_860 is not set
# CONFIG_FATFS_CODEPAGE_861 is not set
# CONFIG_FATFS_CODEPAGE_862 is not set
# CONFIG_FATFS_CODEPAGE_863 is not set
# CONFIG_FATFS_CODEPAGE_864 is not set
# CONFIG_FATFS_CODEPAGE_865 is not set
# CONFIG_FATFS_CODEPAGE_866 is not set
# CONFIG_FATFS_CODEPAGE_869 is not set
# CONFIG_FATFS_CODEPAGE_932 is not set
# CONFIG_FATFS_CODEPAGE_936 is not set
# CONFIG_FATFS_CODEPAGE_949 is not set
# CONFIG_FATFS_CODEPAGE_950 is not set
CONFIG_FATFS_CODEPAGE=437
CONFIG_FATFS_FS_LOCK=0
CONFIG_FATFS_TIMEOUT_MS=10000
CONFIG_FATFS_PER_FILE_CACHE=y
# CONFIG_FATFS_USE_FASTSEEK is not set
CONFIG_FATFS_VFS_FSTAT_BLKSIZE=0
# CONFIG_FATFS_IMMEDIATE_FSYNC is not set
# end of FAT Filesystem support

#
# FreeRTOS
#

#
# Kernel
#
# CONFIG_FREERTOS_SMP is not set
# CONFIG_FREERTOS_UNICORE is not set
CONFIG_FREERTOS_HZ=100
# CONFIG_FREERTOS_CHECK_STACKOVERFLOW_NONE is not set
# CONFIG_FREERTOS_CHECK_STACKOVERFLOW_PTRVAL is not set
CONFIG_FREERTOS_CHECK_STACKOVERFLOW_CANARY=y
CONFIG_FREERTOS_THREAD_LOCAL_STORAGE_POINTERS=1
CONFIG_FREERTOS_IDLE_TASK_STACKSIZE=1536
# CONFIG_FREERTOS_USE_IDLE_HOOK is not set
# CONFIG_FREERTOS_USE_TICK_HOOK is not set
CONFIG_FREERTOS_MAX_TASK_NAME_LEN=16
# CONFIG_FREERTOS_ENABLE_BACKWARD_COMPATIBILITY is not set
CONFIG_FREERTOS_USE_TIMERS=y
CONFIG_FREERTOS_TIMER_SERVICE_TASK_NAME="Tmr Svc"
CONFIG_FREERTOS_TIMER_TASK_PRIORITY=1
CONFIG_FREERTOS_TIMER_TASK_STACK_DEPTH=2048
CONFIG_FREERTOS_TIMER_QUEUE_LENGTH=10
CONFIG_FREERTOS_QUEUE_REGISTRY_SIZE=0
CONFIG_FREERTOS_TASK_NOTIFICATION_ARRAY_ENTRIES=1
# CONFIG_FREERTOS_USE_TRACE_FACILITY is not set
# CONFIG_FREERTOS_GENERATE_RUN_TIME_STATS is not set
# CONFIG_FREERTOS_USE_APPLICATION_TASK_TAG is not set
# end of Kernel

#
# Port
#
CONFIG_FREERTOS_TASK_FUNCTION_WRAPPER=y
# CONFIG_FREERTOS_WATCHPOINT_END_OF_STACK is not set
CONFIG_FREERTOS_TLSP_DELETION_CALLBACKS=y
# CONFIG_FREERTOS_TASK_PRE_DELETION_HOOK is not set
# CONFIG_FREERTOS_ENABLE_STATIC_TASK_CLEAN_UP is not set
CONFIG_FREERTOS_CHECK_MUTEX_GIVEN_BY_OWNER=y
CONFIG_FREERTOS_ISR_STACKSIZE=1536
CONFIG_FREERTOS_INTERRUPT_BACKTRACE=y
CONFIG_FREERTOS_TICK_SUPPORT_SYSTIMER=y
CONFIG_FREERTOS_CORETIMER_SYSTIMER_LVL1=y
# CONFIG_FREERTOS_CORETIMER_SYSTIMER_LVL3 is not set
CONFIG_FREERTOS_SYSTICK_USES_SYSTIMER=y
# CONFIG_FREERTOS_PLACE_FUNCTIONS_INTO_FLASH is not set
# CONFIG_FREERTOS_CHECK_PORT_CRITICAL_COMPLIANCE is not set
# end of Port

CONFIG_FREERTOS_PORT=y
CONFIG_FREERTOS_NO_AFFINITY=0x7FFFFFFF
CONFIG_FREERTOS_SUPPORT_STATIC_ALLOCATION=y
CONFIG_FREERTOS_DEBUG_OCDAWARE=y
CONFIG_FREERTOS_ENABLE_TASK_SNAPSHOT=y
CONFIG_FREERTOS_PLACE_SNAPSHOT_FUNS_INTO_FLASH=y
# end of FreeRTOS

#
# Hardware Abstraction Layer (HAL) and Low Level (LL)
#
CONFIG_HAL_ASSERTION_EQUALS_SYSTEM=y
# CONFIG_HAL_ASSERTION_DISABLE is not set
# CONFIG_HAL_ASSERTION_SILENT is not set
# CONFIG_HAL_ASSERTION_ENABLE is not set
CONFIG_HAL_DEFAULT_ASSERTION_LEVEL=2
CONFIG_HAL_WDT_USE_ROM_IMPL=y
CONFIG_HAL_SPI_MASTER_FUNC_IN_IRAM=y
CONFIG_HAL_SPI_SLAVE_FUNC_IN_IRAM=y
# end of Hardware Abstraction Layer (HAL) and Low Level (LL)

#
# Heap memory debugging
#
CONFIG_HEAP_POISONING_DISABLED=y
# CONFIG_HEAP_POISONING_LIGHT is not set
# CONFIG_HEAP_POISONING_COMPREHENSIVE is not set
CONFIG_HEAP_TRACING_OFF=y
# CONFIG_HEAP_TRACING_STANDALONE is not set
# CONFIG_HEAP_TRACING_TOHOST is not set
# CONFIG_HEAP_USE_HOOKS is not set
# CONFIG_HEAP_TASK_TRACKING is not set
# CONFIG_HEAP_ABORT_WHEN_ALLOCATION_FAILS is not set
# CONFIG_HEAP_PLACE_FUNCTION_INTO_FLASH is not set
# end of Heap memory debugging

#
# Log output
#
# CONFIG_LOG_DEFAULT_LEVEL_NONE is not set
# CONFIG_LOG_DEFAULT_LEVEL_ERROR is not set
# CONFIG_LOG_DEFAULT_LEVEL_WARN is not set
CONFIG_LOG_DEFAULT_LEVEL_INFO=y
# CONFIG_LOG_DEFAULT_LEVEL_DEBUG is not set
# CONFIG_LOG_DEFAULT_LEVEL_VERBOSE is not set
CONFIG_LOG_DEFAULT_LEVEL=3
CONFIG_LOG_MAXIMUM_EQUALS_DEFAULT=y
# CONFIG_LOG_MAXIMUM_LEVEL_DEBUG is not set
# CONFIG_LOG_MAXIMUM_LEVEL_VERBOSE is not set
CONFIG_LOG_MAXIMUM_LEVEL=3
# CONFIG_LOG_MASTER_LEVEL is not set
CONFIG_LOG_COLORS=y
CONFIG_LOG_TIMESTAMP_SOURCE_RTOS=y
# CONFIG_LOG_TIMESTAMP_SOURCE_SYSTEM is not set
# end of Log output

#
# LWIP
#
CONFIG_LWIP_ENABLE=y
CONFIG_LWIP_LOCAL_HOSTNAME="espressif"
# CONFIG_LWIP_NETIF_API is not set
CONFIG_LWIP_TCPIP_TASK_PRIO=18
# CONFIG_LWIP_TCPIP_CORE_LOCKING is not set
# CONFIG_LWIP_CHECK_THREAD_SAFETY is not set
CONFIG_LWIP_DNS_SUPPORT_MDNS_QUERIES=y
# CONFIG_LWIP_L2_TO_L3_COPY is not set
# CONFIG_LWIP_IRAM_OPTIMIZATION is not set
# CONFIG_LWIP_EXTRA_IRAM_OPTIMIZATION is not set
CONFIG_LWIP_TIMERS_ONDEMAND=y
CONFIG_LWIP_ND6=y
# CONFIG_LWIP_FORCE_ROUTER_FORWARDING is not set
CONFIG_LWIP_MAX_SOCKETS=10
# CONFIG_LWIP_USE_ONLY_LWIP_SELECT is not set
# CONFIG_LWIP_SO_LINGER is not set
CONFIG_LWIP_SO_REUSE=y
CONFIG_LWIP_SO_REUSE_RXTOALL=y
# CONFIG_LWIP_SO_RCVBUF is not set
# CONFIG_LWIP_NETBUF_RECVINFO is not set
CONFIG_LWIP_IP_DEFAULT_TTL=64
CONFIG_LWIP_IP4_FRAG=y
CONFIG_LWIP_IP6_FRAG=y
# CONFIG_LWIP_IP4_REASSEMBLY is not set
# CONFIG_LWIP_IP6_REASSEMBLY is not set
CONFIG_LWIP_IP_REASS_MAX_PBUFS=10
# CONFIG_LWIP_IP_FORWARD is not set
# CONFIG_LWIP_STATS is not set
CONFIG_LWIP_ESP_GRATUITOUS_ARP=y
CONFIG_LWIP_GARP_TMR_INTERVAL=60
CONFIG_LWIP_ESP_MLDV6_REPORT=y
CONFIG_LWIP_MLDV6_TMR_INTERVAL=40
CONFIG_LWIP_TCPIP_RECVMBOX_SIZE=32
CONFIG_LWIP_DHCP_DOES_ARP_CHECK=y
# CONFIG_LWIP_DHCP_DISABLE_CLIENT_ID is not set
CONFIG_LWIP_DHCP_DISABLE_VENDOR_CLASS_ID=y
# CONFIG_LWIP_DHCP_RESTORE_LAST_IP is not set
CONFIG_LWIP_DHCP_OPTIONS_LEN=68
CONFIG_LWIP_NUM_NETIF_CLIENT_DATA=0
CONFIG_LWIP_DHCP_COARSE_TIMER_SECS=1

#
# DHCP server
#
CONFIG_LWIP_DHCPS=y
CONFIG_LWIP_DHCPS_LEASE_UNIT=60
CONFIG_LWIP_DHCPS_MAX_STATION_NUM=8
CONFIG_LWIP_DHCPS_STATIC_ENTRIES=y
# end of DHCP server

# CONFIG_LWIP_AUTOIP is not set
CONFIG_LWIP_IPV4=y
CONFIG_LWIP_IPV6=y
# CONFIG_LWIP_IPV6_AUTOCONFIG is not set
CONFIG_LWIP_IPV6_NUM_ADDRESSES=3
# CONFIG_LWIP_IPV6_FORWARD is not set
# CONFIG_LWIP_NETIF_STATUS_CALLBACK is not set
CONFIG_LWIP_NETIF_LOOPBACK=y
CONFIG_LWIP_LOOPBACK_MAX_PBUFS=8

#
# TCP
#
CONFIG_LWIP_MAX_ACTIVE_TCP=16
CONFIG_LWIP_MAX_LISTENING_TCP=16
CONFIG_LWIP_TCP_HIGH_SPEED_RETRANSMISSION=y
CONFIG_LWIP_TCP_MAXRTX=12
CONFIG_LWIP_TCP_SYNMAXRTX=12
CONFIG_LWIP_TCP_MSS=1440
CONFIG_LWIP_TCP_TMR_INTERVAL=250
CONFIG_LWIP_TCP_MSL=60000
CONFIG_LWIP_TCP_FIN_WAIT_TIMEOUT=20000
CONFIG_LWIP_TCP_SND_BUF_DEFAULT=5760
CONFIG_LWIP_TCP_WND_DEFAULT=5760
CONFIG_LWIP_TCP_RECVMBOX_SIZE=6
CONFIG_LWIP_TCP_QUEUE_OOSEQ=y
CONFIG_LWIP_TCP_OOSEQ_TIMEOUT=6
CONFIG_LWIP_TCP_OOSEQ_MAX_PBUFS=4
# CONFIG_LWIP_TCP_SACK_OUT is not set
CONFIG_LWIP_TCP_OVERSIZE_MSS=y
# CONFIG_LWIP_TCP_OVERSIZE_QUARTER_MSS is not set
# CONFIG_LWIP_TCP_OVERSIZE_DISABLE is not set
CONFIG_LWIP_TCP_RTO_TIME=1500
# end of TCP

#
# UDP
#
CONFIG_LWIP_MAX_UDP_PCBS=16
CONFIG_LWIP_UDP_RECVMBOX_SIZE=6
# end of UDP

#
# Checksums
#
# CONFIG_LWIP_CHECKSUM_CHECK_IP is not set
# CONFIG_LWIP_CHECKSUM_CHECK_UDP is not set
CONFIG_LWIP_CHECKSUM_CHECK_ICMP=y
# end of Checksums

CONFIG_LWIP_TCPIP_TASK_STACK_SIZE=3072
CONFIG_LWIP_TCPIP_TASK_AFFINITY_NO_AFFINITY=y
# CONFIG_LWIP_TCPIP_TASK_AFFINITY_CPU0 is not set
# CONFIG_LWIP_TCPIP_TASK_AFFINITY_CPU1 is not set
CONFIG_LWIP_TCPIP_TASK_AFFINITY=0x7FFFFFFF
CONFIG_LWIP_IPV6_ND6_NUM_PREFIXES=5
CONFIG_LWIP_IPV6_ND6_NUM_ROUTERS=3
CONFIG_LWIP_IPV6_ND6_NUM_DESTINATIONS=10
# CONFIG_LWIP_PPP_SUPPORT is not set
CONFIG_LWIP_IPV6_MEMP_NUM_ND6_QUEUE=3
CONFIG_LWIP_IPV6_ND6_NUM_NEIGHBORS=5
# CONFIG_LWIP_SLIP_SUPPORT is not set

#
# ICMP
#
CONFIG_LWIP_ICMP=y
# CONFIG_LWIP_MULTICAST_PING is not set
# CONFIG_LWIP_BROADCAST_PING is not set
# end of ICMP

#
# LWIP RAW API
#
CONFIG_LWIP_MAX_RAW_PCBS=16
# end of LWIP RAW API

#
# SNTP
#
CONFIG_LWIP_SNTP_MAX_SERVERS=1
# CONFIG_LWIP_DHCP_GET_NTP_SRV is not set
CONFIG_LWIP_SNTP_UPDATE_DELAY=3600000
# end of SNTP

#
# DNS
#
CONFIG_LWIP_DNS_MAX_HOST_IP=1
CONFIG_LWIP_DNS_MAX_SERVERS=3
# CONFIG_LWIP_FALLBACK_DNS_SERVER_SUPPORT is not set
# CONFIG_LWIP_DNS_SETSERVER_WITH_NETIF is not set
# end of DNS

CONFIG_LWIP_BRIDGEIF_MAX_PORTS=7
CONFIG_LWIP_ESP_LWIP_ASSERT=y

#
# Hooks
#
# CONFIG_LWIP_HOOK_TCP_ISN_NONE is not set
CONFIG_LWIP_HOOK_TCP_ISN_DEFAULT=y
# CONFIG_LWIP_HOOK_TCP_ISN_CUSTOM is not set
CONFIG_LWIP_HOOK_IP6_ROUTE_NONE=y
# CONFIG_LWIP_HOOK_IP6_ROUTE_DEFAULT is not set
# CONFIG_LWIP_HOOK_IP6_ROUTE_CUSTOM is not set
CONFIG_LWIP_HOOK_ND6_GET_GW_NONE=y
# CONFIG_LWIP_HOOK_ND6_GET_GW_DEFAULT is not set
# CONFIG_LWIP_HOOK_ND6_GET_GW_CUSTOM is not set
CONFIG_LWIP_HOOK_IP6_SELECT_SRC_ADDR_NONE=y
# CONFIG_LWIP_HOOK_IP6_SELECT_SRC_ADDR_DEFAULT is not set
# CONFIG_LWIP_HOOK_IP6_SELECT_SRC_ADDR_CUSTOM is not set
CONFIG_LWIP_HOOK_NETCONN_EXT_RESOLVE_NONE=y
# CONFIG_LWIP_HOOK_NETCONN_EXT_RESOLVE_DEFAULT is not set
# CONFIG_LWIP_HOOK_NETCONN_EXT_RESOLVE_CUSTOM is not set
CONFIG_LWIP_HOOK_DNS_EXT_RESOLVE_NONE=y
# CONFIG_LWIP_HOOK_DNS_EXT_RESOLVE_CUSTOM is not set
# CONFIG_LWIP_HOOK_IP6_INPUT_NONE is not set
CONFIG_LWIP_HOOK_IP6_INPUT_DEFAULT=y
# CONFIG_LWIP_HOOK_IP6_INPUT_CUSTOM is not set
# end of Hooks

# CONFIG_LWIP_DEBUG is not set
# end of LWIP

#
# mbedTLS
#
CONFIG_MBEDTLS_INTERNAL_MEM_ALLOC=y
# CONFIG_MBEDTLS_DEFAULT_MEM_ALLOC is not set
# CONFIG_MBEDTLS_CUSTOM_MEM_ALLOC is not set
CONFIG_MBEDTLS_ASYMMETRIC_CONTENT_LEN=y
CONFIG_MBEDTLS_SSL_IN_CONTENT_LEN=16384
CONFIG_MBEDTLS_SSL_OUT_CONTENT_LEN=4096
# CONFIG_MBEDTLS_DYNAMIC_BUFFER is not set
# CONFIG_MBEDTLS_DEBUG is not set

#
# mbedTLS v3.x related
#
# CONFIG_MBEDTLS_SSL_PROTO_TLS1_3 is not set
# CONFIG_MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH is not set
# CONFIG_MBEDTLS_X509_TRUSTED_CERT_CALLBACK is not set
# CONFIG_MBEDTLS_SSL_CONTEXT_SERIALIZATION is not set
CONFIG_MBEDTLS_SSL_KEEP_PEER_CERTIFICATE=y
CONFIG_MBEDTLS_PKCS7_C=y
# end of mbedTLS v3.x related

#
# Certificate Bundle
#
CONFIG_MBEDTLS_CERTIFICATE_BUNDLE=y
CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_FULL=y
# CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_CMN is not set
# CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_NONE is not set
# CONFIG_MBEDTLS_CUSTOM_CERTIFICATE_BUNDLE is not set
CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_MAX_CERTS=200
# end of Certificate Bundle

# CONFIG_MBEDTLS_ECP_RESTARTABLE is not set
CONFIG_MBEDTLS_CMAC_C=y
CONFIG_MBEDTLS_HARDWARE_AES=y
CONFIG_MBEDTLS_AES_USE_INTERRUPT=y
CONFIG_MBEDTLS_AES_INTERRUPT_LEVEL=0
# CONFIG_MBEDTLS_GCM_SUPPORT_NON_AES_CIPHER is not set
CONFIG_MBEDTLS_HARDWARE_MPI=y
# CONFIG_MBEDTLS_LARGE_KEY_SOFTWARE_MPI is not set
CONFIG_MBEDTLS_MPI_USE_INTERRUPT=y
CONFIG_MBEDTLS_MPI_INTERRUPT_LEVEL=0
CONFIG_MBEDTLS_HARDWARE_SHA=y
CONFIG_MBEDTLS_ROM_MD5=y
# CONFIG_MBEDTLS_ATCA_HW_ECDSA_SIGN is not set
# CONFIG_MBEDTLS_ATCA_HW_ECDSA_VERIFY is not set
CONFIG_MBEDTLS_HAVE_TIME=y
# CONFIG_MBEDTLS_PLATFORM_TIME_ALT is not set
# CONFIG_MBEDTLS_HAVE_TIME_DATE is not set
CONFIG_MBEDTLS_ECDSA_DETERMINISTIC=y
CONFIG_MBEDTLS_SHA512_C=y
# CONFIG_MBEDTLS_SHA3_C is not set
CONFIG_MBEDTLS_TLS_SERVER_AND_CLIENT=y
# CONFIG_MBEDTLS_TLS_SERVER_ONLY is not set
# CONFIG_MBEDTLS_TLS_CLIENT_ONLY is not set
# CONFIG_MBEDTLS_TLS_DISABLED is not set
CONFIG_MBEDTLS_TLS_SERVER=y
CONFIG_MBEDTLS_TLS_CLIENT=y
CONFIG_MBEDTLS_TLS_ENABLED=y

#
# TLS Key Exchange Methods
#
# CONFIG_MBEDTLS_PSK_MODES is not set
CONFIG_MBEDTLS_KEY_EXCHANGE_RSA=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ELLIPTIC_CURVE=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_RSA=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_RSA=y
# end of TLS Key Exchange Methods

CONFIG_MBEDTLS_SSL_RENEGOTIATION=y
CONFIG_MBEDTLS_SSL_PROTO_TLS1_2=y
# CONFIG_MBEDTLS_SSL_PROTO_GMTSSL1_1 is not set
# CONFIG_MBEDTLS_SSL_PROTO_DTLS is not set
CONFIG_MBEDTLS_SSL_ALPN=y
CONFIG_MBEDTLS_CLIENT_SSL_SESSION_TICKETS=y
CONFIG_MBEDTLS_SERVER_SSL_SESSION_TICKETS=y

#
# Symmetric Ciphers
#
CONFIG_MBEDTLS_AES_C=y
# CONFIG_MBEDTLS_CAMELLIA_C is not set
# CONFIG_MBEDTLS_DES_C is not set
# CONFIG_MBEDTLS_BLOWFISH_C is not set
# CONFIG_MBEDTLS_XTEA_C is not set
CONFIG_MBEDTLS_CCM_C=y
CONFIG_MBEDTLS_GCM_C=y
# CONFIG_MBEDTLS_NIST_KW_C is not set
# end of Symmetric Ciphers

# CONFIG_MBEDTLS_RIPEMD160_C is not set

#
# Certificates
#
CONFIG_MBEDTLS_PEM_PARSE_C=y
CONFIG_MBEDTLS_PEM_WRITE_C=y
CONFIG_MBEDTLS_X509_CRL_PARSE_C=y
CONFIG_MBEDTLS_X509_CSR_PARSE_C=y
# end of Certificates

CONFIG_MBEDTLS_ECP_C=y
# CONFIG_MBEDTLS_DHM_C is not set
CONFIG_MBEDTLS_ECDH_C=y
CONFIG_MBEDTLS_ECDSA_C=y
# CONFIG_MBEDTLS_ECJPAKE_C is not set
CONFIG_MBEDTLS_ECP_DP_SECP192R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP224R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP256R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP384R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP521R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP192K1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP224K1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP256K1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_BP256R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_BP384R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_BP512R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_CURVE25519_ENABLED=y
CONFIG_MBEDTLS_ECP_NIST_OPTIM=y
# CONFIG_MBEDTLS_ECP_FIXED_POINT_OPTIM is not set
# CONFIG_MBEDTLS_POLY1305_C is not set
# CONFIG_MBEDTLS_CHACHA20_C is not set
# CONFIG_MBEDTLS_HKDF_C is not set
# CONFIG_MBEDTLS_THREADING_C is not set
CONFIG_MBEDTLS_ERROR_STRINGS=y
CONFIG_MBEDTLS_FS_IO=y
# end of mbedTLS

#
# ESP-MQTT Configurations
#
CONFIG_MQTT_PROTOCOL_311=y
# CONFIG_MQTT_PROTOCOL_5 is not set
CONFIG_MQTT_TRANSPORT_SSL=y
CONFIG_MQTT_TRANSPORT_WEBSOCKET=y
CONFIG_MQTT_TRANSPORT_WEBSOCKET_SECURE=y
# CONFIG_MQTT_MSG_ID_INCREMENTAL is not set
# CONFIG_MQTT_SKIP_PUBLISH_IF_DISCONNECTED is not set
# CONFIG_MQTT_REPORT_DELETED_MESSAGES is not set
# CONFIG_MQTT_USE_CUSTOM_CONFIG is not set
# CONFIG_MQTT_TASK_CORE_SELECTION_ENABLED is not set
# CONFIG_MQTT_CUSTOM_OUTBOX is not set
# end of ESP-MQTT Configurations

#
# Newlib
#
CONFIG_NEWLIB_STDOUT_LINE_ENDING_CRLF=y
# CONFIG_NEWLIB_STDOUT_LINE_ENDING_LF is not set
# CONFIG_NEWLIB_STDOUT_LINE_ENDING_CR is not set
# CONFIG_NEWLIB_STDIN_LINE_ENDING_CRLF is not set
# CONFIG_NEWLIB_STDIN_LINE_ENDING_LF is not set
CONFIG_NEWLIB_STDIN_LINE_ENDING_CR=y
# CONFIG_NEWLIB_NANO_FORMAT is not set
CONFIG_NEWLIB_TIME_SYSCALL_USE_RTC_HRT=y
# CONFIG_NEWLIB_TIME_SYSCALL_USE_RTC is not set
# CONFIG_NEWLIB_TIME_SYSCALL_USE_HRT is not set
# CONFIG_NEWLIB_TIME_SYSCALL_USE_NONE is not set
# end of Newlib

#
# NVS
#
# CONFIG_NVS_ENCRYPTION is not set
# CONFIG_NVS_ASSERT_ERROR_CHECK is not set
# CONFIG_NVS_LEGACY_DUP_KEYS_COMPATIBILITY is not set
# end of NVS

#
# OpenThread
#
# CONFIG_OPENTHREAD_ENABLED is not set

#
# OpenThread Spinel
#
# CONFIG_OPENTHREAD_SPINEL_ONLY is not set
# end of OpenThread Spinel
# end of OpenThread

#
# Protocomm
#
CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_0=y
CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_1=y
CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_2=y
# end of Protocomm

#
# PThreads
#
CONFIG_PTHREAD_TASK_PRIO_DEFAULT=5
CONFIG_PTHREAD_TASK_STACK_SIZE_DEFAULT=3072
CONFIG_PTHREAD_STACK_MIN=768
CONFIG_PTHREAD_DEFAULT_CORE_NO_AFFINITY=y
# CONFIG_PTHREAD_DEFAULT_CORE_0 is not set
# CONFIG_PTHREAD_DEFAULT_CORE_1 is not set
CONFIG_PTHREAD_TASK_CORE_DEFAULT=-1
CONFIG_PTHREAD_TASK_NAME_DEFAULT="pthread"
# end of PThreads

#
# MMU Config
#
CONFIG_MMU_PAGE_SIZE_64KB=y
CONFIG_MMU_PAGE_MODE="64KB"
CONFIG_MMU_PAGE_SIZE=0x10000
# end of MMU Config

#
# Main Flash configuration
#

#
# SPI Flash behavior when brownout
#
CONFIG_SPI_FLASH_BROWNOUT_RESET_XMC=y
CONFIG_SPI_FLASH_BROWNOUT_RESET=y
# end of SPI Flash behavior when brownout

#
# Optional and Experimental Features (READ DOCS FIRST)
#

#
# Features here require specific hardware (READ DOCS FIRST!)
#
# CONFIG_SPI_FLASH_HPM_ENA is not set
CONFIG_SPI_FLASH_HPM_AUTO=y
# CONFIG_SPI_FLASH_HPM_DIS is not set
CONFIG_SPI_FLASH_HPM_ON=y
CONFIG_SPI_FLASH_HPM_DC_AUTO=y
# CONFIG_SPI_FLASH_HPM_DC_DISABLE is not set
CONFIG_SPI_FLASH_SUSPEND_QVL_SUPPORTED=y
# CONFIG_SPI_FLASH_AUTO_SUSPEND is not set
# CONFIG_SPI_FLASH_FORCE_ENABLE_XMC_C_SUSPEND is not set
# end of Optional and Experimental Features (READ DOCS FIRST)
# end of Main Flash configuration

#
# SPI Flash driver
#
# CONFIG_SPI_FLASH_VERIFY_WRITE is not set
# CONFIG_SPI_FLASH_ENABLE_COUNTERS is not set
CONFIG_SPI_FLASH_ROM_DRIVER_PATCH=y
# CONFIG_SPI_FLASH_ROM_IMPL is not set
CONFIG_SPI_FLASH_DANGEROUS_WRITE_ABORTS=y
# CONFIG_SPI_FLASH_DANGEROUS_WRITE_FAILS is not set
# CONFIG_SPI_FLASH_DANGEROUS_WRITE_ALLOWED is not set
# CONFIG_SPI_FLASH_BYPASS_BLOCK_ERASE is not set
CONFIG_SPI_FLASH_YIELD_DURING_ERASE=y
CONFIG_SPI_FLASH_ERASE_YIELD_DURATION_MS=20
CONFIG_SPI_FLASH_ERASE_YIELD_TICKS=1
CONFIG_SPI_FLASH_WRITE_CHUNK_SIZE=8192
# CONFIG_SPI_FLASH_SIZE_OVERRIDE is not set
# CONFIG_SPI_FLASH_CHECK_ERASE_TIMEOUT_DISABLED is not set
# CONFIG_SPI_FLASH_OVERRIDE_CHIP_DRIVER_LIST is not set

#
# Auto-detect flash chips
#
CONFIG_SPI_FLASH_VENDOR_XMC_SUPPORTED=y
CONFIG_SPI_FLASH_VENDOR_GD_SUPPORTED=y
CONFIG_SPI_FLASH_VENDOR_ISSI_SUPPORTED=y
CONFIG_SPI_FLASH_VENDOR_MXIC_SUPPORTED=y
CONFIG_SPI_FLASH_VENDOR_WINBOND_SUPPORTED=y
CONFIG_SPI_FLASH_VENDOR_BOYA_SUPPORTED=y
CONFIG_SPI_FLASH_VENDOR_TH_SUPPORTED=y
CONFIG_SPI_FLASH_SUPPORT_ISSI_CHIP=y
CONFIG_SPI_FLASH_SUPPORT_MXIC_CHIP=y
CONFIG_SPI_FLASH_SUPPORT_GD_CHIP=y
CONFIG_SPI_FLASH_SUPPORT_WINBOND_CHIP=y
CONFIG_SPI_FLASH_SUPPORT_BOYA_CHIP=y
CONFIG_SPI_FLASH_SUPPORT_TH_CHIP=y
CONFIG_SPI_FLASH_SUPPORT_MXIC_OPI_CHIP=y
# end of Auto-detect flash chips

CONFIG_SPI_FLASH_ENABLE_ENCRYPTED_READ_WRITE=y
# end of SPI Flash driver

#
# SPIFFS Configuration
#
CONFIG_SPIFFS_MAX_PARTITIONS=3

#
# SPIFFS Cache Configuration
#
CONFIG_SPIFFS_CACHE=y
CONFIG_SPIFFS_CACHE_WR=y
# CONFIG_SPIFFS_CACHE_STATS is not set
# end of SPIFFS Cache Configuration

CONFIG_SPIFFS_PAGE_CHECK=y
CONFIG_SPIFFS_GC_MAX_RUNS=10
# CONFIG_SPIFFS_GC_STATS is not set
CONFIG_SPIFFS_PAGE_SIZE=256
CONFIG_SPIFFS_OBJ_NAME_LEN=32
# CONFIG_SPIFFS_FOLLOW_SYMLINKS is not set
CONFIG_SPIFFS_USE_MAGIC=y
CONFIG_SPIFFS_USE_MAGIC_LENGTH=y
CONFIG_SPIFFS_META_LENGTH=4
CONFIG_SPIFFS_USE_MTIME=y

#
# Debug Configuration
#
# CONFIG_SPIFFS_DBG is not set
# CONFIG_SPIFFS_API_DBG is not set
# CONFIG_SPIFFS_GC_DBG is not set
# CONFIG_SPIFFS_CACHE_DBG is not set
# CONFIG_SPIFFS_CHECK_DBG is not set
# CONFIG_SPIFFS_TEST_VISUALISATION is not set
# end of Debug Configuration
# end of SPIFFS Configuration

#
# TCP Transport
#

#
# Websocket
#
CONFIG_WS_TRANSPORT=y
CONFIG_WS_BUFFER_SIZE=1024
# CONFIG_WS_DYNAMIC_BUFFER is not set
# end of Websocket
# end of TCP Transport

#
# Ultra Low Power (ULP) Co-processor
#
# CONFIG_ULP_COPROC_ENABLED is not set
# end of Ultra Low Power (ULP) Co-processor

#
# Unity unit testing library
#
CONFIG_UNITY_ENABLE_FLOAT=y
CONFIG_UNITY_ENABLE_DOUBLE=y
# CONFIG_UNITY_ENABLE_64BIT is not set
# CONFIG_UNITY_ENABLE_COLOR is not set
CONFIG_UNITY_ENABLE_IDF_TEST_RUNNER=y
# CONFIG_UNITY_ENABLE_FIXTURE is not set
# CONFIG_UNITY_ENABLE_BACKTRACE_ON_FAIL is not set
# end of Unity unit testing library

#
# USB-OTG
#
CONFIG_USB_HOST_CONTROL_TRANSFER_MAX_SIZE=256
CONFIG_USB_HOST_HW_BUFFER_BIAS_BALANCED=y
# CONFIG_USB_HOST_HW_BUFFER_BIAS_IN is not set
# CONFIG_USB_HOST_HW_BUFFER_BIAS_PERIODIC_OUT is not set

#
# Hub Driver Configuration
#

#
# Root Port configuration
#
CONFIG_USB_HOST_DEBOUNCE_DELAY_MS=250
CONFIG_USB_HOST_RESET_HOLD_MS=30
CONFIG_USB_HOST_RESET_RECOVERY_MS=30
CONFIG_USB_HOST_SET_ADDR_RECOVERY_MS=10
# end of Root Port configuration

# CONFIG_USB_HOST_HUBS_SUPPORTED is not set
# end of Hub Driver Configuration

CONFIG_USB_OTG_SUPPORTED=y
# CONFIG_USB_HOST_ENABLE_ENUM_FILTER_CALLBACK is not set
# end of USB-OTG

#
# Virtual file system
#
CONFIG_VFS_SUPPORT_IO=y
CONFIG_VFS_SUPPORT_DIR=y
CONFIG_VFS_SUPPORT_SELECT=y
CONFIG_VFS_SUPPRESS_SELECT_DEBUG_OUTPUT=y
# CONFIG_VFS_SELECT_IN_RAM is not set
CONFIG_VFS_SUPPORT_TERMIOS=y
CONFIG_VFS_MAX_COUNT=8

#
# Host File System I/O (Semihosting)
#
CONFIG_VFS_SEMIHOSTFS_MAX_MOUNT_POINTS=1
# end of Host File System I/O (Semihosting)
# end of Virtual file system

#
# Wear Levelling
#
# CONFIG_WL_SECTOR_SIZE_512 is not set
CONFIG_WL_SECTOR_SIZE_4096=y
CONFIG_WL_SECTOR_SIZE=4096
# end of Wear Levelling

#
# Wi-Fi Provisioning Manager
#
CONFIG_WIFI_PROV_SCAN_MAX_ENTRIES=16
CONFIG_WIFI_PROV_AUTOSTOP_TIMEOUT=30
CONFIG_WIFI_PROV_STA_ALL_CHANNEL_SCAN=y
# CONFIG_WIFI_PROV_STA_FAST_SCAN is not set
# end of Wi-Fi Provisioning Manager
# end of Component config

# CONFIG_IDF_EXPERIMENTAL_FEATURES is not set

# Deprecated options for backward compatibility
# CONFIG_APP_BUILD_TYPE_ELF_RAM is not set
# CONFIG_NO_BLOBS is not set
# CONFIG_LOG_BOOTLOADER_LEVEL_NONE is not set
# CONFIG_LOG_BOOTLOADER_LEVEL_ERROR is not set
# CONFIG_LOG_BOOTLOADER_LEVEL_WARN is not set
CONFIG_LOG_BOOTLOADER_LEVEL_INFO=y
# CONFIG_LOG_BOOTLOADER_LEVEL_DEBUG is not set
# CONFIG_LOG_BOOTLOADER_LEVEL_VERBOSE is not set
CONFIG_LOG_BOOTLOADER_LEVEL=3
# CONFIG_APP_ROLLBACK_ENABLE is not set
# CONFIG_FLASH_ENCRYPTION_ENABLED is not set
# CONFIG_FLASHMODE_QIO is not set
# CONFIG_FLASHMODE_QOUT is not set
CONFIG_FLASHMODE_DIO=y
# CONFIG_FLASHMODE_DOUT is not set
CONFIG_MONITOR_BAUD=115200
CONFIG_OPTIMIZATION_LEVEL_DEBUG=y
CONFIG_COMPILER_OPTIMIZATION_LEVEL_DEBUG=y
CONFIG_COMPILER_OPTIMIZATION_DEFAULT=y
# CONFIG_OPTIMIZATION_LEVEL_RELEASE is not set
# CONFIG_COMPILER_OPTIMIZATION_LEVEL_RELEASE is not set
CONFIG_OPTIMIZATION_ASSERTIONS_ENABLED=y
# CONFIG_OPTIMIZATION_ASSERTIONS_SILENT is not set
# CONFIG_OPTIMIZATION_ASSERTIONS_DISABLED is not set
CONFIG_OPTIMIZATION_ASSERTION_LEVEL=2
# CONFIG_CXX_EXCEPTIONS is not set
CONFIG_STACK_CHECK_NONE=y
# CONFIG_STACK_CHECK_NORM is not set
# CONFIG_STACK_CHECK_STRONG is not set
# CONFIG_STACK_CHECK_ALL is not set
# CONFIG_WARN_WRITE_STRINGS is not set
# CONFIG_ESP32_APPTRACE_DEST_TRAX is not set
CONFIG_ESP32_APPTRACE_DEST_NONE=y
CONFIG_ESP32_APPTRACE_LOCK_ENABLE=y
# CONFIG_MCPWM_ISR_IN_IRAM is not set
# CONFIG_EXTERNAL_COEX_ENABLE is not set
# CONFIG_ESP_WIFI_EXTERNAL_COEXIST_ENABLE is not set
# CONFIG_EVENT_LOOP_PROFILING is not set
CONFIG_POST_EVENTS_FROM_ISR=y
CONFIG_POST_EVENTS_FROM_IRAM_ISR=y
CONFIG_GDBSTUB_SUPPORT_TASKS=y
CONFIG_GDBSTUB_MAX_TASKS=32
# CONFIG_OTA_ALLOW_HTTP is not set
# CONFIG_ESP_SYSTEM_PD_FLASH is not set
CONFIG_ESP32S3_DEEP_SLEEP_WAKEUP_DELAY=2000
CONFIG_ESP_SLEEP_DEEP_SLEEP_WAKEUP_DELAY=2000
CONFIG_ESP32S3_RTC_CLK_SRC_INT_RC=y
# CONFIG_ESP32S3_RTC_CLK_SRC_EXT_CRYS is not set
# CONFIG_ESP32S3_RTC_CLK_SRC_EXT_OSC is not set
# CONFIG_ESP32S3_RTC_CLK_SRC_INT_8MD256 is not set
CONFIG_ESP32S3_RTC_CLK_CAL_CYCLES=1024
CONFIG_ESP32_PHY_CALIBRATION_AND_DATA_STORAGE=y
# CONFIG_ESP32_PHY_INIT_DATA_IN_PARTITION is not set
CONFIG_ESP32_PHY_MAX_WIFI_TX_POWER=20
CONFIG_ESP32_PHY_MAX_TX_POWER=20
# CONFIG_REDUCE_PHY_TX_POWER is not set
# CONFIG_ESP32_REDUCE_PHY_TX_POWER is not set
CONFIG_ESP_SYSTEM_PM_POWER_DOWN_CPU=y
CONFIG_PM_POWER_DOWN_TAGMEM_IN_LIGHT_SLEEP=y
# CONFIG_ESP32S3_SPIRAM_SUPPORT is not set
# CONFIG_ESP32S3_DEFAULT_CPU_FREQ_80 is not set
CONFIG_ESP32S3_DEFAULT_CPU_FREQ_160=y
# CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240 is not set
CONFIG_ESP32S3_DEFAULT_CPU_FREQ_MHZ=160
CONFIG_SYSTEM_EVENT_QUEUE_SIZE=32
CONFIG_SYSTEM_EVENT_TASK_STACK_SIZE=2304
CONFIG_MAIN_TASK_STACK_SIZE=3584
CONFIG_CONSOLE_UART_DEFAULT=y
# CONFIG_CONSOLE_UART_CUSTOM is not set
# CONFIG_CONSOLE_UART_NONE is not set
# CONFIG_ESP_CONSOLE_UART_NONE is not set
CONFIG_CONSOLE_UART=y
CONFIG_CONSOLE_UART_NUM=0
CONFIG_CONSOLE_UART_BAUDRATE=115200
CONFIG_INT_WDT=y
CONFIG_INT_WDT_TIMEOUT_MS=300
CONFIG_INT_WDT_CHECK_CPU1=y
CONFIG_TASK_WDT=y
CONFIG_ESP_TASK_WDT=y
# CONFIG_TASK_WDT_PANIC is not set
CONFIG_TASK_WDT_TIMEOUT_S=5
CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU0=y
CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU1=y
# CONFIG_ESP32_DEBUG_STUBS_ENABLE is not set
CONFIG_ESP32S3_DEBUG_OCDAWARE=y
CONFIG_BROWNOUT_DET=y
CONFIG_ESP32S3_BROWNOUT_DET=y
CONFIG_ESP32S3_BROWNOUT_DET=y
CONFIG_BROWNOUT_DET_LVL_SEL_7=y
CONFIG_ESP32S3_BROWNOUT_DET_LVL_SEL_7=y
# CONFIG_BROWNOUT_DET_LVL_SEL_6 is not set
# CONFIG_ESP32S3_BROWNOUT_DET_LVL_SEL_6 is not set
# CONFIG_BROWNOUT_DET_LVL_SEL_5 is not set
# CONFIG_ESP32S3_BROWNOUT_DET_LVL_SEL_5 is not set
# CONFIG_BROWNOUT_DET_LVL_SEL_4 is not set
# CONFIG_ESP32S3_BROWNOUT_DET_LVL_SEL_4 is not set
# CONFIG_BROWNOUT_DET_LVL_SEL_3 is not set
# CONFIG_ESP32S3_BROWNOUT_DET_LVL_SEL_3 is not set
# CONFIG_BROWNOUT_DET_LVL_SEL_2 is not set
# CONFIG_ESP32S3_BROWNOUT_DET_LVL_SEL_2 is not set
# CONFIG_BROWNOUT_DET_LVL_SEL_1 is not set
# CONFIG_ESP32S3_BROWNOUT_DET_LVL_SEL_1 is not set
CONFIG_BROWNOUT_DET_LVL=7
CONFIG_ESP32S3_BROWNOUT_DET_LVL=7
CONFIG_IPC_TASK_STACK_SIZE=1280
CONFIG_TIMER_TASK_STACK_SIZE=3584
CONFIG_ESP32_WIFI_ENABLED=y
CONFIG_ESP32_WIFI_STATIC_RX_BUFFER_NUM=10
CONFIG_ESP32_WIFI_DYNAMIC_RX_BUFFER_NUM=32
# CONFIG_ESP32_WIFI_STATIC_TX_BUFFER is not set
CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER=y
CONFIG_ESP32_WIFI_TX_BUFFER_TYPE=1
CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER_NUM=32
# CONFIG_ESP32_WIFI_CSI_ENABLED is not set
CONFIG_ESP32_WIFI_AMPDU_TX_ENABLED=y
CONFIG_ESP32_WIFI_TX_BA_WIN=6
CONFIG_ESP32_WIFI_AMPDU_RX_ENABLED=y
CONFIG_ESP32_WIFI_AMPDU_RX_ENABLED=y
CONFIG_ESP32_WIFI_RX_BA_WIN=6
CONFIG_ESP32_WIFI_RX_BA_WIN=6
CONFIG_ESP32_WIFI_NVS_ENABLED=y
CONFIG_ESP32_WIFI_TASK_PINNED_TO_CORE_0=y
# CONFIG_ESP32_WIFI_TASK_PINNED_TO_CORE_1 is not set
CONFIG_ESP32_WIFI_SOFTAP_BEACON_MAX_LEN=752
CONFIG_ESP32_WIFI_MGMT_SBUF_NUM=32
CONFIG_ESP32_WIFI_IRAM_OPT=y
CONFIG_ESP32_WIFI_RX_IRAM_OPT=y
CONFIG_ESP32_WIFI_ENABLE_WPA3_SAE=y
CONFIG_ESP32_WIFI_ENABLE_WPA3_OWE_STA=y
CONFIG_WPA_MBEDTLS_CRYPTO=y
CONFIG_WPA_MBEDTLS_TLS_CLIENT=y
# CONFIG_WPA_WAPI_PSK is not set
# CONFIG_WPA_SUITE_B_192 is not set
# CONFIG_WPA_11KV_SUPPORT is not set
# CONFIG_WPA_MBO_SUPPORT is not set
# CONFIG_WPA_DPP_SUPPORT is not set
# CONFIG_WPA_11R_SUPPORT is not set
# CONFIG_WPA_WPS_SOFTAP_REGISTRAR is not set
# CONFIG_WPA_WPS_STRICT is not set
# CONFIG_WPA_DEBUG_PRINT is not set
# CONFIG_WPA_TESTING_OPTIONS is not set
# CONFIG_ESP32_ENABLE_COREDUMP_TO_FLASH is not set
# CONFIG_ESP32_ENABLE_COREDUMP_TO_UART is not set
CONFIG_ESP32_ENABLE_COREDUMP_TO_NONE=y
CONFIG_TIMER_TASK_PRIORITY=1
CONFIG_TIMER_TASK_STACK_DEPTH=2048
CONFIG_TIMER_QUEUE_LENGTH=10
# CONFIG_ENABLE_STATIC_TASK_CLEAN_UP_HOOK is not set
# CONFIG_HAL_ASSERTION_SILIENT is not set
# CONFIG_L2_TO_L3_COPY is not set
CONFIG_ESP_GRATUITOUS_ARP=y
CONFIG_GARP_TMR_INTERVAL=60
CONFIG_TCPIP_RECVMBOX_SIZE=32
CONFIG_TCP_MAXRTX=12
CONFIG_TCP_SYNMAXRTX=12
CONFIG_TCP_MSS=1440
CONFIG_TCP_MSL=60000
CONFIG_TCP_SND_BUF_DEFAULT=5760
CONFIG_TCP_WND_DEFAULT=5760
CONFIG_TCP_RECVMBOX_SIZE=6
CONFIG_TCP_QUEUE_OOSEQ=y
CONFIG_TCP_OVERSIZE_MSS=y
# CONFIG_TCP_OVERSIZE_QUARTER_MSS is not set
# CONFIG_TCP_OVERSIZE_DISABLE is not set
CONFIG_UDP_RECVMBOX_SIZE=6
CONFIG_TCPIP_TASK_STACK_SIZE=3072
CONFIG_TCPIP_TASK_AFFINITY_NO_AFFINITY=y
# CONFIG_TCPIP_TASK_AFFINITY_CPU0 is not set
# CONFIG_TCPIP_TASK_AFFINITY_CPU1 is not set
CONFIG_TCPIP_TASK_AFFINITY=0x7FFFFFFF
# CONFIG_PPP_SUPPORT is not set
CONFIG_ESP32S3_TIME_SYSCALL_USE_RTC_SYSTIMER=y
CONFIG_ESP32S3_TIME_SYSCALL_USE_RTC_FRC1=y
# CONFIG_ESP32S3_TIME_SYSCALL_USE_RTC is not set
# CONFIG_ESP32S3_TIME_SYSCALL_USE_SYSTIMER is not set
# CONFIG_ESP32S3_TIME_SYSCALL_USE_FRC1 is not set
# CONFIG_ESP32S3_TIME_SYSCALL_USE_NONE is not set
CONFIG_ESP32_PTHREAD_TASK_PRIO_DEFAULT=5
CONFIG_ESP32_PTHREAD_TASK_STACK_SIZE_DEFAULT=3072
CONFIG_ESP32_PTHREAD_STACK_MIN=768
CONFIG_ESP32_DEFAULT_PTHREAD_CORE_NO_AFFINITY=y
# CONFIG_ESP32_DEFAULT_PTHREAD_CORE_0 is not set
# CONFIG_ESP32_DEFAULT_PTHREAD_CORE_1 is not set
CONFIG_ESP32_PTHREAD_TASK_CORE_DEFAULT=-1
CONFIG_ESP32_PTHREAD_TASK_NAME_DEFAULT="pthread"
CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_ABORTS=y
# CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_FAILS is not set
# CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_ALLOWED is not set
CONFIG_SUPPRESS_SELECT_DEBUG_OUTPUT=y
CONFIG_SUPPORT_TERMIOS=y
CONFIG_SEMIHOSTFS_MAX_MOUNT_POINTS=1
# End of deprecated options


// File: /Users/devyn/splitr/esp32_wifi_ap_api/CMakeLists.txt
# For more information about build system see
# https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/build-system.html
# The following five lines of boilerplate have to be in your project's
# CMakeLists in this exact order for cmake to work correctly
cmake_minimum_required(VERSION 3.5)

include($ENV{IDF_PATH}/tools/cmake/project.cmake)
project(test-project-1)

// File: /Users/devyn/splitr/esp32_wifi_ap_api/sdkconfig.old
#
# Automatically generated file. DO NOT EDIT.
# Espressif IoT Development Framework (ESP-IDF) 5.5.0 Project Configuration
#
CONFIG_SOC_ADC_SUPPORTED=y
CONFIG_SOC_UART_SUPPORTED=y
CONFIG_SOC_PCNT_SUPPORTED=y
CONFIG_SOC_PHY_SUPPORTED=y
CONFIG_SOC_WIFI_SUPPORTED=y
CONFIG_SOC_TWAI_SUPPORTED=y
CONFIG_SOC_GDMA_SUPPORTED=y
CONFIG_SOC_AHB_GDMA_SUPPORTED=y
CONFIG_SOC_GPTIMER_SUPPORTED=y
CONFIG_SOC_LCDCAM_SUPPORTED=y
CONFIG_SOC_LCDCAM_I80_LCD_SUPPORTED=y
CONFIG_SOC_LCDCAM_RGB_LCD_SUPPORTED=y
CONFIG_SOC_MCPWM_SUPPORTED=y
CONFIG_SOC_DEDICATED_GPIO_SUPPORTED=y
CONFIG_SOC_CACHE_SUPPORT_WRAP=y
CONFIG_SOC_ULP_SUPPORTED=y
CONFIG_SOC_ULP_FSM_SUPPORTED=y
CONFIG_SOC_RISCV_COPROC_SUPPORTED=y
CONFIG_SOC_BT_SUPPORTED=y
CONFIG_SOC_USB_OTG_SUPPORTED=y
CONFIG_SOC_USB_SERIAL_JTAG_SUPPORTED=y
CONFIG_SOC_CCOMP_TIMER_SUPPORTED=y
CONFIG_SOC_ASYNC_MEMCPY_SUPPORTED=y
CONFIG_SOC_SUPPORTS_SECURE_DL_MODE=y
CONFIG_SOC_EFUSE_KEY_PURPOSE_FIELD=y
CONFIG_SOC_EFUSE_SUPPORTED=y
CONFIG_SOC_SDMMC_HOST_SUPPORTED=y
CONFIG_SOC_RTC_FAST_MEM_SUPPORTED=y
CONFIG_SOC_RTC_SLOW_MEM_SUPPORTED=y
CONFIG_SOC_RTC_MEM_SUPPORTED=y
CONFIG_SOC_PSRAM_DMA_CAPABLE=y
CONFIG_SOC_XT_WDT_SUPPORTED=y
CONFIG_SOC_I2S_SUPPORTED=y
CONFIG_SOC_RMT_SUPPORTED=y
CONFIG_SOC_SDM_SUPPORTED=y
CONFIG_SOC_GPSPI_SUPPORTED=y
CONFIG_SOC_LEDC_SUPPORTED=y
CONFIG_SOC_I2C_SUPPORTED=y
CONFIG_SOC_SYSTIMER_SUPPORTED=y
CONFIG_SOC_SUPPORT_COEXISTENCE=y
CONFIG_SOC_TEMP_SENSOR_SUPPORTED=y
CONFIG_SOC_AES_SUPPORTED=y
CONFIG_SOC_MPI_SUPPORTED=y
CONFIG_SOC_SHA_SUPPORTED=y
CONFIG_SOC_HMAC_SUPPORTED=y
CONFIG_SOC_DIG_SIGN_SUPPORTED=y
CONFIG_SOC_FLASH_ENC_SUPPORTED=y
CONFIG_SOC_SECURE_BOOT_SUPPORTED=y
CONFIG_SOC_MEMPROT_SUPPORTED=y
CONFIG_SOC_TOUCH_SENSOR_SUPPORTED=y
CONFIG_SOC_BOD_SUPPORTED=y
CONFIG_SOC_CLK_TREE_SUPPORTED=y
CONFIG_SOC_MPU_SUPPORTED=y
CONFIG_SOC_WDT_SUPPORTED=y
CONFIG_SOC_SPI_FLASH_SUPPORTED=y
CONFIG_SOC_RNG_SUPPORTED=y
CONFIG_SOC_LIGHT_SLEEP_SUPPORTED=y
CONFIG_SOC_DEEP_SLEEP_SUPPORTED=y
CONFIG_SOC_LP_PERIPH_SHARE_INTERRUPT=y
CONFIG_SOC_PM_SUPPORTED=y
CONFIG_SOC_SIMD_INSTRUCTION_SUPPORTED=y
CONFIG_SOC_XTAL_SUPPORT_40M=y
CONFIG_SOC_APPCPU_HAS_CLOCK_GATING_BUG=y
CONFIG_SOC_ADC_RTC_CTRL_SUPPORTED=y
CONFIG_SOC_ADC_DIG_CTRL_SUPPORTED=y
CONFIG_SOC_ADC_ARBITER_SUPPORTED=y
CONFIG_SOC_ADC_DIG_IIR_FILTER_SUPPORTED=y
CONFIG_SOC_ADC_MONITOR_SUPPORTED=y
CONFIG_SOC_ADC_DMA_SUPPORTED=y
CONFIG_SOC_ADC_PERIPH_NUM=2
CONFIG_SOC_ADC_MAX_CHANNEL_NUM=10
CONFIG_SOC_ADC_ATTEN_NUM=4
CONFIG_SOC_ADC_DIGI_CONTROLLER_NUM=2
CONFIG_SOC_ADC_PATT_LEN_MAX=24
CONFIG_SOC_ADC_DIGI_MIN_BITWIDTH=12
CONFIG_SOC_ADC_DIGI_MAX_BITWIDTH=12
CONFIG_SOC_ADC_DIGI_RESULT_BYTES=4
CONFIG_SOC_ADC_DIGI_DATA_BYTES_PER_CONV=4
CONFIG_SOC_ADC_DIGI_IIR_FILTER_NUM=2
CONFIG_SOC_ADC_DIGI_MONITOR_NUM=2
CONFIG_SOC_ADC_SAMPLE_FREQ_THRES_HIGH=83333
CONFIG_SOC_ADC_SAMPLE_FREQ_THRES_LOW=611
CONFIG_SOC_ADC_RTC_MIN_BITWIDTH=12
CONFIG_SOC_ADC_RTC_MAX_BITWIDTH=12
CONFIG_SOC_ADC_CALIBRATION_V1_SUPPORTED=y
CONFIG_SOC_ADC_SELF_HW_CALI_SUPPORTED=y
CONFIG_SOC_ADC_SHARED_POWER=y
CONFIG_SOC_APB_BACKUP_DMA=y
CONFIG_SOC_BROWNOUT_RESET_SUPPORTED=y
CONFIG_SOC_CACHE_WRITEBACK_SUPPORTED=y
CONFIG_SOC_CACHE_FREEZE_SUPPORTED=y
CONFIG_SOC_CACHE_ACS_INVALID_STATE_ON_PANIC=y
CONFIG_SOC_CPU_CORES_NUM=2
CONFIG_SOC_CPU_INTR_NUM=32
CONFIG_SOC_CPU_HAS_FPU=y
CONFIG_SOC_HP_CPU_HAS_MULTIPLE_CORES=y
CONFIG_SOC_CPU_BREAKPOINTS_NUM=2
CONFIG_SOC_CPU_WATCHPOINTS_NUM=2
CONFIG_SOC_CPU_WATCHPOINT_MAX_REGION_SIZE=64
CONFIG_SOC_SIMD_PREFERRED_DATA_ALIGNMENT=16
CONFIG_SOC_DS_SIGNATURE_MAX_BIT_LEN=4096
CONFIG_SOC_DS_KEY_PARAM_MD_IV_LENGTH=16
CONFIG_SOC_DS_KEY_CHECK_MAX_WAIT_US=1100
CONFIG_SOC_AHB_GDMA_VERSION=1
CONFIG_SOC_GDMA_NUM_GROUPS_MAX=1
CONFIG_SOC_GDMA_PAIRS_PER_GROUP=5
CONFIG_SOC_GDMA_PAIRS_PER_GROUP_MAX=5
CONFIG_SOC_AHB_GDMA_SUPPORT_PSRAM=y
CONFIG_SOC_GPIO_PORT=1
CONFIG_SOC_GPIO_PIN_COUNT=49
CONFIG_SOC_GPIO_SUPPORT_PIN_GLITCH_FILTER=y
CONFIG_SOC_GPIO_FILTER_CLK_SUPPORT_APB=y
CONFIG_SOC_GPIO_SUPPORT_RTC_INDEPENDENT=y
CONFIG_SOC_GPIO_SUPPORT_FORCE_HOLD=y
CONFIG_SOC_GPIO_VALID_GPIO_MASK=0x1FFFFFFFFFFFF
CONFIG_SOC_GPIO_IN_RANGE_MAX=48
CONFIG_SOC_GPIO_OUT_RANGE_MAX=48
CONFIG_SOC_GPIO_VALID_DIGITAL_IO_PAD_MASK=0x0001FFFFFC000000
CONFIG_SOC_GPIO_CLOCKOUT_BY_IO_MUX=y
CONFIG_SOC_GPIO_CLOCKOUT_CHANNEL_NUM=3
CONFIG_SOC_GPIO_SUPPORT_HOLD_IO_IN_DSLP=y
CONFIG_SOC_DEDIC_GPIO_OUT_CHANNELS_NUM=8
CONFIG_SOC_DEDIC_GPIO_IN_CHANNELS_NUM=8
CONFIG_SOC_DEDIC_GPIO_OUT_AUTO_ENABLE=y
CONFIG_SOC_I2C_NUM=2
CONFIG_SOC_HP_I2C_NUM=2
CONFIG_SOC_I2C_FIFO_LEN=32
CONFIG_SOC_I2C_CMD_REG_NUM=8
CONFIG_SOC_I2C_SUPPORT_SLAVE=y
CONFIG_SOC_I2C_SUPPORT_HW_CLR_BUS=y
CONFIG_SOC_I2C_SUPPORT_XTAL=y
CONFIG_SOC_I2C_SUPPORT_RTC=y
CONFIG_SOC_I2C_SUPPORT_10BIT_ADDR=y
CONFIG_SOC_I2C_SLAVE_SUPPORT_BROADCAST=y
CONFIG_SOC_I2C_SLAVE_SUPPORT_I2CRAM_ACCESS=y
CONFIG_SOC_I2C_SLAVE_CAN_GET_STRETCH_CAUSE=y
CONFIG_SOC_I2S_NUM=2
CONFIG_SOC_I2S_HW_VERSION_2=y
CONFIG_SOC_I2S_SUPPORTS_XTAL=y
CONFIG_SOC_I2S_SUPPORTS_PLL_F160M=y
CONFIG_SOC_I2S_SUPPORTS_PCM=y
CONFIG_SOC_I2S_SUPPORTS_PDM=y
CONFIG_SOC_I2S_SUPPORTS_PDM_TX=y
CONFIG_SOC_I2S_SUPPORTS_PCM2PDM=y
CONFIG_SOC_I2S_SUPPORTS_PDM_RX=y
CONFIG_SOC_I2S_SUPPORTS_PDM2PCM=y
CONFIG_SOC_I2S_PDM_MAX_TX_LINES=2
CONFIG_SOC_I2S_PDM_MAX_RX_LINES=4
CONFIG_SOC_I2S_SUPPORTS_TDM=y
CONFIG_SOC_LEDC_SUPPORT_APB_CLOCK=y
CONFIG_SOC_LEDC_SUPPORT_XTAL_CLOCK=y
CONFIG_SOC_LEDC_TIMER_NUM=4
CONFIG_SOC_LEDC_CHANNEL_NUM=8
CONFIG_SOC_LEDC_TIMER_BIT_WIDTH=14
CONFIG_SOC_LEDC_SUPPORT_FADE_STOP=y
CONFIG_SOC_MCPWM_GROUPS=2
CONFIG_SOC_MCPWM_TIMERS_PER_GROUP=3
CONFIG_SOC_MCPWM_OPERATORS_PER_GROUP=3
CONFIG_SOC_MCPWM_COMPARATORS_PER_OPERATOR=2
CONFIG_SOC_MCPWM_GENERATORS_PER_OPERATOR=2
CONFIG_SOC_MCPWM_TRIGGERS_PER_OPERATOR=2
CONFIG_SOC_MCPWM_GPIO_FAULTS_PER_GROUP=3
CONFIG_SOC_MCPWM_CAPTURE_TIMERS_PER_GROUP=y
CONFIG_SOC_MCPWM_CAPTURE_CHANNELS_PER_TIMER=3
CONFIG_SOC_MCPWM_GPIO_SYNCHROS_PER_GROUP=3
CONFIG_SOC_MCPWM_SWSYNC_CAN_PROPAGATE=y
CONFIG_SOC_MMU_LINEAR_ADDRESS_REGION_NUM=1
CONFIG_SOC_MMU_PERIPH_NUM=1
CONFIG_SOC_MPU_MIN_REGION_SIZE=0x20000000
CONFIG_SOC_MPU_REGIONS_MAX_NUM=8
CONFIG_SOC_PCNT_GROUPS=1
CONFIG_SOC_PCNT_UNITS_PER_GROUP=4
CONFIG_SOC_PCNT_CHANNELS_PER_UNIT=2
CONFIG_SOC_PCNT_THRES_POINT_PER_UNIT=2
CONFIG_SOC_RMT_GROUPS=1
CONFIG_SOC_RMT_TX_CANDIDATES_PER_GROUP=4
CONFIG_SOC_RMT_RX_CANDIDATES_PER_GROUP=4
CONFIG_SOC_RMT_CHANNELS_PER_GROUP=8
CONFIG_SOC_RMT_MEM_WORDS_PER_CHANNEL=48
CONFIG_SOC_RMT_SUPPORT_RX_PINGPONG=y
CONFIG_SOC_RMT_SUPPORT_RX_DEMODULATION=y
CONFIG_SOC_RMT_SUPPORT_TX_ASYNC_STOP=y
CONFIG_SOC_RMT_SUPPORT_TX_LOOP_COUNT=y
CONFIG_SOC_RMT_SUPPORT_TX_LOOP_AUTO_STOP=y
CONFIG_SOC_RMT_SUPPORT_TX_SYNCHRO=y
CONFIG_SOC_RMT_SUPPORT_TX_CARRIER_DATA_ONLY=y
CONFIG_SOC_RMT_SUPPORT_XTAL=y
CONFIG_SOC_RMT_SUPPORT_RC_FAST=y
CONFIG_SOC_RMT_SUPPORT_APB=y
CONFIG_SOC_RMT_SUPPORT_DMA=y
CONFIG_SOC_LCD_I80_SUPPORTED=y
CONFIG_SOC_LCD_RGB_SUPPORTED=y
CONFIG_SOC_LCD_I80_BUSES=1
CONFIG_SOC_LCD_RGB_PANELS=1
CONFIG_SOC_LCD_I80_BUS_WIDTH=16
CONFIG_SOC_LCD_RGB_DATA_WIDTH=16
CONFIG_SOC_LCD_SUPPORT_RGB_YUV_CONV=y
CONFIG_SOC_LCDCAM_I80_NUM_BUSES=1
CONFIG_SOC_LCDCAM_I80_BUS_WIDTH=16
CONFIG_SOC_LCDCAM_RGB_NUM_PANELS=1
CONFIG_SOC_LCDCAM_RGB_DATA_WIDTH=16
CONFIG_SOC_RTC_CNTL_CPU_PD_DMA_BUS_WIDTH=128
CONFIG_SOC_RTC_CNTL_CPU_PD_REG_FILE_NUM=549
CONFIG_SOC_RTC_CNTL_TAGMEM_PD_DMA_BUS_WIDTH=128
CONFIG_SOC_RTCIO_PIN_COUNT=22
CONFIG_SOC_RTCIO_INPUT_OUTPUT_SUPPORTED=y
CONFIG_SOC_RTCIO_HOLD_SUPPORTED=y
CONFIG_SOC_RTCIO_WAKE_SUPPORTED=y
CONFIG_SOC_LP_IO_CLOCK_IS_INDEPENDENT=y
CONFIG_SOC_SDM_GROUPS=y
CONFIG_SOC_SDM_CHANNELS_PER_GROUP=8
CONFIG_SOC_SDM_CLK_SUPPORT_APB=y
CONFIG_SOC_SPI_PERIPH_NUM=3
CONFIG_SOC_SPI_MAX_CS_NUM=6
CONFIG_SOC_SPI_MAXIMUM_BUFFER_SIZE=64
CONFIG_SOC_SPI_SUPPORT_DDRCLK=y
CONFIG_SOC_SPI_SLAVE_SUPPORT_SEG_TRANS=y
CONFIG_SOC_SPI_SUPPORT_CD_SIG=y
CONFIG_SOC_SPI_SUPPORT_CONTINUOUS_TRANS=y
CONFIG_SOC_SPI_SUPPORT_SLAVE_HD_VER2=y
CONFIG_SOC_SPI_SUPPORT_CLK_APB=y
CONFIG_SOC_SPI_SUPPORT_CLK_XTAL=y
CONFIG_SOC_SPI_PERIPH_SUPPORT_CONTROL_DUMMY_OUT=y
CONFIG_SOC_MEMSPI_IS_INDEPENDENT=y
CONFIG_SOC_SPI_MAX_PRE_DIVIDER=16
CONFIG_SOC_SPI_SUPPORT_OCT=y
CONFIG_SOC_SPI_SCT_SUPPORTED=y
CONFIG_SOC_SPI_SCT_REG_NUM=14
CONFIG_SOC_SPI_SCT_BUFFER_NUM_MAX=y
CONFIG_SOC_SPI_SCT_CONF_BITLEN_MAX=0x3FFFA
CONFIG_SOC_MEMSPI_SRC_FREQ_120M_SUPPORTED=y
CONFIG_SOC_MEMSPI_SRC_FREQ_80M_SUPPORTED=y
CONFIG_SOC_MEMSPI_SRC_FREQ_40M_SUPPORTED=y
CONFIG_SOC_MEMSPI_SRC_FREQ_20M_SUPPORTED=y
CONFIG_SOC_SPIRAM_SUPPORTED=y
CONFIG_SOC_SPIRAM_XIP_SUPPORTED=y
CONFIG_SOC_SYSTIMER_COUNTER_NUM=2
CONFIG_SOC_SYSTIMER_ALARM_NUM=3
CONFIG_SOC_SYSTIMER_BIT_WIDTH_LO=32
CONFIG_SOC_SYSTIMER_BIT_WIDTH_HI=20
CONFIG_SOC_SYSTIMER_FIXED_DIVIDER=y
CONFIG_SOC_SYSTIMER_INT_LEVEL=y
CONFIG_SOC_SYSTIMER_ALARM_MISS_COMPENSATE=y
CONFIG_SOC_TIMER_GROUPS=2
CONFIG_SOC_TIMER_GROUP_TIMERS_PER_GROUP=2
CONFIG_SOC_TIMER_GROUP_COUNTER_BIT_WIDTH=54
CONFIG_SOC_TIMER_GROUP_SUPPORT_XTAL=y
CONFIG_SOC_TIMER_GROUP_SUPPORT_APB=y
CONFIG_SOC_TIMER_GROUP_TOTAL_TIMERS=4
CONFIG_SOC_LP_TIMER_BIT_WIDTH_LO=32
CONFIG_SOC_LP_TIMER_BIT_WIDTH_HI=16
CONFIG_SOC_TOUCH_SENSOR_VERSION=2
CONFIG_SOC_TOUCH_SENSOR_NUM=15
CONFIG_SOC_TOUCH_SUPPORT_BENCHMARK=y
CONFIG_SOC_TOUCH_SUPPORT_SLEEP_WAKEUP=y
CONFIG_SOC_TOUCH_SUPPORT_WATERPROOF=y
CONFIG_SOC_TOUCH_SUPPORT_PROX_SENSING=y
CONFIG_SOC_TOUCH_SUPPORT_DENOISE_CHAN=y
CONFIG_SOC_TOUCH_PROXIMITY_CHANNEL_NUM=3
CONFIG_SOC_TOUCH_PROXIMITY_MEAS_DONE_SUPPORTED=y
CONFIG_SOC_TOUCH_SAMPLE_CFG_NUM=1
CONFIG_SOC_TWAI_CONTROLLER_NUM=1
CONFIG_SOC_TWAI_CLK_SUPPORT_APB=y
CONFIG_SOC_TWAI_BRP_MIN=2
CONFIG_SOC_TWAI_BRP_MAX=16384
CONFIG_SOC_TWAI_SUPPORTS_RX_STATUS=y
CONFIG_SOC_UART_NUM=3
CONFIG_SOC_UART_HP_NUM=3
CONFIG_SOC_UART_FIFO_LEN=128
CONFIG_SOC_UART_BITRATE_MAX=5000000
CONFIG_SOC_UART_SUPPORT_FSM_TX_WAIT_SEND=y
CONFIG_SOC_UART_SUPPORT_WAKEUP_INT=y
CONFIG_SOC_UART_SUPPORT_APB_CLK=y
CONFIG_SOC_UART_SUPPORT_RTC_CLK=y
CONFIG_SOC_UART_SUPPORT_XTAL_CLK=y
CONFIG_SOC_UART_WAKEUP_SUPPORT_ACTIVE_THRESH_MODE=y
CONFIG_SOC_USB_OTG_PERIPH_NUM=1
CONFIG_SOC_SHA_DMA_MAX_BUFFER_SIZE=3968
CONFIG_SOC_SHA_SUPPORT_DMA=y
CONFIG_SOC_SHA_SUPPORT_RESUME=y
CONFIG_SOC_SHA_GDMA=y
CONFIG_SOC_SHA_SUPPORT_SHA1=y
CONFIG_SOC_SHA_SUPPORT_SHA224=y
CONFIG_SOC_SHA_SUPPORT_SHA256=y
CONFIG_SOC_SHA_SUPPORT_SHA384=y
CONFIG_SOC_SHA_SUPPORT_SHA512=y
CONFIG_SOC_SHA_SUPPORT_SHA512_224=y
CONFIG_SOC_SHA_SUPPORT_SHA512_256=y
CONFIG_SOC_SHA_SUPPORT_SHA512_T=y
CONFIG_SOC_MPI_MEM_BLOCKS_NUM=4
CONFIG_SOC_MPI_OPERATIONS_NUM=3
CONFIG_SOC_RSA_MAX_BIT_LEN=4096
CONFIG_SOC_AES_SUPPORT_DMA=y
CONFIG_SOC_AES_GDMA=y
CONFIG_SOC_AES_SUPPORT_AES_128=y
CONFIG_SOC_AES_SUPPORT_AES_256=y
CONFIG_SOC_PM_SUPPORT_EXT0_WAKEUP=y
CONFIG_SOC_PM_SUPPORT_EXT1_WAKEUP=y
CONFIG_SOC_PM_SUPPORT_EXT_WAKEUP=y
CONFIG_SOC_PM_SUPPORT_WIFI_WAKEUP=y
CONFIG_SOC_PM_SUPPORT_BT_WAKEUP=y
CONFIG_SOC_PM_SUPPORT_TOUCH_SENSOR_WAKEUP=y
CONFIG_SOC_PM_SUPPORT_CPU_PD=y
CONFIG_SOC_PM_SUPPORT_TAGMEM_PD=y
CONFIG_SOC_PM_SUPPORT_RTC_PERIPH_PD=y
CONFIG_SOC_PM_SUPPORT_RC_FAST_PD=y
CONFIG_SOC_PM_SUPPORT_VDDSDIO_PD=y
CONFIG_SOC_PM_SUPPORT_MAC_BB_PD=y
CONFIG_SOC_PM_SUPPORT_MODEM_PD=y
CONFIG_SOC_CONFIGURABLE_VDDSDIO_SUPPORTED=y
CONFIG_SOC_PM_SUPPORT_DEEPSLEEP_CHECK_STUB_ONLY=y
CONFIG_SOC_PM_CPU_RETENTION_BY_RTCCNTL=y
CONFIG_SOC_PM_MODEM_RETENTION_BY_BACKUPDMA=y
CONFIG_SOC_PM_MODEM_PD_BY_SW=y
CONFIG_SOC_CLK_RC_FAST_D256_SUPPORTED=y
CONFIG_SOC_RTC_SLOW_CLK_SUPPORT_RC_FAST_D256=y
CONFIG_SOC_CLK_RC_FAST_SUPPORT_CALIBRATION=y
CONFIG_SOC_CLK_XTAL32K_SUPPORTED=y
CONFIG_SOC_CLK_LP_FAST_SUPPORT_XTAL_D2=y
CONFIG_SOC_EFUSE_DIS_DOWNLOAD_ICACHE=y
CONFIG_SOC_EFUSE_DIS_DOWNLOAD_DCACHE=y
CONFIG_SOC_EFUSE_HARD_DIS_JTAG=y
CONFIG_SOC_EFUSE_DIS_USB_JTAG=y
CONFIG_SOC_EFUSE_SOFT_DIS_JTAG=y
CONFIG_SOC_EFUSE_DIS_DIRECT_BOOT=y
CONFIG_SOC_EFUSE_DIS_ICACHE=y
CONFIG_SOC_EFUSE_BLOCK9_KEY_PURPOSE_QUIRK=y
CONFIG_SOC_SECURE_BOOT_V2_RSA=y
CONFIG_SOC_EFUSE_SECURE_BOOT_KEY_DIGESTS=3
CONFIG_SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS=y
CONFIG_SOC_SUPPORT_SECURE_BOOT_REVOKE_KEY=y
CONFIG_SOC_FLASH_ENCRYPTED_XTS_AES_BLOCK_MAX=64
CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES=y
CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES_OPTIONS=y
CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES_128=y
CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES_256=y
CONFIG_SOC_MEMPROT_CPU_PREFETCH_PAD_SIZE=16
CONFIG_SOC_MEMPROT_MEM_ALIGN_SIZE=256
CONFIG_SOC_PHY_DIG_REGS_MEM_SIZE=21
CONFIG_SOC_MAC_BB_PD_MEM_SIZE=192
CONFIG_SOC_WIFI_LIGHT_SLEEP_CLK_WIDTH=12
CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_WAIT_IDLE=y
CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND=y
CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_RESUME=y
CONFIG_SOC_SPI_MEM_SUPPORT_SW_SUSPEND=y
CONFIG_SOC_SPI_MEM_SUPPORT_OPI_MODE=y
CONFIG_SOC_SPI_MEM_SUPPORT_TIMING_TUNING=y
CONFIG_SOC_SPI_MEM_SUPPORT_CONFIG_GPIO_BY_EFUSE=y
CONFIG_SOC_SPI_MEM_SUPPORT_WRAP=y
CONFIG_SOC_MEMSPI_TIMING_TUNING_BY_MSPI_DELAY=y
CONFIG_SOC_MEMSPI_CORE_CLK_SHARED_WITH_PSRAM=y
CONFIG_SOC_SPI_MEM_SUPPORT_CACHE_32BIT_ADDR_MAP=y
CONFIG_SOC_COEX_HW_PTI=y
CONFIG_SOC_EXTERNAL_COEX_LEADER_TX_LINE=y
CONFIG_SOC_SDMMC_USE_GPIO_MATRIX=y
CONFIG_SOC_SDMMC_NUM_SLOTS=2
CONFIG_SOC_SDMMC_SUPPORT_XTAL_CLOCK=y
CONFIG_SOC_SDMMC_DELAY_PHASE_NUM=4
CONFIG_SOC_TEMPERATURE_SENSOR_SUPPORT_FAST_RC=y
CONFIG_SOC_WIFI_HW_TSF=y
CONFIG_SOC_WIFI_FTM_SUPPORT=y
CONFIG_SOC_WIFI_GCMP_SUPPORT=y
CONFIG_SOC_WIFI_WAPI_SUPPORT=y
CONFIG_SOC_WIFI_CSI_SUPPORT=y
CONFIG_SOC_WIFI_MESH_SUPPORT=y
CONFIG_SOC_WIFI_SUPPORT_VARIABLE_BEACON_WINDOW=y
CONFIG_SOC_WIFI_PHY_NEEDS_USB_WORKAROUND=y
CONFIG_SOC_BLE_SUPPORTED=y
CONFIG_SOC_BLE_MESH_SUPPORTED=y
CONFIG_SOC_BLE_50_SUPPORTED=y
CONFIG_SOC_BLE_DEVICE_PRIVACY_SUPPORTED=y
CONFIG_SOC_BLUFI_SUPPORTED=y
CONFIG_SOC_ULP_HAS_ADC=y
CONFIG_SOC_PHY_COMBO_MODULE=y
CONFIG_IDF_CMAKE=y
CONFIG_IDF_TOOLCHAIN="gcc"
CONFIG_IDF_TOOLCHAIN_GCC=y
CONFIG_IDF_TARGET_ARCH_XTENSA=y
CONFIG_IDF_TARGET_ARCH="xtensa"
CONFIG_IDF_TARGET="esp32s3"
CONFIG_IDF_INIT_VERSION="5.5.0"
CONFIG_IDF_TARGET_ESP32S3=y
CONFIG_IDF_FIRMWARE_CHIP_ID=0x0009

#
# Build type
#
CONFIG_APP_BUILD_TYPE_APP_2NDBOOT=y
# CONFIG_APP_BUILD_TYPE_RAM is not set
CONFIG_APP_BUILD_GENERATE_BINARIES=y
CONFIG_APP_BUILD_BOOTLOADER=y
CONFIG_APP_BUILD_USE_FLASH_SECTIONS=y
# CONFIG_APP_REPRODUCIBLE_BUILD is not set
# CONFIG_APP_NO_BLOBS is not set
# end of Build type

#
# Bootloader config
#

#
# Bootloader manager
#
CONFIG_BOOTLOADER_COMPILE_TIME_DATE=y
CONFIG_BOOTLOADER_PROJECT_VER=1
# end of Bootloader manager

#
# Application Rollback
#
# CONFIG_BOOTLOADER_APP_ROLLBACK_ENABLE is not set
# end of Application Rollback

#
# Bootloader Rollback
#
# end of Bootloader Rollback

CONFIG_BOOTLOADER_OFFSET_IN_FLASH=0x0
CONFIG_BOOTLOADER_COMPILER_OPTIMIZATION_SIZE=y
# CONFIG_BOOTLOADER_COMPILER_OPTIMIZATION_DEBUG is not set
# CONFIG_BOOTLOADER_COMPILER_OPTIMIZATION_PERF is not set
# CONFIG_BOOTLOADER_COMPILER_OPTIMIZATION_NONE is not set

#
# Log
#
CONFIG_BOOTLOADER_LOG_VERSION_1=y
CONFIG_BOOTLOADER_LOG_VERSION=1
# CONFIG_BOOTLOADER_LOG_LEVEL_NONE is not set
# CONFIG_BOOTLOADER_LOG_LEVEL_ERROR is not set
# CONFIG_BOOTLOADER_LOG_LEVEL_WARN is not set
CONFIG_BOOTLOADER_LOG_LEVEL_INFO=y
# CONFIG_BOOTLOADER_LOG_LEVEL_DEBUG is not set
# CONFIG_BOOTLOADER_LOG_LEVEL_VERBOSE is not set
CONFIG_BOOTLOADER_LOG_LEVEL=3

#
# Format
#
# CONFIG_BOOTLOADER_LOG_COLORS is not set
CONFIG_BOOTLOADER_LOG_TIMESTAMP_SOURCE_CPU_TICKS=y
# end of Format
# end of Log

#
# Serial Flash Configurations
#
# CONFIG_BOOTLOADER_FLASH_DC_AWARE is not set
CONFIG_BOOTLOADER_FLASH_XMC_SUPPORT=y
# end of Serial Flash Configurations

CONFIG_BOOTLOADER_VDDSDIO_BOOST_1_9V=y
# CONFIG_BOOTLOADER_FACTORY_RESET is not set
# CONFIG_BOOTLOADER_APP_TEST is not set
CONFIG_BOOTLOADER_REGION_PROTECTION_ENABLE=y
CONFIG_BOOTLOADER_WDT_ENABLE=y
# CONFIG_BOOTLOADER_WDT_DISABLE_IN_USER_CODE is not set
CONFIG_BOOTLOADER_WDT_TIME_MS=9000
# CONFIG_BOOTLOADER_SKIP_VALIDATE_IN_DEEP_SLEEP is not set
# CONFIG_BOOTLOADER_SKIP_VALIDATE_ON_POWER_ON is not set
# CONFIG_BOOTLOADER_SKIP_VALIDATE_ALWAYS is not set
CONFIG_BOOTLOADER_RESERVE_RTC_SIZE=0
# CONFIG_BOOTLOADER_CUSTOM_RESERVE_RTC is not set
# end of Bootloader config

#
# Security features
#
CONFIG_SECURE_BOOT_V2_RSA_SUPPORTED=y
CONFIG_SECURE_BOOT_V2_PREFERRED=y
# CONFIG_SECURE_SIGNED_APPS_NO_SECURE_BOOT is not set
# CONFIG_SECURE_BOOT is not set
# CONFIG_SECURE_FLASH_ENC_ENABLED is not set
CONFIG_SECURE_ROM_DL_MODE_ENABLED=y
# end of Security features

#
# Application manager
#
CONFIG_APP_COMPILE_TIME_DATE=y
# CONFIG_APP_EXCLUDE_PROJECT_VER_VAR is not set
# CONFIG_APP_EXCLUDE_PROJECT_NAME_VAR is not set
# CONFIG_APP_PROJECT_VER_FROM_CONFIG is not set
CONFIG_APP_RETRIEVE_LEN_ELF_SHA=9
# end of Application manager

CONFIG_ESP_ROM_HAS_CRC_LE=y
CONFIG_ESP_ROM_HAS_CRC_BE=y
CONFIG_ESP_ROM_HAS_MZ_CRC32=y
CONFIG_ESP_ROM_HAS_JPEG_DECODE=y
CONFIG_ESP_ROM_UART_CLK_IS_XTAL=y
CONFIG_ESP_ROM_HAS_RETARGETABLE_LOCKING=y
CONFIG_ESP_ROM_USB_OTG_NUM=3
CONFIG_ESP_ROM_USB_SERIAL_DEVICE_NUM=4
CONFIG_ESP_ROM_HAS_ERASE_0_REGION_BUG=y
CONFIG_ESP_ROM_HAS_ENCRYPTED_WRITES_USING_LEGACY_DRV=y
CONFIG_ESP_ROM_GET_CLK_FREQ=y
CONFIG_ESP_ROM_HAS_HAL_WDT=y
CONFIG_ESP_ROM_NEEDS_SWSETUP_WORKAROUND=y
CONFIG_ESP_ROM_HAS_LAYOUT_TABLE=y
CONFIG_ESP_ROM_HAS_SPI_FLASH=y
CONFIG_ESP_ROM_HAS_ETS_PRINTF_BUG=y
CONFIG_ESP_ROM_HAS_NEWLIB=y
CONFIG_ESP_ROM_HAS_NEWLIB_NANO_FORMAT=y
CONFIG_ESP_ROM_HAS_NEWLIB_32BIT_TIME=y
CONFIG_ESP_ROM_NEEDS_SET_CACHE_MMU_SIZE=y
CONFIG_ESP_ROM_RAM_APP_NEEDS_MMU_INIT=y
CONFIG_ESP_ROM_HAS_FLASH_COUNT_PAGES_BUG=y
CONFIG_ESP_ROM_HAS_CACHE_SUSPEND_WAITI_BUG=y
CONFIG_ESP_ROM_HAS_CACHE_WRITEBACK_BUG=y
CONFIG_ESP_ROM_HAS_SW_FLOAT=y
CONFIG_ESP_ROM_HAS_VERSION=y
CONFIG_ESP_ROM_SUPPORT_DEEP_SLEEP_WAKEUP_STUB=y
CONFIG_ESP_ROM_HAS_OUTPUT_PUTC_FUNC=y

#
# Boot ROM Behavior
#
CONFIG_BOOT_ROM_LOG_ALWAYS_ON=y
# CONFIG_BOOT_ROM_LOG_ALWAYS_OFF is not set
# CONFIG_BOOT_ROM_LOG_ON_GPIO_HIGH is not set
# CONFIG_BOOT_ROM_LOG_ON_GPIO_LOW is not set
# end of Boot ROM Behavior

#
# Serial flasher config
#
# CONFIG_ESPTOOLPY_NO_STUB is not set
# CONFIG_ESPTOOLPY_OCT_FLASH is not set
CONFIG_ESPTOOLPY_FLASH_MODE_AUTO_DETECT=y
# CONFIG_ESPTOOLPY_FLASHMODE_QIO is not set
# CONFIG_ESPTOOLPY_FLASHMODE_QOUT is not set
CONFIG_ESPTOOLPY_FLASHMODE_DIO=y
# CONFIG_ESPTOOLPY_FLASHMODE_DOUT is not set
CONFIG_ESPTOOLPY_FLASH_SAMPLE_MODE_STR=y
CONFIG_ESPTOOLPY_FLASHMODE="dio"
# CONFIG_ESPTOOLPY_FLASHFREQ_120M is not set
CONFIG_ESPTOOLPY_FLASHFREQ_80M=y
# CONFIG_ESPTOOLPY_FLASHFREQ_40M is not set
# CONFIG_ESPTOOLPY_FLASHFREQ_20M is not set
CONFIG_ESPTOOLPY_FLASHFREQ="80m"
# CONFIG_ESPTOOLPY_FLASHSIZE_1MB is not set
CONFIG_ESPTOOLPY_FLASHSIZE_2MB=y
# CONFIG_ESPTOOLPY_FLASHSIZE_4MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_8MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_16MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_32MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_64MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_128MB is not set
CONFIG_ESPTOOLPY_FLASHSIZE="2MB"
# CONFIG_ESPTOOLPY_HEADER_FLASHSIZE_UPDATE is not set
CONFIG_ESPTOOLPY_BEFORE_RESET=y
# CONFIG_ESPTOOLPY_BEFORE_NORESET is not set
CONFIG_ESPTOOLPY_BEFORE="default_reset"
CONFIG_ESPTOOLPY_AFTER_RESET=y
# CONFIG_ESPTOOLPY_AFTER_NORESET is not set
CONFIG_ESPTOOLPY_AFTER="hard_reset"
CONFIG_ESPTOOLPY_MONITOR_BAUD=115200
# end of Serial flasher config

#
# Partition Table
#
CONFIG_PARTITION_TABLE_SINGLE_APP=y
# CONFIG_PARTITION_TABLE_SINGLE_APP_LARGE is not set
# CONFIG_PARTITION_TABLE_TWO_OTA is not set
# CONFIG_PARTITION_TABLE_TWO_OTA_LARGE is not set
# CONFIG_PARTITION_TABLE_CUSTOM is not set
CONFIG_PARTITION_TABLE_CUSTOM_FILENAME="partitions.csv"
CONFIG_PARTITION_TABLE_FILENAME="partitions_singleapp.csv"
CONFIG_PARTITION_TABLE_OFFSET=0x8000
CONFIG_PARTITION_TABLE_MD5=y
# end of Partition Table

#
# Compiler options
#
CONFIG_COMPILER_OPTIMIZATION_DEBUG=y
# CONFIG_COMPILER_OPTIMIZATION_SIZE is not set
# CONFIG_COMPILER_OPTIMIZATION_PERF is not set
# CONFIG_COMPILER_OPTIMIZATION_NONE is not set
CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_ENABLE=y
# CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_SILENT is not set
# CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_DISABLE is not set
CONFIG_COMPILER_ASSERT_NDEBUG_EVALUATE=y
CONFIG_COMPILER_FLOAT_LIB_FROM_GCCLIB=y
CONFIG_COMPILER_OPTIMIZATION_ASSERTION_LEVEL=2
# CONFIG_COMPILER_OPTIMIZATION_CHECKS_SILENT is not set
CONFIG_COMPILER_HIDE_PATHS_MACROS=y
# CONFIG_COMPILER_CXX_EXCEPTIONS is not set
# CONFIG_COMPILER_CXX_RTTI is not set
CONFIG_COMPILER_STACK_CHECK_MODE_NONE=y
# CONFIG_COMPILER_STACK_CHECK_MODE_NORM is not set
# CONFIG_COMPILER_STACK_CHECK_MODE_STRONG is not set
# CONFIG_COMPILER_STACK_CHECK_MODE_ALL is not set
# CONFIG_COMPILER_NO_MERGE_CONSTANTS is not set
# CONFIG_COMPILER_WARN_WRITE_STRINGS is not set
CONFIG_COMPILER_DISABLE_DEFAULT_ERRORS=y
# CONFIG_COMPILER_DISABLE_GCC12_WARNINGS is not set
# CONFIG_COMPILER_DISABLE_GCC13_WARNINGS is not set
# CONFIG_COMPILER_DISABLE_GCC14_WARNINGS is not set
# CONFIG_COMPILER_DUMP_RTL_FILES is not set
CONFIG_COMPILER_RT_LIB_GCCLIB=y
CONFIG_COMPILER_RT_LIB_NAME="gcc"
CONFIG_COMPILER_ORPHAN_SECTIONS_WARNING=y
# CONFIG_COMPILER_ORPHAN_SECTIONS_PLACE is not set
# CONFIG_COMPILER_STATIC_ANALYZER is not set
# end of Compiler options

#
# Component config
#

#
# Application Level Tracing
#
# CONFIG_APPTRACE_DEST_JTAG is not set
CONFIG_APPTRACE_DEST_NONE=y
# CONFIG_APPTRACE_DEST_UART1 is not set
# CONFIG_APPTRACE_DEST_UART2 is not set
# CONFIG_APPTRACE_DEST_USB_CDC is not set
CONFIG_APPTRACE_DEST_UART_NONE=y
CONFIG_APPTRACE_UART_TASK_PRIO=1
CONFIG_APPTRACE_LOCK_ENABLE=y
# end of Application Level Tracing

#
# Bluetooth
#
# CONFIG_BT_ENABLED is not set

#
# Common Options
#
# CONFIG_BT_BLE_LOG_SPI_OUT_ENABLED is not set
# end of Common Options
# end of Bluetooth

#
# Console Library
#
# CONFIG_CONSOLE_SORTED_HELP is not set
# end of Console Library

#
# Driver Configurations
#

#
# TWAI Configuration
#
# CONFIG_TWAI_ISR_IN_IRAM is not set
CONFIG_TWAI_ERRATA_FIX_LISTEN_ONLY_DOM=y
# end of TWAI Configuration

#
# Legacy ADC Driver Configuration
#
# CONFIG_ADC_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_ADC_SKIP_LEGACY_CONFLICT_CHECK is not set

#
# Legacy ADC Calibration Configuration
#
# CONFIG_ADC_CALI_SUPPRESS_DEPRECATE_WARN is not set
# end of Legacy ADC Calibration Configuration
# end of Legacy ADC Driver Configuration

#
# Legacy MCPWM Driver Configurations
#
# CONFIG_MCPWM_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_MCPWM_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy MCPWM Driver Configurations

#
# Legacy Timer Group Driver Configurations
#
# CONFIG_GPTIMER_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_GPTIMER_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy Timer Group Driver Configurations

#
# Legacy RMT Driver Configurations
#
# CONFIG_RMT_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_RMT_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy RMT Driver Configurations

#
# Legacy I2S Driver Configurations
#
# CONFIG_I2S_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_I2S_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy I2S Driver Configurations

#
# Legacy PCNT Driver Configurations
#
# CONFIG_PCNT_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_PCNT_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy PCNT Driver Configurations

#
# Legacy SDM Driver Configurations
#
# CONFIG_SDM_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_SDM_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy SDM Driver Configurations

#
# Legacy Temperature Sensor Driver Configurations
#
# CONFIG_TEMP_SENSOR_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_TEMP_SENSOR_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy Temperature Sensor Driver Configurations

#
# Legacy Touch Sensor Driver Configurations
#
# CONFIG_TOUCH_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_TOUCH_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy Touch Sensor Driver Configurations
# end of Driver Configurations

#
# eFuse Bit Manager
#
# CONFIG_EFUSE_CUSTOM_TABLE is not set
# CONFIG_EFUSE_VIRTUAL is not set
CONFIG_EFUSE_MAX_BLK_LEN=256
# end of eFuse Bit Manager

#
# ESP-TLS
#
CONFIG_ESP_TLS_USING_MBEDTLS=y
# CONFIG_ESP_TLS_USE_SECURE_ELEMENT is not set
CONFIG_ESP_TLS_USE_DS_PERIPHERAL=y
# CONFIG_ESP_TLS_CLIENT_SESSION_TICKETS is not set
# CONFIG_ESP_TLS_SERVER_SESSION_TICKETS is not set
# CONFIG_ESP_TLS_SERVER_CERT_SELECT_HOOK is not set
# CONFIG_ESP_TLS_SERVER_MIN_AUTH_MODE_OPTIONAL is not set
# CONFIG_ESP_TLS_PSK_VERIFICATION is not set
# CONFIG_ESP_TLS_INSECURE is not set
# end of ESP-TLS

#
# ADC and ADC Calibration
#
# CONFIG_ADC_ONESHOT_CTRL_FUNC_IN_IRAM is not set
# CONFIG_ADC_CONTINUOUS_ISR_IRAM_SAFE is not set
# CONFIG_ADC_CONTINUOUS_FORCE_USE_ADC2_ON_C3_S3 is not set
# CONFIG_ADC_ENABLE_DEBUG_LOG is not set
# end of ADC and ADC Calibration

#
# Wireless Coexistence
#
CONFIG_ESP_COEX_ENABLED=y
# CONFIG_ESP_COEX_EXTERNAL_COEXIST_ENABLE is not set
# CONFIG_ESP_COEX_GPIO_DEBUG is not set
# end of Wireless Coexistence

#
# Common ESP-related
#
CONFIG_ESP_ERR_TO_NAME_LOOKUP=y
# end of Common ESP-related

#
# ESP-Driver:GPIO Configurations
#
# CONFIG_GPIO_CTRL_FUNC_IN_IRAM is not set
# end of ESP-Driver:GPIO Configurations

#
# ESP-Driver:GPTimer Configurations
#
CONFIG_GPTIMER_ISR_HANDLER_IN_IRAM=y
# CONFIG_GPTIMER_CTRL_FUNC_IN_IRAM is not set
# CONFIG_GPTIMER_ISR_CACHE_SAFE is not set
CONFIG_GPTIMER_OBJ_CACHE_SAFE=y
# CONFIG_GPTIMER_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:GPTimer Configurations

#
# ESP-Driver:I2C Configurations
#
# CONFIG_I2C_ISR_IRAM_SAFE is not set
# CONFIG_I2C_ENABLE_DEBUG_LOG is not set
# CONFIG_I2C_ENABLE_SLAVE_DRIVER_VERSION_2 is not set
CONFIG_I2C_MASTER_ISR_HANDLER_IN_IRAM=y
# end of ESP-Driver:I2C Configurations

#
# ESP-Driver:I2S Configurations
#
# CONFIG_I2S_ISR_IRAM_SAFE is not set
# CONFIG_I2S_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:I2S Configurations

#
# ESP-Driver:LEDC Configurations
#
# CONFIG_LEDC_CTRL_FUNC_IN_IRAM is not set
# end of ESP-Driver:LEDC Configurations

#
# ESP-Driver:MCPWM Configurations
#
# CONFIG_MCPWM_ISR_IRAM_SAFE is not set
# CONFIG_MCPWM_CTRL_FUNC_IN_IRAM is not set
# CONFIG_MCPWM_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:MCPWM Configurations

#
# ESP-Driver:PCNT Configurations
#
# CONFIG_PCNT_CTRL_FUNC_IN_IRAM is not set
# CONFIG_PCNT_ISR_IRAM_SAFE is not set
# CONFIG_PCNT_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:PCNT Configurations

#
# ESP-Driver:RMT Configurations
#
CONFIG_RMT_ISR_HANDLER_IN_IRAM=y
# CONFIG_RMT_RECV_FUNC_IN_IRAM is not set
# CONFIG_RMT_ISR_CACHE_SAFE is not set
CONFIG_RMT_OBJ_CACHE_SAFE=y
# CONFIG_RMT_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:RMT Configurations

#
# ESP-Driver:Sigma Delta Modulator Configurations
#
# CONFIG_SDM_CTRL_FUNC_IN_IRAM is not set
# CONFIG_SDM_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:Sigma Delta Modulator Configurations

#
# ESP-Driver:SPI Configurations
#
# CONFIG_SPI_MASTER_IN_IRAM is not set
CONFIG_SPI_MASTER_ISR_IN_IRAM=y
# CONFIG_SPI_SLAVE_IN_IRAM is not set
CONFIG_SPI_SLAVE_ISR_IN_IRAM=y
# end of ESP-Driver:SPI Configurations

#
# ESP-Driver:Touch Sensor Configurations
#
# CONFIG_TOUCH_CTRL_FUNC_IN_IRAM is not set
# CONFIG_TOUCH_ISR_IRAM_SAFE is not set
# CONFIG_TOUCH_ENABLE_DEBUG_LOG is not set
# CONFIG_TOUCH_SKIP_FSM_CHECK is not set
# end of ESP-Driver:Touch Sensor Configurations

#
# ESP-Driver:Temperature Sensor Configurations
#
# CONFIG_TEMP_SENSOR_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:Temperature Sensor Configurations

#
# ESP-Driver:UART Configurations
#
# CONFIG_UART_ISR_IN_IRAM is not set
# end of ESP-Driver:UART Configurations

#
# ESP-Driver:USB Serial/JTAG Configuration
#
CONFIG_USJ_ENABLE_USB_SERIAL_JTAG=y
# end of ESP-Driver:USB Serial/JTAG Configuration

#
# Ethernet
#
CONFIG_ETH_ENABLED=y
CONFIG_ETH_USE_SPI_ETHERNET=y
# CONFIG_ETH_SPI_ETHERNET_DM9051 is not set
# CONFIG_ETH_SPI_ETHERNET_W5500 is not set
# CONFIG_ETH_SPI_ETHERNET_KSZ8851SNL is not set
# CONFIG_ETH_USE_OPENETH is not set
# CONFIG_ETH_TRANSMIT_MUTEX is not set
# end of Ethernet

#
# Event Loop Library
#
# CONFIG_ESP_EVENT_LOOP_PROFILING is not set
CONFIG_ESP_EVENT_POST_FROM_ISR=y
CONFIG_ESP_EVENT_POST_FROM_IRAM_ISR=y
# end of Event Loop Library

#
# GDB Stub
#
CONFIG_ESP_GDBSTUB_ENABLED=y
# CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME is not set
CONFIG_ESP_GDBSTUB_SUPPORT_TASKS=y
CONFIG_ESP_GDBSTUB_MAX_TASKS=32
# end of GDB Stub

#
# ESP HID
#
CONFIG_ESPHID_TASK_SIZE_BT=2048
CONFIG_ESPHID_TASK_SIZE_BLE=4096
# end of ESP HID

#
# ESP HTTP client
#
CONFIG_ESP_HTTP_CLIENT_ENABLE_HTTPS=y
# CONFIG_ESP_HTTP_CLIENT_ENABLE_BASIC_AUTH is not set
# CONFIG_ESP_HTTP_CLIENT_ENABLE_DIGEST_AUTH is not set
# CONFIG_ESP_HTTP_CLIENT_ENABLE_CUSTOM_TRANSPORT is not set
CONFIG_ESP_HTTP_CLIENT_EVENT_POST_TIMEOUT=2000
# end of ESP HTTP client

#
# HTTP Server
#
CONFIG_HTTPD_MAX_REQ_HDR_LEN=1024
CONFIG_HTTPD_MAX_URI_LEN=512
CONFIG_HTTPD_ERR_RESP_NO_DELAY=y
CONFIG_HTTPD_PURGE_BUF_LEN=32
# CONFIG_HTTPD_LOG_PURGE_DATA is not set
# CONFIG_HTTPD_WS_SUPPORT is not set
# CONFIG_HTTPD_QUEUE_WORK_BLOCKING is not set
CONFIG_HTTPD_SERVER_EVENT_POST_TIMEOUT=2000
# end of HTTP Server

#
# ESP HTTPS OTA
#
# CONFIG_ESP_HTTPS_OTA_DECRYPT_CB is not set
# CONFIG_ESP_HTTPS_OTA_ALLOW_HTTP is not set
CONFIG_ESP_HTTPS_OTA_EVENT_POST_TIMEOUT=2000
# end of ESP HTTPS OTA

#
# ESP HTTPS server
#
# CONFIG_ESP_HTTPS_SERVER_ENABLE is not set
CONFIG_ESP_HTTPS_SERVER_EVENT_POST_TIMEOUT=2000
# CONFIG_ESP_HTTPS_SERVER_CERT_SELECT_HOOK is not set
# end of ESP HTTPS server

#
# Hardware Settings
#

#
# Chip revision
#
CONFIG_ESP32S3_REV_MIN_0=y
# CONFIG_ESP32S3_REV_MIN_1 is not set
# CONFIG_ESP32S3_REV_MIN_2 is not set
CONFIG_ESP32S3_REV_MIN_FULL=0
CONFIG_ESP_REV_MIN_FULL=0

#
# Maximum Supported ESP32-S3 Revision (Rev v0.99)
#
CONFIG_ESP32S3_REV_MAX_FULL=99
CONFIG_ESP_REV_MAX_FULL=99
CONFIG_ESP_EFUSE_BLOCK_REV_MIN_FULL=0
CONFIG_ESP_EFUSE_BLOCK_REV_MAX_FULL=199

#
# Maximum Supported ESP32-S3 eFuse Block Revision (eFuse Block Rev v1.99)
#
# end of Chip revision

#
# MAC Config
#
CONFIG_ESP_MAC_ADDR_UNIVERSE_WIFI_STA=y
CONFIG_ESP_MAC_ADDR_UNIVERSE_WIFI_AP=y
CONFIG_ESP_MAC_ADDR_UNIVERSE_BT=y
CONFIG_ESP_MAC_ADDR_UNIVERSE_ETH=y
CONFIG_ESP_MAC_UNIVERSAL_MAC_ADDRESSES_FOUR=y
CONFIG_ESP_MAC_UNIVERSAL_MAC_ADDRESSES=4
# CONFIG_ESP32S3_UNIVERSAL_MAC_ADDRESSES_TWO is not set
CONFIG_ESP32S3_UNIVERSAL_MAC_ADDRESSES_FOUR=y
CONFIG_ESP32S3_UNIVERSAL_MAC_ADDRESSES=4
# CONFIG_ESP_MAC_USE_CUSTOM_MAC_AS_BASE_MAC is not set
# end of MAC Config

#
# Sleep Config
#
# CONFIG_ESP_SLEEP_POWER_DOWN_FLASH is not set
CONFIG_ESP_SLEEP_FLASH_LEAKAGE_WORKAROUND=y
CONFIG_ESP_SLEEP_MSPI_NEED_ALL_IO_PU=y
CONFIG_ESP_SLEEP_RTC_BUS_ISO_WORKAROUND=y
CONFIG_ESP_SLEEP_GPIO_RESET_WORKAROUND=y
CONFIG_ESP_SLEEP_WAIT_FLASH_READY_EXTRA_DELAY=2000
# CONFIG_ESP_SLEEP_CACHE_SAFE_ASSERTION is not set
# CONFIG_ESP_SLEEP_DEBUG is not set
CONFIG_ESP_SLEEP_GPIO_ENABLE_INTERNAL_RESISTORS=y
# end of Sleep Config

#
# RTC Clock Config
#
CONFIG_RTC_CLK_SRC_INT_RC=y
# CONFIG_RTC_CLK_SRC_EXT_CRYS is not set
# CONFIG_RTC_CLK_SRC_EXT_OSC is not set
# CONFIG_RTC_CLK_SRC_INT_8MD256 is not set
CONFIG_RTC_CLK_CAL_CYCLES=1024
# end of RTC Clock Config

#
# Peripheral Control
#
CONFIG_PERIPH_CTRL_FUNC_IN_IRAM=y
# end of Peripheral Control

#
# GDMA Configurations
#
CONFIG_GDMA_CTRL_FUNC_IN_IRAM=y
# CONFIG_GDMA_ISR_IRAM_SAFE is not set
CONFIG_GDMA_OBJ_DRAM_SAFE=y
# CONFIG_GDMA_ENABLE_DEBUG_LOG is not set
# end of GDMA Configurations

#
# Main XTAL Config
#
CONFIG_XTAL_FREQ_40=y
CONFIG_XTAL_FREQ=40
# end of Main XTAL Config

#
# Power Supplier
#

#
# Brownout Detector
#
CONFIG_ESP_BROWNOUT_DET=y
CONFIG_ESP_BROWNOUT_DET_LVL_SEL_7=y
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_6 is not set
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_5 is not set
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_4 is not set
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_3 is not set
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_2 is not set
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_1 is not set
CONFIG_ESP_BROWNOUT_DET_LVL=7
CONFIG_ESP_BROWNOUT_USE_INTR=y
# end of Brownout Detector
# end of Power Supplier

CONFIG_ESP_SPI_BUS_LOCK_ISR_FUNCS_IN_IRAM=y
# end of Hardware Settings

#
# ESP-Driver:LCD Controller Configurations
#
# CONFIG_LCD_ENABLE_DEBUG_LOG is not set
# CONFIG_LCD_RGB_ISR_IRAM_SAFE is not set
# CONFIG_LCD_RGB_RESTART_IN_VSYNC is not set
# end of ESP-Driver:LCD Controller Configurations

#
# ESP-MM: Memory Management Configurations
#
# CONFIG_ESP_MM_CACHE_MSYNC_C2M_CHUNKED_OPS is not set
# end of ESP-MM: Memory Management Configurations

#
# ESP NETIF Adapter
#
CONFIG_ESP_NETIF_IP_LOST_TIMER_INTERVAL=120
# CONFIG_ESP_NETIF_PROVIDE_CUSTOM_IMPLEMENTATION is not set
CONFIG_ESP_NETIF_TCPIP_LWIP=y
# CONFIG_ESP_NETIF_LOOPBACK is not set
CONFIG_ESP_NETIF_USES_TCPIP_WITH_BSD_API=y
CONFIG_ESP_NETIF_REPORT_DATA_TRAFFIC=y
# CONFIG_ESP_NETIF_RECEIVE_REPORT_ERRORS is not set
# CONFIG_ESP_NETIF_L2_TAP is not set
# CONFIG_ESP_NETIF_BRIDGE_EN is not set
# CONFIG_ESP_NETIF_SET_DNS_PER_DEFAULT_NETIF is not set
# end of ESP NETIF Adapter

#
# Partition API Configuration
#
# end of Partition API Configuration

#
# PHY
#
CONFIG_ESP_PHY_ENABLED=y
CONFIG_ESP_PHY_CALIBRATION_AND_DATA_STORAGE=y
# CONFIG_ESP_PHY_INIT_DATA_IN_PARTITION is not set
CONFIG_ESP_PHY_MAX_WIFI_TX_POWER=20
CONFIG_ESP_PHY_MAX_TX_POWER=20
# CONFIG_ESP_PHY_REDUCE_TX_POWER is not set
CONFIG_ESP_PHY_ENABLE_USB=y
# CONFIG_ESP_PHY_ENABLE_CERT_TEST is not set
CONFIG_ESP_PHY_RF_CAL_PARTIAL=y
# CONFIG_ESP_PHY_RF_CAL_NONE is not set
# CONFIG_ESP_PHY_RF_CAL_FULL is not set
CONFIG_ESP_PHY_CALIBRATION_MODE=0
# CONFIG_ESP_PHY_PLL_TRACK_DEBUG is not set
# CONFIG_ESP_PHY_RECORD_USED_TIME is not set
# end of PHY

#
# Power Management
#
# CONFIG_PM_ENABLE is not set
# CONFIG_PM_SLP_IRAM_OPT is not set
CONFIG_PM_POWER_DOWN_CPU_IN_LIGHT_SLEEP=y
CONFIG_PM_RESTORE_CACHE_TAGMEM_AFTER_LIGHT_SLEEP=y
# end of Power Management

#
# ESP PSRAM
#
# CONFIG_SPIRAM is not set
# end of ESP PSRAM

#
# ESP Ringbuf
#
# CONFIG_RINGBUF_PLACE_FUNCTIONS_INTO_FLASH is not set
# end of ESP Ringbuf

#
# ESP Security Specific
#
# end of ESP Security Specific

#
# ESP System Settings
#
# CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_80 is not set
CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_160=y
# CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_240 is not set
CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ=160

#
# Cache config
#
CONFIG_ESP32S3_INSTRUCTION_CACHE_16KB=y
# CONFIG_ESP32S3_INSTRUCTION_CACHE_32KB is not set
CONFIG_ESP32S3_INSTRUCTION_CACHE_SIZE=0x4000
# CONFIG_ESP32S3_INSTRUCTION_CACHE_4WAYS is not set
CONFIG_ESP32S3_INSTRUCTION_CACHE_8WAYS=y
CONFIG_ESP32S3_ICACHE_ASSOCIATED_WAYS=8
# CONFIG_ESP32S3_INSTRUCTION_CACHE_LINE_16B is not set
CONFIG_ESP32S3_INSTRUCTION_CACHE_LINE_32B=y
CONFIG_ESP32S3_INSTRUCTION_CACHE_LINE_SIZE=32
# CONFIG_ESP32S3_DATA_CACHE_16KB is not set
CONFIG_ESP32S3_DATA_CACHE_32KB=y
# CONFIG_ESP32S3_DATA_CACHE_64KB is not set
CONFIG_ESP32S3_DATA_CACHE_SIZE=0x8000
# CONFIG_ESP32S3_DATA_CACHE_4WAYS is not set
CONFIG_ESP32S3_DATA_CACHE_8WAYS=y
CONFIG_ESP32S3_DCACHE_ASSOCIATED_WAYS=8
# CONFIG_ESP32S3_DATA_CACHE_LINE_16B is not set
CONFIG_ESP32S3_DATA_CACHE_LINE_32B=y
# CONFIG_ESP32S3_DATA_CACHE_LINE_64B is not set
CONFIG_ESP32S3_DATA_CACHE_LINE_SIZE=32
# end of Cache config

#
# Memory
#
# CONFIG_ESP32S3_RTCDATA_IN_FAST_MEM is not set
# CONFIG_ESP32S3_USE_FIXED_STATIC_RAM_SIZE is not set
# end of Memory

#
# Trace memory
#
# CONFIG_ESP32S3_TRAX is not set
CONFIG_ESP32S3_TRACEMEM_RESERVE_DRAM=0x0
# end of Trace memory

# CONFIG_ESP_SYSTEM_PANIC_PRINT_HALT is not set
CONFIG_ESP_SYSTEM_PANIC_PRINT_REBOOT=y
# CONFIG_ESP_SYSTEM_PANIC_SILENT_REBOOT is not set
# CONFIG_ESP_SYSTEM_PANIC_GDBSTUB is not set
CONFIG_ESP_SYSTEM_PANIC_REBOOT_DELAY_SECONDS=0
CONFIG_ESP_SYSTEM_RTC_FAST_MEM_AS_HEAP_DEPCHECK=y
CONFIG_ESP_SYSTEM_ALLOW_RTC_FAST_MEM_AS_HEAP=y

#
# Memory protection
#
CONFIG_ESP_SYSTEM_MEMPROT_FEATURE=y
CONFIG_ESP_SYSTEM_MEMPROT_FEATURE_LOCK=y
# end of Memory protection

CONFIG_ESP_SYSTEM_EVENT_QUEUE_SIZE=32
CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE=2304
CONFIG_ESP_MAIN_TASK_STACK_SIZE=3584
CONFIG_ESP_MAIN_TASK_AFFINITY_CPU0=y
# CONFIG_ESP_MAIN_TASK_AFFINITY_CPU1 is not set
# CONFIG_ESP_MAIN_TASK_AFFINITY_NO_AFFINITY is not set
CONFIG_ESP_MAIN_TASK_AFFINITY=0x0
CONFIG_ESP_MINIMAL_SHARED_STACK_SIZE=2048
CONFIG_ESP_CONSOLE_UART_DEFAULT=y
# CONFIG_ESP_CONSOLE_USB_CDC is not set
# CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG is not set
# CONFIG_ESP_CONSOLE_UART_CUSTOM is not set
# CONFIG_ESP_CONSOLE_NONE is not set
# CONFIG_ESP_CONSOLE_SECONDARY_NONE is not set
CONFIG_ESP_CONSOLE_SECONDARY_USB_SERIAL_JTAG=y
CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG_ENABLED=y
CONFIG_ESP_CONSOLE_UART=y
CONFIG_ESP_CONSOLE_UART_NUM=0
CONFIG_ESP_CONSOLE_ROM_SERIAL_PORT_NUM=0
CONFIG_ESP_CONSOLE_UART_BAUDRATE=115200
CONFIG_ESP_INT_WDT=y
CONFIG_ESP_INT_WDT_TIMEOUT_MS=300
CONFIG_ESP_INT_WDT_CHECK_CPU1=y
CONFIG_ESP_TASK_WDT_EN=y
CONFIG_ESP_TASK_WDT_INIT=y
# CONFIG_ESP_TASK_WDT_PANIC is not set
CONFIG_ESP_TASK_WDT_TIMEOUT_S=5
CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU0=y
CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU1=y
# CONFIG_ESP_PANIC_HANDLER_IRAM is not set
# CONFIG_ESP_DEBUG_STUBS_ENABLE is not set
CONFIG_ESP_DEBUG_OCDAWARE=y
CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL_4=y
CONFIG_ESP_SYSTEM_BBPLL_RECALIB=y
# end of ESP System Settings

#
# IPC (Inter-Processor Call)
#
CONFIG_ESP_IPC_TASK_STACK_SIZE=1280
CONFIG_ESP_IPC_USES_CALLERS_PRIORITY=y
CONFIG_ESP_IPC_ISR_ENABLE=y
# end of IPC (Inter-Processor Call)

#
# ESP Timer (High Resolution Timer)
#
# CONFIG_ESP_TIMER_PROFILING is not set
CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER=y
CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER=y
CONFIG_ESP_TIMER_TASK_STACK_SIZE=3584
CONFIG_ESP_TIMER_INTERRUPT_LEVEL=1
# CONFIG_ESP_TIMER_SHOW_EXPERIMENTAL is not set
CONFIG_ESP_TIMER_TASK_AFFINITY=0x0
CONFIG_ESP_TIMER_TASK_AFFINITY_CPU0=y
CONFIG_ESP_TIMER_ISR_AFFINITY_CPU0=y
# CONFIG_ESP_TIMER_SUPPORTS_ISR_DISPATCH_METHOD is not set
CONFIG_ESP_TIMER_IMPL_SYSTIMER=y
# end of ESP Timer (High Resolution Timer)

#
# Wi-Fi
#
CONFIG_ESP_WIFI_ENABLED=y
CONFIG_ESP_WIFI_STATIC_RX_BUFFER_NUM=10
CONFIG_ESP_WIFI_DYNAMIC_RX_BUFFER_NUM=32
# CONFIG_ESP_WIFI_STATIC_TX_BUFFER is not set
CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER=y
CONFIG_ESP_WIFI_TX_BUFFER_TYPE=1
CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER_NUM=32
CONFIG_ESP_WIFI_STATIC_RX_MGMT_BUFFER=y
# CONFIG_ESP_WIFI_DYNAMIC_RX_MGMT_BUFFER is not set
CONFIG_ESP_WIFI_DYNAMIC_RX_MGMT_BUF=0
CONFIG_ESP_WIFI_RX_MGMT_BUF_NUM_DEF=5
# CONFIG_ESP_WIFI_CSI_ENABLED is not set
CONFIG_ESP_WIFI_AMPDU_TX_ENABLED=y
CONFIG_ESP_WIFI_TX_BA_WIN=6
CONFIG_ESP_WIFI_AMPDU_RX_ENABLED=y
CONFIG_ESP_WIFI_RX_BA_WIN=6
CONFIG_ESP_WIFI_NVS_ENABLED=y
CONFIG_ESP_WIFI_TASK_PINNED_TO_CORE_0=y
# CONFIG_ESP_WIFI_TASK_PINNED_TO_CORE_1 is not set
CONFIG_ESP_WIFI_SOFTAP_BEACON_MAX_LEN=752
CONFIG_ESP_WIFI_MGMT_SBUF_NUM=32
CONFIG_ESP_WIFI_IRAM_OPT=y
# CONFIG_ESP_WIFI_EXTRA_IRAM_OPT is not set
CONFIG_ESP_WIFI_RX_IRAM_OPT=y
CONFIG_ESP_WIFI_ENABLE_WPA3_SAE=y
CONFIG_ESP_WIFI_ENABLE_SAE_PK=y
CONFIG_ESP_WIFI_SOFTAP_SAE_SUPPORT=y
CONFIG_ESP_WIFI_ENABLE_WPA3_OWE_STA=y
# CONFIG_ESP_WIFI_SLP_IRAM_OPT is not set
CONFIG_ESP_WIFI_SLP_DEFAULT_MIN_ACTIVE_TIME=50
CONFIG_ESP_WIFI_SLP_DEFAULT_MAX_ACTIVE_TIME=10
CONFIG_ESP_WIFI_SLP_DEFAULT_WAIT_BROADCAST_DATA_TIME=15
# CONFIG_ESP_WIFI_FTM_ENABLE is not set
CONFIG_ESP_WIFI_STA_DISCONNECTED_PM_ENABLE=y
# CONFIG_ESP_WIFI_GCMP_SUPPORT is not set
CONFIG_ESP_WIFI_GMAC_SUPPORT=y
CONFIG_ESP_WIFI_SOFTAP_SUPPORT=y
# CONFIG_ESP_WIFI_SLP_BEACON_LOST_OPT is not set
CONFIG_ESP_WIFI_ESPNOW_MAX_ENCRYPT_NUM=7
CONFIG_ESP_WIFI_MBEDTLS_CRYPTO=y
CONFIG_ESP_WIFI_MBEDTLS_TLS_CLIENT=y
# CONFIG_ESP_WIFI_WAPI_PSK is not set
# CONFIG_ESP_WIFI_SUITE_B_192 is not set
# CONFIG_ESP_WIFI_11KV_SUPPORT is not set
# CONFIG_ESP_WIFI_MBO_SUPPORT is not set
# CONFIG_ESP_WIFI_DPP_SUPPORT is not set
# CONFIG_ESP_WIFI_11R_SUPPORT is not set
# CONFIG_ESP_WIFI_WPS_SOFTAP_REGISTRAR is not set

#
# WPS Configuration Options
#
# CONFIG_ESP_WIFI_WPS_STRICT is not set
# CONFIG_ESP_WIFI_WPS_PASSPHRASE is not set
# end of WPS Configuration Options

# CONFIG_ESP_WIFI_DEBUG_PRINT is not set
# CONFIG_ESP_WIFI_TESTING_OPTIONS is not set
CONFIG_ESP_WIFI_ENTERPRISE_SUPPORT=y
# CONFIG_ESP_WIFI_ENT_FREE_DYNAMIC_BUFFER is not set
# end of Wi-Fi

#
# Core dump
#
# CONFIG_ESP_COREDUMP_ENABLE_TO_FLASH is not set
# CONFIG_ESP_COREDUMP_ENABLE_TO_UART is not set
CONFIG_ESP_COREDUMP_ENABLE_TO_NONE=y
# end of Core dump

#
# FAT Filesystem support
#
CONFIG_FATFS_VOLUME_COUNT=2
CONFIG_FATFS_LFN_NONE=y
# CONFIG_FATFS_LFN_HEAP is not set
# CONFIG_FATFS_LFN_STACK is not set
# CONFIG_FATFS_SECTOR_512 is not set
CONFIG_FATFS_SECTOR_4096=y
# CONFIG_FATFS_CODEPAGE_DYNAMIC is not set
CONFIG_FATFS_CODEPAGE_437=y
# CONFIG_FATFS_CODEPAGE_720 is not set
# CONFIG_FATFS_CODEPAGE_737 is not set
# CONFIG_FATFS_CODEPAGE_771 is not set
# CONFIG_FATFS_CODEPAGE_775 is not set
# CONFIG_FATFS_CODEPAGE_850 is not set
# CONFIG_FATFS_CODEPAGE_852 is not set
# CONFIG_FATFS_CODEPAGE_855 is not set
# CONFIG_FATFS_CODEPAGE_857 is not set
# CONFIG_FATFS_CODEPAGE_860 is not set
# CONFIG_FATFS_CODEPAGE_861 is not set
# CONFIG_FATFS_CODEPAGE_862 is not set
# CONFIG_FATFS_CODEPAGE_863 is not set
# CONFIG_FATFS_CODEPAGE_864 is not set
# CONFIG_FATFS_CODEPAGE_865 is not set
# CONFIG_FATFS_CODEPAGE_866 is not set
# CONFIG_FATFS_CODEPAGE_869 is not set
# CONFIG_FATFS_CODEPAGE_932 is not set
# CONFIG_FATFS_CODEPAGE_936 is not set
# CONFIG_FATFS_CODEPAGE_949 is not set
# CONFIG_FATFS_CODEPAGE_950 is not set
CONFIG_FATFS_CODEPAGE=437
CONFIG_FATFS_FS_LOCK=0
CONFIG_FATFS_TIMEOUT_MS=10000
CONFIG_FATFS_PER_FILE_CACHE=y
# CONFIG_FATFS_USE_FASTSEEK is not set
CONFIG_FATFS_USE_STRFUNC_NONE=y
# CONFIG_FATFS_USE_STRFUNC_WITHOUT_CRLF_CONV is not set
# CONFIG_FATFS_USE_STRFUNC_WITH_CRLF_CONV is not set
CONFIG_FATFS_VFS_FSTAT_BLKSIZE=0
# CONFIG_FATFS_IMMEDIATE_FSYNC is not set
# CONFIG_FATFS_USE_LABEL is not set
CONFIG_FATFS_LINK_LOCK=y
# end of FAT Filesystem support

#
# FreeRTOS
#

#
# Kernel
#
# CONFIG_FREERTOS_SMP is not set
# CONFIG_FREERTOS_UNICORE is not set
CONFIG_FREERTOS_HZ=100
# CONFIG_FREERTOS_CHECK_STACKOVERFLOW_NONE is not set
# CONFIG_FREERTOS_CHECK_STACKOVERFLOW_PTRVAL is not set
CONFIG_FREERTOS_CHECK_STACKOVERFLOW_CANARY=y
CONFIG_FREERTOS_THREAD_LOCAL_STORAGE_POINTERS=1
CONFIG_FREERTOS_IDLE_TASK_STACKSIZE=1536
# CONFIG_FREERTOS_USE_IDLE_HOOK is not set
# CONFIG_FREERTOS_USE_TICK_HOOK is not set
CONFIG_FREERTOS_MAX_TASK_NAME_LEN=16
# CONFIG_FREERTOS_ENABLE_BACKWARD_COMPATIBILITY is not set
CONFIG_FREERTOS_USE_TIMERS=y
CONFIG_FREERTOS_TIMER_SERVICE_TASK_NAME="Tmr Svc"
# CONFIG_FREERTOS_TIMER_TASK_AFFINITY_CPU0 is not set
# CONFIG_FREERTOS_TIMER_TASK_AFFINITY_CPU1 is not set
CONFIG_FREERTOS_TIMER_TASK_NO_AFFINITY=y
CONFIG_FREERTOS_TIMER_SERVICE_TASK_CORE_AFFINITY=0x7FFFFFFF
CONFIG_FREERTOS_TIMER_TASK_PRIORITY=1
CONFIG_FREERTOS_TIMER_TASK_STACK_DEPTH=2048
CONFIG_FREERTOS_TIMER_QUEUE_LENGTH=10
CONFIG_FREERTOS_QUEUE_REGISTRY_SIZE=0
CONFIG_FREERTOS_TASK_NOTIFICATION_ARRAY_ENTRIES=1
# CONFIG_FREERTOS_USE_TRACE_FACILITY is not set
# CONFIG_FREERTOS_USE_LIST_DATA_INTEGRITY_CHECK_BYTES is not set
# CONFIG_FREERTOS_GENERATE_RUN_TIME_STATS is not set
# CONFIG_FREERTOS_USE_APPLICATION_TASK_TAG is not set
# end of Kernel

#
# Port
#
CONFIG_FREERTOS_TASK_FUNCTION_WRAPPER=y
# CONFIG_FREERTOS_WATCHPOINT_END_OF_STACK is not set
CONFIG_FREERTOS_TLSP_DELETION_CALLBACKS=y
# CONFIG_FREERTOS_TASK_PRE_DELETION_HOOK is not set
# CONFIG_FREERTOS_ENABLE_STATIC_TASK_CLEAN_UP is not set
CONFIG_FREERTOS_CHECK_MUTEX_GIVEN_BY_OWNER=y
CONFIG_FREERTOS_ISR_STACKSIZE=1536
CONFIG_FREERTOS_INTERRUPT_BACKTRACE=y
# CONFIG_FREERTOS_FPU_IN_ISR is not set
CONFIG_FREERTOS_TICK_SUPPORT_SYSTIMER=y
CONFIG_FREERTOS_CORETIMER_SYSTIMER_LVL1=y
# CONFIG_FREERTOS_CORETIMER_SYSTIMER_LVL3 is not set
CONFIG_FREERTOS_SYSTICK_USES_SYSTIMER=y
# CONFIG_FREERTOS_PLACE_FUNCTIONS_INTO_FLASH is not set
# CONFIG_FREERTOS_CHECK_PORT_CRITICAL_COMPLIANCE is not set
# end of Port

#
# Extra
#
# end of Extra

CONFIG_FREERTOS_PORT=y
CONFIG_FREERTOS_NO_AFFINITY=0x7FFFFFFF
CONFIG_FREERTOS_SUPPORT_STATIC_ALLOCATION=y
CONFIG_FREERTOS_DEBUG_OCDAWARE=y
CONFIG_FREERTOS_ENABLE_TASK_SNAPSHOT=y
CONFIG_FREERTOS_PLACE_SNAPSHOT_FUNS_INTO_FLASH=y
CONFIG_FREERTOS_NUMBER_OF_CORES=2
# end of FreeRTOS

#
# Hardware Abstraction Layer (HAL) and Low Level (LL)
#
CONFIG_HAL_ASSERTION_EQUALS_SYSTEM=y
# CONFIG_HAL_ASSERTION_DISABLE is not set
# CONFIG_HAL_ASSERTION_SILENT is not set
# CONFIG_HAL_ASSERTION_ENABLE is not set
CONFIG_HAL_DEFAULT_ASSERTION_LEVEL=2
CONFIG_HAL_WDT_USE_ROM_IMPL=y
# end of Hardware Abstraction Layer (HAL) and Low Level (LL)

#
# Heap memory debugging
#
CONFIG_HEAP_POISONING_DISABLED=y
# CONFIG_HEAP_POISONING_LIGHT is not set
# CONFIG_HEAP_POISONING_COMPREHENSIVE is not set
CONFIG_HEAP_TRACING_OFF=y
# CONFIG_HEAP_TRACING_STANDALONE is not set
# CONFIG_HEAP_TRACING_TOHOST is not set
# CONFIG_HEAP_USE_HOOKS is not set
# CONFIG_HEAP_TASK_TRACKING is not set
# CONFIG_HEAP_ABORT_WHEN_ALLOCATION_FAILS is not set
# CONFIG_HEAP_PLACE_FUNCTION_INTO_FLASH is not set
# end of Heap memory debugging

#
# Log
#
CONFIG_LOG_VERSION_1=y
# CONFIG_LOG_VERSION_2 is not set
CONFIG_LOG_VERSION=1

#
# Log Level
#
# CONFIG_LOG_DEFAULT_LEVEL_NONE is not set
# CONFIG_LOG_DEFAULT_LEVEL_ERROR is not set
# CONFIG_LOG_DEFAULT_LEVEL_WARN is not set
CONFIG_LOG_DEFAULT_LEVEL_INFO=y
# CONFIG_LOG_DEFAULT_LEVEL_DEBUG is not set
# CONFIG_LOG_DEFAULT_LEVEL_VERBOSE is not set
CONFIG_LOG_DEFAULT_LEVEL=3
CONFIG_LOG_MAXIMUM_EQUALS_DEFAULT=y
# CONFIG_LOG_MAXIMUM_LEVEL_DEBUG is not set
# CONFIG_LOG_MAXIMUM_LEVEL_VERBOSE is not set
CONFIG_LOG_MAXIMUM_LEVEL=3

#
# Level Settings
#
# CONFIG_LOG_MASTER_LEVEL is not set
CONFIG_LOG_DYNAMIC_LEVEL_CONTROL=y
# CONFIG_LOG_TAG_LEVEL_IMPL_NONE is not set
# CONFIG_LOG_TAG_LEVEL_IMPL_LINKED_LIST is not set
CONFIG_LOG_TAG_LEVEL_IMPL_CACHE_AND_LINKED_LIST=y
# CONFIG_LOG_TAG_LEVEL_CACHE_ARRAY is not set
CONFIG_LOG_TAG_LEVEL_CACHE_BINARY_MIN_HEAP=y
CONFIG_LOG_TAG_LEVEL_IMPL_CACHE_SIZE=31
# end of Level Settings
# end of Log Level

#
# Format
#
# CONFIG_LOG_COLORS is not set
CONFIG_LOG_TIMESTAMP_SOURCE_RTOS=y
# CONFIG_LOG_TIMESTAMP_SOURCE_SYSTEM is not set
# end of Format
# end of Log

#
# LWIP
#
CONFIG_LWIP_ENABLE=y
CONFIG_LWIP_LOCAL_HOSTNAME="espressif"
CONFIG_LWIP_TCPIP_TASK_PRIO=18
# CONFIG_LWIP_TCPIP_CORE_LOCKING is not set
# CONFIG_LWIP_CHECK_THREAD_SAFETY is not set
CONFIG_LWIP_DNS_SUPPORT_MDNS_QUERIES=y
# CONFIG_LWIP_L2_TO_L3_COPY is not set
# CONFIG_LWIP_IRAM_OPTIMIZATION is not set
# CONFIG_LWIP_EXTRA_IRAM_OPTIMIZATION is not set
CONFIG_LWIP_TIMERS_ONDEMAND=y
CONFIG_LWIP_ND6=y
# CONFIG_LWIP_FORCE_ROUTER_FORWARDING is not set
CONFIG_LWIP_MAX_SOCKETS=10
# CONFIG_LWIP_USE_ONLY_LWIP_SELECT is not set
# CONFIG_LWIP_SO_LINGER is not set
CONFIG_LWIP_SO_REUSE=y
CONFIG_LWIP_SO_REUSE_RXTOALL=y
# CONFIG_LWIP_SO_RCVBUF is not set
# CONFIG_LWIP_NETBUF_RECVINFO is not set
CONFIG_LWIP_IP_DEFAULT_TTL=64
CONFIG_LWIP_IP4_FRAG=y
CONFIG_LWIP_IP6_FRAG=y
# CONFIG_LWIP_IP4_REASSEMBLY is not set
# CONFIG_LWIP_IP6_REASSEMBLY is not set
CONFIG_LWIP_IP_REASS_MAX_PBUFS=10
# CONFIG_LWIP_IP_FORWARD is not set
# CONFIG_LWIP_STATS is not set
CONFIG_LWIP_ESP_GRATUITOUS_ARP=y
CONFIG_LWIP_GARP_TMR_INTERVAL=60
CONFIG_LWIP_ESP_MLDV6_REPORT=y
CONFIG_LWIP_MLDV6_TMR_INTERVAL=40
CONFIG_LWIP_TCPIP_RECVMBOX_SIZE=32
CONFIG_LWIP_DHCP_DOES_ARP_CHECK=y
# CONFIG_LWIP_DHCP_DOES_ACD_CHECK is not set
# CONFIG_LWIP_DHCP_DOES_NOT_CHECK_OFFERED_IP is not set
# CONFIG_LWIP_DHCP_DISABLE_CLIENT_ID is not set
CONFIG_LWIP_DHCP_DISABLE_VENDOR_CLASS_ID=y
# CONFIG_LWIP_DHCP_RESTORE_LAST_IP is not set
CONFIG_LWIP_DHCP_OPTIONS_LEN=68
CONFIG_LWIP_NUM_NETIF_CLIENT_DATA=0
CONFIG_LWIP_DHCP_COARSE_TIMER_SECS=1

#
# DHCP server
#
CONFIG_LWIP_DHCPS=y
CONFIG_LWIP_DHCPS_LEASE_UNIT=60
CONFIG_LWIP_DHCPS_MAX_STATION_NUM=8
CONFIG_LWIP_DHCPS_STATIC_ENTRIES=y
CONFIG_LWIP_DHCPS_ADD_DNS=y
# end of DHCP server

# CONFIG_LWIP_AUTOIP is not set
CONFIG_LWIP_IPV4=y
CONFIG_LWIP_IPV6=y
# CONFIG_LWIP_IPV6_AUTOCONFIG is not set
CONFIG_LWIP_IPV6_NUM_ADDRESSES=3
# CONFIG_LWIP_IPV6_FORWARD is not set
# CONFIG_LWIP_NETIF_STATUS_CALLBACK is not set
CONFIG_LWIP_NETIF_LOOPBACK=y
CONFIG_LWIP_LOOPBACK_MAX_PBUFS=8

#
# TCP
#
CONFIG_LWIP_MAX_ACTIVE_TCP=16
CONFIG_LWIP_MAX_LISTENING_TCP=16
CONFIG_LWIP_TCP_HIGH_SPEED_RETRANSMISSION=y
CONFIG_LWIP_TCP_MAXRTX=12
CONFIG_LWIP_TCP_SYNMAXRTX=12
CONFIG_LWIP_TCP_MSS=1440
CONFIG_LWIP_TCP_TMR_INTERVAL=250
CONFIG_LWIP_TCP_MSL=60000
CONFIG_LWIP_TCP_FIN_WAIT_TIMEOUT=20000
CONFIG_LWIP_TCP_SND_BUF_DEFAULT=5760
CONFIG_LWIP_TCP_WND_DEFAULT=5760
CONFIG_LWIP_TCP_RECVMBOX_SIZE=6
CONFIG_LWIP_TCP_ACCEPTMBOX_SIZE=6
CONFIG_LWIP_TCP_QUEUE_OOSEQ=y
CONFIG_LWIP_TCP_OOSEQ_TIMEOUT=6
CONFIG_LWIP_TCP_OOSEQ_MAX_PBUFS=4
# CONFIG_LWIP_TCP_SACK_OUT is not set
CONFIG_LWIP_TCP_OVERSIZE_MSS=y
# CONFIG_LWIP_TCP_OVERSIZE_QUARTER_MSS is not set
# CONFIG_LWIP_TCP_OVERSIZE_DISABLE is not set
CONFIG_LWIP_TCP_RTO_TIME=1500
# end of TCP

#
# UDP
#
CONFIG_LWIP_MAX_UDP_PCBS=16
CONFIG_LWIP_UDP_RECVMBOX_SIZE=6
# end of UDP

#
# Checksums
#
# CONFIG_LWIP_CHECKSUM_CHECK_IP is not set
# CONFIG_LWIP_CHECKSUM_CHECK_UDP is not set
CONFIG_LWIP_CHECKSUM_CHECK_ICMP=y
# end of Checksums

CONFIG_LWIP_TCPIP_TASK_STACK_SIZE=3072
CONFIG_LWIP_TCPIP_TASK_AFFINITY_NO_AFFINITY=y
# CONFIG_LWIP_TCPIP_TASK_AFFINITY_CPU0 is not set
# CONFIG_LWIP_TCPIP_TASK_AFFINITY_CPU1 is not set
CONFIG_LWIP_TCPIP_TASK_AFFINITY=0x7FFFFFFF
CONFIG_LWIP_IPV6_MEMP_NUM_ND6_QUEUE=3
CONFIG_LWIP_IPV6_ND6_NUM_NEIGHBORS=5
CONFIG_LWIP_IPV6_ND6_NUM_PREFIXES=5
CONFIG_LWIP_IPV6_ND6_NUM_ROUTERS=3
CONFIG_LWIP_IPV6_ND6_NUM_DESTINATIONS=10
# CONFIG_LWIP_PPP_SUPPORT is not set
# CONFIG_LWIP_SLIP_SUPPORT is not set

#
# ICMP
#
CONFIG_LWIP_ICMP=y
# CONFIG_LWIP_MULTICAST_PING is not set
# CONFIG_LWIP_BROADCAST_PING is not set
# end of ICMP

#
# LWIP RAW API
#
CONFIG_LWIP_MAX_RAW_PCBS=16
# end of LWIP RAW API

#
# SNTP
#
CONFIG_LWIP_SNTP_MAX_SERVERS=1
# CONFIG_LWIP_DHCP_GET_NTP_SRV is not set
CONFIG_LWIP_SNTP_UPDATE_DELAY=3600000
CONFIG_LWIP_SNTP_STARTUP_DELAY=y
CONFIG_LWIP_SNTP_MAXIMUM_STARTUP_DELAY=5000
# end of SNTP

#
# DNS
#
CONFIG_LWIP_DNS_MAX_HOST_IP=1
CONFIG_LWIP_DNS_MAX_SERVERS=3
# CONFIG_LWIP_FALLBACK_DNS_SERVER_SUPPORT is not set
# CONFIG_LWIP_DNS_SETSERVER_WITH_NETIF is not set
# CONFIG_LWIP_USE_ESP_GETADDRINFO is not set
# end of DNS

CONFIG_LWIP_BRIDGEIF_MAX_PORTS=7
CONFIG_LWIP_ESP_LWIP_ASSERT=y

#
# Hooks
#
# CONFIG_LWIP_HOOK_TCP_ISN_NONE is not set
CONFIG_LWIP_HOOK_TCP_ISN_DEFAULT=y
# CONFIG_LWIP_HOOK_TCP_ISN_CUSTOM is not set
CONFIG_LWIP_HOOK_IP6_ROUTE_NONE=y
# CONFIG_LWIP_HOOK_IP6_ROUTE_DEFAULT is not set
# CONFIG_LWIP_HOOK_IP6_ROUTE_CUSTOM is not set
CONFIG_LWIP_HOOK_ND6_GET_GW_NONE=y
# CONFIG_LWIP_HOOK_ND6_GET_GW_DEFAULT is not set
# CONFIG_LWIP_HOOK_ND6_GET_GW_CUSTOM is not set
CONFIG_LWIP_HOOK_IP6_SELECT_SRC_ADDR_NONE=y
# CONFIG_LWIP_HOOK_IP6_SELECT_SRC_ADDR_DEFAULT is not set
# CONFIG_LWIP_HOOK_IP6_SELECT_SRC_ADDR_CUSTOM is not set
CONFIG_LWIP_HOOK_NETCONN_EXT_RESOLVE_NONE=y
# CONFIG_LWIP_HOOK_NETCONN_EXT_RESOLVE_DEFAULT is not set
# CONFIG_LWIP_HOOK_NETCONN_EXT_RESOLVE_CUSTOM is not set
CONFIG_LWIP_HOOK_DNS_EXT_RESOLVE_NONE=y
# CONFIG_LWIP_HOOK_DNS_EXT_RESOLVE_CUSTOM is not set
# CONFIG_LWIP_HOOK_IP6_INPUT_NONE is not set
CONFIG_LWIP_HOOK_IP6_INPUT_DEFAULT=y
# CONFIG_LWIP_HOOK_IP6_INPUT_CUSTOM is not set
# end of Hooks

# CONFIG_LWIP_DEBUG is not set
# end of LWIP

#
# mbedTLS
#
CONFIG_MBEDTLS_INTERNAL_MEM_ALLOC=y
# CONFIG_MBEDTLS_DEFAULT_MEM_ALLOC is not set
# CONFIG_MBEDTLS_CUSTOM_MEM_ALLOC is not set
CONFIG_MBEDTLS_ASYMMETRIC_CONTENT_LEN=y
CONFIG_MBEDTLS_SSL_IN_CONTENT_LEN=16384
CONFIG_MBEDTLS_SSL_OUT_CONTENT_LEN=4096
# CONFIG_MBEDTLS_DYNAMIC_BUFFER is not set
# CONFIG_MBEDTLS_DEBUG is not set

#
# mbedTLS v3.x related
#
# CONFIG_MBEDTLS_SSL_PROTO_TLS1_3 is not set
# CONFIG_MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH is not set
# CONFIG_MBEDTLS_X509_TRUSTED_CERT_CALLBACK is not set
# CONFIG_MBEDTLS_SSL_CONTEXT_SERIALIZATION is not set
CONFIG_MBEDTLS_SSL_KEEP_PEER_CERTIFICATE=y
CONFIG_MBEDTLS_PKCS7_C=y
# end of mbedTLS v3.x related

#
# Certificate Bundle
#
CONFIG_MBEDTLS_CERTIFICATE_BUNDLE=y
CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_FULL=y
# CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_CMN is not set
# CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_NONE is not set
# CONFIG_MBEDTLS_CUSTOM_CERTIFICATE_BUNDLE is not set
# CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEPRECATED_LIST is not set
CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_MAX_CERTS=200
# end of Certificate Bundle

# CONFIG_MBEDTLS_ECP_RESTARTABLE is not set
CONFIG_MBEDTLS_CMAC_C=y
CONFIG_MBEDTLS_HARDWARE_AES=y
CONFIG_MBEDTLS_AES_USE_INTERRUPT=y
CONFIG_MBEDTLS_AES_INTERRUPT_LEVEL=0
CONFIG_MBEDTLS_GCM_SUPPORT_NON_AES_CIPHER=y
CONFIG_MBEDTLS_HARDWARE_MPI=y
# CONFIG_MBEDTLS_LARGE_KEY_SOFTWARE_MPI is not set
CONFIG_MBEDTLS_MPI_USE_INTERRUPT=y
CONFIG_MBEDTLS_MPI_INTERRUPT_LEVEL=0
CONFIG_MBEDTLS_HARDWARE_SHA=y
CONFIG_MBEDTLS_ROM_MD5=y
# CONFIG_MBEDTLS_ATCA_HW_ECDSA_SIGN is not set
# CONFIG_MBEDTLS_ATCA_HW_ECDSA_VERIFY is not set
CONFIG_MBEDTLS_HAVE_TIME=y
# CONFIG_MBEDTLS_PLATFORM_TIME_ALT is not set
# CONFIG_MBEDTLS_HAVE_TIME_DATE is not set
CONFIG_MBEDTLS_ECDSA_DETERMINISTIC=y
CONFIG_MBEDTLS_SHA512_C=y
# CONFIG_MBEDTLS_SHA3_C is not set
CONFIG_MBEDTLS_TLS_SERVER_AND_CLIENT=y
# CONFIG_MBEDTLS_TLS_SERVER_ONLY is not set
# CONFIG_MBEDTLS_TLS_CLIENT_ONLY is not set
# CONFIG_MBEDTLS_TLS_DISABLED is not set
CONFIG_MBEDTLS_TLS_SERVER=y
CONFIG_MBEDTLS_TLS_CLIENT=y
CONFIG_MBEDTLS_TLS_ENABLED=y

#
# TLS Key Exchange Methods
#
# CONFIG_MBEDTLS_PSK_MODES is not set
CONFIG_MBEDTLS_KEY_EXCHANGE_RSA=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ELLIPTIC_CURVE=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_RSA=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_RSA=y
# end of TLS Key Exchange Methods

CONFIG_MBEDTLS_SSL_RENEGOTIATION=y
CONFIG_MBEDTLS_SSL_PROTO_TLS1_2=y
# CONFIG_MBEDTLS_SSL_PROTO_GMTSSL1_1 is not set
# CONFIG_MBEDTLS_SSL_PROTO_DTLS is not set
CONFIG_MBEDTLS_SSL_ALPN=y
CONFIG_MBEDTLS_CLIENT_SSL_SESSION_TICKETS=y
CONFIG_MBEDTLS_SERVER_SSL_SESSION_TICKETS=y

#
# Symmetric Ciphers
#
CONFIG_MBEDTLS_AES_C=y
# CONFIG_MBEDTLS_CAMELLIA_C is not set
# CONFIG_MBEDTLS_DES_C is not set
# CONFIG_MBEDTLS_BLOWFISH_C is not set
# CONFIG_MBEDTLS_XTEA_C is not set
CONFIG_MBEDTLS_CCM_C=y
CONFIG_MBEDTLS_GCM_C=y
# CONFIG_MBEDTLS_NIST_KW_C is not set
# end of Symmetric Ciphers

# CONFIG_MBEDTLS_RIPEMD160_C is not set

#
# Certificates
#
CONFIG_MBEDTLS_PEM_PARSE_C=y
CONFIG_MBEDTLS_PEM_WRITE_C=y
CONFIG_MBEDTLS_X509_CRL_PARSE_C=y
CONFIG_MBEDTLS_X509_CSR_PARSE_C=y
# end of Certificates

CONFIG_MBEDTLS_ECP_C=y
CONFIG_MBEDTLS_PK_PARSE_EC_EXTENDED=y
CONFIG_MBEDTLS_PK_PARSE_EC_COMPRESSED=y
# CONFIG_MBEDTLS_DHM_C is not set
CONFIG_MBEDTLS_ECDH_C=y
CONFIG_MBEDTLS_ECDSA_C=y
# CONFIG_MBEDTLS_ECJPAKE_C is not set
CONFIG_MBEDTLS_ECP_DP_SECP192R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP224R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP256R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP384R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP521R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP192K1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP224K1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP256K1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_BP256R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_BP384R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_BP512R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_CURVE25519_ENABLED=y
CONFIG_MBEDTLS_ECP_NIST_OPTIM=y
# CONFIG_MBEDTLS_ECP_FIXED_POINT_OPTIM is not set
# CONFIG_MBEDTLS_POLY1305_C is not set
# CONFIG_MBEDTLS_CHACHA20_C is not set
# CONFIG_MBEDTLS_HKDF_C is not set
# CONFIG_MBEDTLS_THREADING_C is not set
CONFIG_MBEDTLS_ERROR_STRINGS=y
CONFIG_MBEDTLS_FS_IO=y
# end of mbedTLS

#
# ESP-MQTT Configurations
#
CONFIG_MQTT_PROTOCOL_311=y
# CONFIG_MQTT_PROTOCOL_5 is not set
CONFIG_MQTT_TRANSPORT_SSL=y
CONFIG_MQTT_TRANSPORT_WEBSOCKET=y
CONFIG_MQTT_TRANSPORT_WEBSOCKET_SECURE=y
# CONFIG_MQTT_MSG_ID_INCREMENTAL is not set
# CONFIG_MQTT_SKIP_PUBLISH_IF_DISCONNECTED is not set
# CONFIG_MQTT_REPORT_DELETED_MESSAGES is not set
# CONFIG_MQTT_USE_CUSTOM_CONFIG is not set
# CONFIG_MQTT_TASK_CORE_SELECTION_ENABLED is not set
# CONFIG_MQTT_CUSTOM_OUTBOX is not set
# end of ESP-MQTT Configurations

#
# LibC
#
CONFIG_LIBC_NEWLIB=y
CONFIG_LIBC_STDOUT_LINE_ENDING_CRLF=y
# CONFIG_LIBC_STDOUT_LINE_ENDING_LF is not set
# CONFIG_LIBC_STDOUT_LINE_ENDING_CR is not set
# CONFIG_LIBC_STDIN_LINE_ENDING_CRLF is not set
# CONFIG_LIBC_STDIN_LINE_ENDING_LF is not set
CONFIG_LIBC_STDIN_LINE_ENDING_CR=y
# CONFIG_LIBC_NEWLIB_NANO_FORMAT is not set
CONFIG_LIBC_TIME_SYSCALL_USE_RTC_HRT=y
# CONFIG_LIBC_TIME_SYSCALL_USE_RTC is not set
# CONFIG_LIBC_TIME_SYSCALL_USE_HRT is not set
# CONFIG_LIBC_TIME_SYSCALL_USE_NONE is not set
# end of LibC

#
# NVS
#
# CONFIG_NVS_ENCRYPTION is not set
# CONFIG_NVS_ASSERT_ERROR_CHECK is not set
# CONFIG_NVS_LEGACY_DUP_KEYS_COMPATIBILITY is not set
# end of NVS

#
# OpenThread
#
# CONFIG_OPENTHREAD_ENABLED is not set

#
# OpenThread Spinel
#
# CONFIG_OPENTHREAD_SPINEL_ONLY is not set
# end of OpenThread Spinel
# end of OpenThread

#
# Protocomm
#
CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_0=y
CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_1=y
CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_2=y
# end of Protocomm

#
# PThreads
#
CONFIG_PTHREAD_TASK_PRIO_DEFAULT=5
CONFIG_PTHREAD_TASK_STACK_SIZE_DEFAULT=3072
CONFIG_PTHREAD_STACK_MIN=768
CONFIG_PTHREAD_DEFAULT_CORE_NO_AFFINITY=y
# CONFIG_PTHREAD_DEFAULT_CORE_0 is not set
# CONFIG_PTHREAD_DEFAULT_CORE_1 is not set
CONFIG_PTHREAD_TASK_CORE_DEFAULT=-1
CONFIG_PTHREAD_TASK_NAME_DEFAULT="pthread"
# end of PThreads

#
# MMU Config
#
CONFIG_MMU_PAGE_SIZE_64KB=y
CONFIG_MMU_PAGE_MODE="64KB"
CONFIG_MMU_PAGE_SIZE=0x10000
# end of MMU Config

#
# Main Flash configuration
#

#
# SPI Flash behavior when brownout
#
CONFIG_SPI_FLASH_BROWNOUT_RESET_XMC=y
CONFIG_SPI_FLASH_BROWNOUT_RESET=y
# end of SPI Flash behavior when brownout

#
# Optional and Experimental Features (READ DOCS FIRST)
#

#
# Features here require specific hardware (READ DOCS FIRST!)
#
# CONFIG_SPI_FLASH_HPM_ENA is not set
CONFIG_SPI_FLASH_HPM_AUTO=y
# CONFIG_SPI_FLASH_HPM_DIS is not set
CONFIG_SPI_FLASH_HPM_ON=y
CONFIG_SPI_FLASH_HPM_DC_AUTO=y
# CONFIG_SPI_FLASH_HPM_DC_DISABLE is not set
# CONFIG_SPI_FLASH_AUTO_SUSPEND is not set
CONFIG_SPI_FLASH_SUSPEND_TSUS_VAL_US=50
# CONFIG_SPI_FLASH_FORCE_ENABLE_XMC_C_SUSPEND is not set
CONFIG_SPI_FLASH_PLACE_FUNCTIONS_IN_IRAM=y
# end of Optional and Experimental Features (READ DOCS FIRST)
# end of Main Flash configuration

#
# SPI Flash driver
#
# CONFIG_SPI_FLASH_VERIFY_WRITE is not set
# CONFIG_SPI_FLASH_ENABLE_COUNTERS is not set
CONFIG_SPI_FLASH_ROM_DRIVER_PATCH=y
# CONFIG_SPI_FLASH_ROM_IMPL is not set
CONFIG_SPI_FLASH_DANGEROUS_WRITE_ABORTS=y
# CONFIG_SPI_FLASH_DANGEROUS_WRITE_FAILS is not set
# CONFIG_SPI_FLASH_DANGEROUS_WRITE_ALLOWED is not set
# CONFIG_SPI_FLASH_BYPASS_BLOCK_ERASE is not set
CONFIG_SPI_FLASH_YIELD_DURING_ERASE=y
CONFIG_SPI_FLASH_ERASE_YIELD_DURATION_MS=20
CONFIG_SPI_FLASH_ERASE_YIELD_TICKS=1
CONFIG_SPI_FLASH_WRITE_CHUNK_SIZE=8192
# CONFIG_SPI_FLASH_SIZE_OVERRIDE is not set
# CONFIG_SPI_FLASH_CHECK_ERASE_TIMEOUT_DISABLED is not set
# CONFIG_SPI_FLASH_OVERRIDE_CHIP_DRIVER_LIST is not set

#
# Auto-detect flash chips
#
CONFIG_SPI_FLASH_VENDOR_XMC_SUPPORTED=y
CONFIG_SPI_FLASH_VENDOR_GD_SUPPORTED=y
CONFIG_SPI_FLASH_VENDOR_ISSI_SUPPORTED=y
CONFIG_SPI_FLASH_VENDOR_MXIC_SUPPORTED=y
CONFIG_SPI_FLASH_VENDOR_WINBOND_SUPPORTED=y
CONFIG_SPI_FLASH_VENDOR_BOYA_SUPPORTED=y
CONFIG_SPI_FLASH_VENDOR_TH_SUPPORTED=y
CONFIG_SPI_FLASH_SUPPORT_ISSI_CHIP=y
CONFIG_SPI_FLASH_SUPPORT_MXIC_CHIP=y
CONFIG_SPI_FLASH_SUPPORT_GD_CHIP=y
CONFIG_SPI_FLASH_SUPPORT_WINBOND_CHIP=y
CONFIG_SPI_FLASH_SUPPORT_BOYA_CHIP=y
CONFIG_SPI_FLASH_SUPPORT_TH_CHIP=y
CONFIG_SPI_FLASH_SUPPORT_MXIC_OPI_CHIP=y
# end of Auto-detect flash chips

CONFIG_SPI_FLASH_ENABLE_ENCRYPTED_READ_WRITE=y
# end of SPI Flash driver

#
# SPIFFS Configuration
#
CONFIG_SPIFFS_MAX_PARTITIONS=3

#
# SPIFFS Cache Configuration
#
CONFIG_SPIFFS_CACHE=y
CONFIG_SPIFFS_CACHE_WR=y
# CONFIG_SPIFFS_CACHE_STATS is not set
# end of SPIFFS Cache Configuration

CONFIG_SPIFFS_PAGE_CHECK=y
CONFIG_SPIFFS_GC_MAX_RUNS=10
# CONFIG_SPIFFS_GC_STATS is not set
CONFIG_SPIFFS_PAGE_SIZE=256
CONFIG_SPIFFS_OBJ_NAME_LEN=32
# CONFIG_SPIFFS_FOLLOW_SYMLINKS is not set
CONFIG_SPIFFS_USE_MAGIC=y
CONFIG_SPIFFS_USE_MAGIC_LENGTH=y
CONFIG_SPIFFS_META_LENGTH=4
CONFIG_SPIFFS_USE_MTIME=y

#
# Debug Configuration
#
# CONFIG_SPIFFS_DBG is not set
# CONFIG_SPIFFS_API_DBG is not set
# CONFIG_SPIFFS_GC_DBG is not set
# CONFIG_SPIFFS_CACHE_DBG is not set
# CONFIG_SPIFFS_CHECK_DBG is not set
# CONFIG_SPIFFS_TEST_VISUALISATION is not set
# end of Debug Configuration
# end of SPIFFS Configuration

#
# TCP Transport
#

#
# Websocket
#
CONFIG_WS_TRANSPORT=y
CONFIG_WS_BUFFER_SIZE=1024
# CONFIG_WS_DYNAMIC_BUFFER is not set
# end of Websocket
# end of TCP Transport

#
# Ultra Low Power (ULP) Co-processor
#
# CONFIG_ULP_COPROC_ENABLED is not set

#
# ULP Debugging Options
#
# end of ULP Debugging Options
# end of Ultra Low Power (ULP) Co-processor

#
# Unity unit testing library
#
CONFIG_UNITY_ENABLE_FLOAT=y
CONFIG_UNITY_ENABLE_DOUBLE=y
# CONFIG_UNITY_ENABLE_64BIT is not set
# CONFIG_UNITY_ENABLE_COLOR is not set
CONFIG_UNITY_ENABLE_IDF_TEST_RUNNER=y
# CONFIG_UNITY_ENABLE_FIXTURE is not set
# CONFIG_UNITY_ENABLE_BACKTRACE_ON_FAIL is not set
# end of Unity unit testing library

#
# USB-OTG
#
CONFIG_USB_HOST_CONTROL_TRANSFER_MAX_SIZE=256
CONFIG_USB_HOST_HW_BUFFER_BIAS_BALANCED=y
# CONFIG_USB_HOST_HW_BUFFER_BIAS_IN is not set
# CONFIG_USB_HOST_HW_BUFFER_BIAS_PERIODIC_OUT is not set

#
# Hub Driver Configuration
#

#
# Root Port configuration
#
CONFIG_USB_HOST_DEBOUNCE_DELAY_MS=250
CONFIG_USB_HOST_RESET_HOLD_MS=30
CONFIG_USB_HOST_RESET_RECOVERY_MS=30
CONFIG_USB_HOST_SET_ADDR_RECOVERY_MS=10
# end of Root Port configuration

# CONFIG_USB_HOST_HUBS_SUPPORTED is not set
# end of Hub Driver Configuration

# CONFIG_USB_HOST_ENABLE_ENUM_FILTER_CALLBACK is not set
CONFIG_USB_OTG_SUPPORTED=y
# end of USB-OTG

#
# Virtual file system
#
CONFIG_VFS_SUPPORT_IO=y
CONFIG_VFS_SUPPORT_DIR=y
CONFIG_VFS_SUPPORT_SELECT=y
CONFIG_VFS_SUPPRESS_SELECT_DEBUG_OUTPUT=y
# CONFIG_VFS_SELECT_IN_RAM is not set
CONFIG_VFS_SUPPORT_TERMIOS=y
CONFIG_VFS_MAX_COUNT=8

#
# Host File System I/O (Semihosting)
#
CONFIG_VFS_SEMIHOSTFS_MAX_MOUNT_POINTS=1
# end of Host File System I/O (Semihosting)

CONFIG_VFS_INITIALIZE_DEV_NULL=y
# end of Virtual file system

#
# Wear Levelling
#
# CONFIG_WL_SECTOR_SIZE_512 is not set
CONFIG_WL_SECTOR_SIZE_4096=y
CONFIG_WL_SECTOR_SIZE=4096
# end of Wear Levelling

#
# Wi-Fi Provisioning Manager
#
CONFIG_WIFI_PROV_SCAN_MAX_ENTRIES=16
CONFIG_WIFI_PROV_AUTOSTOP_TIMEOUT=30
CONFIG_WIFI_PROV_STA_ALL_CHANNEL_SCAN=y
# CONFIG_WIFI_PROV_STA_FAST_SCAN is not set
# end of Wi-Fi Provisioning Manager
# end of Component config

# CONFIG_IDF_EXPERIMENTAL_FEATURES is not set

# Deprecated options for backward compatibility
# CONFIG_APP_BUILD_TYPE_ELF_RAM is not set
# CONFIG_NO_BLOBS is not set
# CONFIG_APP_ROLLBACK_ENABLE is not set
# CONFIG_LOG_BOOTLOADER_LEVEL_NONE is not set
# CONFIG_LOG_BOOTLOADER_LEVEL_ERROR is not set
# CONFIG_LOG_BOOTLOADER_LEVEL_WARN is not set
CONFIG_LOG_BOOTLOADER_LEVEL_INFO=y
# CONFIG_LOG_BOOTLOADER_LEVEL_DEBUG is not set
# CONFIG_LOG_BOOTLOADER_LEVEL_VERBOSE is not set
CONFIG_LOG_BOOTLOADER_LEVEL=3
# CONFIG_FLASH_ENCRYPTION_ENABLED is not set
# CONFIG_FLASHMODE_QIO is not set
# CONFIG_FLASHMODE_QOUT is not set
CONFIG_FLASHMODE_DIO=y
# CONFIG_FLASHMODE_DOUT is not set
CONFIG_MONITOR_BAUD=115200
CONFIG_OPTIMIZATION_LEVEL_DEBUG=y
CONFIG_COMPILER_OPTIMIZATION_LEVEL_DEBUG=y
CONFIG_COMPILER_OPTIMIZATION_DEFAULT=y
# CONFIG_OPTIMIZATION_LEVEL_RELEASE is not set
# CONFIG_COMPILER_OPTIMIZATION_LEVEL_RELEASE is not set
CONFIG_OPTIMIZATION_ASSERTIONS_ENABLED=y
# CONFIG_OPTIMIZATION_ASSERTIONS_SILENT is not set
# CONFIG_OPTIMIZATION_ASSERTIONS_DISABLED is not set
CONFIG_OPTIMIZATION_ASSERTION_LEVEL=2
# CONFIG_CXX_EXCEPTIONS is not set
CONFIG_STACK_CHECK_NONE=y
# CONFIG_STACK_CHECK_NORM is not set
# CONFIG_STACK_CHECK_STRONG is not set
# CONFIG_STACK_CHECK_ALL is not set
# CONFIG_WARN_WRITE_STRINGS is not set
# CONFIG_ESP32_APPTRACE_DEST_TRAX is not set
CONFIG_ESP32_APPTRACE_DEST_NONE=y
CONFIG_ESP32_APPTRACE_LOCK_ENABLE=y
# CONFIG_EXTERNAL_COEX_ENABLE is not set
# CONFIG_ESP_WIFI_EXTERNAL_COEXIST_ENABLE is not set
# CONFIG_GPTIMER_ISR_IRAM_SAFE is not set
# CONFIG_MCPWM_ISR_IN_IRAM is not set
# CONFIG_RMT_ISR_IRAM_SAFE is not set
# CONFIG_EVENT_LOOP_PROFILING is not set
CONFIG_POST_EVENTS_FROM_ISR=y
CONFIG_POST_EVENTS_FROM_IRAM_ISR=y
CONFIG_GDBSTUB_SUPPORT_TASKS=y
CONFIG_GDBSTUB_MAX_TASKS=32
# CONFIG_OTA_ALLOW_HTTP is not set
# CONFIG_ESP_SYSTEM_PD_FLASH is not set
CONFIG_ESP32S3_DEEP_SLEEP_WAKEUP_DELAY=2000
CONFIG_ESP_SLEEP_DEEP_SLEEP_WAKEUP_DELAY=2000
CONFIG_ESP32S3_RTC_CLK_SRC_INT_RC=y
# CONFIG_ESP32S3_RTC_CLK_SRC_EXT_CRYS is not set
# CONFIG_ESP32S3_RTC_CLK_SRC_EXT_OSC is not set
# CONFIG_ESP32S3_RTC_CLK_SRC_INT_8MD256 is not set
CONFIG_ESP32S3_RTC_CLK_CAL_CYCLES=1024
CONFIG_BROWNOUT_DET=y
CONFIG_ESP32S3_BROWNOUT_DET=y
CONFIG_BROWNOUT_DET_LVL_SEL_7=y
CONFIG_ESP32S3_BROWNOUT_DET_LVL_SEL_7=y
# CONFIG_BROWNOUT_DET_LVL_SEL_6 is not set
# CONFIG_ESP32S3_BROWNOUT_DET_LVL_SEL_6 is not set
# CONFIG_BROWNOUT_DET_LVL_SEL_5 is not set
# CONFIG_ESP32S3_BROWNOUT_DET_LVL_SEL_5 is not set
# CONFIG_BROWNOUT_DET_LVL_SEL_4 is not set
# CONFIG_ESP32S3_BROWNOUT_DET_LVL_SEL_4 is not set
# CONFIG_BROWNOUT_DET_LVL_SEL_3 is not set
# CONFIG_ESP32S3_BROWNOUT_DET_LVL_SEL_3 is not set
# CONFIG_BROWNOUT_DET_LVL_SEL_2 is not set
# CONFIG_ESP32S3_BROWNOUT_DET_LVL_SEL_2 is not set
# CONFIG_BROWNOUT_DET_LVL_SEL_1 is not set
# CONFIG_ESP32S3_BROWNOUT_DET_LVL_SEL_1 is not set
CONFIG_BROWNOUT_DET_LVL=7
CONFIG_ESP32S3_BROWNOUT_DET_LVL=7
CONFIG_ESP_SYSTEM_BROWNOUT_INTR=y
CONFIG_ESP32_PHY_CALIBRATION_AND_DATA_STORAGE=y
# CONFIG_ESP32_PHY_INIT_DATA_IN_PARTITION is not set
CONFIG_ESP32_PHY_MAX_WIFI_TX_POWER=20
CONFIG_ESP32_PHY_MAX_TX_POWER=20
# CONFIG_REDUCE_PHY_TX_POWER is not set
# CONFIG_ESP32_REDUCE_PHY_TX_POWER is not set
CONFIG_ESP_SYSTEM_PM_POWER_DOWN_CPU=y
CONFIG_PM_POWER_DOWN_TAGMEM_IN_LIGHT_SLEEP=y
# CONFIG_ESP32S3_SPIRAM_SUPPORT is not set
# CONFIG_ESP32S3_DEFAULT_CPU_FREQ_80 is not set
CONFIG_ESP32S3_DEFAULT_CPU_FREQ_160=y
# CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240 is not set
CONFIG_ESP32S3_DEFAULT_CPU_FREQ_MHZ=160
CONFIG_SYSTEM_EVENT_QUEUE_SIZE=32
CONFIG_SYSTEM_EVENT_TASK_STACK_SIZE=2304
CONFIG_MAIN_TASK_STACK_SIZE=3584
CONFIG_CONSOLE_UART_DEFAULT=y
# CONFIG_CONSOLE_UART_CUSTOM is not set
# CONFIG_CONSOLE_UART_NONE is not set
# CONFIG_ESP_CONSOLE_UART_NONE is not set
CONFIG_CONSOLE_UART=y
CONFIG_CONSOLE_UART_NUM=0
CONFIG_CONSOLE_UART_BAUDRATE=115200
CONFIG_INT_WDT=y
CONFIG_INT_WDT_TIMEOUT_MS=300
CONFIG_INT_WDT_CHECK_CPU1=y
CONFIG_TASK_WDT=y
CONFIG_ESP_TASK_WDT=y
# CONFIG_TASK_WDT_PANIC is not set
CONFIG_TASK_WDT_TIMEOUT_S=5
CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU0=y
CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU1=y
# CONFIG_ESP32_DEBUG_STUBS_ENABLE is not set
CONFIG_ESP32S3_DEBUG_OCDAWARE=y
CONFIG_IPC_TASK_STACK_SIZE=1280
CONFIG_TIMER_TASK_STACK_SIZE=3584
CONFIG_ESP32_WIFI_ENABLED=y
CONFIG_ESP32_WIFI_STATIC_RX_BUFFER_NUM=10
CONFIG_ESP32_WIFI_DYNAMIC_RX_BUFFER_NUM=32
# CONFIG_ESP32_WIFI_STATIC_TX_BUFFER is not set
CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER=y
CONFIG_ESP32_WIFI_TX_BUFFER_TYPE=1
CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER_NUM=32
# CONFIG_ESP32_WIFI_CSI_ENABLED is not set
CONFIG_ESP32_WIFI_AMPDU_TX_ENABLED=y
CONFIG_ESP32_WIFI_TX_BA_WIN=6
CONFIG_ESP32_WIFI_AMPDU_RX_ENABLED=y
CONFIG_ESP32_WIFI_RX_BA_WIN=6
CONFIG_ESP32_WIFI_NVS_ENABLED=y
CONFIG_ESP32_WIFI_TASK_PINNED_TO_CORE_0=y
# CONFIG_ESP32_WIFI_TASK_PINNED_TO_CORE_1 is not set
CONFIG_ESP32_WIFI_SOFTAP_BEACON_MAX_LEN=752
CONFIG_ESP32_WIFI_MGMT_SBUF_NUM=32
CONFIG_ESP32_WIFI_IRAM_OPT=y
CONFIG_ESP32_WIFI_RX_IRAM_OPT=y
CONFIG_ESP32_WIFI_ENABLE_WPA3_SAE=y
CONFIG_ESP32_WIFI_ENABLE_WPA3_OWE_STA=y
CONFIG_WPA_MBEDTLS_CRYPTO=y
CONFIG_WPA_MBEDTLS_TLS_CLIENT=y
# CONFIG_WPA_WAPI_PSK is not set
# CONFIG_WPA_SUITE_B_192 is not set
# CONFIG_WPA_11KV_SUPPORT is not set
# CONFIG_WPA_MBO_SUPPORT is not set
# CONFIG_WPA_DPP_SUPPORT is not set
# CONFIG_WPA_11R_SUPPORT is not set
# CONFIG_WPA_WPS_SOFTAP_REGISTRAR is not set
# CONFIG_WPA_WPS_STRICT is not set
# CONFIG_WPA_DEBUG_PRINT is not set
# CONFIG_WPA_TESTING_OPTIONS is not set
# CONFIG_ESP32_ENABLE_COREDUMP_TO_FLASH is not set
# CONFIG_ESP32_ENABLE_COREDUMP_TO_UART is not set
CONFIG_ESP32_ENABLE_COREDUMP_TO_NONE=y
CONFIG_TIMER_TASK_PRIORITY=1
CONFIG_TIMER_TASK_STACK_DEPTH=2048
CONFIG_TIMER_QUEUE_LENGTH=10
# CONFIG_ENABLE_STATIC_TASK_CLEAN_UP_HOOK is not set
# CONFIG_HAL_ASSERTION_SILIENT is not set
# CONFIG_L2_TO_L3_COPY is not set
CONFIG_ESP_GRATUITOUS_ARP=y
CONFIG_GARP_TMR_INTERVAL=60
CONFIG_TCPIP_RECVMBOX_SIZE=32
CONFIG_TCP_MAXRTX=12
CONFIG_TCP_SYNMAXRTX=12
CONFIG_TCP_MSS=1440
CONFIG_TCP_MSL=60000
CONFIG_TCP_SND_BUF_DEFAULT=5760
CONFIG_TCP_WND_DEFAULT=5760
CONFIG_TCP_RECVMBOX_SIZE=6
CONFIG_TCP_QUEUE_OOSEQ=y
CONFIG_TCP_OVERSIZE_MSS=y
# CONFIG_TCP_OVERSIZE_QUARTER_MSS is not set
# CONFIG_TCP_OVERSIZE_DISABLE is not set
CONFIG_UDP_RECVMBOX_SIZE=6
CONFIG_TCPIP_TASK_STACK_SIZE=3072
CONFIG_TCPIP_TASK_AFFINITY_NO_AFFINITY=y
# CONFIG_TCPIP_TASK_AFFINITY_CPU0 is not set
# CONFIG_TCPIP_TASK_AFFINITY_CPU1 is not set
CONFIG_TCPIP_TASK_AFFINITY=0x7FFFFFFF
# CONFIG_PPP_SUPPORT is not set
CONFIG_NEWLIB_STDOUT_LINE_ENDING_CRLF=y
# CONFIG_NEWLIB_STDOUT_LINE_ENDING_LF is not set
# CONFIG_NEWLIB_STDOUT_LINE_ENDING_CR is not set
# CONFIG_NEWLIB_STDIN_LINE_ENDING_CRLF is not set
# CONFIG_NEWLIB_STDIN_LINE_ENDING_LF is not set
CONFIG_NEWLIB_STDIN_LINE_ENDING_CR=y
# CONFIG_NEWLIB_NANO_FORMAT is not set
CONFIG_NEWLIB_TIME_SYSCALL_USE_RTC_HRT=y
CONFIG_ESP32S3_TIME_SYSCALL_USE_RTC_SYSTIMER=y
CONFIG_ESP32S3_TIME_SYSCALL_USE_RTC_FRC1=y
# CONFIG_NEWLIB_TIME_SYSCALL_USE_RTC is not set
# CONFIG_ESP32S3_TIME_SYSCALL_USE_RTC is not set
# CONFIG_NEWLIB_TIME_SYSCALL_USE_HRT is not set
# CONFIG_ESP32S3_TIME_SYSCALL_USE_SYSTIMER is not set
# CONFIG_ESP32S3_TIME_SYSCALL_USE_FRC1 is not set
# CONFIG_NEWLIB_TIME_SYSCALL_USE_NONE is not set
# CONFIG_ESP32S3_TIME_SYSCALL_USE_NONE is not set
CONFIG_ESP32_PTHREAD_TASK_PRIO_DEFAULT=5
CONFIG_ESP32_PTHREAD_TASK_STACK_SIZE_DEFAULT=3072
CONFIG_ESP32_PTHREAD_STACK_MIN=768
CONFIG_ESP32_DEFAULT_PTHREAD_CORE_NO_AFFINITY=y
# CONFIG_ESP32_DEFAULT_PTHREAD_CORE_0 is not set
# CONFIG_ESP32_DEFAULT_PTHREAD_CORE_1 is not set
CONFIG_ESP32_PTHREAD_TASK_CORE_DEFAULT=-1
CONFIG_ESP32_PTHREAD_TASK_NAME_DEFAULT="pthread"
CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_ABORTS=y
# CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_FAILS is not set
# CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_ALLOWED is not set
CONFIG_SUPPRESS_SELECT_DEBUG_OUTPUT=y
CONFIG_SUPPORT_TERMIOS=y
CONFIG_SEMIHOSTFS_MAX_MOUNT_POINTS=1
# End of deprecated options


// File: /Users/devyn/splitr/esp32_wifi_ap_api/README.md
# ESP32 WiFi Access Point with HTTP API for BLE Audio Control

This project sets up an ESP32 to:
1. Create a WiFi Access Point
2. Run an HTTP API server
3. Communicate with an nRF5340 over UART to control BLE audio broadcasting

## Overview

The ESP32 serves as a network-accessible control hub for the audio broadcasting system. It:
- Creates a WiFi access point that users can connect to
- Provides HTTP API endpoints to control the nRF5340 BLE audio broadcaster
- Communicates with the nRF5340 via UART connection

## WiFi Access Point Details

- **SSID**: ESP32-Access-Point
- **Password**: 123456789
- **Maximum Connections**: 4
- **Authentication Mode**: WPA/WPA2 PSK

## HTTP API Endpoints

The ESP32 provides the following API endpoints:

### 1. GET /api/data
- Returns a simple "Hello, World!" JSON message
- Used for testing connectivity

### 2. POST /start-broadcast
- Sends a "START" command to the nRF5340 over UART
- Instructs the nRF5340 to begin BLE audio broadcasting (Auracast)
- Returns a JSON status response

Example response:
```json
{
  "status": "success",
  "message": "BLE broadcast started"
}
```

### 3. POST /stop-broadcast
- Sends a "STOP" command to the nRF5340 over UART
- Instructs the nRF5340 to stop BLE audio broadcasting
- Returns a JSON status response

Example response:
```json
{
  "status": "success",
  "message": "BLE broadcast stopped"
}
```

## UART Configuration for nRF5340 Communication

To connect the ESP32 to the nRF5340, use the following UART configuration:

- **UART Port**: UART1
- **TX Pin**: GPIO 17 (ESP32)  RX (nRF5340)
- **RX Pin**: GPIO 16 (ESP32)  TX (nRF5340)
- **Baud Rate**: 115200
- **Data Bits**: 8
- **Parity**: None
- **Stop Bits**: 1
- **Flow Control**: Disabled

## Command Format

The ESP32 sends simple text commands to the nRF5340:
- `START\n` - Begin BLE broadcasting
- `STOP\n` - End BLE broadcasting

## Development Notes

For testing without the physical nRF5340 hardware, the code includes a mock function that simulates successful responses from the nRF5340.

## Building and Running

```bash
# Build the project
idf.py build

# Flash to ESP32
idf.py -p PORT flash

# Monitor output
idf.py -p PORT monitor
```

Or use the provided buildflash.sh script:
```bash
./buildflash.sh
```

# _Sample project_

(See the README.md file in the upper level 'examples' directory for more information about examples.)

This is the simplest buildable example. The example is used by command `idf.py create-project`
that copies the project to user specified path and set it's name. For more information follow the [docs page](https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/build-system.html#start-a-new-project)



## How to use example
We encourage the users to use the example as a template for the new projects.
A recommended way is to follow the instructions on a [docs page](https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/build-system.html#start-a-new-project).

## Example folder contents

The project **sample_project** contains one source file in C language [main.c](main/main.c). The file is located in folder [main](main).

ESP-IDF projects are built using CMake. The project build configuration is contained in `CMakeLists.txt`
files that provide set of directives and instructions describing the project's source files and targets
(executable, library, or both). 

Below is short explanation of remaining files in the project folder.

```
 CMakeLists.txt
 main
  CMakeLists.txt
  main.c
 README.md                  This is the file you are currently reading
```
Additionally, the sample project contains Makefile and component.mk files, used for the legacy Make based build system. 
They are not used or needed when building with CMake and idf.py.


// File: /Users/devyn/splitr/esp32_wifi_ap_api/dependencies.lock
dependencies:
  espressif/led_strip:
    component_hash: f907c58f722c58ab8545366668cfd8769cefb7d97a631a14e9d16234cc72bdff
    dependencies:
    - name: idf
      require: private
      version: '>=5.0'
    source:
      registry_url: https://components.espressif.com/
      type: service
    version: 3.0.0
  idf:
    source:
      type: idf
    version: 5.5.0
direct_dependencies:
- espressif/led_strip
- idf
manifest_hash: 66f0d1a5019d1277f845b61ed7ecd51b2f8a000d6fb5b32b40131928bf590fba
target: esp32s3
version: 2.0.0


// File: /Users/devyn/splitr/esp32_wifi_ap_api/main/CMakeLists.txt
idf_component_register(SRCS "main.c"
                    INCLUDE_DIRS ".")

// File: /Users/devyn/splitr/esp32_wifi_ap_api/main/main.c
#include "nvs_flash.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_log.h"
#include "esp_http_server.h"
#include "esp_err.h"

#define EXAMPLE_ESP_WIFI_SSID      "ESP32-Access-Point"
#define EXAMPLE_ESP_WIFI_PASS      "123456789"
#define EXAMPLE_MAX_STA_CONN       4

void wifi_init_softap(void) {
    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());
    esp_netif_create_default_wifi_ap();

    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));

    wifi_config_t wifi_config = {
        .ap = {
            .ssid = EXAMPLE_ESP_WIFI_SSID,
            .ssid_len = strlen(EXAMPLE_ESP_WIFI_SSID),
            .password = EXAMPLE_ESP_WIFI_PASS,
            .max_connection = EXAMPLE_MAX_STA_CONN,
            .authmode = WIFI_AUTH_WPA_WPA2_PSK
        },
    };
    if (strlen(EXAMPLE_ESP_WIFI_PASS) == 0) {
        wifi_config.ap.authmode = WIFI_AUTH_OPEN;
    }

    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP));
    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_AP, &wifi_config));
    ESP_ERROR_CHECK(esp_wifi_start());

    ESP_LOGI("wifi_init_softap", "wifi_init_softap finished. SSID:%s password:%s",
             EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS);
}

static esp_err_t data_get_handler(httpd_req_t *req) {
    const char* resp_str = "{\"message\": \"Hello, World!\"}";
    httpd_resp_set_type(req, "application/json");
    httpd_resp_send(req, resp_str, strlen(resp_str));
    return ESP_OK;
}

void start_rest_server(void) {
    httpd_handle_t server = NULL; // Declare and initialize the server handle
    httpd_config_t config = HTTPD_DEFAULT_CONFIG();

    httpd_uri_t data_uri = {
        .uri       = "/api/data",
        .method    = HTTP_GET,
        .handler   = data_get_handler,
        .user_ctx  = NULL
    };

    if (httpd_start(&server, &config) == ESP_OK) {
        httpd_register_uri_handler(server, &data_uri);
    }
}

void app_main(void) {
    // Initialize NVS
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    // Initialize Wi-Fi
    wifi_init_softap();

    // Start HTTP server
    start_rest_server();
}

// File: /Users/devyn/splitr/esp32_bt_wifi_configure/CMakeLists.txt
cmake_minimum_required(VERSION 3.16)

include($ENV{IDF_PATH}/tools/cmake/project.cmake)
project(esp32_bt_wifi_config)

set(COMPONENT_SRCS "main.c")
set(COMPONENT_ADD_INCLUDEDIRS ".")

idf_component_register(SRCS ${COMPONENT_SRCS} INCLUDE_DIRS ${COMPONENT_ADD_INCLUDEDIRS})

// File: /Users/devyn/splitr/esp32_bt_wifi_configure/main.c
#include <stdio.h>
#include "nvs_flash.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_log.h"
#include "esp_bt.h"
#include "esp_spp_api.h"
#include "string.h"

#define BT_DEVICE_NAME "ESP32_Config"
#define BT_PASSWORD "1234"
#define MAX_WIFI_NETWORKS 10
#define WIFI_SCAN_TIME_MS 3000

static const char *TAG = "ESP_BT_WIFI";
static bool authenticated = false;
static uint32_t spp_client_handle = 0;

// Wi-Fi scan function
void scan_wifi_networks() {
    uint16_t num_networks = MAX_WIFI_NETWORKS;
    wifi_ap_record_t ap_records[MAX_WIFI_NETWORKS];
    
    wifi_scan_config_t scan_config = {
        .ssid = NULL,
        .bssid = NULL,
        .channel = 0,
        .show_hidden = true
    };
    
    esp_wifi_scan_start(&scan_config, true);
    esp_wifi_scan_get_ap_records(&num_networks, ap_records);
    
    char buffer[1024];
    memset(buffer, 0, sizeof(buffer));
    snprintf(buffer, sizeof(buffer), "Found %d networks:\n", num_networks);
    
    for (int i = 0; i < num_networks; i++) {
        snprintf(buffer + strlen(buffer), sizeof(buffer) - strlen(buffer), "%d. %s (RSSI: %d)\n", i + 1, ap_records[i].ssid, ap_records[i].rssi);
    }
    
    if (spp_client_handle) {
        esp_spp_write(spp_client_handle, strlen(buffer), (uint8_t *)buffer);
    }
}

// Bluetooth SPP event handler
void bt_spp_cb(esp_spp_cb_event_t event, esp_spp_cb_param_t *param) {
    switch (event) {
        case ESP_SPP_SRV_OPEN_EVT:
            ESP_LOGI(TAG, "Client Connected");
            spp_client_handle = param->srv_open.handle;
            break;
        case ESP_SPP_DATA_IND_EVT:
            if (param->data_ind.len > 0) {
                char received[100];
                memcpy(received, param->data_ind.data, param->data_ind.len);
                received[param->data_ind.len] = '\0';
                ESP_LOGI(TAG, "Received: %s", received);
                
                if (!authenticated) {
                    if (strcmp(received, BT_PASSWORD) == 0) {
                        authenticated = true;
                        esp_spp_write(spp_client_handle, 9, (uint8_t *)"AUTH_OK\n");
                    } else {
                        esp_spp_write(spp_client_handle, 11, (uint8_t *)"AUTH_FAIL\n");
                    }
                } else if (strcmp(received, "SCAN") == 0) {
                    scan_wifi_networks();
                } else if (strncmp(received, "CONNECT", 7) == 0) {
                    char ssid[32], password[64];
                    sscanf(received + 8, "%31s %63s", ssid, password);
                    
                    wifi_config_t wifi_config = {};
                    strncpy((char *)wifi_config.sta.ssid, ssid, sizeof(wifi_config.sta.ssid));
                    strncpy((char *)wifi_config.sta.password, password, sizeof(wifi_config.sta.password));
                    esp_wifi_set_config(WIFI_IF_STA, &wifi_config);
                    esp_wifi_connect();
                    esp_spp_write(spp_client_handle, 13, (uint8_t *)"WIFI_CONNECT\n");
                }
            }
            break;
        default:
            break;
    }
}

// Initialize Bluetooth SPP
void init_bluetooth() {
    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
    esp_bt_controller_init(&bt_cfg);
    esp_bt_controller_enable(ESP_BT_MODE_CLASSIC_BT);
    esp_bluedroid_init();
    esp_bluedroid_enable();
    
    esp_spp_register_callback(bt_spp_cb);
    esp_spp_init(ESP_SPP_MODE_CB);
    
    esp_spp_start_srv(ESP_SPP_SEC_AUTHENTICATED, ESP_SPP_ROLE_SLAVE, 0, BT_DEVICE_NAME);
}

// Initialize Wi-Fi in station mode
void init_wifi() {
    esp_netif_init();
    esp_event_loop_create_default();
    esp_netif_create_default_wifi_sta();
    
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    esp_wifi_init(&cfg);
    esp_wifi_set_mode(WIFI_MODE_STA);
    esp_wifi_start();
}

void app_main(void) {
    nvs_flash_init();
    init_wifi();
    init_bluetooth();
}


